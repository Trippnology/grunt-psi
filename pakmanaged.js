var global = Function("return this;")();
/*jshint strict:true node:true es5:true onevar:true laxcomma:true laxbreak:true eqeqeq:true immed:true latedef:true*/
(function () {
  "use strict";

  var oldRequire = require
    , modules = {}
    ;

  function newRequire(modulename) {
    var err
      , mod
      , metamod
      ;

    try {
      mod = oldRequire(modulename);
    } catch(e) {
      err = e;
    }

    if (mod) {
      return mod;
    }

    metamod = modules[modulename];
    
    if (metamod) {
      mod = metamod();
      return mod;
    }

    // make it possible to require 'process', etc
    mod = global[modulename];

    if (mod) {
      return mod;
    }

    console.error(modulename);
    throw err;
  }

  function provide(modulename, factory) {
    var modReal
      ;

    function metamod() {
      if (modReal) {
        return modReal;
      }

      if (!factory.__pakmanager_factory__) {
        modReal = factory;
        return factory;
      }

      if (factory.__factoryIsResolving) {
        console.error('Your circular dependencies are too powerful!');
        return factory.__moduleExports;
      }

      factory.__factoryIsResolving = true;
      factory.__moduleExports = {};
      modReal = factory(factory.__moduleExports);
      factory.__factoryIsResolving = false;

      return modReal;
    }

    modules[modulename] = metamod;
    // somewhat of a dirty hack since I don't have a plug for loading the "main" module otherwise
    modules['pakmanager.main'] = metamod;
  }

  require = newRequire;
  global.require = newRequire;
  global.provide = provide;
}());

// pakmanager:inherits
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  module.exports = require('util').inherits
    
  provide("inherits", module.exports);
}(global));

// pakmanager:typedarray
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var undefined = (void 0); // Paranoia
    
    // Beyond this value, index getters/setters (i.e. array[0], array[1]) are so slow to
    // create, and consume so much memory, that the browser appears frozen.
    var MAX_ARRAY_LENGTH = 1e5;
    
    // Approximations of internal ECMAScript conversion functions
    var ECMAScript = (function() {
      // Stash a copy in case other scripts modify these
      var opts = Object.prototype.toString,
          ophop = Object.prototype.hasOwnProperty;
    
      return {
        // Class returns internal [[Class]] property, used to avoid cross-frame instanceof issues:
        Class: function(v) { return opts.call(v).replace(/^\[object *|\]$/g, ''); },
        HasProperty: function(o, p) { return p in o; },
        HasOwnProperty: function(o, p) { return ophop.call(o, p); },
        IsCallable: function(o) { return typeof o === 'function'; },
        ToInt32: function(v) { return v >> 0; },
        ToUint32: function(v) { return v >>> 0; }
      };
    }());
    
    // Snapshot intrinsics
    var LN2 = Math.LN2,
        abs = Math.abs,
        floor = Math.floor,
        log = Math.log,
        min = Math.min,
        pow = Math.pow,
        round = Math.round;
    
    // ES5: lock down object properties
    function configureProperties(obj) {
      if (getOwnPropNames && defineProp) {
        var props = getOwnPropNames(obj), i;
        for (i = 0; i < props.length; i += 1) {
          defineProp(obj, props[i], {
            value: obj[props[i]],
            writable: false,
            enumerable: false,
            configurable: false
          });
        }
      }
    }
    
    // emulate ES5 getter/setter API using legacy APIs
    // http://blogs.msdn.com/b/ie/archive/2010/09/07/transitioning-existing-code-to-the-es5-getter-setter-apis.aspx
    // (second clause tests for Object.defineProperty() in IE<9 that only supports extending DOM prototypes, but
    // note that IE<9 does not support __defineGetter__ or __defineSetter__ so it just renders the method harmless)
    var defineProp
    if (Object.defineProperty && (function() {
          try {
            Object.defineProperty({}, 'x', {});
            return true;
          } catch (e) {
            return false;
          }
        })()) {
      defineProp = Object.defineProperty;
    } else {
      defineProp = function(o, p, desc) {
        if (!o === Object(o)) throw new TypeError("Object.defineProperty called on non-object");
        if (ECMAScript.HasProperty(desc, 'get') && Object.prototype.__defineGetter__) { Object.prototype.__defineGetter__.call(o, p, desc.get); }
        if (ECMAScript.HasProperty(desc, 'set') && Object.prototype.__defineSetter__) { Object.prototype.__defineSetter__.call(o, p, desc.set); }
        if (ECMAScript.HasProperty(desc, 'value')) { o[p] = desc.value; }
        return o;
      };
    }
    
    var getOwnPropNames = Object.getOwnPropertyNames || function (o) {
      if (o !== Object(o)) throw new TypeError("Object.getOwnPropertyNames called on non-object");
      var props = [], p;
      for (p in o) {
        if (ECMAScript.HasOwnProperty(o, p)) {
          props.push(p);
        }
      }
      return props;
    };
    
    // ES5: Make obj[index] an alias for obj._getter(index)/obj._setter(index, value)
    // for index in 0 ... obj.length
    function makeArrayAccessors(obj) {
      if (!defineProp) { return; }
    
      if (obj.length > MAX_ARRAY_LENGTH) throw new RangeError("Array too large for polyfill");
    
      function makeArrayAccessor(index) {
        defineProp(obj, index, {
          'get': function() { return obj._getter(index); },
          'set': function(v) { obj._setter(index, v); },
          enumerable: true,
          configurable: false
        });
      }
    
      var i;
      for (i = 0; i < obj.length; i += 1) {
        makeArrayAccessor(i);
      }
    }
    
    // Internal conversion functions:
    //    pack<Type>()   - take a number (interpreted as Type), output a byte array
    //    unpack<Type>() - take a byte array, output a Type-like number
    
    function as_signed(value, bits) { var s = 32 - bits; return (value << s) >> s; }
    function as_unsigned(value, bits) { var s = 32 - bits; return (value << s) >>> s; }
    
    function packI8(n) { return [n & 0xff]; }
    function unpackI8(bytes) { return as_signed(bytes[0], 8); }
    
    function packU8(n) { return [n & 0xff]; }
    function unpackU8(bytes) { return as_unsigned(bytes[0], 8); }
    
    function packU8Clamped(n) { n = round(Number(n)); return [n < 0 ? 0 : n > 0xff ? 0xff : n & 0xff]; }
    
    function packI16(n) { return [(n >> 8) & 0xff, n & 0xff]; }
    function unpackI16(bytes) { return as_signed(bytes[0] << 8 | bytes[1], 16); }
    
    function packU16(n) { return [(n >> 8) & 0xff, n & 0xff]; }
    function unpackU16(bytes) { return as_unsigned(bytes[0] << 8 | bytes[1], 16); }
    
    function packI32(n) { return [(n >> 24) & 0xff, (n >> 16) & 0xff, (n >> 8) & 0xff, n & 0xff]; }
    function unpackI32(bytes) { return as_signed(bytes[0] << 24 | bytes[1] << 16 | bytes[2] << 8 | bytes[3], 32); }
    
    function packU32(n) { return [(n >> 24) & 0xff, (n >> 16) & 0xff, (n >> 8) & 0xff, n & 0xff]; }
    function unpackU32(bytes) { return as_unsigned(bytes[0] << 24 | bytes[1] << 16 | bytes[2] << 8 | bytes[3], 32); }
    
    function packIEEE754(v, ebits, fbits) {
    
      var bias = (1 << (ebits - 1)) - 1,
          s, e, f, ln,
          i, bits, str, bytes;
    
      function roundToEven(n) {
        var w = floor(n), f = n - w;
        if (f < 0.5)
          return w;
        if (f > 0.5)
          return w + 1;
        return w % 2 ? w + 1 : w;
      }
    
      // Compute sign, exponent, fraction
      if (v !== v) {
        // NaN
        // http://dev.w3.org/2006/webapi/WebIDL/#es-type-mapping
        e = (1 << ebits) - 1; f = pow(2, fbits - 1); s = 0;
      } else if (v === Infinity || v === -Infinity) {
        e = (1 << ebits) - 1; f = 0; s = (v < 0) ? 1 : 0;
      } else if (v === 0) {
        e = 0; f = 0; s = (1 / v === -Infinity) ? 1 : 0;
      } else {
        s = v < 0;
        v = abs(v);
    
        if (v >= pow(2, 1 - bias)) {
          e = min(floor(log(v) / LN2), 1023);
          f = roundToEven(v / pow(2, e) * pow(2, fbits));
          if (f / pow(2, fbits) >= 2) {
            e = e + 1;
            f = 1;
          }
          if (e > bias) {
            // Overflow
            e = (1 << ebits) - 1;
            f = 0;
          } else {
            // Normalized
            e = e + bias;
            f = f - pow(2, fbits);
          }
        } else {
          // Denormalized
          e = 0;
          f = roundToEven(v / pow(2, 1 - bias - fbits));
        }
      }
    
      // Pack sign, exponent, fraction
      bits = [];
      for (i = fbits; i; i -= 1) { bits.push(f % 2 ? 1 : 0); f = floor(f / 2); }
      for (i = ebits; i; i -= 1) { bits.push(e % 2 ? 1 : 0); e = floor(e / 2); }
      bits.push(s ? 1 : 0);
      bits.reverse();
      str = bits.join('');
    
      // Bits to bytes
      bytes = [];
      while (str.length) {
        bytes.push(parseInt(str.substring(0, 8), 2));
        str = str.substring(8);
      }
      return bytes;
    }
    
    function unpackIEEE754(bytes, ebits, fbits) {
    
      // Bytes to bits
      var bits = [], i, j, b, str,
          bias, s, e, f;
    
      for (i = bytes.length; i; i -= 1) {
        b = bytes[i - 1];
        for (j = 8; j; j -= 1) {
          bits.push(b % 2 ? 1 : 0); b = b >> 1;
        }
      }
      bits.reverse();
      str = bits.join('');
    
      // Unpack sign, exponent, fraction
      bias = (1 << (ebits - 1)) - 1;
      s = parseInt(str.substring(0, 1), 2) ? -1 : 1;
      e = parseInt(str.substring(1, 1 + ebits), 2);
      f = parseInt(str.substring(1 + ebits), 2);
    
      // Produce number
      if (e === (1 << ebits) - 1) {
        return f !== 0 ? NaN : s * Infinity;
      } else if (e > 0) {
        // Normalized
        return s * pow(2, e - bias) * (1 + f / pow(2, fbits));
      } else if (f !== 0) {
        // Denormalized
        return s * pow(2, -(bias - 1)) * (f / pow(2, fbits));
      } else {
        return s < 0 ? -0 : 0;
      }
    }
    
    function unpackF64(b) { return unpackIEEE754(b, 11, 52); }
    function packF64(v) { return packIEEE754(v, 11, 52); }
    function unpackF32(b) { return unpackIEEE754(b, 8, 23); }
    function packF32(v) { return packIEEE754(v, 8, 23); }
    
    
    //
    // 3 The ArrayBuffer Type
    //
    
    (function() {
    
      /** @constructor */
      var ArrayBuffer = function ArrayBuffer(length) {
        length = ECMAScript.ToInt32(length);
        if (length < 0) throw new RangeError('ArrayBuffer size is not a small enough positive integer');
    
        this.byteLength = length;
        this._bytes = [];
        this._bytes.length = length;
    
        var i;
        for (i = 0; i < this.byteLength; i += 1) {
          this._bytes[i] = 0;
        }
    
        configureProperties(this);
      };
    
      exports.ArrayBuffer = exports.ArrayBuffer || ArrayBuffer;
    
      //
      // 4 The ArrayBufferView Type
      //
    
      // NOTE: this constructor is not exported
      /** @constructor */
      var ArrayBufferView = function ArrayBufferView() {
        //this.buffer = null;
        //this.byteOffset = 0;
        //this.byteLength = 0;
      };
    
      //
      // 5 The Typed Array View Types
      //
    
      function makeConstructor(bytesPerElement, pack, unpack) {
        // Each TypedArray type requires a distinct constructor instance with
        // identical logic, which this produces.
    
        var ctor;
        ctor = function(buffer, byteOffset, length) {
          var array, sequence, i, s;
    
          if (!arguments.length || typeof arguments[0] === 'number') {
            // Constructor(unsigned long length)
            this.length = ECMAScript.ToInt32(arguments[0]);
            if (length < 0) throw new RangeError('ArrayBufferView size is not a small enough positive integer');
    
            this.byteLength = this.length * this.BYTES_PER_ELEMENT;
            this.buffer = new ArrayBuffer(this.byteLength);
            this.byteOffset = 0;
          } else if (typeof arguments[0] === 'object' && arguments[0].constructor === ctor) {
            // Constructor(TypedArray array)
            array = arguments[0];
    
            this.length = array.length;
            this.byteLength = this.length * this.BYTES_PER_ELEMENT;
            this.buffer = new ArrayBuffer(this.byteLength);
            this.byteOffset = 0;
    
            for (i = 0; i < this.length; i += 1) {
              this._setter(i, array._getter(i));
            }
          } else if (typeof arguments[0] === 'object' &&
                     !(arguments[0] instanceof ArrayBuffer || ECMAScript.Class(arguments[0]) === 'ArrayBuffer')) {
            // Constructor(sequence<type> array)
            sequence = arguments[0];
    
            this.length = ECMAScript.ToUint32(sequence.length);
            this.byteLength = this.length * this.BYTES_PER_ELEMENT;
            this.buffer = new ArrayBuffer(this.byteLength);
            this.byteOffset = 0;
    
            for (i = 0; i < this.length; i += 1) {
              s = sequence[i];
              this._setter(i, Number(s));
            }
          } else if (typeof arguments[0] === 'object' &&
                     (arguments[0] instanceof ArrayBuffer || ECMAScript.Class(arguments[0]) === 'ArrayBuffer')) {
            // Constructor(ArrayBuffer buffer,
            //             optional unsigned long byteOffset, optional unsigned long length)
            this.buffer = buffer;
    
            this.byteOffset = ECMAScript.ToUint32(byteOffset);
            if (this.byteOffset > this.buffer.byteLength) {
              throw new RangeError("byteOffset out of range");
            }
    
            if (this.byteOffset % this.BYTES_PER_ELEMENT) {
              // The given byteOffset must be a multiple of the element
              // size of the specific type, otherwise an exception is raised.
              throw new RangeError("ArrayBuffer length minus the byteOffset is not a multiple of the element size.");
            }
    
            if (arguments.length < 3) {
              this.byteLength = this.buffer.byteLength - this.byteOffset;
    
              if (this.byteLength % this.BYTES_PER_ELEMENT) {
                throw new RangeError("length of buffer minus byteOffset not a multiple of the element size");
              }
              this.length = this.byteLength / this.BYTES_PER_ELEMENT;
            } else {
              this.length = ECMAScript.ToUint32(length);
              this.byteLength = this.length * this.BYTES_PER_ELEMENT;
            }
    
            if ((this.byteOffset + this.byteLength) > this.buffer.byteLength) {
              throw new RangeError("byteOffset and length reference an area beyond the end of the buffer");
            }
          } else {
            throw new TypeError("Unexpected argument type(s)");
          }
    
          this.constructor = ctor;
    
          configureProperties(this);
          makeArrayAccessors(this);
        };
    
        ctor.prototype = new ArrayBufferView();
        ctor.prototype.BYTES_PER_ELEMENT = bytesPerElement;
        ctor.prototype._pack = pack;
        ctor.prototype._unpack = unpack;
        ctor.BYTES_PER_ELEMENT = bytesPerElement;
    
        // getter type (unsigned long index);
        ctor.prototype._getter = function(index) {
          if (arguments.length < 1) throw new SyntaxError("Not enough arguments");
    
          index = ECMAScript.ToUint32(index);
          if (index >= this.length) {
            return undefined;
          }
    
          var bytes = [], i, o;
          for (i = 0, o = this.byteOffset + index * this.BYTES_PER_ELEMENT;
               i < this.BYTES_PER_ELEMENT;
               i += 1, o += 1) {
            bytes.push(this.buffer._bytes[o]);
          }
          return this._unpack(bytes);
        };
    
        // NONSTANDARD: convenience alias for getter: type get(unsigned long index);
        ctor.prototype.get = ctor.prototype._getter;
    
        // setter void (unsigned long index, type value);
        ctor.prototype._setter = function(index, value) {
          if (arguments.length < 2) throw new SyntaxError("Not enough arguments");
    
          index = ECMAScript.ToUint32(index);
          if (index >= this.length) {
            return undefined;
          }
    
          var bytes = this._pack(value), i, o;
          for (i = 0, o = this.byteOffset + index * this.BYTES_PER_ELEMENT;
               i < this.BYTES_PER_ELEMENT;
               i += 1, o += 1) {
            this.buffer._bytes[o] = bytes[i];
          }
        };
    
        // void set(TypedArray array, optional unsigned long offset);
        // void set(sequence<type> array, optional unsigned long offset);
        ctor.prototype.set = function(index, value) {
          if (arguments.length < 1) throw new SyntaxError("Not enough arguments");
          var array, sequence, offset, len,
              i, s, d,
              byteOffset, byteLength, tmp;
    
          if (typeof arguments[0] === 'object' && arguments[0].constructor === this.constructor) {
            // void set(TypedArray array, optional unsigned long offset);
            array = arguments[0];
            offset = ECMAScript.ToUint32(arguments[1]);
    
            if (offset + array.length > this.length) {
              throw new RangeError("Offset plus length of array is out of range");
            }
    
            byteOffset = this.byteOffset + offset * this.BYTES_PER_ELEMENT;
            byteLength = array.length * this.BYTES_PER_ELEMENT;
    
            if (array.buffer === this.buffer) {
              tmp = [];
              for (i = 0, s = array.byteOffset; i < byteLength; i += 1, s += 1) {
                tmp[i] = array.buffer._bytes[s];
              }
              for (i = 0, d = byteOffset; i < byteLength; i += 1, d += 1) {
                this.buffer._bytes[d] = tmp[i];
              }
            } else {
              for (i = 0, s = array.byteOffset, d = byteOffset;
                   i < byteLength; i += 1, s += 1, d += 1) {
                this.buffer._bytes[d] = array.buffer._bytes[s];
              }
            }
          } else if (typeof arguments[0] === 'object' && typeof arguments[0].length !== 'undefined') {
            // void set(sequence<type> array, optional unsigned long offset);
            sequence = arguments[0];
            len = ECMAScript.ToUint32(sequence.length);
            offset = ECMAScript.ToUint32(arguments[1]);
    
            if (offset + len > this.length) {
              throw new RangeError("Offset plus length of array is out of range");
            }
    
            for (i = 0; i < len; i += 1) {
              s = sequence[i];
              this._setter(offset + i, Number(s));
            }
          } else {
            throw new TypeError("Unexpected argument type(s)");
          }
        };
    
        // TypedArray subarray(long begin, optional long end);
        ctor.prototype.subarray = function(start, end) {
          function clamp(v, min, max) { return v < min ? min : v > max ? max : v; }
    
          start = ECMAScript.ToInt32(start);
          end = ECMAScript.ToInt32(end);
    
          if (arguments.length < 1) { start = 0; }
          if (arguments.length < 2) { end = this.length; }
    
          if (start < 0) { start = this.length + start; }
          if (end < 0) { end = this.length + end; }
    
          start = clamp(start, 0, this.length);
          end = clamp(end, 0, this.length);
    
          var len = end - start;
          if (len < 0) {
            len = 0;
          }
    
          return new this.constructor(
            this.buffer, this.byteOffset + start * this.BYTES_PER_ELEMENT, len);
        };
    
        return ctor;
      }
    
      var Int8Array = makeConstructor(1, packI8, unpackI8);
      var Uint8Array = makeConstructor(1, packU8, unpackU8);
      var Uint8ClampedArray = makeConstructor(1, packU8Clamped, unpackU8);
      var Int16Array = makeConstructor(2, packI16, unpackI16);
      var Uint16Array = makeConstructor(2, packU16, unpackU16);
      var Int32Array = makeConstructor(4, packI32, unpackI32);
      var Uint32Array = makeConstructor(4, packU32, unpackU32);
      var Float32Array = makeConstructor(4, packF32, unpackF32);
      var Float64Array = makeConstructor(8, packF64, unpackF64);
    
      exports.Int8Array = exports.Int8Array || Int8Array;
      exports.Uint8Array = exports.Uint8Array || Uint8Array;
      exports.Uint8ClampedArray = exports.Uint8ClampedArray || Uint8ClampedArray;
      exports.Int16Array = exports.Int16Array || Int16Array;
      exports.Uint16Array = exports.Uint16Array || Uint16Array;
      exports.Int32Array = exports.Int32Array || Int32Array;
      exports.Uint32Array = exports.Uint32Array || Uint32Array;
      exports.Float32Array = exports.Float32Array || Float32Array;
      exports.Float64Array = exports.Float64Array || Float64Array;
    }());
    
    //
    // 6 The DataView View Type
    //
    
    (function() {
      function r(array, index) {
        return ECMAScript.IsCallable(array.get) ? array.get(index) : array[index];
      }
    
      var IS_BIG_ENDIAN = (function() {
        var u16array = new(exports.Uint16Array)([0x1234]),
            u8array = new(exports.Uint8Array)(u16array.buffer);
        return r(u8array, 0) === 0x12;
      }());
    
      // Constructor(ArrayBuffer buffer,
      //             optional unsigned long byteOffset,
      //             optional unsigned long byteLength)
      /** @constructor */
      var DataView = function DataView(buffer, byteOffset, byteLength) {
        if (arguments.length === 0) {
          buffer = new exports.ArrayBuffer(0);
        } else if (!(buffer instanceof exports.ArrayBuffer || ECMAScript.Class(buffer) === 'ArrayBuffer')) {
          throw new TypeError("TypeError");
        }
    
        this.buffer = buffer || new exports.ArrayBuffer(0);
    
        this.byteOffset = ECMAScript.ToUint32(byteOffset);
        if (this.byteOffset > this.buffer.byteLength) {
          throw new RangeError("byteOffset out of range");
        }
    
        if (arguments.length < 3) {
          this.byteLength = this.buffer.byteLength - this.byteOffset;
        } else {
          this.byteLength = ECMAScript.ToUint32(byteLength);
        }
    
        if ((this.byteOffset + this.byteLength) > this.buffer.byteLength) {
          throw new RangeError("byteOffset and length reference an area beyond the end of the buffer");
        }
    
        configureProperties(this);
      };
    
      function makeGetter(arrayType) {
        return function(byteOffset, littleEndian) {
    
          byteOffset = ECMAScript.ToUint32(byteOffset);
    
          if (byteOffset + arrayType.BYTES_PER_ELEMENT > this.byteLength) {
            throw new RangeError("Array index out of range");
          }
          byteOffset += this.byteOffset;
    
          var uint8Array = new exports.Uint8Array(this.buffer, byteOffset, arrayType.BYTES_PER_ELEMENT),
              bytes = [], i;
          for (i = 0; i < arrayType.BYTES_PER_ELEMENT; i += 1) {
            bytes.push(r(uint8Array, i));
          }
    
          if (Boolean(littleEndian) === Boolean(IS_BIG_ENDIAN)) {
            bytes.reverse();
          }
    
          return r(new arrayType(new exports.Uint8Array(bytes).buffer), 0);
        };
      }
    
      DataView.prototype.getUint8 = makeGetter(exports.Uint8Array);
      DataView.prototype.getInt8 = makeGetter(exports.Int8Array);
      DataView.prototype.getUint16 = makeGetter(exports.Uint16Array);
      DataView.prototype.getInt16 = makeGetter(exports.Int16Array);
      DataView.prototype.getUint32 = makeGetter(exports.Uint32Array);
      DataView.prototype.getInt32 = makeGetter(exports.Int32Array);
      DataView.prototype.getFloat32 = makeGetter(exports.Float32Array);
      DataView.prototype.getFloat64 = makeGetter(exports.Float64Array);
    
      function makeSetter(arrayType) {
        return function(byteOffset, value, littleEndian) {
    
          byteOffset = ECMAScript.ToUint32(byteOffset);
          if (byteOffset + arrayType.BYTES_PER_ELEMENT > this.byteLength) {
            throw new RangeError("Array index out of range");
          }
    
          // Get bytes
          var typeArray = new arrayType([value]),
              byteArray = new exports.Uint8Array(typeArray.buffer),
              bytes = [], i, byteView;
    
          for (i = 0; i < arrayType.BYTES_PER_ELEMENT; i += 1) {
            bytes.push(r(byteArray, i));
          }
    
          // Flip if necessary
          if (Boolean(littleEndian) === Boolean(IS_BIG_ENDIAN)) {
            bytes.reverse();
          }
    
          // Write them
          byteView = new exports.Uint8Array(this.buffer, byteOffset, arrayType.BYTES_PER_ELEMENT);
          byteView.set(bytes);
        };
      }
    
      DataView.prototype.setUint8 = makeSetter(exports.Uint8Array);
      DataView.prototype.setInt8 = makeSetter(exports.Int8Array);
      DataView.prototype.setUint16 = makeSetter(exports.Uint16Array);
      DataView.prototype.setInt16 = makeSetter(exports.Int16Array);
      DataView.prototype.setUint32 = makeSetter(exports.Uint32Array);
      DataView.prototype.setInt32 = makeSetter(exports.Int32Array);
      DataView.prototype.setFloat32 = makeSetter(exports.Float32Array);
      DataView.prototype.setFloat64 = makeSetter(exports.Float64Array);
    
      exports.DataView = exports.DataView || DataView;
    
    }());
    
  provide("typedarray", module.exports);
}(global));

// pakmanager:readable-stream/lib/_stream_writable
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // A bit simpler than readable streams.
    // Implement an async ._write(chunk, cb), and it'll handle all
    // the drain event emission and buffering.
    
    'use strict';
    
    module.exports = Writable;
    
    /*<replacement>*/
    var processNextTick = require('process-nextick-args');
    /*</replacement>*/
    
    
    /*<replacement>*/
    var Buffer = require('buffer').Buffer;
    /*</replacement>*/
    
    Writable.WritableState = WritableState;
    
    
    /*<replacement>*/
    var util = require('core-util-is');
    util.inherits = require('inherits');
    /*</replacement>*/
    
    
    
    /*<replacement>*/
    var Stream;
     (function (){try{
    Stream = require('st' + 'ream');
    }catch(_){Stream = require('events').EventEmitter;}}())
    /*</replacement>*/
    
    var Buffer = require('buffer').Buffer;
    
    util.inherits(Writable, Stream);
    
    function nop() {}
    
    function WriteReq(chunk, encoding, cb) {
      this.chunk = chunk;
      this.encoding = encoding;
      this.callback = cb;
      this.next = null;
    }
    
    function WritableState(options, stream) {
      var Duplex =  require('readable-stream/lib/_stream_duplex');
    
      options = options || {};
    
      // object stream flag to indicate whether or not this stream
      // contains buffers or objects.
      this.objectMode = !!options.objectMode;
    
      if (stream instanceof Duplex)
        this.objectMode = this.objectMode || !!options.writableObjectMode;
    
      // the point at which write() starts returning false
      // Note: 0 is a valid value, means that we always return false if
      // the entire buffer is not flushed immediately on write()
      var hwm = options.highWaterMark;
      var defaultHwm = this.objectMode ? 16 : 16 * 1024;
      this.highWaterMark = (hwm || hwm === 0) ? hwm : defaultHwm;
    
      // cast to ints.
      this.highWaterMark = ~~this.highWaterMark;
    
      this.needDrain = false;
      // at the start of calling end()
      this.ending = false;
      // when end() has been called, and returned
      this.ended = false;
      // when 'finish' is emitted
      this.finished = false;
    
      // should we decode strings into buffers before passing to _write?
      // this is here so that some node-core streams can optimize string
      // handling at a lower level.
      var noDecode = options.decodeStrings === false;
      this.decodeStrings = !noDecode;
    
      // Crypto is kind of old and crusty.  Historically, its default string
      // encoding is 'binary' so we have to make this configurable.
      // Everything else in the universe uses 'utf8', though.
      this.defaultEncoding = options.defaultEncoding || 'utf8';
    
      // not an actual buffer we keep track of, but a measurement
      // of how much we're waiting to get pushed to some underlying
      // socket or file.
      this.length = 0;
    
      // a flag to see when we're in the middle of a write.
      this.writing = false;
    
      // when true all writes will be buffered until .uncork() call
      this.corked = 0;
    
      // a flag to be able to tell if the onwrite cb is called immediately,
      // or on a later tick.  We set this to true at first, because any
      // actions that shouldn't happen until "later" should generally also
      // not happen before the first write call.
      this.sync = true;
    
      // a flag to know if we're processing previously buffered items, which
      // may call the _write() callback in the same tick, so that we don't
      // end up in an overlapped onwrite situation.
      this.bufferProcessing = false;
    
      // the callback that's passed to _write(chunk,cb)
      this.onwrite = function(er) {
        onwrite(stream, er);
      };
    
      // the callback that the user supplies to write(chunk,encoding,cb)
      this.writecb = null;
    
      // the amount that is being written when _write is called.
      this.writelen = 0;
    
      this.bufferedRequest = null;
      this.lastBufferedRequest = null;
    
      // number of pending user-supplied write callbacks
      // this must be 0 before 'finish' can be emitted
      this.pendingcb = 0;
    
      // emit prefinish if the only thing we're waiting for is _write cbs
      // This is relevant for synchronous Transform streams
      this.prefinished = false;
    
      // True if the error was already emitted and should not be thrown again
      this.errorEmitted = false;
    }
    
    WritableState.prototype.getBuffer = function writableStateGetBuffer() {
      var current = this.bufferedRequest;
      var out = [];
      while (current) {
        out.push(current);
        current = current.next;
      }
      return out;
    };
    
    (function (){try {
    Object.defineProperty(WritableState.prototype, 'buffer', {
      get: require('util-deprecate')(function() {
        return this.getBuffer();
      }, '_writableState.buffer is deprecated. Use ' +
          '_writableState.getBuffer() instead.')
    });
    }catch(_){}}());
    
    
    function Writable(options) {
      var Duplex =  require('readable-stream/lib/_stream_duplex');
    
      // Writable ctor is applied to Duplexes, though they're not
      // instanceof Writable, they're instanceof Readable.
      if (!(this instanceof Writable) && !(this instanceof Duplex))
        return new Writable(options);
    
      this._writableState = new WritableState(options, this);
    
      // legacy.
      this.writable = true;
    
      if (options) {
        if (typeof options.write === 'function')
          this._write = options.write;
    
        if (typeof options.writev === 'function')
          this._writev = options.writev;
      }
    
      Stream.call(this);
    }
    
    // Otherwise people can pipe Writable streams, which is just wrong.
    Writable.prototype.pipe = function() {
      this.emit('error', new Error('Cannot pipe. Not readable.'));
    };
    
    
    function writeAfterEnd(stream, cb) {
      var er = new Error('write after end');
      // TODO: defer error events consistently everywhere, not just the cb
      stream.emit('error', er);
      processNextTick(cb, er);
    }
    
    // If we get something that is not a buffer, string, null, or undefined,
    // and we're not in objectMode, then that's an error.
    // Otherwise stream chunks are all considered to be of length=1, and the
    // watermarks determine how many objects to keep in the buffer, rather than
    // how many bytes or characters.
    function validChunk(stream, state, chunk, cb) {
      var valid = true;
    
      if (!(Buffer.isBuffer(chunk)) &&
          typeof chunk !== 'string' &&
          chunk !== null &&
          chunk !== undefined &&
          !state.objectMode) {
        var er = new TypeError('Invalid non-string/buffer chunk');
        stream.emit('error', er);
        processNextTick(cb, er);
        valid = false;
      }
      return valid;
    }
    
    Writable.prototype.write = function(chunk, encoding, cb) {
      var state = this._writableState;
      var ret = false;
    
      if (typeof encoding === 'function') {
        cb = encoding;
        encoding = null;
      }
    
      if (Buffer.isBuffer(chunk))
        encoding = 'buffer';
      else if (!encoding)
        encoding = state.defaultEncoding;
    
      if (typeof cb !== 'function')
        cb = nop;
    
      if (state.ended)
        writeAfterEnd(this, cb);
      else if (validChunk(this, state, chunk, cb)) {
        state.pendingcb++;
        ret = writeOrBuffer(this, state, chunk, encoding, cb);
      }
    
      return ret;
    };
    
    Writable.prototype.cork = function() {
      var state = this._writableState;
    
      state.corked++;
    };
    
    Writable.prototype.uncork = function() {
      var state = this._writableState;
    
      if (state.corked) {
        state.corked--;
    
        if (!state.writing &&
            !state.corked &&
            !state.finished &&
            !state.bufferProcessing &&
            state.bufferedRequest)
          clearBuffer(this, state);
      }
    };
    
    Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
      // node::ParseEncoding() requires lower case.
      if (typeof encoding === 'string')
        encoding = encoding.toLowerCase();
      if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64',
    'ucs2', 'ucs-2','utf16le', 'utf-16le', 'raw']
    .indexOf((encoding + '').toLowerCase()) > -1))
        throw new TypeError('Unknown encoding: ' + encoding);
      this._writableState.defaultEncoding = encoding;
    };
    
    function decodeChunk(state, chunk, encoding) {
      if (!state.objectMode &&
          state.decodeStrings !== false &&
          typeof chunk === 'string') {
        chunk = new Buffer(chunk, encoding);
      }
      return chunk;
    }
    
    // if we're already writing something, then just put this
    // in the queue, and wait our turn.  Otherwise, call _write
    // If we return false, then we need a drain event, so set that flag.
    function writeOrBuffer(stream, state, chunk, encoding, cb) {
      chunk = decodeChunk(state, chunk, encoding);
    
      if (Buffer.isBuffer(chunk))
        encoding = 'buffer';
      var len = state.objectMode ? 1 : chunk.length;
    
      state.length += len;
    
      var ret = state.length < state.highWaterMark;
      // we must ensure that previous needDrain will not be reset to false.
      if (!ret)
        state.needDrain = true;
    
      if (state.writing || state.corked) {
        var last = state.lastBufferedRequest;
        state.lastBufferedRequest = new WriteReq(chunk, encoding, cb);
        if (last) {
          last.next = state.lastBufferedRequest;
        } else {
          state.bufferedRequest = state.lastBufferedRequest;
        }
      } else {
        doWrite(stream, state, false, len, chunk, encoding, cb);
      }
    
      return ret;
    }
    
    function doWrite(stream, state, writev, len, chunk, encoding, cb) {
      state.writelen = len;
      state.writecb = cb;
      state.writing = true;
      state.sync = true;
      if (writev)
        stream._writev(chunk, state.onwrite);
      else
        stream._write(chunk, encoding, state.onwrite);
      state.sync = false;
    }
    
    function onwriteError(stream, state, sync, er, cb) {
      --state.pendingcb;
      if (sync)
        processNextTick(cb, er);
      else
        cb(er);
    
      stream._writableState.errorEmitted = true;
      stream.emit('error', er);
    }
    
    function onwriteStateUpdate(state) {
      state.writing = false;
      state.writecb = null;
      state.length -= state.writelen;
      state.writelen = 0;
    }
    
    function onwrite(stream, er) {
      var state = stream._writableState;
      var sync = state.sync;
      var cb = state.writecb;
    
      onwriteStateUpdate(state);
    
      if (er)
        onwriteError(stream, state, sync, er, cb);
      else {
        // Check if we're actually ready to finish, but don't emit yet
        var finished = needFinish(state);
    
        if (!finished &&
            !state.corked &&
            !state.bufferProcessing &&
            state.bufferedRequest) {
          clearBuffer(stream, state);
        }
    
        if (sync) {
          processNextTick(afterWrite, stream, state, finished, cb);
        } else {
          afterWrite(stream, state, finished, cb);
        }
      }
    }
    
    function afterWrite(stream, state, finished, cb) {
      if (!finished)
        onwriteDrain(stream, state);
      state.pendingcb--;
      cb();
      finishMaybe(stream, state);
    }
    
    // Must force callback to be called on nextTick, so that we don't
    // emit 'drain' before the write() consumer gets the 'false' return
    // value, and has a chance to attach a 'drain' listener.
    function onwriteDrain(stream, state) {
      if (state.length === 0 && state.needDrain) {
        state.needDrain = false;
        stream.emit('drain');
      }
    }
    
    
    // if there's something in the buffer waiting, then process it
    function clearBuffer(stream, state) {
      state.bufferProcessing = true;
      var entry = state.bufferedRequest;
    
      if (stream._writev && entry && entry.next) {
        // Fast case, write everything using _writev()
        var buffer = [];
        var cbs = [];
        while (entry) {
          cbs.push(entry.callback);
          buffer.push(entry);
          entry = entry.next;
        }
    
        // count the one we are adding, as well.
        // TODO(isaacs) clean this up
        state.pendingcb++;
        state.lastBufferedRequest = null;
        doWrite(stream, state, true, state.length, buffer, '', function(err) {
          for (var i = 0; i < cbs.length; i++) {
            state.pendingcb--;
            cbs[i](err);
          }
        });
    
        // Clear buffer
      } else {
        // Slow case, write chunks one-by-one
        while (entry) {
          var chunk = entry.chunk;
          var encoding = entry.encoding;
          var cb = entry.callback;
          var len = state.objectMode ? 1 : chunk.length;
    
          doWrite(stream, state, false, len, chunk, encoding, cb);
          entry = entry.next;
          // if we didn't call the onwrite immediately, then
          // it means that we need to wait until it does.
          // also, that means that the chunk and cb are currently
          // being processed, so move the buffer counter past them.
          if (state.writing) {
            break;
          }
        }
    
        if (entry === null)
          state.lastBufferedRequest = null;
      }
      state.bufferedRequest = entry;
      state.bufferProcessing = false;
    }
    
    Writable.prototype._write = function(chunk, encoding, cb) {
      cb(new Error('not implemented'));
    };
    
    Writable.prototype._writev = null;
    
    Writable.prototype.end = function(chunk, encoding, cb) {
      var state = this._writableState;
    
      if (typeof chunk === 'function') {
        cb = chunk;
        chunk = null;
        encoding = null;
      } else if (typeof encoding === 'function') {
        cb = encoding;
        encoding = null;
      }
    
      if (chunk !== null && chunk !== undefined)
        this.write(chunk, encoding);
    
      // .end() fully uncorks
      if (state.corked) {
        state.corked = 1;
        this.uncork();
      }
    
      // ignore unnecessary end() calls.
      if (!state.ending && !state.finished)
        endWritable(this, state, cb);
    };
    
    
    function needFinish(state) {
      return (state.ending &&
              state.length === 0 &&
              state.bufferedRequest === null &&
              !state.finished &&
              !state.writing);
    }
    
    function prefinish(stream, state) {
      if (!state.prefinished) {
        state.prefinished = true;
        stream.emit('prefinish');
      }
    }
    
    function finishMaybe(stream, state) {
      var need = needFinish(state);
      if (need) {
        if (state.pendingcb === 0) {
          prefinish(stream, state);
          state.finished = true;
          stream.emit('finish');
        } else {
          prefinish(stream, state);
        }
      }
      return need;
    }
    
    function endWritable(stream, state, cb) {
      state.ending = true;
      finishMaybe(stream, state);
      if (cb) {
        if (state.finished)
          processNextTick(cb);
        else
          stream.once('finish', cb);
      }
      state.ended = true;
    }
    
  provide("readable-stream/lib/_stream_writable", module.exports);
}(global));

// pakmanager:readable-stream/lib/_stream_readable
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    module.exports = Readable;
    
    /*<replacement>*/
    var processNextTick = require('process-nextick-args');
    /*</replacement>*/
    
    
    /*<replacement>*/
    var isArray = require('isarray');
    /*</replacement>*/
    
    
    /*<replacement>*/
    var Buffer = require('buffer').Buffer;
    /*</replacement>*/
    
    Readable.ReadableState = ReadableState;
    
    var EE = require('events').EventEmitter;
    
    /*<replacement>*/
    if (!EE.listenerCount) EE.listenerCount = function(emitter, type) {
      return emitter.listeners(type).length;
    };
    /*</replacement>*/
    
    
    
    /*<replacement>*/
    var Stream;
     (function (){try{
    Stream = require('st' + 'ream');
    }catch(_){Stream = require('events').EventEmitter;}}())
    /*</replacement>*/
    
    var Buffer = require('buffer').Buffer;
    
    /*<replacement>*/
    var util = require('core-util-is');
    util.inherits = require('inherits');
    /*</replacement>*/
    
    
    
    /*<replacement>*/
    var debug = require('util');
    if (debug && debug.debuglog) {
      debug = debug.debuglog('stream');
    } else {
      debug = function () {};
    }
    /*</replacement>*/
    
    var StringDecoder;
    
    util.inherits(Readable, Stream);
    
    function ReadableState(options, stream) {
      var Duplex =  require('readable-stream/lib/_stream_duplex');
    
      options = options || {};
    
      // object stream flag. Used to make read(n) ignore n and to
      // make all the buffer merging and length checks go away
      this.objectMode = !!options.objectMode;
    
      if (stream instanceof Duplex)
        this.objectMode = this.objectMode || !!options.readableObjectMode;
    
      // the point at which it stops calling _read() to fill the buffer
      // Note: 0 is a valid value, means "don't call _read preemptively ever"
      var hwm = options.highWaterMark;
      var defaultHwm = this.objectMode ? 16 : 16 * 1024;
      this.highWaterMark = (hwm || hwm === 0) ? hwm : defaultHwm;
    
      // cast to ints.
      this.highWaterMark = ~~this.highWaterMark;
    
      this.buffer = [];
      this.length = 0;
      this.pipes = null;
      this.pipesCount = 0;
      this.flowing = null;
      this.ended = false;
      this.endEmitted = false;
      this.reading = false;
    
      // a flag to be able to tell if the onwrite cb is called immediately,
      // or on a later tick.  We set this to true at first, because any
      // actions that shouldn't happen until "later" should generally also
      // not happen before the first write call.
      this.sync = true;
    
      // whenever we return null, then we set a flag to say
      // that we're awaiting a 'readable' event emission.
      this.needReadable = false;
      this.emittedReadable = false;
      this.readableListening = false;
    
      // Crypto is kind of old and crusty.  Historically, its default string
      // encoding is 'binary' so we have to make this configurable.
      // Everything else in the universe uses 'utf8', though.
      this.defaultEncoding = options.defaultEncoding || 'utf8';
    
      // when piping, we only care about 'readable' events that happen
      // after read()ing all the bytes and not getting any pushback.
      this.ranOut = false;
    
      // the number of writers that are awaiting a drain event in .pipe()s
      this.awaitDrain = 0;
    
      // if true, a maybeReadMore has been scheduled
      this.readingMore = false;
    
      this.decoder = null;
      this.encoding = null;
      if (options.encoding) {
        if (!StringDecoder)
          StringDecoder = require('string_decoder/').StringDecoder;
        this.decoder = new StringDecoder(options.encoding);
        this.encoding = options.encoding;
      }
    }
    
    function Readable(options) {
      var Duplex =  require('readable-stream/lib/_stream_duplex');
    
      if (!(this instanceof Readable))
        return new Readable(options);
    
      this._readableState = new ReadableState(options, this);
    
      // legacy
      this.readable = true;
    
      if (options && typeof options.read === 'function')
        this._read = options.read;
    
      Stream.call(this);
    }
    
    // Manually shove something into the read() buffer.
    // This returns true if the highWaterMark has not been hit yet,
    // similar to how Writable.write() returns true if you should
    // write() some more.
    Readable.prototype.push = function(chunk, encoding) {
      var state = this._readableState;
    
      if (!state.objectMode && typeof chunk === 'string') {
        encoding = encoding || state.defaultEncoding;
        if (encoding !== state.encoding) {
          chunk = new Buffer(chunk, encoding);
          encoding = '';
        }
      }
    
      return readableAddChunk(this, state, chunk, encoding, false);
    };
    
    // Unshift should *always* be something directly out of read()
    Readable.prototype.unshift = function(chunk) {
      var state = this._readableState;
      return readableAddChunk(this, state, chunk, '', true);
    };
    
    Readable.prototype.isPaused = function() {
      return this._readableState.flowing === false;
    };
    
    function readableAddChunk(stream, state, chunk, encoding, addToFront) {
      var er = chunkInvalid(state, chunk);
      if (er) {
        stream.emit('error', er);
      } else if (chunk === null) {
        state.reading = false;
        onEofChunk(stream, state);
      } else if (state.objectMode || chunk && chunk.length > 0) {
        if (state.ended && !addToFront) {
          var e = new Error('stream.push() after EOF');
          stream.emit('error', e);
        } else if (state.endEmitted && addToFront) {
          var e = new Error('stream.unshift() after end event');
          stream.emit('error', e);
        } else {
          if (state.decoder && !addToFront && !encoding)
            chunk = state.decoder.write(chunk);
    
          if (!addToFront)
            state.reading = false;
    
          // if we want the data now, just emit it.
          if (state.flowing && state.length === 0 && !state.sync) {
            stream.emit('data', chunk);
            stream.read(0);
          } else {
            // update the buffer info.
            state.length += state.objectMode ? 1 : chunk.length;
            if (addToFront)
              state.buffer.unshift(chunk);
            else
              state.buffer.push(chunk);
    
            if (state.needReadable)
              emitReadable(stream);
          }
    
          maybeReadMore(stream, state);
        }
      } else if (!addToFront) {
        state.reading = false;
      }
    
      return needMoreData(state);
    }
    
    
    
    // if it's past the high water mark, we can push in some more.
    // Also, if we have no data yet, we can stand some
    // more bytes.  This is to work around cases where hwm=0,
    // such as the repl.  Also, if the push() triggered a
    // readable event, and the user called read(largeNumber) such that
    // needReadable was set, then we ought to push more, so that another
    // 'readable' event will be triggered.
    function needMoreData(state) {
      return !state.ended &&
             (state.needReadable ||
              state.length < state.highWaterMark ||
              state.length === 0);
    }
    
    // backwards compatibility.
    Readable.prototype.setEncoding = function(enc) {
      if (!StringDecoder)
        StringDecoder = require('string_decoder/').StringDecoder;
      this._readableState.decoder = new StringDecoder(enc);
      this._readableState.encoding = enc;
      return this;
    };
    
    // Don't raise the hwm > 128MB
    var MAX_HWM = 0x800000;
    function roundUpToNextPowerOf2(n) {
      if (n >= MAX_HWM) {
        n = MAX_HWM;
      } else {
        // Get the next highest power of 2
        n--;
        for (var p = 1; p < 32; p <<= 1) n |= n >> p;
        n++;
      }
      return n;
    }
    
    function howMuchToRead(n, state) {
      if (state.length === 0 && state.ended)
        return 0;
    
      if (state.objectMode)
        return n === 0 ? 0 : 1;
    
      if (n === null || isNaN(n)) {
        // only flow one buffer at a time
        if (state.flowing && state.buffer.length)
          return state.buffer[0].length;
        else
          return state.length;
      }
    
      if (n <= 0)
        return 0;
    
      // If we're asking for more than the target buffer level,
      // then raise the water mark.  Bump up to the next highest
      // power of 2, to prevent increasing it excessively in tiny
      // amounts.
      if (n > state.highWaterMark)
        state.highWaterMark = roundUpToNextPowerOf2(n);
    
      // don't have that much.  return null, unless we've ended.
      if (n > state.length) {
        if (!state.ended) {
          state.needReadable = true;
          return 0;
        } else {
          return state.length;
        }
      }
    
      return n;
    }
    
    // you can override either this method, or the async _read(n) below.
    Readable.prototype.read = function(n) {
      debug('read', n);
      var state = this._readableState;
      var nOrig = n;
    
      if (typeof n !== 'number' || n > 0)
        state.emittedReadable = false;
    
      // if we're doing read(0) to trigger a readable event, but we
      // already have a bunch of data in the buffer, then just trigger
      // the 'readable' event and move on.
      if (n === 0 &&
          state.needReadable &&
          (state.length >= state.highWaterMark || state.ended)) {
        debug('read: emitReadable', state.length, state.ended);
        if (state.length === 0 && state.ended)
          endReadable(this);
        else
          emitReadable(this);
        return null;
      }
    
      n = howMuchToRead(n, state);
    
      // if we've ended, and we're now clear, then finish it up.
      if (n === 0 && state.ended) {
        if (state.length === 0)
          endReadable(this);
        return null;
      }
    
      // All the actual chunk generation logic needs to be
      // *below* the call to _read.  The reason is that in certain
      // synthetic stream cases, such as passthrough streams, _read
      // may be a completely synchronous operation which may change
      // the state of the read buffer, providing enough data when
      // before there was *not* enough.
      //
      // So, the steps are:
      // 1. Figure out what the state of things will be after we do
      // a read from the buffer.
      //
      // 2. If that resulting state will trigger a _read, then call _read.
      // Note that this may be asynchronous, or synchronous.  Yes, it is
      // deeply ugly to write APIs this way, but that still doesn't mean
      // that the Readable class should behave improperly, as streams are
      // designed to be sync/async agnostic.
      // Take note if the _read call is sync or async (ie, if the read call
      // has returned yet), so that we know whether or not it's safe to emit
      // 'readable' etc.
      //
      // 3. Actually pull the requested chunks out of the buffer and return.
    
      // if we need a readable event, then we need to do some reading.
      var doRead = state.needReadable;
      debug('need readable', doRead);
    
      // if we currently have less than the highWaterMark, then also read some
      if (state.length === 0 || state.length - n < state.highWaterMark) {
        doRead = true;
        debug('length less than watermark', doRead);
      }
    
      // however, if we've ended, then there's no point, and if we're already
      // reading, then it's unnecessary.
      if (state.ended || state.reading) {
        doRead = false;
        debug('reading or ended', doRead);
      }
    
      if (doRead) {
        debug('do read');
        state.reading = true;
        state.sync = true;
        // if the length is currently zero, then we *need* a readable event.
        if (state.length === 0)
          state.needReadable = true;
        // call internal read method
        this._read(state.highWaterMark);
        state.sync = false;
      }
    
      // If _read pushed data synchronously, then `reading` will be false,
      // and we need to re-evaluate how much data we can return to the user.
      if (doRead && !state.reading)
        n = howMuchToRead(nOrig, state);
    
      var ret;
      if (n > 0)
        ret = fromList(n, state);
      else
        ret = null;
    
      if (ret === null) {
        state.needReadable = true;
        n = 0;
      }
    
      state.length -= n;
    
      // If we have nothing in the buffer, then we want to know
      // as soon as we *do* get something into the buffer.
      if (state.length === 0 && !state.ended)
        state.needReadable = true;
    
      // If we tried to read() past the EOF, then emit end on the next tick.
      if (nOrig !== n && state.ended && state.length === 0)
        endReadable(this);
    
      if (ret !== null)
        this.emit('data', ret);
    
      return ret;
    };
    
    function chunkInvalid(state, chunk) {
      var er = null;
      if (!(Buffer.isBuffer(chunk)) &&
          typeof chunk !== 'string' &&
          chunk !== null &&
          chunk !== undefined &&
          !state.objectMode) {
        er = new TypeError('Invalid non-string/buffer chunk');
      }
      return er;
    }
    
    
    function onEofChunk(stream, state) {
      if (state.ended) return;
      if (state.decoder) {
        var chunk = state.decoder.end();
        if (chunk && chunk.length) {
          state.buffer.push(chunk);
          state.length += state.objectMode ? 1 : chunk.length;
        }
      }
      state.ended = true;
    
      // emit 'readable' now to make sure it gets picked up.
      emitReadable(stream);
    }
    
    // Don't emit readable right away in sync mode, because this can trigger
    // another read() call => stack overflow.  This way, it might trigger
    // a nextTick recursion warning, but that's not so bad.
    function emitReadable(stream) {
      var state = stream._readableState;
      state.needReadable = false;
      if (!state.emittedReadable) {
        debug('emitReadable', state.flowing);
        state.emittedReadable = true;
        if (state.sync)
          processNextTick(emitReadable_, stream);
        else
          emitReadable_(stream);
      }
    }
    
    function emitReadable_(stream) {
      debug('emit readable');
      stream.emit('readable');
      flow(stream);
    }
    
    
    // at this point, the user has presumably seen the 'readable' event,
    // and called read() to consume some data.  that may have triggered
    // in turn another _read(n) call, in which case reading = true if
    // it's in progress.
    // However, if we're not ended, or reading, and the length < hwm,
    // then go ahead and try to read some more preemptively.
    function maybeReadMore(stream, state) {
      if (!state.readingMore) {
        state.readingMore = true;
        processNextTick(maybeReadMore_, stream, state);
      }
    }
    
    function maybeReadMore_(stream, state) {
      var len = state.length;
      while (!state.reading && !state.flowing && !state.ended &&
             state.length < state.highWaterMark) {
        debug('maybeReadMore read 0');
        stream.read(0);
        if (len === state.length)
          // didn't get any data, stop spinning.
          break;
        else
          len = state.length;
      }
      state.readingMore = false;
    }
    
    // abstract method.  to be overridden in specific implementation classes.
    // call cb(er, data) where data is <= n in length.
    // for virtual (non-string, non-buffer) streams, "length" is somewhat
    // arbitrary, and perhaps not very meaningful.
    Readable.prototype._read = function(n) {
      this.emit('error', new Error('not implemented'));
    };
    
    Readable.prototype.pipe = function(dest, pipeOpts) {
      var src = this;
      var state = this._readableState;
    
      switch (state.pipesCount) {
        case 0:
          state.pipes = dest;
          break;
        case 1:
          state.pipes = [state.pipes, dest];
          break;
        default:
          state.pipes.push(dest);
          break;
      }
      state.pipesCount += 1;
      debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);
    
      var doEnd = (!pipeOpts || pipeOpts.end !== false) &&
                  dest !== process.stdout &&
                  dest !== process.stderr;
    
      var endFn = doEnd ? onend : cleanup;
      if (state.endEmitted)
        processNextTick(endFn);
      else
        src.once('end', endFn);
    
      dest.on('unpipe', onunpipe);
      function onunpipe(readable) {
        debug('onunpipe');
        if (readable === src) {
          cleanup();
        }
      }
    
      function onend() {
        debug('onend');
        dest.end();
      }
    
      // when the dest drains, it reduces the awaitDrain counter
      // on the source.  This would be more elegant with a .once()
      // handler in flow(), but adding and removing repeatedly is
      // too slow.
      var ondrain = pipeOnDrain(src);
      dest.on('drain', ondrain);
    
      function cleanup() {
        debug('cleanup');
        // cleanup event handlers once the pipe is broken
        dest.removeListener('close', onclose);
        dest.removeListener('finish', onfinish);
        dest.removeListener('drain', ondrain);
        dest.removeListener('error', onerror);
        dest.removeListener('unpipe', onunpipe);
        src.removeListener('end', onend);
        src.removeListener('end', cleanup);
        src.removeListener('data', ondata);
    
        // if the reader is waiting for a drain event from this
        // specific writer, then it would cause it to never start
        // flowing again.
        // So, if this is awaiting a drain, then we just call it now.
        // If we don't know, then assume that we are waiting for one.
        if (state.awaitDrain &&
            (!dest._writableState || dest._writableState.needDrain))
          ondrain();
      }
    
      src.on('data', ondata);
      function ondata(chunk) {
        debug('ondata');
        var ret = dest.write(chunk);
        if (false === ret) {
          debug('false write response, pause',
                src._readableState.awaitDrain);
          src._readableState.awaitDrain++;
          src.pause();
        }
      }
    
      // if the dest has an error, then stop piping into it.
      // however, don't suppress the throwing behavior for this.
      function onerror(er) {
        debug('onerror', er);
        unpipe();
        dest.removeListener('error', onerror);
        if (EE.listenerCount(dest, 'error') === 0)
          dest.emit('error', er);
      }
      // This is a brutally ugly hack to make sure that our error handler
      // is attached before any userland ones.  NEVER DO THIS.
      if (!dest._events || !dest._events.error)
        dest.on('error', onerror);
      else if (isArray(dest._events.error))
        dest._events.error.unshift(onerror);
      else
        dest._events.error = [onerror, dest._events.error];
    
    
    
      // Both close and finish should trigger unpipe, but only once.
      function onclose() {
        dest.removeListener('finish', onfinish);
        unpipe();
      }
      dest.once('close', onclose);
      function onfinish() {
        debug('onfinish');
        dest.removeListener('close', onclose);
        unpipe();
      }
      dest.once('finish', onfinish);
    
      function unpipe() {
        debug('unpipe');
        src.unpipe(dest);
      }
    
      // tell the dest that it's being piped to
      dest.emit('pipe', src);
    
      // start the flow if it hasn't been started already.
      if (!state.flowing) {
        debug('pipe resume');
        src.resume();
      }
    
      return dest;
    };
    
    function pipeOnDrain(src) {
      return function() {
        var state = src._readableState;
        debug('pipeOnDrain', state.awaitDrain);
        if (state.awaitDrain)
          state.awaitDrain--;
        if (state.awaitDrain === 0 && EE.listenerCount(src, 'data')) {
          state.flowing = true;
          flow(src);
        }
      };
    }
    
    
    Readable.prototype.unpipe = function(dest) {
      var state = this._readableState;
    
      // if we're not piping anywhere, then do nothing.
      if (state.pipesCount === 0)
        return this;
    
      // just one destination.  most common case.
      if (state.pipesCount === 1) {
        // passed in one, but it's not the right one.
        if (dest && dest !== state.pipes)
          return this;
    
        if (!dest)
          dest = state.pipes;
    
        // got a match.
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        if (dest)
          dest.emit('unpipe', this);
        return this;
      }
    
      // slow case. multiple pipe destinations.
    
      if (!dest) {
        // remove all.
        var dests = state.pipes;
        var len = state.pipesCount;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
    
        for (var i = 0; i < len; i++)
          dests[i].emit('unpipe', this);
        return this;
      }
    
      // try to find the right one.
      var i = indexOf(state.pipes, dest);
      if (i === -1)
        return this;
    
      state.pipes.splice(i, 1);
      state.pipesCount -= 1;
      if (state.pipesCount === 1)
        state.pipes = state.pipes[0];
    
      dest.emit('unpipe', this);
    
      return this;
    };
    
    // set up data events if they are asked for
    // Ensure readable listeners eventually get something
    Readable.prototype.on = function(ev, fn) {
      var res = Stream.prototype.on.call(this, ev, fn);
    
      // If listening to data, and it has not explicitly been paused,
      // then call resume to start the flow of data on the next tick.
      if (ev === 'data' && false !== this._readableState.flowing) {
        this.resume();
      }
    
      if (ev === 'readable' && this.readable) {
        var state = this._readableState;
        if (!state.readableListening) {
          state.readableListening = true;
          state.emittedReadable = false;
          state.needReadable = true;
          if (!state.reading) {
            processNextTick(nReadingNextTick, this);
          } else if (state.length) {
            emitReadable(this, state);
          }
        }
      }
    
      return res;
    };
    Readable.prototype.addListener = Readable.prototype.on;
    
    function nReadingNextTick(self) {
      debug('readable nexttick read 0');
      self.read(0);
    }
    
    // pause() and resume() are remnants of the legacy readable stream API
    // If the user uses them, then switch into old mode.
    Readable.prototype.resume = function() {
      var state = this._readableState;
      if (!state.flowing) {
        debug('resume');
        state.flowing = true;
        resume(this, state);
      }
      return this;
    };
    
    function resume(stream, state) {
      if (!state.resumeScheduled) {
        state.resumeScheduled = true;
        processNextTick(resume_, stream, state);
      }
    }
    
    function resume_(stream, state) {
      if (!state.reading) {
        debug('resume read 0');
        stream.read(0);
      }
    
      state.resumeScheduled = false;
      stream.emit('resume');
      flow(stream);
      if (state.flowing && !state.reading)
        stream.read(0);
    }
    
    Readable.prototype.pause = function() {
      debug('call pause flowing=%j', this._readableState.flowing);
      if (false !== this._readableState.flowing) {
        debug('pause');
        this._readableState.flowing = false;
        this.emit('pause');
      }
      return this;
    };
    
    function flow(stream) {
      var state = stream._readableState;
      debug('flow', state.flowing);
      if (state.flowing) {
        do {
          var chunk = stream.read();
        } while (null !== chunk && state.flowing);
      }
    }
    
    // wrap an old-style stream as the async data source.
    // This is *not* part of the readable stream interface.
    // It is an ugly unfortunate mess of history.
    Readable.prototype.wrap = function(stream) {
      var state = this._readableState;
      var paused = false;
    
      var self = this;
      stream.on('end', function() {
        debug('wrapped end');
        if (state.decoder && !state.ended) {
          var chunk = state.decoder.end();
          if (chunk && chunk.length)
            self.push(chunk);
        }
    
        self.push(null);
      });
    
      stream.on('data', function(chunk) {
        debug('wrapped data');
        if (state.decoder)
          chunk = state.decoder.write(chunk);
    
        // don't skip over falsy values in objectMode
        if (state.objectMode && (chunk === null || chunk === undefined))
          return;
        else if (!state.objectMode && (!chunk || !chunk.length))
          return;
    
        var ret = self.push(chunk);
        if (!ret) {
          paused = true;
          stream.pause();
        }
      });
    
      // proxy all the other methods.
      // important when wrapping filters and duplexes.
      for (var i in stream) {
        if (this[i] === undefined && typeof stream[i] === 'function') {
          this[i] = function(method) { return function() {
            return stream[method].apply(stream, arguments);
          }; }(i);
        }
      }
    
      // proxy certain important events.
      var events = ['error', 'close', 'destroy', 'pause', 'resume'];
      forEach(events, function(ev) {
        stream.on(ev, self.emit.bind(self, ev));
      });
    
      // when we try to consume some more bytes, simply unpause the
      // underlying stream.
      self._read = function(n) {
        debug('wrapped _read', n);
        if (paused) {
          paused = false;
          stream.resume();
        }
      };
    
      return self;
    };
    
    
    
    // exposed for testing purposes only.
    Readable._fromList = fromList;
    
    // Pluck off n bytes from an array of buffers.
    // Length is the combined lengths of all the buffers in the list.
    function fromList(n, state) {
      var list = state.buffer;
      var length = state.length;
      var stringMode = !!state.decoder;
      var objectMode = !!state.objectMode;
      var ret;
    
      // nothing in the list, definitely empty.
      if (list.length === 0)
        return null;
    
      if (length === 0)
        ret = null;
      else if (objectMode)
        ret = list.shift();
      else if (!n || n >= length) {
        // read it all, truncate the array.
        if (stringMode)
          ret = list.join('');
        else
          ret = Buffer.concat(list, length);
        list.length = 0;
      } else {
        // read just some of it.
        if (n < list[0].length) {
          // just take a part of the first list item.
          // slice is the same for buffers and strings.
          var buf = list[0];
          ret = buf.slice(0, n);
          list[0] = buf.slice(n);
        } else if (n === list[0].length) {
          // first list is a perfect match
          ret = list.shift();
        } else {
          // complex case.
          // we have enough to cover it, but it spans past the first buffer.
          if (stringMode)
            ret = '';
          else
            ret = new Buffer(n);
    
          var c = 0;
          for (var i = 0, l = list.length; i < l && c < n; i++) {
            var buf = list[0];
            var cpy = Math.min(n - c, buf.length);
    
            if (stringMode)
              ret += buf.slice(0, cpy);
            else
              buf.copy(ret, c, 0, cpy);
    
            if (cpy < buf.length)
              list[0] = buf.slice(cpy);
            else
              list.shift();
    
            c += cpy;
          }
        }
      }
    
      return ret;
    }
    
    function endReadable(stream) {
      var state = stream._readableState;
    
      // If we get here before consuming all the bytes, then that is a
      // bug in node.  Should never happen.
      if (state.length > 0)
        throw new Error('endReadable called on non-empty stream');
    
      if (!state.endEmitted) {
        state.ended = true;
        processNextTick(endReadableNT, state, stream);
      }
    }
    
    function endReadableNT(state, stream) {
      // Check that we didn't get one last unshift.
      if (!state.endEmitted && state.length === 0) {
        state.endEmitted = true;
        stream.readable = false;
        stream.emit('end');
      }
    }
    
    function forEach (xs, f) {
      for (var i = 0, l = xs.length; i < l; i++) {
        f(xs[i], i);
      }
    }
    
    function indexOf (xs, x) {
      for (var i = 0, l = xs.length; i < l; i++) {
        if (xs[i] === x) return i;
      }
      return -1;
    }
    
  provide("readable-stream/lib/_stream_readable", module.exports);
}(global));

// pakmanager:readable-stream/lib/_stream_duplex
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // a duplex stream is just a stream that is both readable and writable.
    // Since JS doesn't have multiple prototypal inheritance, this class
    // prototypally inherits from Readable, and then parasitically from
    // Writable.
    
    'use strict';
    
    /*<replacement>*/
    var objectKeys = Object.keys || function (obj) {
      var keys = [];
      for (var key in obj) keys.push(key);
      return keys;
    }
    /*</replacement>*/
    
    
    module.exports = Duplex;
    
    /*<replacement>*/
    var processNextTick = require('process-nextick-args');
    /*</replacement>*/
    
    
    
    /*<replacement>*/
    var util = require('core-util-is');
    util.inherits = require('inherits');
    /*</replacement>*/
    
    var Readable =  require('readable-stream/lib/_stream_readable');
    var Writable =  require('readable-stream/lib/_stream_writable');
    
    util.inherits(Duplex, Readable);
    
    var keys = objectKeys(Writable.prototype);
    for (var v = 0; v < keys.length; v++) {
      var method = keys[v];
      if (!Duplex.prototype[method])
        Duplex.prototype[method] = Writable.prototype[method];
    }
    
    function Duplex(options) {
      if (!(this instanceof Duplex))
        return new Duplex(options);
    
      Readable.call(this, options);
      Writable.call(this, options);
    
      if (options && options.readable === false)
        this.readable = false;
    
      if (options && options.writable === false)
        this.writable = false;
    
      this.allowHalfOpen = true;
      if (options && options.allowHalfOpen === false)
        this.allowHalfOpen = false;
    
      this.once('end', onend);
    }
    
    // the no-half-open enforcer
    function onend() {
      // if we allow half-open state, or if the writable side ended,
      // then we're ok.
      if (this.allowHalfOpen || this._writableState.ended)
        return;
    
      // no more data can be written.
      // But allow more writes to happen in this tick.
      processNextTick(onEndNT, this);
    }
    
    function onEndNT(self) {
      self.end();
    }
    
    function forEach (xs, f) {
      for (var i = 0, l = xs.length; i < l; i++) {
        f(xs[i], i);
      }
    }
    
  provide("readable-stream/lib/_stream_duplex", module.exports);
}(global));

// pakmanager:readable-stream/lib/_stream_transform
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // a transform stream is a readable/writable stream where you do
    // something with the data.  Sometimes it's called a "filter",
    // but that's not a great name for it, since that implies a thing where
    // some bits pass through, and others are simply ignored.  (That would
    // be a valid example of a transform, of course.)
    //
    // While the output is causally related to the input, it's not a
    // necessarily symmetric or synchronous transformation.  For example,
    // a zlib stream might take multiple plain-text writes(), and then
    // emit a single compressed chunk some time in the future.
    //
    // Here's how this works:
    //
    // The Transform stream has all the aspects of the readable and writable
    // stream classes.  When you write(chunk), that calls _write(chunk,cb)
    // internally, and returns false if there's a lot of pending writes
    // buffered up.  When you call read(), that calls _read(n) until
    // there's enough pending readable data buffered up.
    //
    // In a transform stream, the written data is placed in a buffer.  When
    // _read(n) is called, it transforms the queued up data, calling the
    // buffered _write cb's as it consumes chunks.  If consuming a single
    // written chunk would result in multiple output chunks, then the first
    // outputted bit calls the readcb, and subsequent chunks just go into
    // the read buffer, and will cause it to emit 'readable' if necessary.
    //
    // This way, back-pressure is actually determined by the reading side,
    // since _read has to be called to start processing a new chunk.  However,
    // a pathological inflate type of transform can cause excessive buffering
    // here.  For example, imagine a stream where every byte of input is
    // interpreted as an integer from 0-255, and then results in that many
    // bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
    // 1kb of data being output.  In this case, you could write a very small
    // amount of input, and end up with a very large amount of output.  In
    // such a pathological inflating mechanism, there'd be no way to tell
    // the system to stop doing the transform.  A single 4MB write could
    // cause the system to run out of memory.
    //
    // However, even in such a pathological case, only a single written chunk
    // would be consumed, and then the rest would wait (un-transformed) until
    // the results of the previous transformed chunk were consumed.
    
    'use strict';
    
    module.exports = Transform;
    
    var Duplex =  require('readable-stream/lib/_stream_duplex');
    
    /*<replacement>*/
    var util = require('core-util-is');
    util.inherits = require('inherits');
    /*</replacement>*/
    
    util.inherits(Transform, Duplex);
    
    
    function TransformState(stream) {
      this.afterTransform = function(er, data) {
        return afterTransform(stream, er, data);
      };
    
      this.needTransform = false;
      this.transforming = false;
      this.writecb = null;
      this.writechunk = null;
    }
    
    function afterTransform(stream, er, data) {
      var ts = stream._transformState;
      ts.transforming = false;
    
      var cb = ts.writecb;
    
      if (!cb)
        return stream.emit('error', new Error('no writecb in Transform class'));
    
      ts.writechunk = null;
      ts.writecb = null;
    
      if (data !== null && data !== undefined)
        stream.push(data);
    
      if (cb)
        cb(er);
    
      var rs = stream._readableState;
      rs.reading = false;
      if (rs.needReadable || rs.length < rs.highWaterMark) {
        stream._read(rs.highWaterMark);
      }
    }
    
    
    function Transform(options) {
      if (!(this instanceof Transform))
        return new Transform(options);
    
      Duplex.call(this, options);
    
      this._transformState = new TransformState(this);
    
      // when the writable side finishes, then flush out anything remaining.
      var stream = this;
    
      // start out asking for a readable event once data is transformed.
      this._readableState.needReadable = true;
    
      // we have implemented the _read method, and done the other things
      // that Readable wants before the first _read call, so unset the
      // sync guard flag.
      this._readableState.sync = false;
    
      if (options) {
        if (typeof options.transform === 'function')
          this._transform = options.transform;
    
        if (typeof options.flush === 'function')
          this._flush = options.flush;
      }
    
      this.once('prefinish', function() {
        if (typeof this._flush === 'function')
          this._flush(function(er) {
            done(stream, er);
          });
        else
          done(stream);
      });
    }
    
    Transform.prototype.push = function(chunk, encoding) {
      this._transformState.needTransform = false;
      return Duplex.prototype.push.call(this, chunk, encoding);
    };
    
    // This is the part where you do stuff!
    // override this function in implementation classes.
    // 'chunk' is an input chunk.
    //
    // Call `push(newChunk)` to pass along transformed output
    // to the readable side.  You may call 'push' zero or more times.
    //
    // Call `cb(err)` when you are done with this chunk.  If you pass
    // an error, then that'll put the hurt on the whole operation.  If you
    // never call cb(), then you'll never get another chunk.
    Transform.prototype._transform = function(chunk, encoding, cb) {
      throw new Error('not implemented');
    };
    
    Transform.prototype._write = function(chunk, encoding, cb) {
      var ts = this._transformState;
      ts.writecb = cb;
      ts.writechunk = chunk;
      ts.writeencoding = encoding;
      if (!ts.transforming) {
        var rs = this._readableState;
        if (ts.needTransform ||
            rs.needReadable ||
            rs.length < rs.highWaterMark)
          this._read(rs.highWaterMark);
      }
    };
    
    // Doesn't matter what the args are here.
    // _transform does all the work.
    // That we got here means that the readable side wants more data.
    Transform.prototype._read = function(n) {
      var ts = this._transformState;
    
      if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
        ts.transforming = true;
        this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
      } else {
        // mark that we need a transform, so that any data that comes in
        // will get processed, now that we've asked for it.
        ts.needTransform = true;
      }
    };
    
    
    function done(stream, er) {
      if (er)
        return stream.emit('error', er);
    
      // if there's nothing in the write buffer, then that means
      // that nothing more will ever be provided
      var ws = stream._writableState;
      var ts = stream._transformState;
    
      if (ws.length)
        throw new Error('calling transform done when ws.length != 0');
    
      if (ts.transforming)
        throw new Error('calling transform done when still transforming');
    
      return stream.push(null);
    }
    
  provide("readable-stream/lib/_stream_transform", module.exports);
}(global));

// pakmanager:readable-stream/lib/_stream_readable.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    module.exports = Readable;
    
    /*<replacement>*/
    var processNextTick = require('process-nextick-args');
    /*</replacement>*/
    
    
    /*<replacement>*/
    var isArray = require('isarray');
    /*</replacement>*/
    
    
    /*<replacement>*/
    var Buffer = require('buffer').Buffer;
    /*</replacement>*/
    
    Readable.ReadableState = ReadableState;
    
    var EE = require('events').EventEmitter;
    
    /*<replacement>*/
    if (!EE.listenerCount) EE.listenerCount = function(emitter, type) {
      return emitter.listeners(type).length;
    };
    /*</replacement>*/
    
    
    
    /*<replacement>*/
    var Stream;
     (function (){try{
    Stream = require('st' + 'ream');
    }catch(_){Stream = require('events').EventEmitter;}}())
    /*</replacement>*/
    
    var Buffer = require('buffer').Buffer;
    
    /*<replacement>*/
    var util = require('core-util-is');
    util.inherits = require('inherits');
    /*</replacement>*/
    
    
    
    /*<replacement>*/
    var debug = require('util');
    if (debug && debug.debuglog) {
      debug = debug.debuglog('stream');
    } else {
      debug = function () {};
    }
    /*</replacement>*/
    
    var StringDecoder;
    
    util.inherits(Readable, Stream);
    
    function ReadableState(options, stream) {
      var Duplex =  require('readable-stream/lib/_stream_duplex');
    
      options = options || {};
    
      // object stream flag. Used to make read(n) ignore n and to
      // make all the buffer merging and length checks go away
      this.objectMode = !!options.objectMode;
    
      if (stream instanceof Duplex)
        this.objectMode = this.objectMode || !!options.readableObjectMode;
    
      // the point at which it stops calling _read() to fill the buffer
      // Note: 0 is a valid value, means "don't call _read preemptively ever"
      var hwm = options.highWaterMark;
      var defaultHwm = this.objectMode ? 16 : 16 * 1024;
      this.highWaterMark = (hwm || hwm === 0) ? hwm : defaultHwm;
    
      // cast to ints.
      this.highWaterMark = ~~this.highWaterMark;
    
      this.buffer = [];
      this.length = 0;
      this.pipes = null;
      this.pipesCount = 0;
      this.flowing = null;
      this.ended = false;
      this.endEmitted = false;
      this.reading = false;
    
      // a flag to be able to tell if the onwrite cb is called immediately,
      // or on a later tick.  We set this to true at first, because any
      // actions that shouldn't happen until "later" should generally also
      // not happen before the first write call.
      this.sync = true;
    
      // whenever we return null, then we set a flag to say
      // that we're awaiting a 'readable' event emission.
      this.needReadable = false;
      this.emittedReadable = false;
      this.readableListening = false;
    
      // Crypto is kind of old and crusty.  Historically, its default string
      // encoding is 'binary' so we have to make this configurable.
      // Everything else in the universe uses 'utf8', though.
      this.defaultEncoding = options.defaultEncoding || 'utf8';
    
      // when piping, we only care about 'readable' events that happen
      // after read()ing all the bytes and not getting any pushback.
      this.ranOut = false;
    
      // the number of writers that are awaiting a drain event in .pipe()s
      this.awaitDrain = 0;
    
      // if true, a maybeReadMore has been scheduled
      this.readingMore = false;
    
      this.decoder = null;
      this.encoding = null;
      if (options.encoding) {
        if (!StringDecoder)
          StringDecoder = require('string_decoder/').StringDecoder;
        this.decoder = new StringDecoder(options.encoding);
        this.encoding = options.encoding;
      }
    }
    
    function Readable(options) {
      var Duplex =  require('readable-stream/lib/_stream_duplex');
    
      if (!(this instanceof Readable))
        return new Readable(options);
    
      this._readableState = new ReadableState(options, this);
    
      // legacy
      this.readable = true;
    
      if (options && typeof options.read === 'function')
        this._read = options.read;
    
      Stream.call(this);
    }
    
    // Manually shove something into the read() buffer.
    // This returns true if the highWaterMark has not been hit yet,
    // similar to how Writable.write() returns true if you should
    // write() some more.
    Readable.prototype.push = function(chunk, encoding) {
      var state = this._readableState;
    
      if (!state.objectMode && typeof chunk === 'string') {
        encoding = encoding || state.defaultEncoding;
        if (encoding !== state.encoding) {
          chunk = new Buffer(chunk, encoding);
          encoding = '';
        }
      }
    
      return readableAddChunk(this, state, chunk, encoding, false);
    };
    
    // Unshift should *always* be something directly out of read()
    Readable.prototype.unshift = function(chunk) {
      var state = this._readableState;
      return readableAddChunk(this, state, chunk, '', true);
    };
    
    Readable.prototype.isPaused = function() {
      return this._readableState.flowing === false;
    };
    
    function readableAddChunk(stream, state, chunk, encoding, addToFront) {
      var er = chunkInvalid(state, chunk);
      if (er) {
        stream.emit('error', er);
      } else if (chunk === null) {
        state.reading = false;
        onEofChunk(stream, state);
      } else if (state.objectMode || chunk && chunk.length > 0) {
        if (state.ended && !addToFront) {
          var e = new Error('stream.push() after EOF');
          stream.emit('error', e);
        } else if (state.endEmitted && addToFront) {
          var e = new Error('stream.unshift() after end event');
          stream.emit('error', e);
        } else {
          if (state.decoder && !addToFront && !encoding)
            chunk = state.decoder.write(chunk);
    
          if (!addToFront)
            state.reading = false;
    
          // if we want the data now, just emit it.
          if (state.flowing && state.length === 0 && !state.sync) {
            stream.emit('data', chunk);
            stream.read(0);
          } else {
            // update the buffer info.
            state.length += state.objectMode ? 1 : chunk.length;
            if (addToFront)
              state.buffer.unshift(chunk);
            else
              state.buffer.push(chunk);
    
            if (state.needReadable)
              emitReadable(stream);
          }
    
          maybeReadMore(stream, state);
        }
      } else if (!addToFront) {
        state.reading = false;
      }
    
      return needMoreData(state);
    }
    
    
    
    // if it's past the high water mark, we can push in some more.
    // Also, if we have no data yet, we can stand some
    // more bytes.  This is to work around cases where hwm=0,
    // such as the repl.  Also, if the push() triggered a
    // readable event, and the user called read(largeNumber) such that
    // needReadable was set, then we ought to push more, so that another
    // 'readable' event will be triggered.
    function needMoreData(state) {
      return !state.ended &&
             (state.needReadable ||
              state.length < state.highWaterMark ||
              state.length === 0);
    }
    
    // backwards compatibility.
    Readable.prototype.setEncoding = function(enc) {
      if (!StringDecoder)
        StringDecoder = require('string_decoder/').StringDecoder;
      this._readableState.decoder = new StringDecoder(enc);
      this._readableState.encoding = enc;
      return this;
    };
    
    // Don't raise the hwm > 128MB
    var MAX_HWM = 0x800000;
    function roundUpToNextPowerOf2(n) {
      if (n >= MAX_HWM) {
        n = MAX_HWM;
      } else {
        // Get the next highest power of 2
        n--;
        for (var p = 1; p < 32; p <<= 1) n |= n >> p;
        n++;
      }
      return n;
    }
    
    function howMuchToRead(n, state) {
      if (state.length === 0 && state.ended)
        return 0;
    
      if (state.objectMode)
        return n === 0 ? 0 : 1;
    
      if (n === null || isNaN(n)) {
        // only flow one buffer at a time
        if (state.flowing && state.buffer.length)
          return state.buffer[0].length;
        else
          return state.length;
      }
    
      if (n <= 0)
        return 0;
    
      // If we're asking for more than the target buffer level,
      // then raise the water mark.  Bump up to the next highest
      // power of 2, to prevent increasing it excessively in tiny
      // amounts.
      if (n > state.highWaterMark)
        state.highWaterMark = roundUpToNextPowerOf2(n);
    
      // don't have that much.  return null, unless we've ended.
      if (n > state.length) {
        if (!state.ended) {
          state.needReadable = true;
          return 0;
        } else {
          return state.length;
        }
      }
    
      return n;
    }
    
    // you can override either this method, or the async _read(n) below.
    Readable.prototype.read = function(n) {
      debug('read', n);
      var state = this._readableState;
      var nOrig = n;
    
      if (typeof n !== 'number' || n > 0)
        state.emittedReadable = false;
    
      // if we're doing read(0) to trigger a readable event, but we
      // already have a bunch of data in the buffer, then just trigger
      // the 'readable' event and move on.
      if (n === 0 &&
          state.needReadable &&
          (state.length >= state.highWaterMark || state.ended)) {
        debug('read: emitReadable', state.length, state.ended);
        if (state.length === 0 && state.ended)
          endReadable(this);
        else
          emitReadable(this);
        return null;
      }
    
      n = howMuchToRead(n, state);
    
      // if we've ended, and we're now clear, then finish it up.
      if (n === 0 && state.ended) {
        if (state.length === 0)
          endReadable(this);
        return null;
      }
    
      // All the actual chunk generation logic needs to be
      // *below* the call to _read.  The reason is that in certain
      // synthetic stream cases, such as passthrough streams, _read
      // may be a completely synchronous operation which may change
      // the state of the read buffer, providing enough data when
      // before there was *not* enough.
      //
      // So, the steps are:
      // 1. Figure out what the state of things will be after we do
      // a read from the buffer.
      //
      // 2. If that resulting state will trigger a _read, then call _read.
      // Note that this may be asynchronous, or synchronous.  Yes, it is
      // deeply ugly to write APIs this way, but that still doesn't mean
      // that the Readable class should behave improperly, as streams are
      // designed to be sync/async agnostic.
      // Take note if the _read call is sync or async (ie, if the read call
      // has returned yet), so that we know whether or not it's safe to emit
      // 'readable' etc.
      //
      // 3. Actually pull the requested chunks out of the buffer and return.
    
      // if we need a readable event, then we need to do some reading.
      var doRead = state.needReadable;
      debug('need readable', doRead);
    
      // if we currently have less than the highWaterMark, then also read some
      if (state.length === 0 || state.length - n < state.highWaterMark) {
        doRead = true;
        debug('length less than watermark', doRead);
      }
    
      // however, if we've ended, then there's no point, and if we're already
      // reading, then it's unnecessary.
      if (state.ended || state.reading) {
        doRead = false;
        debug('reading or ended', doRead);
      }
    
      if (doRead) {
        debug('do read');
        state.reading = true;
        state.sync = true;
        // if the length is currently zero, then we *need* a readable event.
        if (state.length === 0)
          state.needReadable = true;
        // call internal read method
        this._read(state.highWaterMark);
        state.sync = false;
      }
    
      // If _read pushed data synchronously, then `reading` will be false,
      // and we need to re-evaluate how much data we can return to the user.
      if (doRead && !state.reading)
        n = howMuchToRead(nOrig, state);
    
      var ret;
      if (n > 0)
        ret = fromList(n, state);
      else
        ret = null;
    
      if (ret === null) {
        state.needReadable = true;
        n = 0;
      }
    
      state.length -= n;
    
      // If we have nothing in the buffer, then we want to know
      // as soon as we *do* get something into the buffer.
      if (state.length === 0 && !state.ended)
        state.needReadable = true;
    
      // If we tried to read() past the EOF, then emit end on the next tick.
      if (nOrig !== n && state.ended && state.length === 0)
        endReadable(this);
    
      if (ret !== null)
        this.emit('data', ret);
    
      return ret;
    };
    
    function chunkInvalid(state, chunk) {
      var er = null;
      if (!(Buffer.isBuffer(chunk)) &&
          typeof chunk !== 'string' &&
          chunk !== null &&
          chunk !== undefined &&
          !state.objectMode) {
        er = new TypeError('Invalid non-string/buffer chunk');
      }
      return er;
    }
    
    
    function onEofChunk(stream, state) {
      if (state.ended) return;
      if (state.decoder) {
        var chunk = state.decoder.end();
        if (chunk && chunk.length) {
          state.buffer.push(chunk);
          state.length += state.objectMode ? 1 : chunk.length;
        }
      }
      state.ended = true;
    
      // emit 'readable' now to make sure it gets picked up.
      emitReadable(stream);
    }
    
    // Don't emit readable right away in sync mode, because this can trigger
    // another read() call => stack overflow.  This way, it might trigger
    // a nextTick recursion warning, but that's not so bad.
    function emitReadable(stream) {
      var state = stream._readableState;
      state.needReadable = false;
      if (!state.emittedReadable) {
        debug('emitReadable', state.flowing);
        state.emittedReadable = true;
        if (state.sync)
          processNextTick(emitReadable_, stream);
        else
          emitReadable_(stream);
      }
    }
    
    function emitReadable_(stream) {
      debug('emit readable');
      stream.emit('readable');
      flow(stream);
    }
    
    
    // at this point, the user has presumably seen the 'readable' event,
    // and called read() to consume some data.  that may have triggered
    // in turn another _read(n) call, in which case reading = true if
    // it's in progress.
    // However, if we're not ended, or reading, and the length < hwm,
    // then go ahead and try to read some more preemptively.
    function maybeReadMore(stream, state) {
      if (!state.readingMore) {
        state.readingMore = true;
        processNextTick(maybeReadMore_, stream, state);
      }
    }
    
    function maybeReadMore_(stream, state) {
      var len = state.length;
      while (!state.reading && !state.flowing && !state.ended &&
             state.length < state.highWaterMark) {
        debug('maybeReadMore read 0');
        stream.read(0);
        if (len === state.length)
          // didn't get any data, stop spinning.
          break;
        else
          len = state.length;
      }
      state.readingMore = false;
    }
    
    // abstract method.  to be overridden in specific implementation classes.
    // call cb(er, data) where data is <= n in length.
    // for virtual (non-string, non-buffer) streams, "length" is somewhat
    // arbitrary, and perhaps not very meaningful.
    Readable.prototype._read = function(n) {
      this.emit('error', new Error('not implemented'));
    };
    
    Readable.prototype.pipe = function(dest, pipeOpts) {
      var src = this;
      var state = this._readableState;
    
      switch (state.pipesCount) {
        case 0:
          state.pipes = dest;
          break;
        case 1:
          state.pipes = [state.pipes, dest];
          break;
        default:
          state.pipes.push(dest);
          break;
      }
      state.pipesCount += 1;
      debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);
    
      var doEnd = (!pipeOpts || pipeOpts.end !== false) &&
                  dest !== process.stdout &&
                  dest !== process.stderr;
    
      var endFn = doEnd ? onend : cleanup;
      if (state.endEmitted)
        processNextTick(endFn);
      else
        src.once('end', endFn);
    
      dest.on('unpipe', onunpipe);
      function onunpipe(readable) {
        debug('onunpipe');
        if (readable === src) {
          cleanup();
        }
      }
    
      function onend() {
        debug('onend');
        dest.end();
      }
    
      // when the dest drains, it reduces the awaitDrain counter
      // on the source.  This would be more elegant with a .once()
      // handler in flow(), but adding and removing repeatedly is
      // too slow.
      var ondrain = pipeOnDrain(src);
      dest.on('drain', ondrain);
    
      function cleanup() {
        debug('cleanup');
        // cleanup event handlers once the pipe is broken
        dest.removeListener('close', onclose);
        dest.removeListener('finish', onfinish);
        dest.removeListener('drain', ondrain);
        dest.removeListener('error', onerror);
        dest.removeListener('unpipe', onunpipe);
        src.removeListener('end', onend);
        src.removeListener('end', cleanup);
        src.removeListener('data', ondata);
    
        // if the reader is waiting for a drain event from this
        // specific writer, then it would cause it to never start
        // flowing again.
        // So, if this is awaiting a drain, then we just call it now.
        // If we don't know, then assume that we are waiting for one.
        if (state.awaitDrain &&
            (!dest._writableState || dest._writableState.needDrain))
          ondrain();
      }
    
      src.on('data', ondata);
      function ondata(chunk) {
        debug('ondata');
        var ret = dest.write(chunk);
        if (false === ret) {
          debug('false write response, pause',
                src._readableState.awaitDrain);
          src._readableState.awaitDrain++;
          src.pause();
        }
      }
    
      // if the dest has an error, then stop piping into it.
      // however, don't suppress the throwing behavior for this.
      function onerror(er) {
        debug('onerror', er);
        unpipe();
        dest.removeListener('error', onerror);
        if (EE.listenerCount(dest, 'error') === 0)
          dest.emit('error', er);
      }
      // This is a brutally ugly hack to make sure that our error handler
      // is attached before any userland ones.  NEVER DO THIS.
      if (!dest._events || !dest._events.error)
        dest.on('error', onerror);
      else if (isArray(dest._events.error))
        dest._events.error.unshift(onerror);
      else
        dest._events.error = [onerror, dest._events.error];
    
    
    
      // Both close and finish should trigger unpipe, but only once.
      function onclose() {
        dest.removeListener('finish', onfinish);
        unpipe();
      }
      dest.once('close', onclose);
      function onfinish() {
        debug('onfinish');
        dest.removeListener('close', onclose);
        unpipe();
      }
      dest.once('finish', onfinish);
    
      function unpipe() {
        debug('unpipe');
        src.unpipe(dest);
      }
    
      // tell the dest that it's being piped to
      dest.emit('pipe', src);
    
      // start the flow if it hasn't been started already.
      if (!state.flowing) {
        debug('pipe resume');
        src.resume();
      }
    
      return dest;
    };
    
    function pipeOnDrain(src) {
      return function() {
        var state = src._readableState;
        debug('pipeOnDrain', state.awaitDrain);
        if (state.awaitDrain)
          state.awaitDrain--;
        if (state.awaitDrain === 0 && EE.listenerCount(src, 'data')) {
          state.flowing = true;
          flow(src);
        }
      };
    }
    
    
    Readable.prototype.unpipe = function(dest) {
      var state = this._readableState;
    
      // if we're not piping anywhere, then do nothing.
      if (state.pipesCount === 0)
        return this;
    
      // just one destination.  most common case.
      if (state.pipesCount === 1) {
        // passed in one, but it's not the right one.
        if (dest && dest !== state.pipes)
          return this;
    
        if (!dest)
          dest = state.pipes;
    
        // got a match.
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        if (dest)
          dest.emit('unpipe', this);
        return this;
      }
    
      // slow case. multiple pipe destinations.
    
      if (!dest) {
        // remove all.
        var dests = state.pipes;
        var len = state.pipesCount;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
    
        for (var i = 0; i < len; i++)
          dests[i].emit('unpipe', this);
        return this;
      }
    
      // try to find the right one.
      var i = indexOf(state.pipes, dest);
      if (i === -1)
        return this;
    
      state.pipes.splice(i, 1);
      state.pipesCount -= 1;
      if (state.pipesCount === 1)
        state.pipes = state.pipes[0];
    
      dest.emit('unpipe', this);
    
      return this;
    };
    
    // set up data events if they are asked for
    // Ensure readable listeners eventually get something
    Readable.prototype.on = function(ev, fn) {
      var res = Stream.prototype.on.call(this, ev, fn);
    
      // If listening to data, and it has not explicitly been paused,
      // then call resume to start the flow of data on the next tick.
      if (ev === 'data' && false !== this._readableState.flowing) {
        this.resume();
      }
    
      if (ev === 'readable' && this.readable) {
        var state = this._readableState;
        if (!state.readableListening) {
          state.readableListening = true;
          state.emittedReadable = false;
          state.needReadable = true;
          if (!state.reading) {
            processNextTick(nReadingNextTick, this);
          } else if (state.length) {
            emitReadable(this, state);
          }
        }
      }
    
      return res;
    };
    Readable.prototype.addListener = Readable.prototype.on;
    
    function nReadingNextTick(self) {
      debug('readable nexttick read 0');
      self.read(0);
    }
    
    // pause() and resume() are remnants of the legacy readable stream API
    // If the user uses them, then switch into old mode.
    Readable.prototype.resume = function() {
      var state = this._readableState;
      if (!state.flowing) {
        debug('resume');
        state.flowing = true;
        resume(this, state);
      }
      return this;
    };
    
    function resume(stream, state) {
      if (!state.resumeScheduled) {
        state.resumeScheduled = true;
        processNextTick(resume_, stream, state);
      }
    }
    
    function resume_(stream, state) {
      if (!state.reading) {
        debug('resume read 0');
        stream.read(0);
      }
    
      state.resumeScheduled = false;
      stream.emit('resume');
      flow(stream);
      if (state.flowing && !state.reading)
        stream.read(0);
    }
    
    Readable.prototype.pause = function() {
      debug('call pause flowing=%j', this._readableState.flowing);
      if (false !== this._readableState.flowing) {
        debug('pause');
        this._readableState.flowing = false;
        this.emit('pause');
      }
      return this;
    };
    
    function flow(stream) {
      var state = stream._readableState;
      debug('flow', state.flowing);
      if (state.flowing) {
        do {
          var chunk = stream.read();
        } while (null !== chunk && state.flowing);
      }
    }
    
    // wrap an old-style stream as the async data source.
    // This is *not* part of the readable stream interface.
    // It is an ugly unfortunate mess of history.
    Readable.prototype.wrap = function(stream) {
      var state = this._readableState;
      var paused = false;
    
      var self = this;
      stream.on('end', function() {
        debug('wrapped end');
        if (state.decoder && !state.ended) {
          var chunk = state.decoder.end();
          if (chunk && chunk.length)
            self.push(chunk);
        }
    
        self.push(null);
      });
    
      stream.on('data', function(chunk) {
        debug('wrapped data');
        if (state.decoder)
          chunk = state.decoder.write(chunk);
    
        // don't skip over falsy values in objectMode
        if (state.objectMode && (chunk === null || chunk === undefined))
          return;
        else if (!state.objectMode && (!chunk || !chunk.length))
          return;
    
        var ret = self.push(chunk);
        if (!ret) {
          paused = true;
          stream.pause();
        }
      });
    
      // proxy all the other methods.
      // important when wrapping filters and duplexes.
      for (var i in stream) {
        if (this[i] === undefined && typeof stream[i] === 'function') {
          this[i] = function(method) { return function() {
            return stream[method].apply(stream, arguments);
          }; }(i);
        }
      }
    
      // proxy certain important events.
      var events = ['error', 'close', 'destroy', 'pause', 'resume'];
      forEach(events, function(ev) {
        stream.on(ev, self.emit.bind(self, ev));
      });
    
      // when we try to consume some more bytes, simply unpause the
      // underlying stream.
      self._read = function(n) {
        debug('wrapped _read', n);
        if (paused) {
          paused = false;
          stream.resume();
        }
      };
    
      return self;
    };
    
    
    
    // exposed for testing purposes only.
    Readable._fromList = fromList;
    
    // Pluck off n bytes from an array of buffers.
    // Length is the combined lengths of all the buffers in the list.
    function fromList(n, state) {
      var list = state.buffer;
      var length = state.length;
      var stringMode = !!state.decoder;
      var objectMode = !!state.objectMode;
      var ret;
    
      // nothing in the list, definitely empty.
      if (list.length === 0)
        return null;
    
      if (length === 0)
        ret = null;
      else if (objectMode)
        ret = list.shift();
      else if (!n || n >= length) {
        // read it all, truncate the array.
        if (stringMode)
          ret = list.join('');
        else
          ret = Buffer.concat(list, length);
        list.length = 0;
      } else {
        // read just some of it.
        if (n < list[0].length) {
          // just take a part of the first list item.
          // slice is the same for buffers and strings.
          var buf = list[0];
          ret = buf.slice(0, n);
          list[0] = buf.slice(n);
        } else if (n === list[0].length) {
          // first list is a perfect match
          ret = list.shift();
        } else {
          // complex case.
          // we have enough to cover it, but it spans past the first buffer.
          if (stringMode)
            ret = '';
          else
            ret = new Buffer(n);
    
          var c = 0;
          for (var i = 0, l = list.length; i < l && c < n; i++) {
            var buf = list[0];
            var cpy = Math.min(n - c, buf.length);
    
            if (stringMode)
              ret += buf.slice(0, cpy);
            else
              buf.copy(ret, c, 0, cpy);
    
            if (cpy < buf.length)
              list[0] = buf.slice(cpy);
            else
              list.shift();
    
            c += cpy;
          }
        }
      }
    
      return ret;
    }
    
    function endReadable(stream) {
      var state = stream._readableState;
    
      // If we get here before consuming all the bytes, then that is a
      // bug in node.  Should never happen.
      if (state.length > 0)
        throw new Error('endReadable called on non-empty stream');
    
      if (!state.endEmitted) {
        state.ended = true;
        processNextTick(endReadableNT, state, stream);
      }
    }
    
    function endReadableNT(state, stream) {
      // Check that we didn't get one last unshift.
      if (!state.endEmitted && state.length === 0) {
        state.endEmitted = true;
        stream.readable = false;
        stream.emit('end');
      }
    }
    
    function forEach (xs, f) {
      for (var i = 0, l = xs.length; i < l; i++) {
        f(xs[i], i);
      }
    }
    
    function indexOf (xs, x) {
      for (var i = 0, l = xs.length; i < l; i++) {
        if (xs[i] === x) return i;
      }
      return -1;
    }
    
  provide("readable-stream/lib/_stream_readable.js", module.exports);
}(global));

// pakmanager:readable-stream/lib/_stream_writable.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // A bit simpler than readable streams.
    // Implement an async ._write(chunk, cb), and it'll handle all
    // the drain event emission and buffering.
    
    'use strict';
    
    module.exports = Writable;
    
    /*<replacement>*/
    var processNextTick = require('process-nextick-args');
    /*</replacement>*/
    
    
    /*<replacement>*/
    var Buffer = require('buffer').Buffer;
    /*</replacement>*/
    
    Writable.WritableState = WritableState;
    
    
    /*<replacement>*/
    var util = require('core-util-is');
    util.inherits = require('inherits');
    /*</replacement>*/
    
    
    
    /*<replacement>*/
    var Stream;
     (function (){try{
    Stream = require('st' + 'ream');
    }catch(_){Stream = require('events').EventEmitter;}}())
    /*</replacement>*/
    
    var Buffer = require('buffer').Buffer;
    
    util.inherits(Writable, Stream);
    
    function nop() {}
    
    function WriteReq(chunk, encoding, cb) {
      this.chunk = chunk;
      this.encoding = encoding;
      this.callback = cb;
      this.next = null;
    }
    
    function WritableState(options, stream) {
      var Duplex =  require('readable-stream/lib/_stream_duplex');
    
      options = options || {};
    
      // object stream flag to indicate whether or not this stream
      // contains buffers or objects.
      this.objectMode = !!options.objectMode;
    
      if (stream instanceof Duplex)
        this.objectMode = this.objectMode || !!options.writableObjectMode;
    
      // the point at which write() starts returning false
      // Note: 0 is a valid value, means that we always return false if
      // the entire buffer is not flushed immediately on write()
      var hwm = options.highWaterMark;
      var defaultHwm = this.objectMode ? 16 : 16 * 1024;
      this.highWaterMark = (hwm || hwm === 0) ? hwm : defaultHwm;
    
      // cast to ints.
      this.highWaterMark = ~~this.highWaterMark;
    
      this.needDrain = false;
      // at the start of calling end()
      this.ending = false;
      // when end() has been called, and returned
      this.ended = false;
      // when 'finish' is emitted
      this.finished = false;
    
      // should we decode strings into buffers before passing to _write?
      // this is here so that some node-core streams can optimize string
      // handling at a lower level.
      var noDecode = options.decodeStrings === false;
      this.decodeStrings = !noDecode;
    
      // Crypto is kind of old and crusty.  Historically, its default string
      // encoding is 'binary' so we have to make this configurable.
      // Everything else in the universe uses 'utf8', though.
      this.defaultEncoding = options.defaultEncoding || 'utf8';
    
      // not an actual buffer we keep track of, but a measurement
      // of how much we're waiting to get pushed to some underlying
      // socket or file.
      this.length = 0;
    
      // a flag to see when we're in the middle of a write.
      this.writing = false;
    
      // when true all writes will be buffered until .uncork() call
      this.corked = 0;
    
      // a flag to be able to tell if the onwrite cb is called immediately,
      // or on a later tick.  We set this to true at first, because any
      // actions that shouldn't happen until "later" should generally also
      // not happen before the first write call.
      this.sync = true;
    
      // a flag to know if we're processing previously buffered items, which
      // may call the _write() callback in the same tick, so that we don't
      // end up in an overlapped onwrite situation.
      this.bufferProcessing = false;
    
      // the callback that's passed to _write(chunk,cb)
      this.onwrite = function(er) {
        onwrite(stream, er);
      };
    
      // the callback that the user supplies to write(chunk,encoding,cb)
      this.writecb = null;
    
      // the amount that is being written when _write is called.
      this.writelen = 0;
    
      this.bufferedRequest = null;
      this.lastBufferedRequest = null;
    
      // number of pending user-supplied write callbacks
      // this must be 0 before 'finish' can be emitted
      this.pendingcb = 0;
    
      // emit prefinish if the only thing we're waiting for is _write cbs
      // This is relevant for synchronous Transform streams
      this.prefinished = false;
    
      // True if the error was already emitted and should not be thrown again
      this.errorEmitted = false;
    }
    
    WritableState.prototype.getBuffer = function writableStateGetBuffer() {
      var current = this.bufferedRequest;
      var out = [];
      while (current) {
        out.push(current);
        current = current.next;
      }
      return out;
    };
    
    (function (){try {
    Object.defineProperty(WritableState.prototype, 'buffer', {
      get: require('util-deprecate')(function() {
        return this.getBuffer();
      }, '_writableState.buffer is deprecated. Use ' +
          '_writableState.getBuffer() instead.')
    });
    }catch(_){}}());
    
    
    function Writable(options) {
      var Duplex =  require('readable-stream/lib/_stream_duplex');
    
      // Writable ctor is applied to Duplexes, though they're not
      // instanceof Writable, they're instanceof Readable.
      if (!(this instanceof Writable) && !(this instanceof Duplex))
        return new Writable(options);
    
      this._writableState = new WritableState(options, this);
    
      // legacy.
      this.writable = true;
    
      if (options) {
        if (typeof options.write === 'function')
          this._write = options.write;
    
        if (typeof options.writev === 'function')
          this._writev = options.writev;
      }
    
      Stream.call(this);
    }
    
    // Otherwise people can pipe Writable streams, which is just wrong.
    Writable.prototype.pipe = function() {
      this.emit('error', new Error('Cannot pipe. Not readable.'));
    };
    
    
    function writeAfterEnd(stream, cb) {
      var er = new Error('write after end');
      // TODO: defer error events consistently everywhere, not just the cb
      stream.emit('error', er);
      processNextTick(cb, er);
    }
    
    // If we get something that is not a buffer, string, null, or undefined,
    // and we're not in objectMode, then that's an error.
    // Otherwise stream chunks are all considered to be of length=1, and the
    // watermarks determine how many objects to keep in the buffer, rather than
    // how many bytes or characters.
    function validChunk(stream, state, chunk, cb) {
      var valid = true;
    
      if (!(Buffer.isBuffer(chunk)) &&
          typeof chunk !== 'string' &&
          chunk !== null &&
          chunk !== undefined &&
          !state.objectMode) {
        var er = new TypeError('Invalid non-string/buffer chunk');
        stream.emit('error', er);
        processNextTick(cb, er);
        valid = false;
      }
      return valid;
    }
    
    Writable.prototype.write = function(chunk, encoding, cb) {
      var state = this._writableState;
      var ret = false;
    
      if (typeof encoding === 'function') {
        cb = encoding;
        encoding = null;
      }
    
      if (Buffer.isBuffer(chunk))
        encoding = 'buffer';
      else if (!encoding)
        encoding = state.defaultEncoding;
    
      if (typeof cb !== 'function')
        cb = nop;
    
      if (state.ended)
        writeAfterEnd(this, cb);
      else if (validChunk(this, state, chunk, cb)) {
        state.pendingcb++;
        ret = writeOrBuffer(this, state, chunk, encoding, cb);
      }
    
      return ret;
    };
    
    Writable.prototype.cork = function() {
      var state = this._writableState;
    
      state.corked++;
    };
    
    Writable.prototype.uncork = function() {
      var state = this._writableState;
    
      if (state.corked) {
        state.corked--;
    
        if (!state.writing &&
            !state.corked &&
            !state.finished &&
            !state.bufferProcessing &&
            state.bufferedRequest)
          clearBuffer(this, state);
      }
    };
    
    Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
      // node::ParseEncoding() requires lower case.
      if (typeof encoding === 'string')
        encoding = encoding.toLowerCase();
      if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64',
    'ucs2', 'ucs-2','utf16le', 'utf-16le', 'raw']
    .indexOf((encoding + '').toLowerCase()) > -1))
        throw new TypeError('Unknown encoding: ' + encoding);
      this._writableState.defaultEncoding = encoding;
    };
    
    function decodeChunk(state, chunk, encoding) {
      if (!state.objectMode &&
          state.decodeStrings !== false &&
          typeof chunk === 'string') {
        chunk = new Buffer(chunk, encoding);
      }
      return chunk;
    }
    
    // if we're already writing something, then just put this
    // in the queue, and wait our turn.  Otherwise, call _write
    // If we return false, then we need a drain event, so set that flag.
    function writeOrBuffer(stream, state, chunk, encoding, cb) {
      chunk = decodeChunk(state, chunk, encoding);
    
      if (Buffer.isBuffer(chunk))
        encoding = 'buffer';
      var len = state.objectMode ? 1 : chunk.length;
    
      state.length += len;
    
      var ret = state.length < state.highWaterMark;
      // we must ensure that previous needDrain will not be reset to false.
      if (!ret)
        state.needDrain = true;
    
      if (state.writing || state.corked) {
        var last = state.lastBufferedRequest;
        state.lastBufferedRequest = new WriteReq(chunk, encoding, cb);
        if (last) {
          last.next = state.lastBufferedRequest;
        } else {
          state.bufferedRequest = state.lastBufferedRequest;
        }
      } else {
        doWrite(stream, state, false, len, chunk, encoding, cb);
      }
    
      return ret;
    }
    
    function doWrite(stream, state, writev, len, chunk, encoding, cb) {
      state.writelen = len;
      state.writecb = cb;
      state.writing = true;
      state.sync = true;
      if (writev)
        stream._writev(chunk, state.onwrite);
      else
        stream._write(chunk, encoding, state.onwrite);
      state.sync = false;
    }
    
    function onwriteError(stream, state, sync, er, cb) {
      --state.pendingcb;
      if (sync)
        processNextTick(cb, er);
      else
        cb(er);
    
      stream._writableState.errorEmitted = true;
      stream.emit('error', er);
    }
    
    function onwriteStateUpdate(state) {
      state.writing = false;
      state.writecb = null;
      state.length -= state.writelen;
      state.writelen = 0;
    }
    
    function onwrite(stream, er) {
      var state = stream._writableState;
      var sync = state.sync;
      var cb = state.writecb;
    
      onwriteStateUpdate(state);
    
      if (er)
        onwriteError(stream, state, sync, er, cb);
      else {
        // Check if we're actually ready to finish, but don't emit yet
        var finished = needFinish(state);
    
        if (!finished &&
            !state.corked &&
            !state.bufferProcessing &&
            state.bufferedRequest) {
          clearBuffer(stream, state);
        }
    
        if (sync) {
          processNextTick(afterWrite, stream, state, finished, cb);
        } else {
          afterWrite(stream, state, finished, cb);
        }
      }
    }
    
    function afterWrite(stream, state, finished, cb) {
      if (!finished)
        onwriteDrain(stream, state);
      state.pendingcb--;
      cb();
      finishMaybe(stream, state);
    }
    
    // Must force callback to be called on nextTick, so that we don't
    // emit 'drain' before the write() consumer gets the 'false' return
    // value, and has a chance to attach a 'drain' listener.
    function onwriteDrain(stream, state) {
      if (state.length === 0 && state.needDrain) {
        state.needDrain = false;
        stream.emit('drain');
      }
    }
    
    
    // if there's something in the buffer waiting, then process it
    function clearBuffer(stream, state) {
      state.bufferProcessing = true;
      var entry = state.bufferedRequest;
    
      if (stream._writev && entry && entry.next) {
        // Fast case, write everything using _writev()
        var buffer = [];
        var cbs = [];
        while (entry) {
          cbs.push(entry.callback);
          buffer.push(entry);
          entry = entry.next;
        }
    
        // count the one we are adding, as well.
        // TODO(isaacs) clean this up
        state.pendingcb++;
        state.lastBufferedRequest = null;
        doWrite(stream, state, true, state.length, buffer, '', function(err) {
          for (var i = 0; i < cbs.length; i++) {
            state.pendingcb--;
            cbs[i](err);
          }
        });
    
        // Clear buffer
      } else {
        // Slow case, write chunks one-by-one
        while (entry) {
          var chunk = entry.chunk;
          var encoding = entry.encoding;
          var cb = entry.callback;
          var len = state.objectMode ? 1 : chunk.length;
    
          doWrite(stream, state, false, len, chunk, encoding, cb);
          entry = entry.next;
          // if we didn't call the onwrite immediately, then
          // it means that we need to wait until it does.
          // also, that means that the chunk and cb are currently
          // being processed, so move the buffer counter past them.
          if (state.writing) {
            break;
          }
        }
    
        if (entry === null)
          state.lastBufferedRequest = null;
      }
      state.bufferedRequest = entry;
      state.bufferProcessing = false;
    }
    
    Writable.prototype._write = function(chunk, encoding, cb) {
      cb(new Error('not implemented'));
    };
    
    Writable.prototype._writev = null;
    
    Writable.prototype.end = function(chunk, encoding, cb) {
      var state = this._writableState;
    
      if (typeof chunk === 'function') {
        cb = chunk;
        chunk = null;
        encoding = null;
      } else if (typeof encoding === 'function') {
        cb = encoding;
        encoding = null;
      }
    
      if (chunk !== null && chunk !== undefined)
        this.write(chunk, encoding);
    
      // .end() fully uncorks
      if (state.corked) {
        state.corked = 1;
        this.uncork();
      }
    
      // ignore unnecessary end() calls.
      if (!state.ending && !state.finished)
        endWritable(this, state, cb);
    };
    
    
    function needFinish(state) {
      return (state.ending &&
              state.length === 0 &&
              state.bufferedRequest === null &&
              !state.finished &&
              !state.writing);
    }
    
    function prefinish(stream, state) {
      if (!state.prefinished) {
        state.prefinished = true;
        stream.emit('prefinish');
      }
    }
    
    function finishMaybe(stream, state) {
      var need = needFinish(state);
      if (need) {
        if (state.pendingcb === 0) {
          prefinish(stream, state);
          state.finished = true;
          stream.emit('finish');
        } else {
          prefinish(stream, state);
        }
      }
      return need;
    }
    
    function endWritable(stream, state, cb) {
      state.ending = true;
      finishMaybe(stream, state);
      if (cb) {
        if (state.finished)
          processNextTick(cb);
        else
          stream.once('finish', cb);
      }
      state.ended = true;
    }
    
  provide("readable-stream/lib/_stream_writable.js", module.exports);
}(global));

// pakmanager:readable-stream/lib/_stream_duplex.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // a duplex stream is just a stream that is both readable and writable.
    // Since JS doesn't have multiple prototypal inheritance, this class
    // prototypally inherits from Readable, and then parasitically from
    // Writable.
    
    'use strict';
    
    /*<replacement>*/
    var objectKeys = Object.keys || function (obj) {
      var keys = [];
      for (var key in obj) keys.push(key);
      return keys;
    }
    /*</replacement>*/
    
    
    module.exports = Duplex;
    
    /*<replacement>*/
    var processNextTick = require('process-nextick-args');
    /*</replacement>*/
    
    
    
    /*<replacement>*/
    var util = require('core-util-is');
    util.inherits = require('inherits');
    /*</replacement>*/
    
    var Readable =  require('readable-stream/lib/_stream_readable');
    var Writable =  require('readable-stream/lib/_stream_writable');
    
    util.inherits(Duplex, Readable);
    
    var keys = objectKeys(Writable.prototype);
    for (var v = 0; v < keys.length; v++) {
      var method = keys[v];
      if (!Duplex.prototype[method])
        Duplex.prototype[method] = Writable.prototype[method];
    }
    
    function Duplex(options) {
      if (!(this instanceof Duplex))
        return new Duplex(options);
    
      Readable.call(this, options);
      Writable.call(this, options);
    
      if (options && options.readable === false)
        this.readable = false;
    
      if (options && options.writable === false)
        this.writable = false;
    
      this.allowHalfOpen = true;
      if (options && options.allowHalfOpen === false)
        this.allowHalfOpen = false;
    
      this.once('end', onend);
    }
    
    // the no-half-open enforcer
    function onend() {
      // if we allow half-open state, or if the writable side ended,
      // then we're ok.
      if (this.allowHalfOpen || this._writableState.ended)
        return;
    
      // no more data can be written.
      // But allow more writes to happen in this tick.
      processNextTick(onEndNT, this);
    }
    
    function onEndNT(self) {
      self.end();
    }
    
    function forEach (xs, f) {
      for (var i = 0, l = xs.length; i < l; i++) {
        f(xs[i], i);
      }
    }
    
  provide("readable-stream/lib/_stream_duplex.js", module.exports);
}(global));

// pakmanager:readable-stream/lib/_stream_transform.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // a transform stream is a readable/writable stream where you do
    // something with the data.  Sometimes it's called a "filter",
    // but that's not a great name for it, since that implies a thing where
    // some bits pass through, and others are simply ignored.  (That would
    // be a valid example of a transform, of course.)
    //
    // While the output is causally related to the input, it's not a
    // necessarily symmetric or synchronous transformation.  For example,
    // a zlib stream might take multiple plain-text writes(), and then
    // emit a single compressed chunk some time in the future.
    //
    // Here's how this works:
    //
    // The Transform stream has all the aspects of the readable and writable
    // stream classes.  When you write(chunk), that calls _write(chunk,cb)
    // internally, and returns false if there's a lot of pending writes
    // buffered up.  When you call read(), that calls _read(n) until
    // there's enough pending readable data buffered up.
    //
    // In a transform stream, the written data is placed in a buffer.  When
    // _read(n) is called, it transforms the queued up data, calling the
    // buffered _write cb's as it consumes chunks.  If consuming a single
    // written chunk would result in multiple output chunks, then the first
    // outputted bit calls the readcb, and subsequent chunks just go into
    // the read buffer, and will cause it to emit 'readable' if necessary.
    //
    // This way, back-pressure is actually determined by the reading side,
    // since _read has to be called to start processing a new chunk.  However,
    // a pathological inflate type of transform can cause excessive buffering
    // here.  For example, imagine a stream where every byte of input is
    // interpreted as an integer from 0-255, and then results in that many
    // bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
    // 1kb of data being output.  In this case, you could write a very small
    // amount of input, and end up with a very large amount of output.  In
    // such a pathological inflating mechanism, there'd be no way to tell
    // the system to stop doing the transform.  A single 4MB write could
    // cause the system to run out of memory.
    //
    // However, even in such a pathological case, only a single written chunk
    // would be consumed, and then the rest would wait (un-transformed) until
    // the results of the previous transformed chunk were consumed.
    
    'use strict';
    
    module.exports = Transform;
    
    var Duplex =  require('readable-stream/lib/_stream_duplex');
    
    /*<replacement>*/
    var util = require('core-util-is');
    util.inherits = require('inherits');
    /*</replacement>*/
    
    util.inherits(Transform, Duplex);
    
    
    function TransformState(stream) {
      this.afterTransform = function(er, data) {
        return afterTransform(stream, er, data);
      };
    
      this.needTransform = false;
      this.transforming = false;
      this.writecb = null;
      this.writechunk = null;
    }
    
    function afterTransform(stream, er, data) {
      var ts = stream._transformState;
      ts.transforming = false;
    
      var cb = ts.writecb;
    
      if (!cb)
        return stream.emit('error', new Error('no writecb in Transform class'));
    
      ts.writechunk = null;
      ts.writecb = null;
    
      if (data !== null && data !== undefined)
        stream.push(data);
    
      if (cb)
        cb(er);
    
      var rs = stream._readableState;
      rs.reading = false;
      if (rs.needReadable || rs.length < rs.highWaterMark) {
        stream._read(rs.highWaterMark);
      }
    }
    
    
    function Transform(options) {
      if (!(this instanceof Transform))
        return new Transform(options);
    
      Duplex.call(this, options);
    
      this._transformState = new TransformState(this);
    
      // when the writable side finishes, then flush out anything remaining.
      var stream = this;
    
      // start out asking for a readable event once data is transformed.
      this._readableState.needReadable = true;
    
      // we have implemented the _read method, and done the other things
      // that Readable wants before the first _read call, so unset the
      // sync guard flag.
      this._readableState.sync = false;
    
      if (options) {
        if (typeof options.transform === 'function')
          this._transform = options.transform;
    
        if (typeof options.flush === 'function')
          this._flush = options.flush;
      }
    
      this.once('prefinish', function() {
        if (typeof this._flush === 'function')
          this._flush(function(er) {
            done(stream, er);
          });
        else
          done(stream);
      });
    }
    
    Transform.prototype.push = function(chunk, encoding) {
      this._transformState.needTransform = false;
      return Duplex.prototype.push.call(this, chunk, encoding);
    };
    
    // This is the part where you do stuff!
    // override this function in implementation classes.
    // 'chunk' is an input chunk.
    //
    // Call `push(newChunk)` to pass along transformed output
    // to the readable side.  You may call 'push' zero or more times.
    //
    // Call `cb(err)` when you are done with this chunk.  If you pass
    // an error, then that'll put the hurt on the whole operation.  If you
    // never call cb(), then you'll never get another chunk.
    Transform.prototype._transform = function(chunk, encoding, cb) {
      throw new Error('not implemented');
    };
    
    Transform.prototype._write = function(chunk, encoding, cb) {
      var ts = this._transformState;
      ts.writecb = cb;
      ts.writechunk = chunk;
      ts.writeencoding = encoding;
      if (!ts.transforming) {
        var rs = this._readableState;
        if (ts.needTransform ||
            rs.needReadable ||
            rs.length < rs.highWaterMark)
          this._read(rs.highWaterMark);
      }
    };
    
    // Doesn't matter what the args are here.
    // _transform does all the work.
    // That we got here means that the readable side wants more data.
    Transform.prototype._read = function(n) {
      var ts = this._transformState;
    
      if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
        ts.transforming = true;
        this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
      } else {
        // mark that we need a transform, so that any data that comes in
        // will get processed, now that we've asked for it.
        ts.needTransform = true;
      }
    };
    
    
    function done(stream, er) {
      if (er)
        return stream.emit('error', er);
    
      // if there's nothing in the write buffer, then that means
      // that nothing more will ever be provided
      var ws = stream._writableState;
      var ts = stream._transformState;
    
      if (ws.length)
        throw new Error('calling transform done when ws.length != 0');
    
      if (ts.transforming)
        throw new Error('calling transform done when still transforming');
    
      return stream.push(null);
    }
    
  provide("readable-stream/lib/_stream_transform.js", module.exports);
}(global));

// pakmanager:readable-stream/lib/_stream_passthrough.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // a passthrough stream.
    // basically just the most minimal sort of Transform stream.
    // Every written chunk gets output as-is.
    
    'use strict';
    
    module.exports = PassThrough;
    
    var Transform =  require('readable-stream/lib/_stream_transform');
    
    /*<replacement>*/
    var util = require('core-util-is');
    util.inherits = require('inherits');
    /*</replacement>*/
    
    util.inherits(PassThrough, Transform);
    
    function PassThrough(options) {
      if (!(this instanceof PassThrough))
        return new PassThrough(options);
    
      Transform.call(this, options);
    }
    
    PassThrough.prototype._transform = function(chunk, encoding, cb) {
      cb(null, chunk);
    };
    
  provide("readable-stream/lib/_stream_passthrough.js", module.exports);
}(global));

// pakmanager:readable-stream
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var Stream = (function (){
      try {
        return require('st' + 'ream'); // hack to fix a circular dependency issue when used with browserify
      } catch(_){}
    }());
    exports = module.exports =  require('readable-stream/lib/_stream_readable.js');
    exports.Stream = Stream || exports;
    exports.Readable = exports;
    exports.Writable =  require('readable-stream/lib/_stream_writable.js');
    exports.Duplex =  require('readable-stream/lib/_stream_duplex.js');
    exports.Transform =  require('readable-stream/lib/_stream_transform.js');
    exports.PassThrough =  require('readable-stream/lib/_stream_passthrough.js');
    
  provide("readable-stream", module.exports);
}(global));

// pakmanager:camelcase-keys
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    var mapObj = require('map-obj');
    var camelCase = require('camelcase');
    
    module.exports = function (obj) {
    	return mapObj(obj, function (key, val) {
    		return [camelCase(key), val];
    	});
    };
    
  provide("camelcase-keys", module.exports);
}(global));

// pakmanager:indent-string
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    var repeating = require('repeating');
    
    module.exports = function (str, indent, count) {
    	if (typeof str !== 'string' || typeof indent !== 'string') {
    		throw new TypeError('`string` and `indent` should be strings');
    	}
    
    	if (count != null && typeof count !== 'number') {
    		throw new TypeError('`count` should be a number');
    	}
    
    	indent = count > 1 ? repeating(indent, count) : indent;
    
    	return str.replace(/^(?!\s*$)/mg, indent);
    };
    
  provide("indent-string", module.exports);
}(global));

// pakmanager:minimist
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  module.exports = function (args, opts) {
        if (!opts) opts = {};
        
        var flags = { bools : {}, strings : {}, unknownFn: null };
    
        if (typeof opts['unknown'] === 'function') {
            flags.unknownFn = opts['unknown'];
        }
    
        if (typeof opts['boolean'] === 'boolean' && opts['boolean']) {
          flags.allBools = true;
        } else {
          [].concat(opts['boolean']).filter(Boolean).forEach(function (key) {
              flags.bools[key] = true;
          });
        }
        
        var aliases = {};
        Object.keys(opts.alias || {}).forEach(function (key) {
            aliases[key] = [].concat(opts.alias[key]);
            aliases[key].forEach(function (x) {
                aliases[x] = [key].concat(aliases[key].filter(function (y) {
                    return x !== y;
                }));
            });
        });
    
        [].concat(opts.string).filter(Boolean).forEach(function (key) {
            flags.strings[key] = true;
            if (aliases[key]) {
                flags.strings[aliases[key]] = true;
            }
         });
    
        var defaults = opts['default'] || {};
        
        var argv = { _ : [] };
        Object.keys(flags.bools).forEach(function (key) {
            setArg(key, defaults[key] === undefined ? false : defaults[key]);
        });
        
        var notFlags = [];
    
        if (args.indexOf('--') !== -1) {
            notFlags = args.slice(args.indexOf('--')+1);
            args = args.slice(0, args.indexOf('--'));
        }
    
        function argDefined(key, arg) {
            return (flags.allBools && /^--[^=]+$/.test(arg)) ||
                flags.strings[key] || flags.bools[key] || aliases[key];
        }
    
        function setArg (key, val, arg) {
            if (arg && flags.unknownFn && !argDefined(key, arg)) {
                if (flags.unknownFn(arg) === false) return;
            }
    
            var value = !flags.strings[key] && isNumber(val)
                ? Number(val) : val
            ;
            setKey(argv, key.split('.'), value);
            
            (aliases[key] || []).forEach(function (x) {
                setKey(argv, x.split('.'), value);
            });
        }
    
        function setKey (obj, keys, value) {
            var o = obj;
            keys.slice(0,-1).forEach(function (key) {
                if (o[key] === undefined) o[key] = {};
                o = o[key];
            });
    
            var key = keys[keys.length - 1];
            if (o[key] === undefined || flags.bools[key] || typeof o[key] === 'boolean') {
                o[key] = value;
            }
            else if (Array.isArray(o[key])) {
                o[key].push(value);
            }
            else {
                o[key] = [ o[key], value ];
            }
        }
        
        for (var i = 0; i < args.length; i++) {
            var arg = args[i];
            
            if (/^--.+=/.test(arg)) {
                // Using [\s\S] instead of . because js doesn't support the
                // 'dotall' regex modifier. See:
                // http://stackoverflow.com/a/1068308/13216
                var m = arg.match(/^--([^=]+)=([\s\S]*)$/);
                setArg(m[1], m[2], arg);
            }
            else if (/^--no-.+/.test(arg)) {
                var key = arg.match(/^--no-(.+)/)[1];
                setArg(key, false, arg);
            }
            else if (/^--.+/.test(arg)) {
                var key = arg.match(/^--(.+)/)[1];
                var next = args[i + 1];
                if (next !== undefined && !/^-/.test(next)
                && !flags.bools[key]
                && !flags.allBools
                && (aliases[key] ? !flags.bools[aliases[key]] : true)) {
                    setArg(key, next, arg);
                    i++;
                }
                else if (/^(true|false)$/.test(next)) {
                    setArg(key, next === 'true', arg);
                    i++;
                }
                else {
                    setArg(key, flags.strings[key] ? '' : true, arg);
                }
            }
            else if (/^-[^-]+/.test(arg)) {
                var letters = arg.slice(1,-1).split('');
                
                var broken = false;
                for (var j = 0; j < letters.length; j++) {
                    var next = arg.slice(j+2);
                    
                    if (next === '-') {
                        setArg(letters[j], next, arg)
                        continue;
                    }
                    
                    if (/[A-Za-z]/.test(letters[j])
                    && /-?\d+(\.\d*)?(e-?\d+)?$/.test(next)) {
                        setArg(letters[j], next, arg);
                        broken = true;
                        break;
                    }
                    
                    if (letters[j+1] && letters[j+1].match(/\W/)) {
                        setArg(letters[j], arg.slice(j+2), arg);
                        broken = true;
                        break;
                    }
                    else {
                        setArg(letters[j], flags.strings[letters[j]] ? '' : true, arg);
                    }
                }
                
                var key = arg.slice(-1)[0];
                if (!broken && key !== '-') {
                    if (args[i+1] && !/^(-|--)[^-]/.test(args[i+1])
                    && !flags.bools[key]
                    && (aliases[key] ? !flags.bools[aliases[key]] : true)) {
                        setArg(key, args[i+1], arg);
                        i++;
                    }
                    else if (args[i+1] && /true|false/.test(args[i+1])) {
                        setArg(key, args[i+1] === 'true', arg);
                        i++;
                    }
                    else {
                        setArg(key, flags.strings[key] ? '' : true, arg);
                    }
                }
            }
            else {
                if (!flags.unknownFn || flags.unknownFn(arg) !== false) {
                    argv._.push(
                        flags.strings['_'] || !isNumber(arg) ? arg : Number(arg)
                    );
                }
                if (opts.stopEarly) {
                    argv._.push.apply(argv._, args.slice(i + 1));
                    break;
                }
            }
        }
        
        Object.keys(defaults).forEach(function (key) {
            if (!hasKey(argv, key.split('.'))) {
                setKey(argv, key.split('.'), defaults[key]);
                
                (aliases[key] || []).forEach(function (x) {
                    setKey(argv, x.split('.'), defaults[key]);
                });
            }
        });
        
        if (opts['--']) {
            argv['--'] = new Array();
            notFlags.forEach(function(key) {
                argv['--'].push(key);
            });
        }
        else {
            notFlags.forEach(function(key) {
                argv._.push(key);
            });
        }
    
        return argv;
    };
    
    function hasKey (obj, keys) {
        var o = obj;
        keys.slice(0,-1).forEach(function (key) {
            o = (o[key] || {});
        });
    
        var key = keys[keys.length - 1];
        return key in o;
    }
    
    function isNumber (x) {
        if (typeof x === 'number') return true;
        if (/^0x[0-9a-f]+$/i.test(x)) return true;
        return /^[-+]?(?:\d+(?:\.\d*)?|\.\d+)(e[-+]?\d+)?$/.test(x);
    }
    
    
  provide("minimist", module.exports);
}(global));

// pakmanager:object-assign
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    var propIsEnumerable = Object.prototype.propertyIsEnumerable;
    
    function ToObject(val) {
    	if (val == null) {
    		throw new TypeError('Object.assign cannot be called with null or undefined');
    	}
    
    	return Object(val);
    }
    
    function ownEnumerableKeys(obj) {
    	var keys = Object.getOwnPropertyNames(obj);
    
    	if (Object.getOwnPropertySymbols) {
    		keys = keys.concat(Object.getOwnPropertySymbols(obj));
    	}
    
    	return keys.filter(function (key) {
    		return propIsEnumerable.call(obj, key);
    	});
    }
    
    module.exports = Object.assign || function (target, source) {
    	var from;
    	var keys;
    	var to = ToObject(target);
    
    	for (var s = 1; s < arguments.length; s++) {
    		from = arguments[s];
    		keys = ownEnumerableKeys(Object(from));
    
    		for (var i = 0; i < keys.length; i++) {
    			to[keys[i]] = from[keys[i]];
    		}
    	}
    
    	return to;
    };
    
  provide("object-assign", module.exports);
}(global));

// pakmanager:bn.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  (function (module, exports) {
    
    'use strict';
    
    // Utils
    
    function assert(val, msg) {
      if (!val)
        throw new Error(msg || 'Assertion failed');
    }
    
    // Could use `inherits` module, but don't want to move from single file
    // architecture yet.
    function inherits(ctor, superCtor) {
      ctor.super_ = superCtor;
      var TempCtor = function () {};
      TempCtor.prototype = superCtor.prototype;
      ctor.prototype = new TempCtor();
      ctor.prototype.constructor = ctor;
    }
    
    // BN
    
    function BN(number, base, endian) {
      // May be `new BN(bn)` ?
      if (number !== null &&
          typeof number === 'object' &&
          Array.isArray(number.words)) {
        return number;
      }
    
      this.sign = false;
      this.words = null;
      this.length = 0;
    
      // Reduction context
      this.red = null;
    
      if (base === 'le' || base === 'be') {
        endian = base;
        base = 10;
      }
    
      if (number !== null)
        this._init(number || 0, base || 10, endian || 'be');
    }
    if (typeof module === 'object')
      module.exports = BN;
    else
      exports.BN = BN;
    
    BN.BN = BN;
    BN.wordSize = 26;
    
    BN.prototype._init = function init(number, base, endian) {
      if (typeof number === 'number') {
        return this._initNumber(number, base, endian);
      } else if (typeof number === 'object') {
        return this._initArray(number, base, endian);
      }
      if (base === 'hex')
        base = 16;
      assert(base === (base | 0) && base >= 2 && base <= 36);
    
      number = number.toString().replace(/\s+/g, '');
      var start = 0;
      if (number[0] === '-')
        start++;
    
      if (base === 16)
        this._parseHex(number, start);
      else
        this._parseBase(number, base, start);
    
      if (number[0] === '-')
        this.sign = true;
    
      this.strip();
    
      if (endian !== 'le')
        return;
    
      this._initArray(this.toArray(), base, endian);
    };
    
    BN.prototype._initNumber = function _initNumber(number, base, endian) {
      if (number < 0) {
        this.sign = true;
        number = -number;
      }
      if (number < 0x4000000) {
        this.words = [ number & 0x3ffffff ];
        this.length = 1;
      } else if (number < 0x10000000000000) {
        this.words = [
          number & 0x3ffffff,
          (number / 0x4000000) & 0x3ffffff
        ];
        this.length = 2;
      } else {
        assert(number < 0x20000000000000); // 2 ^ 53 (unsafe)
        this.words = [
          number & 0x3ffffff,
          (number / 0x4000000) & 0x3ffffff,
          1
        ];
        this.length = 3;
      }
    
      if (endian !== 'le')
        return;
    
      // Reverse the bytes
      this._initArray(this.toArray(), base, endian);
    };
    
    BN.prototype._initArray = function _initArray(number, base, endian) {
      // Perhaps a Uint8Array
      assert(typeof number.length === 'number');
      if (number.length <= 0) {
        this.words = [ 0 ];
        this.length = 1;
        return this;
      }
    
      this.length = Math.ceil(number.length / 3);
      this.words = new Array(this.length);
      for (var i = 0; i < this.length; i++)
        this.words[i] = 0;
    
      var off = 0;
      if (endian === 'be') {
        for (var i = number.length - 1, j = 0; i >= 0; i -= 3) {
          var w = number[i] | (number[i - 1] << 8) | (number[i - 2] << 16);
          this.words[j] |= (w << off) & 0x3ffffff;
          this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
          off += 24;
          if (off >= 26) {
            off -= 26;
            j++;
          }
        }
      } else if (endian === 'le') {
        for (var i = 0, j = 0; i < number.length; i += 3) {
          var w = number[i] | (number[i + 1] << 8) | (number[i + 2] << 16);
          this.words[j] |= (w << off) & 0x3ffffff;
          this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
          off += 24;
          if (off >= 26) {
            off -= 26;
            j++;
          }
        }
      }
      return this.strip();
    };
    
    function parseHex(str, start, end) {
      var r = 0;
      var len = Math.min(str.length, end);
      for (var i = start; i < len; i++) {
        var c = str.charCodeAt(i) - 48;
    
        r <<= 4;
    
        // 'a' - 'f'
        if (c >= 49 && c <= 54)
          r |= c - 49 + 0xa;
    
        // 'A' - 'F'
        else if (c >= 17 && c <= 22)
          r |= c - 17 + 0xa;
    
        // '0' - '9'
        else
          r |= c & 0xf;
      }
      return r;
    }
    
    BN.prototype._parseHex = function _parseHex(number, start) {
      // Create possibly bigger array to ensure that it fits the number
      this.length = Math.ceil((number.length - start) / 6);
      this.words = new Array(this.length);
      for (var i = 0; i < this.length; i++)
        this.words[i] = 0;
    
      // Scan 24-bit chunks and add them to the number
      var off = 0;
      for (var i = number.length - 6, j = 0; i >= start; i -= 6) {
        var w = parseHex(number, i, i + 6);
        this.words[j] |= (w << off) & 0x3ffffff;
        this.words[j + 1] |= w >>> (26 - off) & 0x3fffff;
        off += 24;
        if (off >= 26) {
          off -= 26;
          j++;
        }
      }
      if (i + 6 !== start) {
        var w = parseHex(number, start, i + 6);
        this.words[j] |= (w << off) & 0x3ffffff;
        this.words[j + 1] |= w >>> (26 - off) & 0x3fffff;
      }
      this.strip();
    };
    
    function parseBase(str, start, end, mul) {
      var r = 0;
      var len = Math.min(str.length, end);
      for (var i = start; i < len; i++) {
        var c = str.charCodeAt(i) - 48;
    
        r *= mul;
    
        // 'a'
        if (c >= 49)
          r += c - 49 + 0xa;
    
        // 'A'
        else if (c >= 17)
          r += c - 17 + 0xa;
    
        // '0' - '9'
        else
          r += c;
      }
      return r;
    }
    
    BN.prototype._parseBase = function _parseBase(number, base, start) {
      // Initialize as zero
      this.words = [ 0 ];
      this.length = 1;
    
      // Find length of limb in base
      for (var limbLen = 0, limbPow = 1; limbPow <= 0x3ffffff; limbPow *= base)
        limbLen++;
      limbLen--;
      limbPow = (limbPow / base) | 0;
    
      var total = number.length - start;
      var mod = total % limbLen;
      var end = Math.min(total, total - mod) + start;
    
      var word = 0;
      for (var i = start; i < end; i += limbLen) {
        word = parseBase(number, i, i + limbLen, base);
    
        this.imuln(limbPow);
        if (this.words[0] + word < 0x4000000)
          this.words[0] += word;
        else
          this._iaddn(word);
      }
    
      if (mod !== 0) {
        var pow = 1;
        var word = parseBase(number, i, number.length, base);
    
        for (var i = 0; i < mod; i++)
          pow *= base;
        this.imuln(pow);
        if (this.words[0] + word < 0x4000000)
          this.words[0] += word;
        else
          this._iaddn(word);
      }
    };
    
    BN.prototype.copy = function copy(dest) {
      dest.words = new Array(this.length);
      for (var i = 0; i < this.length; i++)
        dest.words[i] = this.words[i];
      dest.length = this.length;
      dest.sign = this.sign;
      dest.red = this.red;
    };
    
    BN.prototype.clone = function clone() {
      var r = new BN(null);
      this.copy(r);
      return r;
    };
    
    // Remove leading `0` from `this`
    BN.prototype.strip = function strip() {
      while (this.length > 1 && this.words[this.length - 1] === 0)
        this.length--;
      return this._normSign();
    };
    
    BN.prototype._normSign = function _normSign() {
      // -0 = 0
      if (this.length === 1 && this.words[0] === 0)
        this.sign = false;
      return this;
    };
    
    BN.prototype.inspect = function inspect() {
      return (this.red ? '<BN-R: ' : '<BN: ') + this.toString(16) + '>';
    };
    
    /*
    
    var zeros = [];
    var groupSizes = [];
    var groupBases = [];
    
    var s = '';
    var i = -1;
    while (++i < BN.wordSize) {
      zeros[i] = s;
      s += '0';
    }
    groupSizes[0] = 0;
    groupSizes[1] = 0;
    groupBases[0] = 0;
    groupBases[1] = 0;
    var base = 2 - 1;
    while (++base < 36 + 1) {
      var groupSize = 0;
      var groupBase = 1;
      while (groupBase < (1 << BN.wordSize) / base) {
        groupBase *= base;
        groupSize += 1;
      }
      groupSizes[base] = groupSize;
      groupBases[base] = groupBase;
    }
    
    */
    
    var zeros = [
      '',
      '0',
      '00',
      '000',
      '0000',
      '00000',
      '000000',
      '0000000',
      '00000000',
      '000000000',
      '0000000000',
      '00000000000',
      '000000000000',
      '0000000000000',
      '00000000000000',
      '000000000000000',
      '0000000000000000',
      '00000000000000000',
      '000000000000000000',
      '0000000000000000000',
      '00000000000000000000',
      '000000000000000000000',
      '0000000000000000000000',
      '00000000000000000000000',
      '000000000000000000000000',
      '0000000000000000000000000'
    ];
    
    var groupSizes = [
      0, 0,
      25, 16, 12, 11, 10, 9, 8,
      8, 7, 7, 7, 7, 6, 6,
      6, 6, 6, 6, 6, 5, 5,
      5, 5, 5, 5, 5, 5, 5,
      5, 5, 5, 5, 5, 5, 5
    ];
    
    var groupBases = [
      0, 0,
      33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216,
      43046721, 10000000, 19487171, 35831808, 62748517, 7529536, 11390625,
      16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632,
      6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149,
      24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176
    ];
    
    BN.prototype.toString = function toString(base, padding) {
      base = base || 10;
      if (base === 16 || base === 'hex') {
        var out = '';
        var off = 0;
        var padding = padding | 0 || 1;
        var carry = 0;
        for (var i = 0; i < this.length; i++) {
          var w = this.words[i];
          var word = (((w << off) | carry) & 0xffffff).toString(16);
          carry = (w >>> (24 - off)) & 0xffffff;
          if (carry !== 0 || i !== this.length - 1)
            out = zeros[6 - word.length] + word + out;
          else
            out = word + out;
          off += 2;
          if (off >= 26) {
            off -= 26;
            i--;
          }
        }
        if (carry !== 0)
          out = carry.toString(16) + out;
        while (out.length % padding !== 0)
          out = '0' + out;
        if (this.sign)
          out = '-' + out;
        return out;
      } else if (base === (base | 0) && base >= 2 && base <= 36) {
        // var groupSize = Math.floor(BN.wordSize * Math.LN2 / Math.log(base));
        var groupSize = groupSizes[base];
        // var groupBase = Math.pow(base, groupSize);
        var groupBase = groupBases[base];
        var out = '';
        var c = this.clone();
        c.sign = false;
        while (c.cmpn(0) !== 0) {
          var r = c.modn(groupBase).toString(base);
          c = c.idivn(groupBase);
    
          if (c.cmpn(0) !== 0)
            out = zeros[groupSize - r.length] + r + out;
          else
            out = r + out;
        }
        if (this.cmpn(0) === 0)
          out = '0' + out;
        if (this.sign)
          out = '-' + out;
        return out;
      } else {
        assert(false, 'Base should be between 2 and 36');
      }
    };
    
    BN.prototype.toJSON = function toJSON() {
      return this.toString(16);
    };
    
    BN.prototype.toArray = function toArray(endian) {
      this.strip();
      var res = new Array(this.byteLength());
      res[0] = 0;
    
      var q = this.clone();
      if (endian !== 'le') {
        // Assume big-endian
        for (var i = 0; q.cmpn(0) !== 0; i++) {
          var b = q.andln(0xff);
          q.ishrn(8);
    
          res[res.length - i - 1] = b;
        }
      } else {
        // Assume little-endian
        for (var i = 0; q.cmpn(0) !== 0; i++) {
          var b = q.andln(0xff);
          q.ishrn(8);
    
          res[i] = b;
        }
      }
    
      return res;
    };
    
    if (Math.clz32) {
      BN.prototype._countBits = function _countBits(w) {
        return 32 - Math.clz32(w);
      };
    } else {
      BN.prototype._countBits = function _countBits(w) {
        var t = w;
        var r = 0;
        if (t >= 0x1000) {
          r += 13;
          t >>>= 13;
        }
        if (t >= 0x40) {
          r += 7;
          t >>>= 7;
        }
        if (t >= 0x8) {
          r += 4;
          t >>>= 4;
        }
        if (t >= 0x02) {
          r += 2;
          t >>>= 2;
        }
        return r + t;
      };
    }
    
    BN.prototype._zeroBits = function _zeroBits(w) {
      // Short-cut
      if (w === 0)
        return 26;
    
      var t = w;
      var r = 0;
      if ((t & 0x1fff) === 0) {
        r += 13;
        t >>>= 13;
      }
      if ((t & 0x7f) === 0) {
        r += 7;
        t >>>= 7;
      }
      if ((t & 0xf) === 0) {
        r += 4;
        t >>>= 4;
      }
      if ((t & 0x3) === 0) {
        r += 2;
        t >>>= 2;
      }
      if ((t & 0x1) === 0)
        r++;
      return r;
    };
    
    // Return number of used bits in a BN
    BN.prototype.bitLength = function bitLength() {
      var hi = 0;
      var w = this.words[this.length - 1];
      var hi = this._countBits(w);
      return (this.length - 1) * 26 + hi;
    };
    
    // Number of trailing zero bits
    BN.prototype.zeroBits = function zeroBits() {
      if (this.cmpn(0) === 0)
        return 0;
    
      var r = 0;
      for (var i = 0; i < this.length; i++) {
        var b = this._zeroBits(this.words[i]);
        r += b;
        if (b !== 26)
          break;
      }
      return r;
    };
    
    BN.prototype.byteLength = function byteLength() {
      return Math.ceil(this.bitLength() / 8);
    };
    
    // Return negative clone of `this`
    BN.prototype.neg = function neg() {
      if (this.cmpn(0) === 0)
        return this.clone();
    
      var r = this.clone();
      r.sign = !this.sign;
      return r;
    };
    
    
    // Or `num` with `this` in-place
    BN.prototype.ior = function ior(num) {
      this.sign = this.sign || num.sign;
    
      while (this.length < num.length)
        this.words[this.length++] = 0;
    
      for (var i = 0; i < num.length; i++)
        this.words[i] = this.words[i] | num.words[i];
    
      return this.strip();
    };
    
    
    // Or `num` with `this`
    BN.prototype.or = function or(num) {
      if (this.length > num.length)
        return this.clone().ior(num);
      else
        return num.clone().ior(this);
    };
    
    
    // And `num` with `this` in-place
    BN.prototype.iand = function iand(num) {
      this.sign = this.sign && num.sign;
    
      // b = min-length(num, this)
      var b;
      if (this.length > num.length)
        b = num;
      else
        b = this;
    
      for (var i = 0; i < b.length; i++)
        this.words[i] = this.words[i] & num.words[i];
    
      this.length = b.length;
    
      return this.strip();
    };
    
    
    // And `num` with `this`
    BN.prototype.and = function and(num) {
      if (this.length > num.length)
        return this.clone().iand(num);
      else
        return num.clone().iand(this);
    };
    
    
    // Xor `num` with `this` in-place
    BN.prototype.ixor = function ixor(num) {
      this.sign = this.sign || num.sign;
    
      // a.length > b.length
      var a;
      var b;
      if (this.length > num.length) {
        a = this;
        b = num;
      } else {
        a = num;
        b = this;
      }
    
      for (var i = 0; i < b.length; i++)
        this.words[i] = a.words[i] ^ b.words[i];
    
      if (this !== a)
        for (; i < a.length; i++)
          this.words[i] = a.words[i];
    
      this.length = a.length;
    
      return this.strip();
    };
    
    
    // Xor `num` with `this`
    BN.prototype.xor = function xor(num) {
      if (this.length > num.length)
        return this.clone().ixor(num);
      else
        return num.clone().ixor(this);
    };
    
    
    // Set `bit` of `this`
    BN.prototype.setn = function setn(bit, val) {
      assert(typeof bit === 'number' && bit >= 0);
    
      var off = (bit / 26) | 0;
      var wbit = bit % 26;
    
      while (this.length <= off)
        this.words[this.length++] = 0;
    
      if (val)
        this.words[off] = this.words[off] | (1 << wbit);
      else
        this.words[off] = this.words[off] & ~(1 << wbit);
    
      return this.strip();
    };
    
    
    // Add `num` to `this` in-place
    BN.prototype.iadd = function iadd(num) {
      // negative + positive
      if (this.sign && !num.sign) {
        this.sign = false;
        var r = this.isub(num);
        this.sign = !this.sign;
        return this._normSign();
    
      // positive + negative
      } else if (!this.sign && num.sign) {
        num.sign = false;
        var r = this.isub(num);
        num.sign = true;
        return r._normSign();
      }
    
      // a.length > b.length
      var a;
      var b;
      if (this.length > num.length) {
        a = this;
        b = num;
      } else {
        a = num;
        b = this;
      }
    
      var carry = 0;
      for (var i = 0; i < b.length; i++) {
        var r = a.words[i] + b.words[i] + carry;
        this.words[i] = r & 0x3ffffff;
        carry = r >>> 26;
      }
      for (; carry !== 0 && i < a.length; i++) {
        var r = a.words[i] + carry;
        this.words[i] = r & 0x3ffffff;
        carry = r >>> 26;
      }
    
      this.length = a.length;
      if (carry !== 0) {
        this.words[this.length] = carry;
        this.length++;
      // Copy the rest of the words
      } else if (a !== this) {
        for (; i < a.length; i++)
          this.words[i] = a.words[i];
      }
    
      return this;
    };
    
    // Add `num` to `this`
    BN.prototype.add = function add(num) {
      if (num.sign && !this.sign) {
        num.sign = false;
        var res = this.sub(num);
        num.sign = true;
        return res;
      } else if (!num.sign && this.sign) {
        this.sign = false;
        var res = num.sub(this);
        this.sign = true;
        return res;
      }
    
      if (this.length > num.length)
        return this.clone().iadd(num);
      else
        return num.clone().iadd(this);
    };
    
    // Subtract `num` from `this` in-place
    BN.prototype.isub = function isub(num) {
      // this - (-num) = this + num
      if (num.sign) {
        num.sign = false;
        var r = this.iadd(num);
        num.sign = true;
        return r._normSign();
    
      // -this - num = -(this + num)
      } else if (this.sign) {
        this.sign = false;
        this.iadd(num);
        this.sign = true;
        return this._normSign();
      }
    
      // At this point both numbers are positive
      var cmp = this.cmp(num);
    
      // Optimization - zeroify
      if (cmp === 0) {
        this.sign = false;
        this.length = 1;
        this.words[0] = 0;
        return this;
      }
    
      // a > b
      var a;
      var b;
      if (cmp > 0) {
        a = this;
        b = num;
      } else {
        a = num;
        b = this;
      }
    
      var carry = 0;
      for (var i = 0; i < b.length; i++) {
        var r = a.words[i] - b.words[i] + carry;
        carry = r >> 26;
        this.words[i] = r & 0x3ffffff;
      }
      for (; carry !== 0 && i < a.length; i++) {
        var r = a.words[i] + carry;
        carry = r >> 26;
        this.words[i] = r & 0x3ffffff;
      }
    
      // Copy rest of the words
      if (carry === 0 && i < a.length && a !== this)
        for (; i < a.length; i++)
          this.words[i] = a.words[i];
      this.length = Math.max(this.length, i);
    
      if (a !== this)
        this.sign = true;
    
      return this.strip();
    };
    
    // Subtract `num` from `this`
    BN.prototype.sub = function sub(num) {
      return this.clone().isub(num);
    };
    
    /*
    // NOTE: This could be potentionally used to generate loop-less multiplications
    function _genCombMulTo(alen, blen) {
      var len = alen + blen - 1;
      var src = [
        'var a = this.words, b = num.words, o = out.words, c = 0, w, ' +
            'mask = 0x3ffffff, shift = 0x4000000;',
        'out.length = ' + len + ';'
      ];
      for (var k = 0; k < len; k++) {
        var minJ = Math.max(0, k - alen + 1);
        var maxJ = Math.min(k, blen - 1);
    
        for (var j = minJ; j <= maxJ; j++) {
          var i = k - j;
          var mul = 'a[' + i + '] * b[' + j + ']';
    
          if (j === minJ) {
            src.push('w = ' + mul + ' + c;');
            src.push('c = (w / shift) | 0;');
          } else {
            src.push('w += ' + mul + ';');
            src.push('c += (w / shift) | 0;');
          }
          src.push('w &= mask;');
        }
        src.push('o[' + k + '] = w;');
      }
      src.push('if (c !== 0) {',
               '  o[' + k + '] = c;',
               '  out.length++;',
               '}',
               'return out;');
    
      return src.join('\n');
    }
    */
    
    BN.prototype._smallMulTo = function _smallMulTo(num, out) {
      out.sign = num.sign !== this.sign;
      out.length = this.length + num.length;
    
      var carry = 0;
      for (var k = 0; k < out.length - 1; k++) {
        // Sum all words with the same `i + j = k` and accumulate `ncarry`,
        // note that ncarry could be >= 0x3ffffff
        var ncarry = carry >>> 26;
        var rword = carry & 0x3ffffff;
        var maxJ = Math.min(k, num.length - 1);
        for (var j = Math.max(0, k - this.length + 1); j <= maxJ; j++) {
          var i = k - j;
          var a = this.words[i] | 0;
          var b = num.words[j] | 0;
          var r = a * b;
    
          var lo = r & 0x3ffffff;
          ncarry = (ncarry + ((r / 0x4000000) | 0)) | 0;
          lo = (lo + rword) | 0;
          rword = lo & 0x3ffffff;
          ncarry = (ncarry + (lo >>> 26)) | 0;
        }
        out.words[k] = rword;
        carry = ncarry;
      }
      if (carry !== 0) {
        out.words[k] = carry;
      } else {
        out.length--;
      }
    
      return out.strip();
    };
    
    BN.prototype._bigMulTo = function _bigMulTo(num, out) {
      out.sign = num.sign !== this.sign;
      out.length = this.length + num.length;
    
      var carry = 0;
      var hncarry = 0;
      for (var k = 0; k < out.length - 1; k++) {
        // Sum all words with the same `i + j = k` and accumulate `ncarry`,
        // note that ncarry could be >= 0x3ffffff
        var ncarry = hncarry;
        hncarry = 0;
        var rword = carry & 0x3ffffff;
        var maxJ = Math.min(k, num.length - 1);
        for (var j = Math.max(0, k - this.length + 1); j <= maxJ; j++) {
          var i = k - j;
          var a = this.words[i] | 0;
          var b = num.words[j] | 0;
          var r = a * b;
    
          var lo = r & 0x3ffffff;
          ncarry = (ncarry + ((r / 0x4000000) | 0)) | 0;
          lo = (lo + rword) | 0;
          rword = lo & 0x3ffffff;
          ncarry = (ncarry + (lo >>> 26)) | 0;
    
          hncarry += ncarry >>> 26;
          ncarry &= 0x3ffffff;
        }
        out.words[k] = rword;
        carry = ncarry;
        ncarry = hncarry;
      }
      if (carry !== 0) {
        out.words[k] = carry;
      } else {
        out.length--;
      }
    
      return out.strip();
    };
    
    BN.prototype.mulTo = function mulTo(num, out) {
      var res;
      if (this.length + num.length < 63)
        res = this._smallMulTo(num, out);
      else
        res = this._bigMulTo(num, out);
      return res;
    };
    
    // Multiply `this` by `num`
    BN.prototype.mul = function mul(num) {
      var out = new BN(null);
      out.words = new Array(this.length + num.length);
      return this.mulTo(num, out);
    };
    
    // In-place Multiplication
    BN.prototype.imul = function imul(num) {
      if (this.cmpn(0) === 0 || num.cmpn(0) === 0) {
        this.words[0] = 0;
        this.length = 1;
        return this;
      }
    
      var tlen = this.length;
      var nlen = num.length;
    
      this.sign = num.sign !== this.sign;
      this.length = this.length + num.length;
      this.words[this.length - 1] = 0;
    
      for (var k = this.length - 2; k >= 0; k--) {
        // Sum all words with the same `i + j = k` and accumulate `carry`,
        // note that carry could be >= 0x3ffffff
        var carry = 0;
        var rword = 0;
        var maxJ = Math.min(k, nlen - 1);
        for (var j = Math.max(0, k - tlen + 1); j <= maxJ; j++) {
          var i = k - j;
          var a = this.words[i];
          var b = num.words[j];
          var r = a * b;
    
          var lo = r & 0x3ffffff;
          carry += (r / 0x4000000) | 0;
          lo += rword;
          rword = lo & 0x3ffffff;
          carry += lo >>> 26;
        }
        this.words[k] = rword;
        this.words[k + 1] += carry;
        carry = 0;
      }
    
      // Propagate overflows
      var carry = 0;
      for (var i = 1; i < this.length; i++) {
        var w = this.words[i] + carry;
        this.words[i] = w & 0x3ffffff;
        carry = w >>> 26;
      }
    
      return this.strip();
    };
    
    BN.prototype.imuln = function imuln(num) {
      assert(typeof num === 'number');
    
      // Carry
      var carry = 0;
      for (var i = 0; i < this.length; i++) {
        var w = this.words[i] * num;
        var lo = (w & 0x3ffffff) + (carry & 0x3ffffff);
        carry >>= 26;
        carry += (w / 0x4000000) | 0;
        // NOTE: lo is 27bit maximum
        carry += lo >>> 26;
        this.words[i] = lo & 0x3ffffff;
      }
    
      if (carry !== 0) {
        this.words[i] = carry;
        this.length++;
      }
    
      return this;
    };
    
    BN.prototype.muln = function muln(num) {
      return this.clone().imuln(num);
    };
    
    // `this` * `this`
    BN.prototype.sqr = function sqr() {
      return this.mul(this);
    };
    
    // `this` * `this` in-place
    BN.prototype.isqr = function isqr() {
      return this.mul(this);
    };
    
    // Shift-left in-place
    BN.prototype.ishln = function ishln(bits) {
      assert(typeof bits === 'number' && bits >= 0);
      var r = bits % 26;
      var s = (bits - r) / 26;
      var carryMask = (0x3ffffff >>> (26 - r)) << (26 - r);
    
      if (r !== 0) {
        var carry = 0;
        for (var i = 0; i < this.length; i++) {
          var newCarry = this.words[i] & carryMask;
          var c = (this.words[i] - newCarry) << r;
          this.words[i] = c | carry;
          carry = newCarry >>> (26 - r);
        }
        if (carry) {
          this.words[i] = carry;
          this.length++;
        }
      }
    
      if (s !== 0) {
        for (var i = this.length - 1; i >= 0; i--)
          this.words[i + s] = this.words[i];
        for (var i = 0; i < s; i++)
          this.words[i] = 0;
        this.length += s;
      }
    
      return this.strip();
    };
    
    // Shift-right in-place
    // NOTE: `hint` is a lowest bit before trailing zeroes
    // NOTE: if `extended` is present - it will be filled with destroyed bits
    BN.prototype.ishrn = function ishrn(bits, hint, extended) {
      assert(typeof bits === 'number' && bits >= 0);
      var h;
      if (hint)
        h = (hint - (hint % 26)) / 26;
      else
        h = 0;
    
      var r = bits % 26;
      var s = Math.min((bits - r) / 26, this.length);
      var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
      var maskedWords = extended;
    
      h -= s;
      h = Math.max(0, h);
    
      // Extended mode, copy masked part
      if (maskedWords) {
        for (var i = 0; i < s; i++)
          maskedWords.words[i] = this.words[i];
        maskedWords.length = s;
      }
    
      if (s === 0) {
        // No-op, we should not move anything at all
      } else if (this.length > s) {
        this.length -= s;
        for (var i = 0; i < this.length; i++)
          this.words[i] = this.words[i + s];
      } else {
        this.words[0] = 0;
        this.length = 1;
      }
    
      var carry = 0;
      for (var i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {
        var word = this.words[i];
        this.words[i] = (carry << (26 - r)) | (word >>> r);
        carry = word & mask;
      }
    
      // Push carried bits as a mask
      if (maskedWords && carry !== 0)
        maskedWords.words[maskedWords.length++] = carry;
    
      if (this.length === 0) {
        this.words[0] = 0;
        this.length = 1;
      }
    
      this.strip();
    
      return this;
    };
    
    // Shift-left
    BN.prototype.shln = function shln(bits) {
      return this.clone().ishln(bits);
    };
    
    // Shift-right
    BN.prototype.shrn = function shrn(bits) {
      return this.clone().ishrn(bits);
    };
    
    // Test if n bit is set
    BN.prototype.testn = function testn(bit) {
      assert(typeof bit === 'number' && bit >= 0);
      var r = bit % 26;
      var s = (bit - r) / 26;
      var q = 1 << r;
    
      // Fast case: bit is much higher than all existing words
      if (this.length <= s) {
        return false;
      }
    
      // Check bit and return
      var w = this.words[s];
    
      return !!(w & q);
    };
    
    // Return only lowers bits of number (in-place)
    BN.prototype.imaskn = function imaskn(bits) {
      assert(typeof bits === 'number' && bits >= 0);
      var r = bits % 26;
      var s = (bits - r) / 26;
    
      assert(!this.sign, 'imaskn works only with positive numbers');
    
      if (r !== 0)
        s++;
      this.length = Math.min(s, this.length);
    
      if (r !== 0) {
        var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
        this.words[this.length - 1] &= mask;
      }
    
      return this.strip();
    };
    
    // Return only lowers bits of number
    BN.prototype.maskn = function maskn(bits) {
      return this.clone().imaskn(bits);
    };
    
    // Add plain number `num` to `this`
    BN.prototype.iaddn = function iaddn(num) {
      assert(typeof num === 'number');
      if (num < 0)
        return this.isubn(-num);
    
      // Possible sign change
      if (this.sign) {
        if (this.length === 1 && this.words[0] < num) {
          this.words[0] = num - this.words[0];
          this.sign = false;
          return this;
        }
    
        this.sign = false;
        this.isubn(num);
        this.sign = true;
        return this;
      }
    
      // Add without checks
      return this._iaddn(num);
    };
    
    BN.prototype._iaddn = function _iaddn(num) {
      this.words[0] += num;
    
      // Carry
      for (var i = 0; i < this.length && this.words[i] >= 0x4000000; i++) {
        this.words[i] -= 0x4000000;
        if (i === this.length - 1)
          this.words[i + 1] = 1;
        else
          this.words[i + 1]++;
      }
      this.length = Math.max(this.length, i + 1);
    
      return this;
    };
    
    // Subtract plain number `num` from `this`
    BN.prototype.isubn = function isubn(num) {
      assert(typeof num === 'number');
      if (num < 0)
        return this.iaddn(-num);
    
      if (this.sign) {
        this.sign = false;
        this.iaddn(num);
        this.sign = true;
        return this;
      }
    
      this.words[0] -= num;
    
      // Carry
      for (var i = 0; i < this.length && this.words[i] < 0; i++) {
        this.words[i] += 0x4000000;
        this.words[i + 1] -= 1;
      }
    
      return this.strip();
    };
    
    BN.prototype.addn = function addn(num) {
      return this.clone().iaddn(num);
    };
    
    BN.prototype.subn = function subn(num) {
      return this.clone().isubn(num);
    };
    
    BN.prototype.iabs = function iabs() {
      this.sign = false;
    
      return this;
    };
    
    BN.prototype.abs = function abs() {
      return this.clone().iabs();
    };
    
    BN.prototype._ishlnsubmul = function _ishlnsubmul(num, mul, shift) {
      // Bigger storage is needed
      var len = num.length + shift;
      var i;
      if (this.words.length < len) {
        var t = new Array(len);
        for (var i = 0; i < this.length; i++)
          t[i] = this.words[i];
        this.words = t;
      } else {
        i = this.length;
      }
    
      // Zeroify rest
      this.length = Math.max(this.length, len);
      for (; i < this.length; i++)
        this.words[i] = 0;
    
      var carry = 0;
      for (var i = 0; i < num.length; i++) {
        var w = this.words[i + shift] + carry;
        var right = num.words[i] * mul;
        w -= right & 0x3ffffff;
        carry = (w >> 26) - ((right / 0x4000000) | 0);
        this.words[i + shift] = w & 0x3ffffff;
      }
      for (; i < this.length - shift; i++) {
        var w = this.words[i + shift] + carry;
        carry = w >> 26;
        this.words[i + shift] = w & 0x3ffffff;
      }
    
      if (carry === 0)
        return this.strip();
    
      // Subtraction overflow
      assert(carry === -1);
      carry = 0;
      for (var i = 0; i < this.length; i++) {
        var w = -this.words[i] + carry;
        carry = w >> 26;
        this.words[i] = w & 0x3ffffff;
      }
      this.sign = true;
    
      return this.strip();
    };
    
    BN.prototype._wordDiv = function _wordDiv(num, mode) {
      var shift = this.length - num.length;
    
      var a = this.clone();
      var b = num;
    
      // Normalize
      var bhi = b.words[b.length - 1];
      var bhiBits = this._countBits(bhi);
      shift = 26 - bhiBits;
      if (shift !== 0) {
        b = b.shln(shift);
        a.ishln(shift);
        bhi = b.words[b.length - 1];
      }
    
      // Initialize quotient
      var m = a.length - b.length;
      var q;
    
      if (mode !== 'mod') {
        q = new BN(null);
        q.length = m + 1;
        q.words = new Array(q.length);
        for (var i = 0; i < q.length; i++)
          q.words[i] = 0;
      }
    
      var diff = a.clone()._ishlnsubmul(b, 1, m);
      if (!diff.sign) {
        a = diff;
        if (q)
          q.words[m] = 1;
      }
    
      for (var j = m - 1; j >= 0; j--) {
        var qj = a.words[b.length + j] * 0x4000000 + a.words[b.length + j - 1];
    
        // NOTE: (qj / bhi) is (0x3ffffff * 0x4000000 + 0x3ffffff) / 0x2000000 max
        // (0x7ffffff)
        qj = Math.min((qj / bhi) | 0, 0x3ffffff);
    
        a._ishlnsubmul(b, qj, j);
        while (a.sign) {
          qj--;
          a.sign = false;
          a._ishlnsubmul(b, 1, j);
          if (a.cmpn(0) !== 0)
            a.sign = !a.sign;
        }
        if (q)
          q.words[j] = qj;
      }
      if (q)
        q.strip();
      a.strip();
    
      // Denormalize
      if (mode !== 'div' && shift !== 0)
        a.ishrn(shift);
      return { div: q ? q : null, mod: a };
    };
    
    BN.prototype.divmod = function divmod(num, mode) {
      assert(num.cmpn(0) !== 0);
    
      if (this.sign && !num.sign) {
        var res = this.neg().divmod(num, mode);
        var div;
        var mod;
        if (mode !== 'mod')
          div = res.div.neg();
        if (mode !== 'div')
          mod = res.mod.cmpn(0) === 0 ? res.mod : num.sub(res.mod);
        return {
          div: div,
          mod: mod
        };
      } else if (!this.sign && num.sign) {
        var res = this.divmod(num.neg(), mode);
        var div;
        if (mode !== 'mod')
          div = res.div.neg();
        return { div: div, mod: res.mod };
      } else if (this.sign && num.sign) {
        return this.neg().divmod(num.neg(), mode);
      }
    
      // Both numbers are positive at this point
    
      // Strip both numbers to approximate shift value
      if (num.length > this.length || this.cmp(num) < 0)
        return { div: new BN(0), mod: this };
    
      // Very short reduction
      if (num.length === 1) {
        if (mode === 'div')
          return { div: this.divn(num.words[0]), mod: null };
        else if (mode === 'mod')
          return { div: null, mod: new BN(this.modn(num.words[0])) };
        return {
          div: this.divn(num.words[0]),
          mod: new BN(this.modn(num.words[0]))
        };
      }
    
      return this._wordDiv(num, mode);
    };
    
    // Find `this` / `num`
    BN.prototype.div = function div(num) {
      return this.divmod(num, 'div').div;
    };
    
    // Find `this` % `num`
    BN.prototype.mod = function mod(num) {
      return this.divmod(num, 'mod').mod;
    };
    
    // Find Round(`this` / `num`)
    BN.prototype.divRound = function divRound(num) {
      var dm = this.divmod(num);
    
      // Fast case - exact division
      if (dm.mod.cmpn(0) === 0)
        return dm.div;
    
      var mod = dm.div.sign ? dm.mod.isub(num) : dm.mod;
    
      var half = num.shrn(1);
      var r2 = num.andln(1);
      var cmp = mod.cmp(half);
    
      // Round down
      if (cmp < 0 || r2 === 1 && cmp === 0)
        return dm.div;
    
      // Round up
      return dm.div.sign ? dm.div.isubn(1) : dm.div.iaddn(1);
    };
    
    BN.prototype.modn = function modn(num) {
      assert(num <= 0x3ffffff);
      var p = (1 << 26) % num;
    
      var acc = 0;
      for (var i = this.length - 1; i >= 0; i--)
        acc = (p * acc + this.words[i]) % num;
    
      return acc;
    };
    
    // In-place division by number
    BN.prototype.idivn = function idivn(num) {
      assert(num <= 0x3ffffff);
    
      var carry = 0;
      for (var i = this.length - 1; i >= 0; i--) {
        var w = this.words[i] + carry * 0x4000000;
        this.words[i] = (w / num) | 0;
        carry = w % num;
      }
    
      return this.strip();
    };
    
    BN.prototype.divn = function divn(num) {
      return this.clone().idivn(num);
    };
    
    BN.prototype.egcd = function egcd(p) {
      assert(!p.sign);
      assert(p.cmpn(0) !== 0);
    
      var x = this;
      var y = p.clone();
    
      if (x.sign)
        x = x.mod(p);
      else
        x = x.clone();
    
      // A * x + B * y = x
      var A = new BN(1);
      var B = new BN(0);
    
      // C * x + D * y = y
      var C = new BN(0);
      var D = new BN(1);
    
      var g = 0;
    
      while (x.isEven() && y.isEven()) {
        x.ishrn(1);
        y.ishrn(1);
        ++g;
      }
    
      var yp = y.clone();
      var xp = x.clone();
    
      while (x.cmpn(0) !== 0) {
        while (x.isEven()) {
          x.ishrn(1);
          if (A.isEven() && B.isEven()) {
            A.ishrn(1);
            B.ishrn(1);
          } else {
            A.iadd(yp).ishrn(1);
            B.isub(xp).ishrn(1);
          }
        }
    
        while (y.isEven()) {
          y.ishrn(1);
          if (C.isEven() && D.isEven()) {
            C.ishrn(1);
            D.ishrn(1);
          } else {
            C.iadd(yp).ishrn(1);
            D.isub(xp).ishrn(1);
          }
        }
    
        if (x.cmp(y) >= 0) {
          x.isub(y);
          A.isub(C);
          B.isub(D);
        } else {
          y.isub(x);
          C.isub(A);
          D.isub(B);
        }
      }
    
      return {
        a: C,
        b: D,
        gcd: y.ishln(g)
      };
    };
    
    // This is reduced incarnation of the binary EEA
    // above, designated to invert members of the
    // _prime_ fields F(p) at a maximal speed
    BN.prototype._invmp = function _invmp(p) {
      assert(!p.sign);
      assert(p.cmpn(0) !== 0);
    
      var a = this;
      var b = p.clone();
    
      if (a.sign)
        a = a.mod(p);
      else
        a = a.clone();
    
      var x1 = new BN(1);
      var x2 = new BN(0);
    
      var delta = b.clone();
    
      while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
        while (a.isEven()) {
          a.ishrn(1);
          if (x1.isEven())
            x1.ishrn(1);
          else
            x1.iadd(delta).ishrn(1);
        }
        while (b.isEven()) {
          b.ishrn(1);
          if (x2.isEven())
            x2.ishrn(1);
          else
            x2.iadd(delta).ishrn(1);
        }
        if (a.cmp(b) >= 0) {
          a.isub(b);
          x1.isub(x2);
        } else {
          b.isub(a);
          x2.isub(x1);
        }
      }
      if (a.cmpn(1) === 0)
        return x1;
      else
        return x2;
    };
    
    BN.prototype.gcd = function gcd(num) {
      if (this.cmpn(0) === 0)
        return num.clone();
      if (num.cmpn(0) === 0)
        return this.clone();
    
      var a = this.clone();
      var b = num.clone();
      a.sign = false;
      b.sign = false;
    
      // Remove common factor of two
      for (var shift = 0; a.isEven() && b.isEven(); shift++) {
        a.ishrn(1);
        b.ishrn(1);
      }
    
      do {
        while (a.isEven())
          a.ishrn(1);
        while (b.isEven())
          b.ishrn(1);
    
        var r = a.cmp(b);
        if (r < 0) {
          // Swap `a` and `b` to make `a` always bigger than `b`
          var t = a;
          a = b;
          b = t;
        } else if (r === 0 || b.cmpn(1) === 0) {
          break;
        }
    
        a.isub(b);
      } while (true);
    
      return b.ishln(shift);
    };
    
    // Invert number in the field F(num)
    BN.prototype.invm = function invm(num) {
      return this.egcd(num).a.mod(num);
    };
    
    BN.prototype.isEven = function isEven() {
      return (this.words[0] & 1) === 0;
    };
    
    BN.prototype.isOdd = function isOdd() {
      return (this.words[0] & 1) === 1;
    };
    
    // And first word and num
    BN.prototype.andln = function andln(num) {
      return this.words[0] & num;
    };
    
    // Increment at the bit position in-line
    BN.prototype.bincn = function bincn(bit) {
      assert(typeof bit === 'number');
      var r = bit % 26;
      var s = (bit - r) / 26;
      var q = 1 << r;
    
      // Fast case: bit is much higher than all existing words
      if (this.length <= s) {
        for (var i = this.length; i < s + 1; i++)
          this.words[i] = 0;
        this.words[s] |= q;
        this.length = s + 1;
        return this;
      }
    
      // Add bit and propagate, if needed
      var carry = q;
      for (var i = s; carry !== 0 && i < this.length; i++) {
        var w = this.words[i];
        w += carry;
        carry = w >>> 26;
        w &= 0x3ffffff;
        this.words[i] = w;
      }
      if (carry !== 0) {
        this.words[i] = carry;
        this.length++;
      }
      return this;
    };
    
    BN.prototype.cmpn = function cmpn(num) {
      var sign = num < 0;
      if (sign)
        num = -num;
    
      if (this.sign && !sign)
        return -1;
      else if (!this.sign && sign)
        return 1;
    
      num &= 0x3ffffff;
      this.strip();
    
      var res;
      if (this.length > 1) {
        res = 1;
      } else {
        var w = this.words[0];
        res = w === num ? 0 : w < num ? -1 : 1;
      }
      if (this.sign)
        res = -res;
      return res;
    };
    
    // Compare two numbers and return:
    // 1 - if `this` > `num`
    // 0 - if `this` == `num`
    // -1 - if `this` < `num`
    BN.prototype.cmp = function cmp(num) {
      if (this.sign && !num.sign)
        return -1;
      else if (!this.sign && num.sign)
        return 1;
    
      var res = this.ucmp(num);
      if (this.sign)
        return -res;
      else
        return res;
    };
    
    // Unsigned comparison
    BN.prototype.ucmp = function ucmp(num) {
      // At this point both numbers have the same sign
      if (this.length > num.length)
        return 1;
      else if (this.length < num.length)
        return -1;
    
      var res = 0;
      for (var i = this.length - 1; i >= 0; i--) {
        var a = this.words[i];
        var b = num.words[i];
    
        if (a === b)
          continue;
        if (a < b)
          res = -1;
        else if (a > b)
          res = 1;
        break;
      }
      return res;
    };
    
    //
    // A reduce context, could be using montgomery or something better, depending
    // on the `m` itself.
    //
    BN.red = function red(num) {
      return new Red(num);
    };
    
    BN.prototype.toRed = function toRed(ctx) {
      assert(!this.red, 'Already a number in reduction context');
      assert(!this.sign, 'red works only with positives');
      return ctx.convertTo(this)._forceRed(ctx);
    };
    
    BN.prototype.fromRed = function fromRed() {
      assert(this.red, 'fromRed works only with numbers in reduction context');
      return this.red.convertFrom(this);
    };
    
    BN.prototype._forceRed = function _forceRed(ctx) {
      this.red = ctx;
      return this;
    };
    
    BN.prototype.forceRed = function forceRed(ctx) {
      assert(!this.red, 'Already a number in reduction context');
      return this._forceRed(ctx);
    };
    
    BN.prototype.redAdd = function redAdd(num) {
      assert(this.red, 'redAdd works only with red numbers');
      return this.red.add(this, num);
    };
    
    BN.prototype.redIAdd = function redIAdd(num) {
      assert(this.red, 'redIAdd works only with red numbers');
      return this.red.iadd(this, num);
    };
    
    BN.prototype.redSub = function redSub(num) {
      assert(this.red, 'redSub works only with red numbers');
      return this.red.sub(this, num);
    };
    
    BN.prototype.redISub = function redISub(num) {
      assert(this.red, 'redISub works only with red numbers');
      return this.red.isub(this, num);
    };
    
    BN.prototype.redShl = function redShl(num) {
      assert(this.red, 'redShl works only with red numbers');
      return this.red.shl(this, num);
    };
    
    BN.prototype.redMul = function redMul(num) {
      assert(this.red, 'redMul works only with red numbers');
      this.red._verify2(this, num);
      return this.red.mul(this, num);
    };
    
    BN.prototype.redIMul = function redIMul(num) {
      assert(this.red, 'redMul works only with red numbers');
      this.red._verify2(this, num);
      return this.red.imul(this, num);
    };
    
    BN.prototype.redSqr = function redSqr() {
      assert(this.red, 'redSqr works only with red numbers');
      this.red._verify1(this);
      return this.red.sqr(this);
    };
    
    BN.prototype.redISqr = function redISqr() {
      assert(this.red, 'redISqr works only with red numbers');
      this.red._verify1(this);
      return this.red.isqr(this);
    };
    
    // Square root over p
    BN.prototype.redSqrt = function redSqrt() {
      assert(this.red, 'redSqrt works only with red numbers');
      this.red._verify1(this);
      return this.red.sqrt(this);
    };
    
    BN.prototype.redInvm = function redInvm() {
      assert(this.red, 'redInvm works only with red numbers');
      this.red._verify1(this);
      return this.red.invm(this);
    };
    
    // Return negative clone of `this` % `red modulo`
    BN.prototype.redNeg = function redNeg() {
      assert(this.red, 'redNeg works only with red numbers');
      this.red._verify1(this);
      return this.red.neg(this);
    };
    
    BN.prototype.redPow = function redPow(num) {
      assert(this.red && !num.red, 'redPow(normalNum)');
      this.red._verify1(this);
      return this.red.pow(this, num);
    };
    
    // Prime numbers with efficient reduction
    var primes = {
      k256: null,
      p224: null,
      p192: null,
      p25519: null
    };
    
    // Pseudo-Mersenne prime
    function MPrime(name, p) {
      // P = 2 ^ N - K
      this.name = name;
      this.p = new BN(p, 16);
      this.n = this.p.bitLength();
      this.k = new BN(1).ishln(this.n).isub(this.p);
    
      this.tmp = this._tmp();
    }
    
    MPrime.prototype._tmp = function _tmp() {
      var tmp = new BN(null);
      tmp.words = new Array(Math.ceil(this.n / 13));
      return tmp;
    };
    
    MPrime.prototype.ireduce = function ireduce(num) {
      // Assumes that `num` is less than `P^2`
      // num = HI * (2 ^ N - K) + HI * K + LO = HI * K + LO (mod P)
      var r = num;
      var rlen;
    
      do {
        this.split(r, this.tmp);
        r = this.imulK(r);
        r = r.iadd(this.tmp);
        rlen = r.bitLength();
      } while (rlen > this.n);
    
      var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
      if (cmp === 0) {
        r.words[0] = 0;
        r.length = 1;
      } else if (cmp > 0) {
        r.isub(this.p);
      } else {
        r.strip();
      }
    
      return r;
    };
    
    MPrime.prototype.split = function split(input, out) {
      input.ishrn(this.n, 0, out);
    };
    
    MPrime.prototype.imulK = function imulK(num) {
      return num.imul(this.k);
    };
    
    function K256() {
      MPrime.call(
        this,
        'k256',
        'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f');
    }
    inherits(K256, MPrime);
    
    K256.prototype.split = function split(input, output) {
      // 256 = 9 * 26 + 22
      var mask = 0x3fffff;
    
      var outLen = Math.min(input.length, 9);
      for (var i = 0; i < outLen; i++)
        output.words[i] = input.words[i];
      output.length = outLen;
    
      if (input.length <= 9) {
        input.words[0] = 0;
        input.length = 1;
        return;
      }
    
      // Shift by 9 limbs
      var prev = input.words[9];
      output.words[output.length++] = prev & mask;
    
      for (var i = 10; i < input.length; i++) {
        var next = input.words[i];
        input.words[i - 10] = ((next & mask) << 4) | (prev >>> 22);
        prev = next;
      }
      input.words[i - 10] = prev >>> 22;
      input.length -= 9;
    };
    
    K256.prototype.imulK = function imulK(num) {
      // K = 0x1000003d1 = [ 0x40, 0x3d1 ]
      num.words[num.length] = 0;
      num.words[num.length + 1] = 0;
      num.length += 2;
    
      // bounded at: 0x40 * 0x3ffffff + 0x3d0 = 0x100000390
      var hi;
      var lo = 0;
      for (var i = 0; i < num.length; i++) {
        var w = num.words[i];
        hi = w * 0x40;
        lo += w * 0x3d1;
        hi += (lo / 0x4000000) | 0;
        lo &= 0x3ffffff;
    
        num.words[i] = lo;
    
        lo = hi;
      }
    
      // Fast length reduction
      if (num.words[num.length - 1] === 0) {
        num.length--;
        if (num.words[num.length - 1] === 0)
          num.length--;
      }
      return num;
    };
    
    function P224() {
      MPrime.call(
        this,
        'p224',
        'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001');
    }
    inherits(P224, MPrime);
    
    function P192() {
      MPrime.call(
        this,
        'p192',
        'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff');
    }
    inherits(P192, MPrime);
    
    function P25519() {
      // 2 ^ 255 - 19
      MPrime.call(
        this,
        '25519',
        '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed');
    }
    inherits(P25519, MPrime);
    
    P25519.prototype.imulK = function imulK(num) {
      // K = 0x13
      var carry = 0;
      for (var i = 0; i < num.length; i++) {
        var hi = num.words[i] * 0x13 + carry;
        var lo = hi & 0x3ffffff;
        hi >>>= 26;
    
        num.words[i] = lo;
        carry = hi;
      }
      if (carry !== 0)
        num.words[num.length++] = carry;
      return num;
    };
    
    // Exported mostly for testing purposes, use plain name instead
    BN._prime = function prime(name) {
      // Cached version of prime
      if (primes[name])
        return primes[name];
    
      var prime;
      if (name === 'k256')
        prime = new K256();
      else if (name === 'p224')
        prime = new P224();
      else if (name === 'p192')
        prime = new P192();
      else if (name === 'p25519')
        prime = new P25519();
      else
        throw new Error('Unknown prime ' + name);
      primes[name] = prime;
    
      return prime;
    };
    
    //
    // Base reduction engine
    //
    function Red(m) {
      if (typeof m === 'string') {
        var prime = BN._prime(m);
        this.m = prime.p;
        this.prime = prime;
      } else {
        this.m = m;
        this.prime = null;
      }
    }
    
    Red.prototype._verify1 = function _verify1(a) {
      assert(!a.sign, 'red works only with positives');
      assert(a.red, 'red works only with red numbers');
    };
    
    Red.prototype._verify2 = function _verify2(a, b) {
      assert(!a.sign && !b.sign, 'red works only with positives');
      assert(a.red && a.red === b.red,
             'red works only with red numbers');
    };
    
    Red.prototype.imod = function imod(a) {
      if (this.prime)
        return this.prime.ireduce(a)._forceRed(this);
      return a.mod(this.m)._forceRed(this);
    };
    
    Red.prototype.neg = function neg(a) {
      var r = a.clone();
      r.sign = !r.sign;
      return r.iadd(this.m)._forceRed(this);
    };
    
    Red.prototype.add = function add(a, b) {
      this._verify2(a, b);
    
      var res = a.add(b);
      if (res.cmp(this.m) >= 0)
        res.isub(this.m);
      return res._forceRed(this);
    };
    
    Red.prototype.iadd = function iadd(a, b) {
      this._verify2(a, b);
    
      var res = a.iadd(b);
      if (res.cmp(this.m) >= 0)
        res.isub(this.m);
      return res;
    };
    
    Red.prototype.sub = function sub(a, b) {
      this._verify2(a, b);
    
      var res = a.sub(b);
      if (res.cmpn(0) < 0)
        res.iadd(this.m);
      return res._forceRed(this);
    };
    
    Red.prototype.isub = function isub(a, b) {
      this._verify2(a, b);
    
      var res = a.isub(b);
      if (res.cmpn(0) < 0)
        res.iadd(this.m);
      return res;
    };
    
    Red.prototype.shl = function shl(a, num) {
      this._verify1(a);
      return this.imod(a.shln(num));
    };
    
    Red.prototype.imul = function imul(a, b) {
      this._verify2(a, b);
      return this.imod(a.imul(b));
    };
    
    Red.prototype.mul = function mul(a, b) {
      this._verify2(a, b);
      return this.imod(a.mul(b));
    };
    
    Red.prototype.isqr = function isqr(a) {
      return this.imul(a, a);
    };
    
    Red.prototype.sqr = function sqr(a) {
      return this.mul(a, a);
    };
    
    Red.prototype.sqrt = function sqrt(a) {
      if (a.cmpn(0) === 0)
        return a.clone();
    
      var mod3 = this.m.andln(3);
      assert(mod3 % 2 === 1);
    
      // Fast case
      if (mod3 === 3) {
        var pow = this.m.add(new BN(1)).ishrn(2);
        var r = this.pow(a, pow);
        return r;
      }
    
      // Tonelli-Shanks algorithm (Totally unoptimized and slow)
      //
      // Find Q and S, that Q * 2 ^ S = (P - 1)
      var q = this.m.subn(1);
      var s = 0;
      while (q.cmpn(0) !== 0 && q.andln(1) === 0) {
        s++;
        q.ishrn(1);
      }
      assert(q.cmpn(0) !== 0);
    
      var one = new BN(1).toRed(this);
      var nOne = one.redNeg();
    
      // Find quadratic non-residue
      // NOTE: Max is such because of generalized Riemann hypothesis.
      var lpow = this.m.subn(1).ishrn(1);
      var z = this.m.bitLength();
      z = new BN(2 * z * z).toRed(this);
      while (this.pow(z, lpow).cmp(nOne) !== 0)
        z.redIAdd(nOne);
    
      var c = this.pow(z, q);
      var r = this.pow(a, q.addn(1).ishrn(1));
      var t = this.pow(a, q);
      var m = s;
      while (t.cmp(one) !== 0) {
        var tmp = t;
        for (var i = 0; tmp.cmp(one) !== 0; i++)
          tmp = tmp.redSqr();
        assert(i < m);
        var b = this.pow(c, new BN(1).ishln(m - i - 1));
    
        r = r.redMul(b);
        c = b.redSqr();
        t = t.redMul(c);
        m = i;
      }
    
      return r;
    };
    
    Red.prototype.invm = function invm(a) {
      var inv = a._invmp(this.m);
      if (inv.sign) {
        inv.sign = false;
        return this.imod(inv).redNeg();
      } else {
        return this.imod(inv);
      }
    };
    
    Red.prototype.pow = function pow(a, num) {
      var w = [];
    
      if (num.cmpn(0) === 0)
        return new BN(1);
    
      var q = num.clone();
    
      while (q.cmpn(0) !== 0) {
        w.push(q.andln(1));
        q.ishrn(1);
      }
    
      // Skip leading zeroes
      var res = a;
      for (var i = 0; i < w.length; i++, res = this.sqr(res))
        if (w[i] !== 0)
          break;
    
      if (++i < w.length) {
        for (var q = this.sqr(res); i < w.length; i++, q = this.sqr(q)) {
          if (w[i] === 0)
            continue;
          res = this.mul(res, q);
        }
      }
    
      return res;
    };
    
    Red.prototype.convertTo = function convertTo(num) {
      var r = num.mod(this.m);
      if (r === num)
        return r.clone();
      else
        return r;
    };
    
    Red.prototype.convertFrom = function convertFrom(num) {
      var res = num.clone();
      res.red = null;
      return res;
    };
    
    //
    // Montgomery method engine
    //
    
    BN.mont = function mont(num) {
      return new Mont(num);
    };
    
    function Mont(m) {
      Red.call(this, m);
    
      this.shift = this.m.bitLength();
      if (this.shift % 26 !== 0)
        this.shift += 26 - (this.shift % 26);
      this.r = new BN(1).ishln(this.shift);
      this.r2 = this.imod(this.r.sqr());
      this.rinv = this.r._invmp(this.m);
    
      this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
      this.minv.sign = true;
      this.minv = this.minv.mod(this.r);
    }
    inherits(Mont, Red);
    
    Mont.prototype.convertTo = function convertTo(num) {
      return this.imod(num.shln(this.shift));
    };
    
    Mont.prototype.convertFrom = function convertFrom(num) {
      var r = this.imod(num.mul(this.rinv));
      r.red = null;
      return r;
    };
    
    Mont.prototype.imul = function imul(a, b) {
      if (a.cmpn(0) === 0 || b.cmpn(0) === 0) {
        a.words[0] = 0;
        a.length = 1;
        return a;
      }
    
      var t = a.imul(b);
      var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
      var u = t.isub(c).ishrn(this.shift);
      var res = u;
      if (u.cmp(this.m) >= 0)
        res = u.isub(this.m);
      else if (u.cmpn(0) < 0)
        res = u.iadd(this.m);
    
      return res._forceRed(this);
    };
    
    Mont.prototype.mul = function mul(a, b) {
      if (a.cmpn(0) === 0 || b.cmpn(0) === 0)
        return new BN(0)._forceRed(this);
    
      var t = a.mul(b);
      var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
      var u = t.isub(c).ishrn(this.shift);
      var res = u;
      if (u.cmp(this.m) >= 0)
        res = u.isub(this.m);
      else if (u.cmpn(0) < 0)
        res = u.iadd(this.m);
    
      return res._forceRed(this);
    };
    
    Mont.prototype.invm = function invm(a) {
      // (AR)^-1 * R^2 = (A^-1 * R^-1) * R^2 = A^-1 * R
      var res = this.imod(a._invmp(this.m).mul(this.r2));
      return res._forceRed(this);
    };
    
    })(typeof module === 'undefined' || module, this);
    
  provide("bn.js", module.exports);
}(global));

// pakmanager:minimalistic-assert
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  module.exports = assert;
    
    function assert(val, msg) {
      if (!val)
        throw new Error(msg || 'Assertion failed');
    }
    
    assert.equal = function assertEqual(l, r, msg) {
      if (l != r)
        throw new Error(msg || ('Assertion failed: ' + l + ' != ' + r));
    };
    
  provide("minimalistic-assert", module.exports);
}(global));

// pakmanager:core-util-is
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Copyright Joyent, Inc. and other Node contributors.
    //
    // Permission is hereby granted, free of charge, to any person obtaining a
    // copy of this software and associated documentation files (the
    // "Software"), to deal in the Software without restriction, including
    // without limitation the rights to use, copy, modify, merge, publish,
    // distribute, sublicense, and/or sell copies of the Software, and to permit
    // persons to whom the Software is furnished to do so, subject to the
    // following conditions:
    //
    // The above copyright notice and this permission notice shall be included
    // in all copies or substantial portions of the Software.
    //
    // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
    // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
    // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
    // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
    // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
    // USE OR OTHER DEALINGS IN THE SOFTWARE.
    
    // NOTE: These type checking functions intentionally don't use `instanceof`
    // because it is fragile and can be easily faked with `Object.create()`.
    function isArray(ar) {
      return Array.isArray(ar);
    }
    exports.isArray = isArray;
    
    function isBoolean(arg) {
      return typeof arg === 'boolean';
    }
    exports.isBoolean = isBoolean;
    
    function isNull(arg) {
      return arg === null;
    }
    exports.isNull = isNull;
    
    function isNullOrUndefined(arg) {
      return arg == null;
    }
    exports.isNullOrUndefined = isNullOrUndefined;
    
    function isNumber(arg) {
      return typeof arg === 'number';
    }
    exports.isNumber = isNumber;
    
    function isString(arg) {
      return typeof arg === 'string';
    }
    exports.isString = isString;
    
    function isSymbol(arg) {
      return typeof arg === 'symbol';
    }
    exports.isSymbol = isSymbol;
    
    function isUndefined(arg) {
      return arg === void 0;
    }
    exports.isUndefined = isUndefined;
    
    function isRegExp(re) {
      return isObject(re) && objectToString(re) === '[object RegExp]';
    }
    exports.isRegExp = isRegExp;
    
    function isObject(arg) {
      return typeof arg === 'object' && arg !== null;
    }
    exports.isObject = isObject;
    
    function isDate(d) {
      return isObject(d) && objectToString(d) === '[object Date]';
    }
    exports.isDate = isDate;
    
    function isError(e) {
      return isObject(e) &&
          (objectToString(e) === '[object Error]' || e instanceof Error);
    }
    exports.isError = isError;
    
    function isFunction(arg) {
      return typeof arg === 'function';
    }
    exports.isFunction = isFunction;
    
    function isPrimitive(arg) {
      return arg === null ||
             typeof arg === 'boolean' ||
             typeof arg === 'number' ||
             typeof arg === 'string' ||
             typeof arg === 'symbol' ||  // ES6 symbol
             typeof arg === 'undefined';
    }
    exports.isPrimitive = isPrimitive;
    
    function isBuffer(arg) {
      return Buffer.isBuffer(arg);
    }
    exports.isBuffer = isBuffer;
    
    function objectToString(o) {
      return Object.prototype.toString.call(o);
    }
  provide("core-util-is", module.exports);
}(global));

// pakmanager:isarray
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  module.exports = Array.isArray || function (arr) {
      return Object.prototype.toString.call(arr) == '[object Array]';
    };
    
  provide("isarray", module.exports);
}(global));

// pakmanager:process-nextick-args
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    module.exports = nextTick;
    
    function nextTick(fn) {
      var args = new Array(arguments.length - 1);
      var i = 0;
      while (i < arguments.length) {
        args[i++] = arguments[i];
      }
      process.nextTick(function afterTick() {
        fn.apply(null, args);
      });
    }
    
  provide("process-nextick-args", module.exports);
}(global));

// pakmanager:util-deprecate
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  
    /**
     * For Node.js, simply re-export the core `util.deprecate` function.
     */
    
    module.exports = require('util').deprecate;
    
  provide("util-deprecate", module.exports);
}(global));

// pakmanager:camelcase
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    module.exports = function (str) {
    	str = str.trim();
    
    	if (str.length === 1 || !(/[_.\- ]+/).test(str) ) {
    		if (str[0] === str[0].toLowerCase() && str.slice(1) !== str.slice(1).toLowerCase()) {
    			return str;
    		}
    
    		return str.toLowerCase();
    	}
    
    	return str
    	.replace(/^[_.\- ]+/, '')
    	.toLowerCase()
    	.replace(/[_.\- ]+(\w|$)/g, function (m, p1) {
    		return p1.toUpperCase();
    	});
    };
    
  provide("camelcase", module.exports);
}(global));

// pakmanager:map-obj
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    module.exports = function (obj, cb) {
    	var ret = {};
    	var keys = Object.keys(obj);
    
    	for (var i = 0; i < keys.length; i++) {
    		var key = keys[i];
    		var res = cb(key, obj[key], obj);
    		ret[res[0]] = res[1];
    	}
    
    	return ret;
    };
    
  provide("map-obj", module.exports);
}(global));

// pakmanager:get-stdin
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    module.exports = function (cb) {
    	var stdin = process.stdin;
    	var ret = '';
    
    	if (stdin.isTTY) {
    		setImmediate(cb, '');
    		return;
    	}
    
    	stdin.setEncoding('utf8');
    
    	stdin.on('readable', function () {
    		var chunk;
    
    		while (chunk = stdin.read()) {
    			ret += chunk;
    		}
    	});
    
    	stdin.on('end', function () {
    		cb(ret);
    	});
    };
    
    module.exports.buffer = function (cb) {
    	var stdin = process.stdin;
    	var ret = [];
    	var len = 0;
    
    	if (stdin.isTTY) {
    		setImmediate(cb, new Buffer(''));
    		return;
    	}
    
    	stdin.on('readable', function () {
    		var chunk;
    
    		while (chunk = stdin.read()) {
    			ret.push(chunk);
    			len += chunk.length;
    		}
    	});
    
    	stdin.on('end', function () {
    		cb(Buffer.concat(ret, len));
    	});
    };
    
  provide("get-stdin", module.exports);
}(global));

// pakmanager:repeating
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    var isFinite = require('is-finite');
    
    module.exports = function (str, n) {
    	if (typeof str !== 'string') {
    		throw new TypeError('Expected a string as the first argument');
    	}
    
    	if (n < 0 || !isFinite(n)) {
    		throw new TypeError('Expected a finite positive number');
    	}
    
    	var ret = '';
    
    	do {
    		if (n & 1) {
    			ret += str;
    		}
    
    		str += str;
    	} while (n = n >> 1);
    
    	return ret;
    };
    
  provide("repeating", module.exports);
}(global));

// pakmanager:hoek/lib/escape
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Declare internals
    
    var internals = {};
    
    
    exports.escapeJavaScript = function (input) {
    
        if (!input) {
            return '';
        }
    
        var escaped = '';
    
        for (var i = 0, il = input.length; i < il; ++i) {
    
            var charCode = input.charCodeAt(i);
    
            if (internals.isSafe(charCode)) {
                escaped += input[i];
            }
            else {
                escaped += internals.escapeJavaScriptChar(charCode);
            }
        }
    
        return escaped;
    };
    
    
    exports.escapeHtml = function (input) {
    
        if (!input) {
            return '';
        }
    
        var escaped = '';
    
        for (var i = 0, il = input.length; i < il; ++i) {
    
            var charCode = input.charCodeAt(i);
    
            if (internals.isSafe(charCode)) {
                escaped += input[i];
            }
            else {
                escaped += internals.escapeHtmlChar(charCode);
            }
        }
    
        return escaped;
    };
    
    
    internals.escapeJavaScriptChar = function (charCode) {
    
        if (charCode >= 256) {
            return '\\u' + internals.padLeft('' + charCode, 4);
        }
    
        var hexValue = new Buffer(String.fromCharCode(charCode), 'ascii').toString('hex');
        return '\\x' + internals.padLeft(hexValue, 2);
    };
    
    
    internals.escapeHtmlChar = function (charCode) {
    
        var namedEscape = internals.namedHtml[charCode];
        if (typeof namedEscape !== 'undefined') {
            return namedEscape;
        }
    
        if (charCode >= 256) {
            return '&#' + charCode + ';';
        }
    
        var hexValue = new Buffer(String.fromCharCode(charCode), 'ascii').toString('hex');
        return '&#x' + internals.padLeft(hexValue, 2) + ';';
    };
    
    
    internals.padLeft = function (str, len) {
    
        while (str.length < len) {
            str = '0' + str;
        }
    
        return str;
    };
    
    
    internals.isSafe = function (charCode) {
    
        return (typeof internals.safeCharCodes[charCode] !== 'undefined');
    };
    
    
    internals.namedHtml = {
        '38': '&amp;',
        '60': '&lt;',
        '62': '&gt;',
        '34': '&quot;',
        '160': '&nbsp;',
        '162': '&cent;',
        '163': '&pound;',
        '164': '&curren;',
        '169': '&copy;',
        '174': '&reg;'
    };
    
    
    internals.safeCharCodes = (function () {
    
        var safe = {};
    
        for (var i = 32; i < 123; ++i) {
    
            if ((i >= 97) ||                    // a-z
                (i >= 65 && i <= 90) ||         // A-Z
                (i >= 48 && i <= 57) ||         // 0-9
                i === 32 ||                     // space
                i === 46 ||                     // .
                i === 44 ||                     // ,
                i === 45 ||                     // -
                i === 58 ||                     // :
                i === 95) {                     // _
    
                safe[i] = null;
            }
        }
    
        return safe;
    }());
    
  provide("hoek/lib/escape", module.exports);
}(global));

// pakmanager:hoek/lib
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Load modules
    
    var Crypto = require('crypto');
    var Path = require('path');
    var Util = require('util');
    var Escape =  require('hoek/lib/escape');
    
    
    // Declare internals
    
    var internals = {};
    
    
    // Clone object or array
    
    exports.clone = function (obj, seen) {
    
        if (typeof obj !== 'object' ||
            obj === null) {
    
            return obj;
        }
    
        seen = seen || { orig: [], copy: [] };
    
        var lookup = seen.orig.indexOf(obj);
        if (lookup !== -1) {
            return seen.copy[lookup];
        }
    
        var newObj;
        var cloneDeep = false;
    
        if (!Array.isArray(obj)) {
            if (Buffer.isBuffer(obj)) {
                newObj = new Buffer(obj);
            }
            else if (obj instanceof Date) {
                newObj = new Date(obj.getTime());
            }
            else if (obj instanceof RegExp) {
                newObj = new RegExp(obj);
            }
            else {
                var proto = Object.getPrototypeOf(obj);
                if (proto &&
                    proto.isImmutable) {
    
                    newObj = obj;
                }
                else {
                    newObj = Object.create(proto);
                    cloneDeep = true;
                }
            }
        }
        else {
            newObj = [];
            cloneDeep = true;
        }
    
        seen.orig.push(obj);
        seen.copy.push(newObj);
    
        if (cloneDeep) {
            var keys = Object.getOwnPropertyNames(obj);
            for (var i = 0, il = keys.length; i < il; ++i) {
                var key = keys[i];
                var descriptor = Object.getOwnPropertyDescriptor(obj, key);
                if (descriptor.get ||
                    descriptor.set) {
    
                    Object.defineProperty(newObj, key, descriptor);
                }
                else {
                    newObj[key] = exports.clone(obj[key], seen);
                }
            }
        }
    
        return newObj;
    };
    
    
    // Merge all the properties of source into target, source wins in conflict, and by default null and undefined from source are applied
    /*eslint-disable */
    exports.merge = function (target, source, isNullOverride /* = true */, isMergeArrays /* = true */) {
    /*eslint-enable */
        exports.assert(target && typeof target === 'object', 'Invalid target value: must be an object');
        exports.assert(source === null || source === undefined || typeof source === 'object', 'Invalid source value: must be null, undefined, or an object');
    
        if (!source) {
            return target;
        }
    
        if (Array.isArray(source)) {
            exports.assert(Array.isArray(target), 'Cannot merge array onto an object');
            if (isMergeArrays === false) {                                                  // isMergeArrays defaults to true
                target.length = 0;                                                          // Must not change target assignment
            }
    
            for (var i = 0, il = source.length; i < il; ++i) {
                target.push(exports.clone(source[i]));
            }
    
            return target;
        }
    
        var keys = Object.keys(source);
        for (var k = 0, kl = keys.length; k < kl; ++k) {
            var key = keys[k];
            var value = source[key];
            if (value &&
                typeof value === 'object') {
    
                if (!target[key] ||
                    typeof target[key] !== 'object' ||
                    (Array.isArray(target[key]) ^ Array.isArray(value)) ||
                    value instanceof Date ||
                    Buffer.isBuffer(value) ||
                    value instanceof RegExp) {
    
                    target[key] = exports.clone(value);
                }
                else {
                    exports.merge(target[key], value, isNullOverride, isMergeArrays);
                }
            }
            else {
                if (value !== null &&
                    value !== undefined) {                              // Explicit to preserve empty strings
    
                    target[key] = value;
                }
                else if (isNullOverride !== false) {                    // Defaults to true
                    target[key] = value;
                }
            }
        }
    
        return target;
    };
    
    
    // Apply options to a copy of the defaults
    
    exports.applyToDefaults = function (defaults, options, isNullOverride) {
    
        exports.assert(defaults && typeof defaults === 'object', 'Invalid defaults value: must be an object');
        exports.assert(!options || options === true || typeof options === 'object', 'Invalid options value: must be true, falsy or an object');
    
        if (!options) {                                                 // If no options, return null
            return null;
        }
    
        var copy = exports.clone(defaults);
    
        if (options === true) {                                         // If options is set to true, use defaults
            return copy;
        }
    
        return exports.merge(copy, options, isNullOverride === true, false);
    };
    
    
    // Clone an object except for the listed keys which are shallow copied
    
    exports.cloneWithShallow = function (source, keys) {
    
        if (!source ||
            typeof source !== 'object') {
    
            return source;
        }
    
        var storage = internals.store(source, keys);    // Move shallow copy items to storage
        var copy = exports.clone(source);               // Deep copy the rest
        internals.restore(copy, source, storage);       // Shallow copy the stored items and restore
        return copy;
    };
    
    
    internals.store = function (source, keys) {
    
        var storage = {};
        for (var i = 0, il = keys.length; i < il; ++i) {
            var key = keys[i];
            var value = exports.reach(source, key);
            if (value !== undefined) {
                storage[key] = value;
                internals.reachSet(source, key, undefined);
            }
        }
    
        return storage;
    };
    
    
    internals.restore = function (copy, source, storage) {
    
        var keys = Object.keys(storage);
        for (var i = 0, il = keys.length; i < il; ++i) {
            var key = keys[i];
            internals.reachSet(copy, key, storage[key]);
            internals.reachSet(source, key, storage[key]);
        }
    };
    
    
    internals.reachSet = function (obj, key, value) {
    
        var path = key.split('.');
        var ref = obj;
        for (var i = 0, il = path.length; i < il; ++i) {
            var segment = path[i];
            if (i + 1 === il) {
                ref[segment] = value;
            }
    
            ref = ref[segment];
        }
    };
    
    
    // Apply options to defaults except for the listed keys which are shallow copied from option without merging
    
    exports.applyToDefaultsWithShallow = function (defaults, options, keys) {
    
        exports.assert(defaults && typeof defaults === 'object', 'Invalid defaults value: must be an object');
        exports.assert(!options || options === true || typeof options === 'object', 'Invalid options value: must be true, falsy or an object');
        exports.assert(keys && Array.isArray(keys), 'Invalid keys');
    
        if (!options) {                                                 // If no options, return null
            return null;
        }
    
        var copy = exports.cloneWithShallow(defaults, keys);
    
        if (options === true) {                                         // If options is set to true, use defaults
            return copy;
        }
    
        var storage = internals.store(options, keys);   // Move shallow copy items to storage
        exports.merge(copy, options, false, false);     // Deep copy the rest
        internals.restore(copy, options, storage);      // Shallow copy the stored items and restore
        return copy;
    };
    
    
    // Deep object or array comparison
    
    exports.deepEqual = function (obj, ref, options, seen) {
    
        options = options || { prototype: true };
    
        var type = typeof obj;
    
        if (type !== typeof ref) {
            return false;
        }
    
        if (type !== 'object' ||
            obj === null ||
            ref === null) {
    
            if (obj === ref) {                                                      // Copied from Deep-eql, copyright(c) 2013 Jake Luer, jake@alogicalparadox.com, MIT Licensed, https://github.com/chaijs/deep-eql
                return obj !== 0 || 1 / obj === 1 / ref;        // -0 / +0
            }
    
            return obj !== obj && ref !== ref;                  // NaN
        }
    
        seen = seen || [];
        if (seen.indexOf(obj) !== -1) {
            return true;                            // If previous comparison failed, it would have stopped execution
        }
    
        seen.push(obj);
    
        if (Array.isArray(obj)) {
            if (!Array.isArray(ref)) {
                return false;
            }
    
            if (!options.part && obj.length !== ref.length) {
                return false;
            }
    
            for (var i = 0, il = obj.length; i < il; ++i) {
                if (options.part) {
                    var found = false;
                    for (var r = 0, rl = ref.length; r < rl; ++r) {
                        if (exports.deepEqual(obj[i], ref[r], options, seen)) {
                            found = true;
                            break;
                        }
                    }
    
                    return found;
                }
    
                if (!exports.deepEqual(obj[i], ref[i], options, seen)) {
                    return false;
                }
            }
    
            return true;
        }
    
        if (Buffer.isBuffer(obj)) {
            if (!Buffer.isBuffer(ref)) {
                return false;
            }
    
            if (obj.length !== ref.length) {
                return false;
            }
    
            for (var j = 0, jl = obj.length; j < jl; ++j) {
                if (obj[j] !== ref[j]) {
                    return false;
                }
            }
    
            return true;
        }
    
        if (obj instanceof Date) {
            return (ref instanceof Date && obj.getTime() === ref.getTime());
        }
    
        if (obj instanceof RegExp) {
            return (ref instanceof RegExp && obj.toString() === ref.toString());
        }
    
        if (options.prototype) {
            if (Object.getPrototypeOf(obj) !== Object.getPrototypeOf(ref)) {
                return false;
            }
        }
    
        var keys = Object.getOwnPropertyNames(obj);
    
        if (!options.part && keys.length !== Object.getOwnPropertyNames(ref).length) {
            return false;
        }
    
        for (var k = 0, kl = keys.length; k < kl; ++k) {
            var key = keys[k];
            var descriptor = Object.getOwnPropertyDescriptor(obj, key);
            if (descriptor.get) {
                if (!exports.deepEqual(descriptor, Object.getOwnPropertyDescriptor(ref, key), options, seen)) {
                    return false;
                }
            }
            else if (!exports.deepEqual(obj[key], ref[key], options, seen)) {
                return false;
            }
        }
    
        return true;
    };
    
    
    // Remove duplicate items from array
    
    exports.unique = function (array, key) {
    
        var index = {};
        var result = [];
    
        for (var i = 0, il = array.length; i < il; ++i) {
            var id = (key ? array[i][key] : array[i]);
            if (index[id] !== true) {
    
                result.push(array[i]);
                index[id] = true;
            }
        }
    
        return result;
    };
    
    
    // Convert array into object
    
    exports.mapToObject = function (array, key) {
    
        if (!array) {
            return null;
        }
    
        var obj = {};
        for (var i = 0, il = array.length; i < il; ++i) {
            if (key) {
                if (array[i][key]) {
                    obj[array[i][key]] = true;
                }
            }
            else {
                obj[array[i]] = true;
            }
        }
    
        return obj;
    };
    
    
    // Find the common unique items in two arrays
    
    exports.intersect = function (array1, array2, justFirst) {
    
        if (!array1 || !array2) {
            return [];
        }
    
        var common = [];
        var hash = (Array.isArray(array1) ? exports.mapToObject(array1) : array1);
        var found = {};
        for (var i = 0, il = array2.length; i < il; ++i) {
            if (hash[array2[i]] && !found[array2[i]]) {
                if (justFirst) {
                    return array2[i];
                }
    
                common.push(array2[i]);
                found[array2[i]] = true;
            }
        }
    
        return (justFirst ? null : common);
    };
    
    
    // Test if the reference contains the values
    
    exports.contain = function (ref, values, options) {
    
        /*
            string -> string(s)
            array -> item(s)
            object -> key(s)
            object -> object (key:value)
        */
    
        var valuePairs = null;
        if (typeof ref === 'object' &&
            typeof values === 'object' &&
            !Array.isArray(ref) &&
            !Array.isArray(values)) {
    
            valuePairs = values;
            values = Object.keys(values);
        }
        else {
            values = [].concat(values);
        }
    
        options = options || {};            // deep, once, only, part
    
        exports.assert(arguments.length >= 2, 'Insufficient arguments');
        exports.assert(typeof ref === 'string' || typeof ref === 'object', 'Reference must be string or an object');
        exports.assert(values.length, 'Values array cannot be empty');
    
        var compare, compareFlags;
        if (options.deep) {
            compare = exports.deepEqual;
    
            var hasOnly = options.hasOwnProperty('only'), hasPart = options.hasOwnProperty('part');
    
            compareFlags = {
                prototype: hasOnly ? options.only : hasPart ? !options.part : false,
                part: hasOnly ? !options.only : hasPart ? options.part : true
            };
        }
        else {
            compare = function (a, b) {
    
                return a === b;
            };
        }
    
        var misses = false;
        var matches = new Array(values.length);
        for (var i = 0, il = matches.length; i < il; ++i) {
            matches[i] = 0;
        }
    
        if (typeof ref === 'string') {
            var pattern = '(';
            for (i = 0, il = values.length; i < il; ++i) {
                var value = values[i];
                exports.assert(typeof value === 'string', 'Cannot compare string reference to non-string value');
                pattern += (i ? '|' : '') + exports.escapeRegex(value);
            }
    
            var regex = new RegExp(pattern + ')', 'g');
            var leftovers = ref.replace(regex, function ($0, $1) {
    
                var index = values.indexOf($1);
                ++matches[index];
                return '';          // Remove from string
            });
    
            misses = !!leftovers;
        }
        else if (Array.isArray(ref)) {
            for (i = 0, il = ref.length; i < il; ++i) {
                for (var j = 0, jl = values.length, matched = false; j < jl && matched === false; ++j) {
                    matched = compare(values[j], ref[i], compareFlags) && j;
                }
    
                if (matched !== false) {
                    ++matches[matched];
                }
                else {
                    misses = true;
                }
            }
        }
        else {
            var keys = Object.keys(ref);
            for (i = 0, il = keys.length; i < il; ++i) {
                var key = keys[i];
                var pos = values.indexOf(key);
                if (pos !== -1) {
                    if (valuePairs &&
                        !compare(valuePairs[key], ref[key], compareFlags)) {
    
                        return false;
                    }
    
                    ++matches[pos];
                }
                else {
                    misses = true;
                }
            }
        }
    
        var result = false;
        for (i = 0, il = matches.length; i < il; ++i) {
            result = result || !!matches[i];
            if ((options.once && matches[i] > 1) ||
                (!options.part && !matches[i])) {
    
                return false;
            }
        }
    
        if (options.only &&
            misses) {
    
            return false;
        }
    
        return result;
    };
    
    
    // Flatten array
    
    exports.flatten = function (array, target) {
    
        var result = target || [];
    
        for (var i = 0, il = array.length; i < il; ++i) {
            if (Array.isArray(array[i])) {
                exports.flatten(array[i], result);
            }
            else {
                result.push(array[i]);
            }
        }
    
        return result;
    };
    
    
    // Convert an object key chain string ('a.b.c') to reference (object[a][b][c])
    
    exports.reach = function (obj, chain, options) {
    
        options = options || {};
        if (typeof options === 'string') {
            options = { separator: options };
        }
    
        var path = chain.split(options.separator || '.');
        var ref = obj;
        for (var i = 0, il = path.length; i < il; ++i) {
            var key = path[i];
            if (key[0] === '-' && Array.isArray(ref)) {
                key = key.slice(1, key.length);
                key = ref.length - key;
            }
    
            if (!ref ||
                !ref.hasOwnProperty(key) ||
                (typeof ref !== 'object' && options.functions === false)) {         // Only object and function can have properties
    
                exports.assert(!options.strict || i + 1 === il, 'Missing segment', key, 'in reach path ', chain);
                exports.assert(typeof ref === 'object' || options.functions === true || typeof ref !== 'function', 'Invalid segment', key, 'in reach path ', chain);
                ref = options.default;
                break;
            }
    
            ref = ref[key];
        }
    
        return ref;
    };
    
    
    exports.reachTemplate = function (obj, template, options) {
    
        return template.replace(/{([^}]+)}/g, function ($0, chain) {
    
            var value = exports.reach(obj, chain, options);
            return (value === undefined || value === null ? '' : value);
        });
    };
    
    
    exports.formatStack = function (stack) {
    
        var trace = [];
        for (var i = 0, il = stack.length; i < il; ++i) {
            var item = stack[i];
            trace.push([item.getFileName(), item.getLineNumber(), item.getColumnNumber(), item.getFunctionName(), item.isConstructor()]);
        }
    
        return trace;
    };
    
    
    exports.formatTrace = function (trace) {
    
        var display = [];
    
        for (var i = 0, il = trace.length; i < il; ++i) {
            var row = trace[i];
            display.push((row[4] ? 'new ' : '') + row[3] + ' (' + row[0] + ':' + row[1] + ':' + row[2] + ')');
        }
    
        return display;
    };
    
    
    exports.callStack = function (slice) {
    
        // http://code.google.com/p/v8/wiki/JavaScriptStackTraceApi
    
        var v8 = Error.prepareStackTrace;
        Error.prepareStackTrace = function (err, stack) {
    
            return stack;
        };
    
        var capture = {};
        Error.captureStackTrace(capture, arguments.callee);     /*eslint no-caller:0 */
        var stack = capture.stack;
    
        Error.prepareStackTrace = v8;
    
        var trace = exports.formatStack(stack);
    
        if (slice) {
            return trace.slice(slice);
        }
    
        return trace;
    };
    
    
    exports.displayStack = function (slice) {
    
        var trace = exports.callStack(slice === undefined ? 1 : slice + 1);
    
        return exports.formatTrace(trace);
    };
    
    
    exports.abortThrow = false;
    
    
    exports.abort = function (message, hideStack) {
    
        if (process.env.NODE_ENV === 'test' || exports.abortThrow === true) {
            throw new Error(message || 'Unknown error');
        }
    
        var stack = '';
        if (!hideStack) {
            stack = exports.displayStack(1).join('\n\t');
        }
        console.log('ABORT: ' + message + '\n\t' + stack);
        process.exit(1);
    };
    
    
    exports.assert = function (condition /*, msg1, msg2, msg3 */) {
    
        if (condition) {
            return;
        }
    
        if (arguments.length === 2 && arguments[1] instanceof Error) {
            throw arguments[1];
        }
    
        var msgs = [];
        for (var i = 1, il = arguments.length; i < il; ++i) {
            if (arguments[i] !== '') {
                msgs.push(arguments[i]);            // Avoids Array.slice arguments leak, allowing for V8 optimizations
            }
        }
    
        msgs = msgs.map(function (msg) {
    
            return typeof msg === 'string' ? msg : msg instanceof Error ? msg.message : exports.stringify(msg);
        });
        throw new Error(msgs.join(' ') || 'Unknown error');
    };
    
    
    exports.Timer = function () {
    
        this.ts = 0;
        this.reset();
    };
    
    
    exports.Timer.prototype.reset = function () {
    
        this.ts = Date.now();
    };
    
    
    exports.Timer.prototype.elapsed = function () {
    
        return Date.now() - this.ts;
    };
    
    
    exports.Bench = function () {
    
        this.ts = 0;
        this.reset();
    };
    
    
    exports.Bench.prototype.reset = function () {
    
        this.ts = exports.Bench.now();
    };
    
    
    exports.Bench.prototype.elapsed = function () {
    
        return exports.Bench.now() - this.ts;
    };
    
    
    exports.Bench.now = function () {
    
        var ts = process.hrtime();
        return (ts[0] * 1e3) + (ts[1] / 1e6);
    };
    
    
    // Escape string for Regex construction
    
    exports.escapeRegex = function (string) {
    
        // Escape ^$.*+-?=!:|\/()[]{},
        return string.replace(/[\^\$\.\*\+\-\?\=\!\:\|\\\/\(\)\[\]\{\}\,]/g, '\\$&');
    };
    
    
    // Base64url (RFC 4648) encode
    
    exports.base64urlEncode = function (value, encoding) {
    
        var buf = (Buffer.isBuffer(value) ? value : new Buffer(value, encoding || 'binary'));
        return buf.toString('base64').replace(/\+/g, '-').replace(/\//g, '_').replace(/\=/g, '');
    };
    
    
    // Base64url (RFC 4648) decode
    
    exports.base64urlDecode = function (value, encoding) {
    
        if (value &&
            !/^[\w\-]*$/.test(value)) {
    
            return new Error('Invalid character');
        }
    
        try {
            var buf = new Buffer(value, 'base64');
            return (encoding === 'buffer' ? buf : buf.toString(encoding || 'binary'));
        }
        catch (err) {
            return err;
        }
    };
    
    
    // Escape attribute value for use in HTTP header
    
    exports.escapeHeaderAttribute = function (attribute) {
    
        // Allowed value characters: !#$%&'()*+,-./:;<=>?@[]^_`{|}~ and space, a-z, A-Z, 0-9, \, "
    
        exports.assert(/^[ \w\!#\$%&'\(\)\*\+,\-\.\/\:;<\=>\?@\[\]\^`\{\|\}~\"\\]*$/.test(attribute), 'Bad attribute value (' + attribute + ')');
    
        return attribute.replace(/\\/g, '\\\\').replace(/\"/g, '\\"');                             // Escape quotes and slash
    };
    
    
    exports.escapeHtml = function (string) {
    
        return Escape.escapeHtml(string);
    };
    
    
    exports.escapeJavaScript = function (string) {
    
        return Escape.escapeJavaScript(string);
    };
    
    
    exports.nextTick = function (callback) {
    
        return function () {
    
            var args = arguments;
            process.nextTick(function () {
    
                callback.apply(null, args);
            });
        };
    };
    
    
    exports.once = function (method) {
    
        if (method._hoekOnce) {
            return method;
        }
    
        var once = false;
        var wrapped = function () {
    
            if (!once) {
                once = true;
                method.apply(null, arguments);
            }
        };
    
        wrapped._hoekOnce = true;
    
        return wrapped;
    };
    
    
    exports.isAbsolutePath = function (path, platform) {
    
        if (!path) {
            return false;
        }
    
        if (Path.isAbsolute) {                      // node >= 0.11
            return Path.isAbsolute(path);
        }
    
        platform = platform || process.platform;
    
        // Unix
    
        if (platform !== 'win32') {
            return path[0] === '/';
        }
    
        // Windows
    
        return !!/^(?:[a-zA-Z]:[\\\/])|(?:[\\\/]{2}[^\\\/]+[\\\/]+[^\\\/])/.test(path);        // C:\ or \\something\something
    };
    
    
    exports.isInteger = function (value) {
    
        return (typeof value === 'number' &&
                parseFloat(value) === parseInt(value, 10) &&
                !isNaN(value));
    };
    
    
    exports.ignore = function () { };
    
    
    exports.inherits = Util.inherits;
    
    
    exports.format = Util.format;
    
    
    exports.transform = function (source, transform, options) {
    
        exports.assert(source === null || source === undefined || typeof source === 'object', 'Invalid source object: must be null, undefined, or an object');
    
        var result = {};
        var keys = Object.keys(transform);
    
        for (var k = 0, kl = keys.length; k < kl; ++k) {
            var key = keys[k];
            var path = key.split('.');
            var sourcePath = transform[key];
    
            exports.assert(typeof sourcePath === 'string', 'All mappings must be "." delineated strings');
    
            var segment;
            var res = result;
    
            while (path.length > 1) {
                segment = path.shift();
                if (!res[segment]) {
                    res[segment] = {};
                }
                res = res[segment];
            }
            segment = path.shift();
            res[segment] = exports.reach(source, sourcePath, options);
        }
    
        return result;
    };
    
    
    exports.uniqueFilename = function (path, extension) {
    
        if (extension) {
            extension = extension[0] !== '.' ? '.' + extension : extension;
        }
        else {
            extension = '';
        }
    
        path = Path.resolve(path);
        var name = [Date.now(), process.pid, Crypto.randomBytes(8).toString('hex')].join('-') + extension;
        return Path.join(path, name);
    };
    
    
    exports.stringify = function () {
    
        try {
            return JSON.stringify.apply(null, arguments);
        }
        catch (err) {
            return '[Cannot display object: ' + err.message + ']';
        }
    };
    
    
    exports.shallow = function (source) {
    
        var target = {};
        var keys = Object.keys(source);
        for (var i = 0, il = keys.length; i < il; ++i) {
            var key = keys[i];
            target[key] = source[key];
        }
    
        return target;
    };
    
  provide("hoek/lib", module.exports);
}(global));

// pakmanager:hoek
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  module.exports =  require('hoek/lib');
    
  provide("hoek", module.exports);
}(global));

// pakmanager:ansi-regex
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    module.exports = function () {
    	return /[\u001b\u009b][[()#;?]*(?:[0-9]{1,4}(?:;[0-9]{0,4})*)?[0-9A-ORZcf-nqry=><]/g;
    };
    
  provide("ansi-regex", module.exports);
}(global));

// pakmanager:is-property
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  "use strict"
    function isProperty(str) {
      return /^[$A-Z\_a-z\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376\u0377\u037a-\u037d\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u0527\u0531-\u0556\u0559\u0561-\u0587\u05d0-\u05ea\u05f0-\u05f2\u0620-\u064a\u066e\u066f\u0671-\u06d3\u06d5\u06e5\u06e6\u06ee\u06ef\u06fa-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07ca-\u07ea\u07f4\u07f5\u07fa\u0800-\u0815\u081a\u0824\u0828\u0840-\u0858\u08a0\u08a2-\u08ac\u0904-\u0939\u093d\u0950\u0958-\u0961\u0971-\u0977\u0979-\u097f\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc\u09dd\u09df-\u09e1\u09f0\u09f1\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0\u0ae1\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3d\u0b5c\u0b5d\u0b5f-\u0b61\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c33\u0c35-\u0c39\u0c3d\u0c58\u0c59\u0c60\u0c61\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cde\u0ce0\u0ce1\u0cf1\u0cf2\u0d05-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d\u0d4e\u0d60\u0d61\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32\u0e33\u0e40-\u0e46\u0e81\u0e82\u0e84\u0e87\u0e88\u0e8a\u0e8d\u0e94-\u0e97\u0e99-\u0e9f\u0ea1-\u0ea3\u0ea5\u0ea7\u0eaa\u0eab\u0ead-\u0eb0\u0eb2\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0edc-\u0edf\u0f00\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8c\u1000-\u102a\u103f\u1050-\u1055\u105a-\u105d\u1061\u1065\u1066\u106e-\u1070\u1075-\u1081\u108e\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f4\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f0\u1700-\u170c\u170e-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u1820-\u1877\u1880-\u18a8\u18aa\u18b0-\u18f5\u1900-\u191c\u1950-\u196d\u1970-\u1974\u1980-\u19ab\u19c1-\u19c7\u1a00-\u1a16\u1a20-\u1a54\u1aa7\u1b05-\u1b33\u1b45-\u1b4b\u1b83-\u1ba0\u1bae\u1baf\u1bba-\u1be5\u1c00-\u1c23\u1c4d-\u1c4f\u1c5a-\u1c7d\u1ce9-\u1cec\u1cee-\u1cf1\u1cf5\u1cf6\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u209c\u2102\u2107\u210a-\u2113\u2115\u2119-\u211d\u2124\u2126\u2128\u212a-\u212d\u212f-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cee\u2cf2\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u2e2f\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303c\u3041-\u3096\u309d-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312d\u3131-\u318e\u31a0-\u31ba\u31f0-\u31ff\u3400-\u4db5\u4e00-\u9fcc\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua61f\ua62a\ua62b\ua640-\ua66e\ua67f-\ua697\ua6a0-\ua6ef\ua717-\ua71f\ua722-\ua788\ua78b-\ua78e\ua790-\ua793\ua7a0-\ua7aa\ua7f8-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8f2-\ua8f7\ua8fb\ua90a-\ua925\ua930-\ua946\ua960-\ua97c\ua984-\ua9b2\ua9cf\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa60-\uaa76\uaa7a\uaa80-\uaaaf\uaab1\uaab5\uaab6\uaab9-\uaabd\uaac0\uaac2\uaadb-\uaadd\uaae0-\uaaea\uaaf2-\uaaf4\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uabc0-\uabe2\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc][$A-Z\_a-z\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376\u0377\u037a-\u037d\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u0527\u0531-\u0556\u0559\u0561-\u0587\u05d0-\u05ea\u05f0-\u05f2\u0620-\u064a\u066e\u066f\u0671-\u06d3\u06d5\u06e5\u06e6\u06ee\u06ef\u06fa-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07ca-\u07ea\u07f4\u07f5\u07fa\u0800-\u0815\u081a\u0824\u0828\u0840-\u0858\u08a0\u08a2-\u08ac\u0904-\u0939\u093d\u0950\u0958-\u0961\u0971-\u0977\u0979-\u097f\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc\u09dd\u09df-\u09e1\u09f0\u09f1\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0\u0ae1\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3d\u0b5c\u0b5d\u0b5f-\u0b61\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c33\u0c35-\u0c39\u0c3d\u0c58\u0c59\u0c60\u0c61\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cde\u0ce0\u0ce1\u0cf1\u0cf2\u0d05-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d\u0d4e\u0d60\u0d61\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32\u0e33\u0e40-\u0e46\u0e81\u0e82\u0e84\u0e87\u0e88\u0e8a\u0e8d\u0e94-\u0e97\u0e99-\u0e9f\u0ea1-\u0ea3\u0ea5\u0ea7\u0eaa\u0eab\u0ead-\u0eb0\u0eb2\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0edc-\u0edf\u0f00\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8c\u1000-\u102a\u103f\u1050-\u1055\u105a-\u105d\u1061\u1065\u1066\u106e-\u1070\u1075-\u1081\u108e\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f4\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f0\u1700-\u170c\u170e-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u1820-\u1877\u1880-\u18a8\u18aa\u18b0-\u18f5\u1900-\u191c\u1950-\u196d\u1970-\u1974\u1980-\u19ab\u19c1-\u19c7\u1a00-\u1a16\u1a20-\u1a54\u1aa7\u1b05-\u1b33\u1b45-\u1b4b\u1b83-\u1ba0\u1bae\u1baf\u1bba-\u1be5\u1c00-\u1c23\u1c4d-\u1c4f\u1c5a-\u1c7d\u1ce9-\u1cec\u1cee-\u1cf1\u1cf5\u1cf6\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u209c\u2102\u2107\u210a-\u2113\u2115\u2119-\u211d\u2124\u2126\u2128\u212a-\u212d\u212f-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cee\u2cf2\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u2e2f\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303c\u3041-\u3096\u309d-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312d\u3131-\u318e\u31a0-\u31ba\u31f0-\u31ff\u3400-\u4db5\u4e00-\u9fcc\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua61f\ua62a\ua62b\ua640-\ua66e\ua67f-\ua697\ua6a0-\ua6ef\ua717-\ua71f\ua722-\ua788\ua78b-\ua78e\ua790-\ua793\ua7a0-\ua7aa\ua7f8-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8f2-\ua8f7\ua8fb\ua90a-\ua925\ua930-\ua946\ua960-\ua97c\ua984-\ua9b2\ua9cf\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa60-\uaa76\uaa7a\uaa80-\uaaaf\uaab1\uaab5\uaab6\uaab9-\uaabd\uaac0\uaac2\uaadb-\uaadd\uaae0-\uaaea\uaaf2-\uaaf4\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uabc0-\uabe2\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc0-9\u0300-\u036f\u0483-\u0487\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u0669\u0670\u06d6-\u06dc\u06df-\u06e4\u06e7\u06e8\u06ea-\u06ed\u06f0-\u06f9\u0711\u0730-\u074a\u07a6-\u07b0\u07c0-\u07c9\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0859-\u085b\u08e4-\u08fe\u0900-\u0903\u093a-\u093c\u093e-\u094f\u0951-\u0957\u0962\u0963\u0966-\u096f\u0981-\u0983\u09bc\u09be-\u09c4\u09c7\u09c8\u09cb-\u09cd\u09d7\u09e2\u09e3\u09e6-\u09ef\u0a01-\u0a03\u0a3c\u0a3e-\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a66-\u0a71\u0a75\u0a81-\u0a83\u0abc\u0abe-\u0ac5\u0ac7-\u0ac9\u0acb-\u0acd\u0ae2\u0ae3\u0ae6-\u0aef\u0b01-\u0b03\u0b3c\u0b3e-\u0b44\u0b47\u0b48\u0b4b-\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b66-\u0b6f\u0b82\u0bbe-\u0bc2\u0bc6-\u0bc8\u0bca-\u0bcd\u0bd7\u0be6-\u0bef\u0c01-\u0c03\u0c3e-\u0c44\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0c66-\u0c6f\u0c82\u0c83\u0cbc\u0cbe-\u0cc4\u0cc6-\u0cc8\u0cca-\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0ce6-\u0cef\u0d02\u0d03\u0d3e-\u0d44\u0d46-\u0d48\u0d4a-\u0d4d\u0d57\u0d62\u0d63\u0d66-\u0d6f\u0d82\u0d83\u0dca\u0dcf-\u0dd4\u0dd6\u0dd8-\u0ddf\u0df2\u0df3\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0e50-\u0e59\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0ed0-\u0ed9\u0f18\u0f19\u0f20-\u0f29\u0f35\u0f37\u0f39\u0f3e\u0f3f\u0f71-\u0f84\u0f86\u0f87\u0f8d-\u0f97\u0f99-\u0fbc\u0fc6\u102b-\u103e\u1040-\u1049\u1056-\u1059\u105e-\u1060\u1062-\u1064\u1067-\u106d\u1071-\u1074\u1082-\u108d\u108f-\u109d\u135d-\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b4-\u17d3\u17dd\u17e0-\u17e9\u180b-\u180d\u1810-\u1819\u18a9\u1920-\u192b\u1930-\u193b\u1946-\u194f\u19b0-\u19c0\u19c8\u19c9\u19d0-\u19d9\u1a17-\u1a1b\u1a55-\u1a5e\u1a60-\u1a7c\u1a7f-\u1a89\u1a90-\u1a99\u1b00-\u1b04\u1b34-\u1b44\u1b50-\u1b59\u1b6b-\u1b73\u1b80-\u1b82\u1ba1-\u1bad\u1bb0-\u1bb9\u1be6-\u1bf3\u1c24-\u1c37\u1c40-\u1c49\u1c50-\u1c59\u1cd0-\u1cd2\u1cd4-\u1ce8\u1ced\u1cf2-\u1cf4\u1dc0-\u1de6\u1dfc-\u1dff\u200c\u200d\u203f\u2040\u2054\u20d0-\u20dc\u20e1\u20e5-\u20f0\u2cef-\u2cf1\u2d7f\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua620-\ua629\ua66f\ua674-\ua67d\ua69f\ua6f0\ua6f1\ua802\ua806\ua80b\ua823-\ua827\ua880\ua881\ua8b4-\ua8c4\ua8d0-\ua8d9\ua8e0-\ua8f1\ua900-\ua909\ua926-\ua92d\ua947-\ua953\ua980-\ua983\ua9b3-\ua9c0\ua9d0-\ua9d9\uaa29-\uaa36\uaa43\uaa4c\uaa4d\uaa50-\uaa59\uaa7b\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uaaeb-\uaaef\uaaf5\uaaf6\uabe3-\uabea\uabec\uabed\uabf0-\uabf9\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\ufe33\ufe34\ufe4d-\ufe4f\uff10-\uff19\uff3f]*$/.test(str)
    }
    module.exports = isProperty
  provide("is-property", module.exports);
}(global));

// pakmanager:concat-stream
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var Writable = require('readable-stream').Writable
    var inherits = require('inherits')
    
    if (typeof Uint8Array === 'undefined') {
      var U8 = require('typedarray').Uint8Array
    } else {
      var U8 = Uint8Array
    }
    
    function ConcatStream(opts, cb) {
      if (!(this instanceof ConcatStream)) return new ConcatStream(opts, cb)
    
      if (typeof opts === 'function') {
        cb = opts
        opts = {}
      }
      if (!opts) opts = {}
    
      var encoding = opts.encoding
      var shouldInferEncoding = false
    
      if (!encoding) {
        shouldInferEncoding = true
      } else {
        encoding =  String(encoding).toLowerCase()
        if (encoding === 'u8' || encoding === 'uint8') {
          encoding = 'uint8array'
        }
      }
    
      Writable.call(this, { objectMode: true })
    
      this.encoding = encoding
      this.shouldInferEncoding = shouldInferEncoding
    
      if (cb) this.on('finish', function () { cb(this.getBody()) })
      this.body = []
    }
    
    module.exports = ConcatStream
    inherits(ConcatStream, Writable)
    
    ConcatStream.prototype._write = function(chunk, enc, next) {
      this.body.push(chunk)
      next()
    }
    
    ConcatStream.prototype.inferEncoding = function (buff) {
      var firstBuffer = buff === undefined ? this.body[0] : buff;
      if (Buffer.isBuffer(firstBuffer)) return 'buffer'
      if (typeof Uint8Array !== 'undefined' && firstBuffer instanceof Uint8Array) return 'uint8array'
      if (Array.isArray(firstBuffer)) return 'array'
      if (typeof firstBuffer === 'string') return 'string'
      if (Object.prototype.toString.call(firstBuffer) === "[object Object]") return 'object'
      return 'buffer'
    }
    
    ConcatStream.prototype.getBody = function () {
      if (!this.encoding && this.body.length === 0) return []
      if (this.shouldInferEncoding) this.encoding = this.inferEncoding()
      if (this.encoding === 'array') return arrayConcat(this.body)
      if (this.encoding === 'string') return stringConcat(this.body)
      if (this.encoding === 'buffer') return bufferConcat(this.body)
      if (this.encoding === 'uint8array') return u8Concat(this.body)
      return this.body
    }
    
    var isArray = Array.isArray || function (arr) {
      return Object.prototype.toString.call(arr) == '[object Array]'
    }
    
    function isArrayish (arr) {
      return /Array\]$/.test(Object.prototype.toString.call(arr))
    }
    
    function stringConcat (parts) {
      var strings = []
      var needsToString = false
      for (var i = 0; i < parts.length; i++) {
        var p = parts[i]
        if (typeof p === 'string') {
          strings.push(p)
        } else if (Buffer.isBuffer(p)) {
          strings.push(p)
        } else {
          strings.push(Buffer(p))
        }
      }
      if (Buffer.isBuffer(parts[0])) {
        strings = Buffer.concat(strings)
        strings = strings.toString('utf8')
      } else {
        strings = strings.join('')
      }
      return strings
    }
    
    function bufferConcat (parts) {
      var bufs = []
      for (var i = 0; i < parts.length; i++) {
        var p = parts[i]
        if (Buffer.isBuffer(p)) {
          bufs.push(p)
        } else if (typeof p === 'string' || isArrayish(p)
        || (p && typeof p.subarray === 'function')) {
          bufs.push(Buffer(p))
        } else bufs.push(Buffer(String(p)))
      }
      return Buffer.concat(bufs)
    }
    
    function arrayConcat (parts) {
      var res = []
      for (var i = 0; i < parts.length; i++) {
        res.push.apply(res, parts[i])
      }
      return res
    }
    
    function u8Concat (parts) {
      var len = 0
      for (var i = 0; i < parts.length; i++) {
        if (typeof parts[i] === 'string') {
          parts[i] = Buffer(parts[i])
        }
        len += parts[i].length
      }
      var u8 = new U8(len)
      for (var i = 0, offset = 0; i < parts.length; i++) {
        var part = parts[i]
        for (var j = 0; j < part.length; j++) {
          u8[offset++] = part[j]
        }
      }
      return u8
    }
    
  provide("concat-stream", module.exports);
}(global));

// pakmanager:meow
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    var path = require('path');
    var minimist = require('minimist');
    var indentString = require('indent-string');
    var objectAssign = require('object-assign');
    var camelcaseKeys = require('camelcase-keys');
    
    // needed to get the uncached parent
    delete require.cache[__filename];
    var parentDir = path.dirname(module.parent.filename);
    
    module.exports = function (opts, minimistOpts) {
    	opts = objectAssign({
    		pkg: './package.json',
    		argv: process.argv.slice(2)
    	}, opts);
    
    	if (Array.isArray(opts.help)) {
    		opts.help = opts.help.join('\n');
    	}
    
    	var pkg = typeof opts.pkg === 'string' ? require(path.join(parentDir, opts.pkg)) : opts.pkg;
    	var argv = minimist(opts.argv, minimistOpts);
    	var help = '\n' + indentString(pkg.description + (opts.help ? '\n\n' + opts.help : '\n'), '  ');
    	var showHelp = function () {
    		console.log(help);
    		process.exit();
    	};
    
    	if (argv.version && opts.version !== false) {
    		console.log(typeof opts.version === 'string' ? opts.version : pkg.version);
    		process.exit();
    	}
    
    	if (argv.help && opts.help !== false) {
    		showHelp();
    	}
    
    	var _ = argv._;
    	delete argv._;
    
    	return {
    		input: _,
    		flags: camelcaseKeys(argv),
    		pkg: pkg,
    		help: help,
    		showHelp: showHelp
    	};
    };
    
  provide("meow", module.exports);
}(global));

// pakmanager:asn1.js/lib/asn1/encoders/der
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var inherits = require('inherits');
    var Buffer = require('buffer').Buffer;
    
    var asn1 =  require('asn1.js/lib/asn1');
    var base = asn1.base;
    var bignum = asn1.bignum;
    
    // Import DER constants
    var der = asn1.constants.der;
    
    function DEREncoder(entity) {
      this.enc = 'der';
      this.name = entity.name;
      this.entity = entity;
    
      // Construct base tree
      this.tree = new DERNode();
      this.tree._init(entity.body);
    };
    module.exports = DEREncoder;
    
    DEREncoder.prototype.encode = function encode(data, reporter) {
      return this.tree._encode(data, reporter).join();
    };
    
    // Tree methods
    
    function DERNode(parent) {
      base.Node.call(this, 'der', parent);
    }
    inherits(DERNode, base.Node);
    
    DERNode.prototype._encodeComposite = function encodeComposite(tag,
                                                                  primitive,
                                                                  cls,
                                                                  content) {
      var encodedTag = encodeTag(tag, primitive, cls, this.reporter);
    
      // Short form
      if (content.length < 0x80) {
        var header = new Buffer(2);
        header[0] = encodedTag;
        header[1] = content.length;
        return this._createEncoderBuffer([ header, content ]);
      }
    
      // Long form
      // Count octets required to store length
      var lenOctets = 1;
      for (var i = content.length; i >= 0x100; i >>= 8)
        lenOctets++;
    
      var header = new Buffer(1 + 1 + lenOctets);
      header[0] = encodedTag;
      header[1] = 0x80 | lenOctets;
    
      for (var i = 1 + lenOctets, j = content.length; j > 0; i--, j >>= 8)
        header[i] = j & 0xff;
    
      return this._createEncoderBuffer([ header, content ]);
    };
    
    DERNode.prototype._encodeStr = function encodeStr(str, tag) {
      if (tag === 'octstr')
        return this._createEncoderBuffer(str);
      else if (tag === 'bitstr')
        return this._createEncoderBuffer([ str.unused | 0, str.data ]);
      else if (tag === 'ia5str')
        return this._createEncoderBuffer(str);
      return this.reporter.error('Encoding of string type: ' + tag +
                                 ' unsupported');
    };
    
    DERNode.prototype._encodeObjid = function encodeObjid(id, values, relative) {
      if (typeof id === 'string') {
        if (!values)
          return this.reporter.error('string objid given, but no values map found');
        if (!values.hasOwnProperty(id))
          return this.reporter.error('objid not found in values map');
        id = values[id].split(/\s+/g);
        for (var i = 0; i < id.length; i++)
          id[i] |= 0;
      } else if (Array.isArray(id)) {
        id = id.slice();
      }
    
      if (!Array.isArray(id)) {
        return this.reporter.error('objid() should be either array or string, ' +
                                   'got: ' + JSON.stringify(id));
      }
    
      if (!relative) {
        if (id[1] >= 40)
          return this.reporter.error('Second objid identifier OOB');
        id.splice(0, 2, id[0] * 40 + id[1]);
      }
    
      // Count number of octets
      var size = 0;
      for (var i = 0; i < id.length; i++) {
        var ident = id[i];
        for (size++; ident >= 0x80; ident >>= 7)
          size++;
      }
    
      var objid = new Buffer(size);
      var offset = objid.length - 1;
      for (var i = id.length - 1; i >= 0; i--) {
        var ident = id[i];
        objid[offset--] = ident & 0x7f;
        while ((ident >>= 7) > 0)
          objid[offset--] = 0x80 | (ident & 0x7f);
      }
    
      return this._createEncoderBuffer(objid);
    };
    
    function two(num) {
      if (num < 10)
        return '0' + num;
      else
        return num;
    }
    
    DERNode.prototype._encodeTime = function encodeTime(time, tag) {
      var str;
      var date = new Date(time);
    
      if (tag === 'gentime') {
        str = [
          two(date.getFullYear()),
          two(date.getUTCMonth() + 1),
          two(date.getUTCDate()),
          two(date.getUTCHours()),
          two(date.getUTCMinutes()),
          two(date.getUTCSeconds()),
          'Z'
        ].join('');
      } else if (tag === 'utctime') {
        str = [
          two(date.getFullYear() % 100),
          two(date.getUTCMonth() + 1),
          two(date.getUTCDate()),
          two(date.getUTCHours()),
          two(date.getUTCMinutes()),
          two(date.getUTCSeconds()),
          'Z'
        ].join('');
      } else {
        this.reporter.error('Encoding ' + tag + ' time is not supported yet');
      }
    
      return this._encodeStr(str, 'octstr');
    };
    
    DERNode.prototype._encodeNull = function encodeNull() {
      return this._createEncoderBuffer('');
    };
    
    DERNode.prototype._encodeInt = function encodeInt(num, values) {
      if (typeof num === 'string') {
        if (!values)
          return this.reporter.error('String int or enum given, but no values map');
        if (!values.hasOwnProperty(num)) {
          return this.reporter.error('Values map doesn\'t contain: ' +
                                     JSON.stringify(num));
        }
        num = values[num];
      }
    
      // Bignum, assume big endian
      if (typeof num !== 'number' && !Buffer.isBuffer(num)) {
        var numArray = num.toArray();
        if (num.sign === false && numArray[0] & 0x80) {
          numArray.unshift(0);
        }
        num = new Buffer(numArray);
      }
    
      if (Buffer.isBuffer(num)) {
        var size = num.length;
        if (num.length === 0)
          size++;
    
        var out = new Buffer(size);
        num.copy(out);
        if (num.length === 0)
          out[0] = 0
        return this._createEncoderBuffer(out);
      }
    
      if (num < 0x80)
        return this._createEncoderBuffer(num);
    
      if (num < 0x100)
        return this._createEncoderBuffer([0, num]);
    
      var size = 1;
      for (var i = num; i >= 0x100; i >>= 8)
        size++;
    
      var out = new Array(size);
      for (var i = out.length - 1; i >= 0; i--) {
        out[i] = num & 0xff;
        num >>= 8;
      }
      if(out[0] & 0x80) {
        out.unshift(0);
      }
    
      return this._createEncoderBuffer(new Buffer(out));
    };
    
    DERNode.prototype._encodeBool = function encodeBool(value) {
      return this._createEncoderBuffer(value ? 0xff : 0);
    };
    
    DERNode.prototype._use = function use(entity, obj) {
      if (typeof entity === 'function')
        entity = entity(obj);
      return entity._getEncoder('der').tree;
    };
    
    DERNode.prototype._skipDefault = function skipDefault(dataBuffer, reporter, parent) {
      var state = this._baseState;
      var i;
      if (state['default'] === null)
        return false;
    
      var data = dataBuffer.join();
      if (state.defaultBuffer === undefined)
        state.defaultBuffer = this._encodeValue(state['default'], reporter, parent).join();
    
      if (data.length !== state.defaultBuffer.length)
        return false;
    
      for (i=0; i < data.length; i++)
        if (data[i] !== state.defaultBuffer[i])
          return false;
    
      return true;
    };
    
    // Utility methods
    
    function encodeTag(tag, primitive, cls, reporter) {
      var res;
    
      if (tag === 'seqof')
        tag = 'seq';
      else if (tag === 'setof')
        tag = 'set';
    
      if (der.tagByName.hasOwnProperty(tag))
        res = der.tagByName[tag];
      else if (typeof tag === 'number' && (tag | 0) === tag)
        res = tag;
      else
        return reporter.error('Unknown tag: ' + tag);
    
      if (res >= 0x1f)
        return reporter.error('Multi-octet tag encoding unsupported');
    
      if (!primitive)
        res |= 0x20;
    
      res |= (der.tagClassByName[cls || 'universal'] << 6);
    
      return res;
    }
    
  provide("asn1.js/lib/asn1/encoders/der", module.exports);
}(global));

// pakmanager:asn1.js/lib/asn1/decoders/der
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var inherits = require('inherits');
    
    var asn1 =  require('asn1.js/lib/asn1');
    var base = asn1.base;
    var bignum = asn1.bignum;
    
    // Import DER constants
    var der = asn1.constants.der;
    
    function DERDecoder(entity) {
      this.enc = 'der';
      this.name = entity.name;
      this.entity = entity;
    
      // Construct base tree
      this.tree = new DERNode();
      this.tree._init(entity.body);
    };
    module.exports = DERDecoder;
    
    DERDecoder.prototype.decode = function decode(data, options) {
      if (!(data instanceof base.DecoderBuffer))
        data = new base.DecoderBuffer(data, options);
    
      return this.tree._decode(data, options);
    };
    
    // Tree methods
    
    function DERNode(parent) {
      base.Node.call(this, 'der', parent);
    }
    inherits(DERNode, base.Node);
    
    DERNode.prototype._peekTag = function peekTag(buffer, tag, any) {
      if (buffer.isEmpty())
        return false;
    
      var state = buffer.save();
      var decodedTag = derDecodeTag(buffer, 'Failed to peek tag: "' + tag + '"');
      if (buffer.isError(decodedTag))
        return decodedTag;
    
      buffer.restore(state);
    
      return decodedTag.tag === tag || decodedTag.tagStr === tag || any;
    };
    
    DERNode.prototype._decodeTag = function decodeTag(buffer, tag, any) {
      var decodedTag = derDecodeTag(buffer,
                                    'Failed to decode tag of "' + tag + '"');
      if (buffer.isError(decodedTag))
        return decodedTag;
    
      var len = derDecodeLen(buffer,
                             decodedTag.primitive,
                             'Failed to get length of "' + tag + '"');
    
      // Failure
      if (buffer.isError(len))
        return len;
    
      if (!any &&
          decodedTag.tag !== tag &&
          decodedTag.tagStr !== tag &&
          decodedTag.tagStr + 'of' !== tag) {
        return buffer.error('Failed to match tag: "' + tag + '"');
      }
    
      if (decodedTag.primitive || len !== null)
        return buffer.skip(len, 'Failed to match body of: "' + tag + '"');
    
      // Indefinite length... find END tag
      var state = buffer.start();
      var res = this._skipUntilEnd(
          buffer,
          'Failed to skip indefinite length body: "' + this.tag + '"');
      if (buffer.isError(res))
        return res;
    
      return buffer.cut(state);
    };
    
    DERNode.prototype._skipUntilEnd = function skipUntilEnd(buffer, fail) {
      while (true) {
        var tag = derDecodeTag(buffer, fail);
        if (buffer.isError(tag))
          return tag;
        var len = derDecodeLen(buffer, tag.primitive, fail);
        if (buffer.isError(len))
          return len;
    
        var res;
        if (tag.primitive || len !== null)
          res = buffer.skip(len)
        else
          res = this._skipUntilEnd(buffer, fail);
    
        // Failure
        if (buffer.isError(res))
          return res;
    
        if (tag.tagStr === 'end')
          break;
      }
    };
    
    DERNode.prototype._decodeList = function decodeList(buffer, tag, decoder) {
      var result = [];
      while (!buffer.isEmpty()) {
        var possibleEnd = this._peekTag(buffer, 'end');
        if (buffer.isError(possibleEnd))
          return possibleEnd;
    
        var res = decoder.decode(buffer, 'der');
        if (buffer.isError(res) && possibleEnd)
          break;
        result.push(res);
      }
      return result;
    };
    
    DERNode.prototype._decodeStr = function decodeStr(buffer, tag) {
      if (tag === 'octstr') {
        return buffer.raw();
      } else if (tag === 'bitstr') {
        var unused = buffer.readUInt8();
        if (buffer.isError(unused))
          return unused;
    
        return { unused: unused, data: buffer.raw() };
      } else if (tag === 'ia5str') {
        return buffer.raw().toString();
      } else {
        return this.error('Decoding of string type: ' + tag + ' unsupported');
      }
    };
    
    DERNode.prototype._decodeObjid = function decodeObjid(buffer, values, relative) {
      var identifiers = [];
      var ident = 0;
      while (!buffer.isEmpty()) {
        var subident = buffer.readUInt8();
        ident <<= 7;
        ident |= subident & 0x7f;
        if ((subident & 0x80) === 0) {
          identifiers.push(ident);
          ident = 0;
        }
      }
      if (subident & 0x80)
        identifiers.push(ident);
    
      var first = (identifiers[0] / 40) | 0;
      var second = identifiers[0] % 40;
    
      if (relative)
        result = identifiers;
      else
        result = [first, second].concat(identifiers.slice(1));
    
      if (values)
        result = values[result.join(' ')];
    
      return result;
    };
    
    DERNode.prototype._decodeTime = function decodeTime(buffer, tag) {
      var str = buffer.raw().toString();
      if (tag === 'gentime') {
        var year = str.slice(0, 4) | 0;
        var mon = str.slice(4, 6) | 0;
        var day = str.slice(6, 8) | 0;
        var hour = str.slice(8, 10) | 0;
        var min = str.slice(10, 12) | 0;
        var sec = str.slice(12, 14) | 0;
      } else if (tag === 'utctime') {
        var year = str.slice(0, 2) | 0;
        var mon = str.slice(2, 4) | 0;
        var day = str.slice(4, 6) | 0;
        var hour = str.slice(6, 8) | 0;
        var min = str.slice(8, 10) | 0;
        var sec = str.slice(10, 12) | 0;
        if (year < 70)
          year = 2000 + year;
        else
          year = 1900 + year;
      } else {
        return this.error('Decoding ' + tag + ' time is not supported yet');
      }
    
      return Date.UTC(year, mon - 1, day, hour, min, sec, 0);
    };
    
    DERNode.prototype._decodeNull = function decodeNull(buffer) {
      return null;
    };
    
    DERNode.prototype._decodeBool = function decodeBool(buffer) {
      var res = buffer.readUInt8();
      if (buffer.isError(res))
        return res;
      else
        return res !== 0;
    };
    
    DERNode.prototype._decodeInt = function decodeInt(buffer, values) {
      // Bigint, return as it is (assume big endian)
      var raw = buffer.raw();
      var res = new bignum(raw);
    
      if (values)
        res = values[res.toString(10)] || res;
    
      return res;
    };
    
    DERNode.prototype._use = function use(entity, obj) {
      if (typeof entity === 'function')
        entity = entity(obj);
      return entity._getDecoder('der').tree;
    };
    
    // Utility methods
    
    function derDecodeTag(buf, fail) {
      var tag = buf.readUInt8(fail);
      if (buf.isError(tag))
        return tag;
    
      var cls = der.tagClass[tag >> 6];
      var primitive = (tag & 0x20) === 0;
    
      // Multi-octet tag - load
      if ((tag & 0x1f) === 0x1f) {
        var oct = tag;
        tag = 0;
        while ((oct & 0x80) === 0x80) {
          oct = buf.readUInt8(fail);
          if (buf.isError(oct))
            return oct;
    
          tag <<= 7;
          tag |= oct & 0x7f;
        }
      } else {
        tag &= 0x1f;
      }
      var tagStr = der.tag[tag];
    
      return {
        cls: cls,
        primitive: primitive,
        tag: tag,
        tagStr: tagStr
      };
    }
    
    function derDecodeLen(buf, primitive, fail) {
      var len = buf.readUInt8(fail);
      if (buf.isError(len))
        return len;
    
      // Indefinite form
      if (!primitive && len === 0x80)
        return null;
    
      // Definite form
      if ((len & 0x80) === 0) {
        // Short form
        return len;
      }
    
      // Long form
      var num = len & 0x7f;
      if (num >= 4)
        return buf.error('length octect is too long');
    
      len = 0;
      for (var i = 0; i < num; i++) {
        len <<= 8;
        var j = buf.readUInt8(fail);
        if (buf.isError(j))
          return j;
        len |= j;
      }
    
      return len;
    }
    
  provide("asn1.js/lib/asn1/decoders/der", module.exports);
}(global));

// pakmanager:asn1.js/lib/asn1/base/reporter
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var inherits = require('inherits');
    
    function Reporter(options) {
      this._reporterState = {
        obj: null,
        path: [],
        options: options || {},
        errors: []
      };
    }
    exports.Reporter = Reporter;
    
    Reporter.prototype.isError = function isError(obj) {
      return obj instanceof ReporterError;
    };
    
    Reporter.prototype.save = function save() {
      var state = this._reporterState;
    
      return { obj: state.obj, pathLen: state.path.length };
    };
    
    Reporter.prototype.restore = function restore(data) {
      var state = this._reporterState;
    
      state.obj = data.obj;
      state.path = state.path.slice(0, data.pathLen);
    };
    
    Reporter.prototype.enterKey = function enterKey(key) {
      return this._reporterState.path.push(key);
    };
    
    Reporter.prototype.leaveKey = function leaveKey(index, key, value) {
      var state = this._reporterState;
    
      state.path = state.path.slice(0, index - 1);
      if (state.obj !== null)
        state.obj[key] = value;
    };
    
    Reporter.prototype.enterObject = function enterObject() {
      var state = this._reporterState;
    
      var prev = state.obj;
      state.obj = {};
      return prev;
    };
    
    Reporter.prototype.leaveObject = function leaveObject(prev) {
      var state = this._reporterState;
    
      var now = state.obj;
      state.obj = prev;
      return now;
    };
    
    Reporter.prototype.error = function error(msg) {
      var err;
      var state = this._reporterState;
    
      var inherited = msg instanceof ReporterError;
      if (inherited) {
        err = msg;
      } else {
        err = new ReporterError(state.path.map(function(elem) {
          return '[' + JSON.stringify(elem) + ']';
        }).join(''), msg.message || msg, msg.stack);
      }
    
      if (!state.options.partial)
        throw err;
    
      if (!inherited)
        state.errors.push(err);
    
      return err;
    };
    
    Reporter.prototype.wrapResult = function wrapResult(result) {
      var state = this._reporterState;
      if (!state.options.partial)
        return result;
    
      return {
        result: this.isError(result) ? null : result,
        errors: state.errors
      };
    };
    
    function ReporterError(path, msg) {
      this.path = path;
      this.rethrow(msg);
    };
    inherits(ReporterError, Error);
    
    ReporterError.prototype.rethrow = function rethrow(msg) {
      this.message = msg + ' at: ' + (this.path || '(shallow)');
      Error.captureStackTrace(this, ReporterError);
    
      return this;
    };
    
  provide("asn1.js/lib/asn1/base/reporter", module.exports);
}(global));

// pakmanager:asn1.js/lib/asn1/base/buffer
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var inherits = require('inherits');
    var Reporter =  require('asn1.js/lib/asn1/base').Reporter;
    var Buffer = require('buffer').Buffer;
    
    function DecoderBuffer(base, options) {
      Reporter.call(this, options);
      if (!Buffer.isBuffer(base)) {
        this.error('Input not Buffer');
        return;
      }
    
      this.base = base;
      this.offset = 0;
      this.length = base.length;
    }
    inherits(DecoderBuffer, Reporter);
    exports.DecoderBuffer = DecoderBuffer;
    
    DecoderBuffer.prototype.save = function save() {
      return { offset: this.offset, reporter: Reporter.prototype.save.call(this) };
    };
    
    DecoderBuffer.prototype.restore = function restore(save) {
      // Return skipped data
      var res = new DecoderBuffer(this.base);
      res.offset = save.offset;
      res.length = this.offset;
    
      this.offset = save.offset;
      Reporter.prototype.restore.call(this, save.reporter);
    
      return res;
    };
    
    DecoderBuffer.prototype.isEmpty = function isEmpty() {
      return this.offset === this.length;
    };
    
    DecoderBuffer.prototype.readUInt8 = function readUInt8(fail) {
      if (this.offset + 1 <= this.length)
        return this.base.readUInt8(this.offset++, true);
      else
        return this.error(fail || 'DecoderBuffer overrun');
    }
    
    DecoderBuffer.prototype.skip = function skip(bytes, fail) {
      if (!(this.offset + bytes <= this.length))
        return this.error(fail || 'DecoderBuffer overrun');
    
      var res = new DecoderBuffer(this.base);
    
      // Share reporter state
      res._reporterState = this._reporterState;
    
      res.offset = this.offset;
      res.length = this.offset + bytes;
      this.offset += bytes;
      return res;
    }
    
    DecoderBuffer.prototype.raw = function raw(save) {
      return this.base.slice(save ? save.offset : this.offset, this.length);
    }
    
    function EncoderBuffer(value, reporter) {
      if (Array.isArray(value)) {
        this.length = 0;
        this.value = value.map(function(item) {
          if (!(item instanceof EncoderBuffer))
            item = new EncoderBuffer(item, reporter);
          this.length += item.length;
          return item;
        }, this);
      } else if (typeof value === 'number') {
        if (!(0 <= value && value <= 0xff))
          return reporter.error('non-byte EncoderBuffer value');
        this.value = value;
        this.length = 1;
      } else if (typeof value === 'string') {
        this.value = value;
        this.length = Buffer.byteLength(value);
      } else if (Buffer.isBuffer(value)) {
        this.value = value;
        this.length = value.length;
      } else {
        return reporter.error('Unsupported type: ' + typeof value);
      }
    }
    exports.EncoderBuffer = EncoderBuffer;
    
    EncoderBuffer.prototype.join = function join(out, offset) {
      if (!out)
        out = new Buffer(this.length);
      if (!offset)
        offset = 0;
    
      if (this.length === 0)
        return out;
    
      if (Array.isArray(this.value)) {
        this.value.forEach(function(item) {
          item.join(out, offset);
          offset += item.length;
        });
      } else {
        if (typeof this.value === 'number')
          out[offset] = this.value;
        else if (typeof this.value === 'string')
          out.write(this.value, offset);
        else if (Buffer.isBuffer(this.value))
          this.value.copy(out, offset);
        offset += this.length;
      }
    
      return out;
    };
    
  provide("asn1.js/lib/asn1/base/buffer", module.exports);
}(global));

// pakmanager:asn1.js/lib/asn1/base/node
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var Reporter =  require('asn1.js/lib/asn1/base').Reporter;
    var EncoderBuffer =  require('asn1.js/lib/asn1/base').EncoderBuffer;
    var assert = require('minimalistic-assert');
    
    // Supported tags
    var tags = [
      'seq', 'seqof', 'set', 'setof', 'octstr', 'bitstr', 'objid', 'bool',
      'gentime', 'utctime', 'null_', 'enum', 'int', 'ia5str'
    ];
    
    // Public methods list
    var methods = [
      'key', 'obj', 'use', 'optional', 'explicit', 'implicit', 'def', 'choice',
      'any'
    ].concat(tags);
    
    // Overrided methods list
    var overrided = [
      '_peekTag', '_decodeTag', '_use',
      '_decodeStr', '_decodeObjid', '_decodeTime',
      '_decodeNull', '_decodeInt', '_decodeBool', '_decodeList',
    
      '_encodeComposite', '_encodeStr', '_encodeObjid', '_encodeTime',
      '_encodeNull', '_encodeInt', '_encodeBool'
    ];
    
    function Node(enc, parent) {
      var state = {};
      this._baseState = state;
    
      state.enc = enc;
    
      state.parent = parent || null;
      state.children = null;
    
      // State
      state.tag = null;
      state.args = null;
      state.reverseArgs = null;
      state.choice = null;
      state.optional = false;
      state.any = false;
      state.obj = false;
      state.use = null;
      state.useDecoder = null;
      state.key = null;
      state['default'] = null;
      state.explicit = null;
      state.implicit = null;
    
      // Should create new instance on each method
      if (!state.parent) {
        state.children = [];
        this._wrap();
      }
    }
    module.exports = Node;
    
    var stateProps = [
      'enc', 'parent', 'children', 'tag', 'args', 'reverseArgs', 'choice',
      'optional', 'any', 'obj', 'use', 'alteredUse', 'key', 'default', 'explicit',
      'implicit'
    ];
    
    Node.prototype.clone = function clone() {
      var state = this._baseState;
      var cstate = {};
      stateProps.forEach(function(prop) {
        cstate[prop] = state[prop];
      });
      var res = new this.constructor(cstate.parent);
      res._baseState = cstate;
      return res;
    };
    
    Node.prototype._wrap = function wrap() {
      var state = this._baseState;
      methods.forEach(function(method) {
        this[method] = function _wrappedMethod() {
          var clone = new this.constructor(this);
          state.children.push(clone);
          return clone[method].apply(clone, arguments);
        };
      }, this);
    };
    
    Node.prototype._init = function init(body) {
      var state = this._baseState;
    
      assert(state.parent === null);
      body.call(this);
    
      // Filter children
      state.children = state.children.filter(function(child) {
        return child._baseState.parent === this;
      }, this);
      assert.equal(state.children.length, 1, 'Root node can have only one child');
    };
    
    Node.prototype._useArgs = function useArgs(args) {
      var state = this._baseState;
    
      // Filter children and args
      var children = args.filter(function(arg) {
        return arg instanceof this.constructor;
      }, this);
      args = args.filter(function(arg) {
        return !(arg instanceof this.constructor);
      }, this);
    
      if (children.length !== 0) {
        assert(state.children === null);
        state.children = children;
    
        // Replace parent to maintain backward link
        children.forEach(function(child) {
          child._baseState.parent = this;
        }, this);
      }
      if (args.length !== 0) {
        assert(state.args === null);
        state.args = args;
        state.reverseArgs = args.map(function(arg) {
          if (typeof arg !== 'object' || arg.constructor !== Object)
            return arg;
    
          var res = {};
          Object.keys(arg).forEach(function(key) {
            if (key == (key | 0))
              key |= 0;
            var value = arg[key];
            res[value] = key;
          });
          return res;
        });
      }
    };
    
    //
    // Overrided methods
    //
    
    overrided.forEach(function(method) {
      Node.prototype[method] = function _overrided() {
        var state = this._baseState;
        throw new Error(method + ' not implemented for encoding: ' + state.enc);
      };
    });
    
    //
    // Public methods
    //
    
    tags.forEach(function(tag) {
      Node.prototype[tag] = function _tagMethod() {
        var state = this._baseState;
        var args = Array.prototype.slice.call(arguments);
    
        assert(state.tag === null);
        state.tag = tag;
    
        this._useArgs(args);
    
        return this;
      };
    });
    
    Node.prototype.use = function use(item) {
      var state = this._baseState;
    
      assert(state.use === null);
      state.use = item;
    
      return this;
    };
    
    Node.prototype.optional = function optional() {
      var state = this._baseState;
    
      state.optional = true;
    
      return this;
    };
    
    Node.prototype.def = function def(val) {
      var state = this._baseState;
    
      assert(state['default'] === null);
      state['default'] = val;
      state.optional = true;
    
      return this;
    };
    
    Node.prototype.explicit = function explicit(num) {
      var state = this._baseState;
    
      assert(state.explicit === null && state.implicit === null);
      state.explicit = num;
    
      return this;
    };
    
    Node.prototype.implicit = function implicit(num) {
      var state = this._baseState;
    
      assert(state.explicit === null && state.implicit === null);
      state.implicit = num;
    
      return this;
    };
    
    Node.prototype.obj = function obj() {
      var state = this._baseState;
      var args = Array.prototype.slice.call(arguments);
    
      state.obj = true;
    
      if (args.length !== 0)
        this._useArgs(args);
    
      return this;
    };
    
    Node.prototype.key = function key(newKey) {
      var state = this._baseState;
    
      assert(state.key === null);
      state.key = newKey;
    
      return this;
    };
    
    Node.prototype.any = function any() {
      var state = this._baseState;
    
      state.any = true;
    
      return this;
    };
    
    Node.prototype.choice = function choice(obj) {
      var state = this._baseState;
    
      assert(state.choice === null);
      state.choice = obj;
      this._useArgs(Object.keys(obj).map(function(key) {
        return obj[key];
      }));
    
      return this;
    };
    
    //
    // Decoding
    //
    
    Node.prototype._decode = function decode(input) {
      var state = this._baseState;
    
      // Decode root node
      if (state.parent === null)
        return input.wrapResult(state.children[0]._decode(input));
    
      var result = state['default'];
      var present = true;
    
      var prevKey;
      if (state.key !== null)
        prevKey = input.enterKey(state.key);
    
      // Check if tag is there
      if (state.optional) {
        var tag = null;
        if (state.explicit !== null)
          tag = state.explicit;
        else if (state.implicit !== null)
          tag = state.implicit;
        else if (state.tag !== null)
          tag = state.tag;
    
        if (tag === null && !state.any) {
          // Trial and Error
          var save = input.save();
          try {
            if (state.choice === null)
              this._decodeGeneric(state.tag, input);
            else
              this._decodeChoice(input);
            present = true;
          } catch (e) {
            present = false;
          }
          input.restore(save);
        } else {
          present = this._peekTag(input, tag, state.any);
    
          if (input.isError(present))
            return present;
        }
      }
    
      // Push object on stack
      var prevObj;
      if (state.obj && present)
        prevObj = input.enterObject();
    
      if (present) {
        // Unwrap explicit values
        if (state.explicit !== null) {
          var explicit = this._decodeTag(input, state.explicit);
          if (input.isError(explicit))
            return explicit;
          input = explicit;
        }
    
        // Unwrap implicit and normal values
        if (state.use === null && state.choice === null) {
          if (state.any)
            var save = input.save();
          var body = this._decodeTag(
            input,
            state.implicit !== null ? state.implicit : state.tag,
            state.any
          );
          if (input.isError(body))
            return body;
    
          if (state.any)
            result = input.raw(save);
          else
            input = body;
        }
    
        // Select proper method for tag
        if (state.any)
          result = result;
        else if (state.choice === null)
          result = this._decodeGeneric(state.tag, input);
        else
          result = this._decodeChoice(input);
    
        if (input.isError(result))
          return result;
    
        // Decode children
        if (!state.any && state.choice === null && state.children !== null) {
          var fail = state.children.some(function decodeChildren(child) {
            // NOTE: We are ignoring errors here, to let parser continue with other
            // parts of encoded data
            child._decode(input);
          });
          if (fail)
            return err;
        }
      }
    
      // Pop object
      if (state.obj && present)
        result = input.leaveObject(prevObj);
    
      // Set key
      if (state.key !== null && (result !== null || present === true))
        input.leaveKey(prevKey, state.key, result);
    
      return result;
    };
    
    Node.prototype._decodeGeneric = function decodeGeneric(tag, input) {
      var state = this._baseState;
    
      if (tag === 'seq' || tag === 'set')
        return null;
      if (tag === 'seqof' || tag === 'setof')
        return this._decodeList(input, tag, state.args[0]);
      else if (tag === 'octstr' || tag === 'bitstr' || tag === 'ia5str')
        return this._decodeStr(input, tag);
      else if (tag === 'objid' && state.args)
        return this._decodeObjid(input, state.args[0], state.args[1]);
      else if (tag === 'objid')
        return this._decodeObjid(input, null, null);
      else if (tag === 'gentime' || tag === 'utctime')
        return this._decodeTime(input, tag);
      else if (tag === 'null_')
        return this._decodeNull(input);
      else if (tag === 'bool')
        return this._decodeBool(input);
      else if (tag === 'int' || tag === 'enum')
        return this._decodeInt(input, state.args && state.args[0]);
      else if (state.use !== null)
        return this._getUse(state.use, input._reporterState.obj)._decode(input);
      else
        return input.error('unknown tag: ' + tag);
    
      return null;
    };
    
    Node.prototype._getUse = function _getUse(entity, obj) {
    
      var state = this._baseState;
      // Create altered use decoder if implicit is set
      state.useDecoder = this._use(entity, obj);
      assert(state.useDecoder._baseState.parent === null);
      state.useDecoder = state.useDecoder._baseState.children[0];
      if (state.implicit !== state.useDecoder._baseState.implicit) {
        state.useDecoder = state.useDecoder.clone();
        state.useDecoder._baseState.implicit = state.implicit;
      }
      return state.useDecoder;
    };
    
    Node.prototype._decodeChoice = function decodeChoice(input) {
      var state = this._baseState;
      var result = null;
      var match = false;
    
      Object.keys(state.choice).some(function(key) {
        var save = input.save();
        var node = state.choice[key];
        try {
          var value = node._decode(input);
          if (input.isError(value))
            return false;
    
          result = { type: key, value: value };
          match = true;
        } catch (e) {
          input.restore(save);
          return false;
        }
        return true;
      }, this);
    
      if (!match)
        return input.error('Choice not matched');
    
      return result;
    };
    
    //
    // Encoding
    //
    
    Node.prototype._createEncoderBuffer = function createEncoderBuffer(data) {
      return new EncoderBuffer(data, this.reporter);
    };
    
    Node.prototype._encode = function encode(data, reporter, parent) {
      var state = this._baseState;
      if (state['default'] !== null && state['default'] === data)
        return;
    
      var result = this._encodeValue(data, reporter, parent);
      if (result === undefined)
        return;
    
      if (this._skipDefault(result, reporter, parent))
        return;
    
      return result;
    };
    
    Node.prototype._encodeValue = function encode(data, reporter, parent) {
      var state = this._baseState;
    
      // Decode root node
      if (state.parent === null)
        return state.children[0]._encode(data, reporter || new Reporter());
    
      var result = null;
      var present = true;
    
      // Set reporter to share it with a child class
      this.reporter = reporter;
    
      // Check if data is there
      if (state.optional && data === undefined) {
        if (state['default'] !== null)
          data = state['default']
        else
          return;
      }
    
      // For error reporting
      var prevKey;
    
      // Encode children first
      var content = null;
      var primitive = false;
      if (state.any) {
        // Anything that was given is translated to buffer
        result = this._createEncoderBuffer(data);
      } else if (state.choice) {
        result = this._encodeChoice(data, reporter);
      } else if (state.children) {
        content = state.children.map(function(child) {
          if (child._baseState.tag === 'null_')
            return child._encode(null, reporter, data);
    
          if (child._baseState.key === null)
            return reporter.error('Child should have a key');
          var prevKey = reporter.enterKey(child._baseState.key);
    
          if (typeof data !== 'object')
            return reporter.error('Child expected, but input is not object');
    
          var res = child._encode(data[child._baseState.key], reporter, data);
          reporter.leaveKey(prevKey);
    
          return res;
        }, this).filter(function(child) {
          return child;
        });
    
        content = this._createEncoderBuffer(content);
      } else {
        if (state.tag === 'seqof' || state.tag === 'setof') {
          // TODO(indutny): this should be thrown on DSL level
          if (!(state.args && state.args.length === 1))
            return reporter.error('Too many args for : ' + state.tag);
    
          if (!Array.isArray(data))
            return reporter.error('seqof/setof, but data is not Array');
    
          var child = this.clone();
          child._baseState.implicit = null;
          content = this._createEncoderBuffer(data.map(function(item) {
            var state = this._baseState;
    
            return this._getUse(state.args[0], data)._encode(item, reporter);
          }, child));
        } else if (state.use !== null) {
          result = this._getUse(state.use, parent)._encode(data, reporter);
        } else {
          content = this._encodePrimitive(state.tag, data);
          primitive = true;
        }
      }
    
      // Encode data itself
      var result;
      if (!state.any && state.choice === null) {
        var tag = state.implicit !== null ? state.implicit : state.tag;
        var cls = state.implicit === null ? 'universal' : 'context';
    
        if (tag === null) {
          if (state.use === null)
            reporter.error('Tag could be ommited only for .use()');
        } else {
          if (state.use === null)
            result = this._encodeComposite(tag, primitive, cls, content);
        }
      }
    
      // Wrap in explicit
      if (state.explicit !== null)
        result = this._encodeComposite(state.explicit, false, 'context', result);
    
      return result;
    };
    
    Node.prototype._encodeChoice = function encodeChoice(data, reporter) {
      var state = this._baseState;
    
      var node = state.choice[data.type];
      if (!node) {
        assert(
            false,
            data.type + ' not found in ' +
                JSON.stringify(Object.keys(state.choice)));
      }
      return node._encode(data.value, reporter);
    };
    
    Node.prototype._encodePrimitive = function encodePrimitive(tag, data) {
      var state = this._baseState;
    
      if (tag === 'octstr' || tag === 'bitstr' || tag === 'ia5str')
        return this._encodeStr(data, tag);
      else if (tag === 'objid' && state.args)
        return this._encodeObjid(data, state.reverseArgs[0], state.args[1]);
      else if (tag === 'objid')
        return this._encodeObjid(data, null, null);
      else if (tag === 'gentime' || tag === 'utctime')
        return this._encodeTime(data, tag);
      else if (tag === 'null_')
        return this._encodeNull();
      else if (tag === 'int' || tag === 'enum')
        return this._encodeInt(data, state.args && state.reverseArgs[0]);
      else if (tag === 'bool')
        return this._encodeBool(data);
      else
        throw new Error('Unsupported tag: ' + tag);
    };
    
  provide("asn1.js/lib/asn1/base/node", module.exports);
}(global));

// pakmanager:asn1.js/lib/asn1/constants/der
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var constants =  require('asn1.js/lib/asn1/constants');
    
    exports.tagClass = {
      0: 'universal',
      1: 'application',
      2: 'context',
      3: 'private'
    };
    exports.tagClassByName = constants._reverse(exports.tagClass);
    
    exports.tag = {
      0x00: 'end',
      0x01: 'bool',
      0x02: 'int',
      0x03: 'bitstr',
      0x04: 'octstr',
      0x05: 'null_',
      0x06: 'objid',
      0x07: 'objDesc',
      0x08: 'external',
      0x09: 'real',
      0x0a: 'enum',
      0x0b: 'embed',
      0x0c: 'utf8str',
      0x0d: 'relativeOid',
      0x10: 'seq',
      0x11: 'set',
      0x12: 'numstr',
      0x13: 'printstr',
      0x14: 't61str',
      0x15: 'videostr',
      0x16: 'ia5str',
      0x17: 'utctime',
      0x18: 'gentime',
      0x19: 'graphstr',
      0x1a: 'iso646str',
      0x1b: 'genstr',
      0x1c: 'unistr',
      0x1d: 'charstr',
      0x1e: 'bmpstr'
    };
    exports.tagByName = constants._reverse(exports.tag);
    
  provide("asn1.js/lib/asn1/constants/der", module.exports);
}(global));

// pakmanager:asn1.js/lib/asn1/encoders/pem
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var inherits = require('inherits');
    var Buffer = require('buffer').Buffer;
    
    var asn1 =  require('asn1.js/lib/asn1');
    var DEREncoder =  require('asn1.js/lib/asn1/encoders/der');
    
    function PEMEncoder(entity) {
      DEREncoder.call(this, entity);
      this.enc = 'pem';
    };
    inherits(PEMEncoder, DEREncoder);
    module.exports = PEMEncoder;
    
    PEMEncoder.prototype.encode = function encode(data, options) {
      var buf = DEREncoder.prototype.encode.call(this, data);
    
      var p = buf.toString('base64');
      var out = [ '-----BEGIN ' + options.label + '-----' ];
      for (var i = 0; i < p.length; i += 64)
        out.push(p.slice(i, i + 64));
      out.push('-----END ' + options.label + '-----');
      return out.join('\n');
    };
    
  provide("asn1.js/lib/asn1/encoders/pem", module.exports);
}(global));

// pakmanager:asn1.js/lib/asn1/decoders/pem
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var inherits = require('inherits');
    var Buffer = require('buffer').Buffer;
    
    var asn1 =  require('asn1.js/lib/asn1');
    var DERDecoder =  require('asn1.js/lib/asn1/encoders/der');
    
    function PEMDecoder(entity) {
      DERDecoder.call(this, entity);
      this.enc = 'pem';
    };
    inherits(PEMDecoder, DERDecoder);
    module.exports = PEMDecoder;
    
    PEMDecoder.prototype.decode = function decode(data, options) {
      var lines = data.toString().split(/[\r\n]+/g);
    
      var label = options.label.toUpperCase();
    
      var re = /^-----(BEGIN|END) ([^-]+)-----$/;
      var start = -1;
      var end = -1;
      for (var i = 0; i < lines.length; i++) {
        var match = lines[i].match(re);
        if (match === null)
          continue;
    
        if (match[2] !== label)
          continue;
    
        if (start === -1) {
          if (match[1] !== 'BEGIN')
            break;
          start = i;
        } else {
          if (match[1] !== 'END')
            break;
          end = i;
          break;
        }
      }
      if (start === -1 || end === -1)
        throw new Error('PEM section not found for: ' + label);
    
      var base64 = lines.slice(start + 1, end).join('');
      // Remove excessive symbols
      base64.replace(/[^a-z0-9\+\/=]+/gi, '');
    
      var input = new Buffer(base64, 'base64');
      return DERDecoder.prototype.decode.call(this, input, options);
    };
    
  provide("asn1.js/lib/asn1/decoders/pem", module.exports);
}(global));

// pakmanager:asn1.js/lib/asn1/api
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var asn1 =  require('asn1.js/lib/asn1');
    var inherits = require('inherits');
    
    var api = exports;
    
    api.define = function define(name, body) {
      return new Entity(name, body);
    };
    
    function Entity(name, body) {
      this.name = name;
      this.body = body;
    
      this.decoders = {};
      this.encoders = {};
    };
    
    Entity.prototype._createNamed = function createNamed(base) {
      var named;
      try {
        named = require('vm').runInThisContext(
          '(function ' + this.name + '(entity) {\n' +
          '  this._initNamed(entity);\n' +
          '})'
        );
      } catch (e) {
        named = function (entity) {
          this._initNamed(entity);
        };
      }
      inherits(named, base);
      named.prototype._initNamed = function initnamed(entity) {
        base.call(this, entity);
      };
    
      return new named(this);
    };
    
    Entity.prototype._getDecoder = function _getDecoder(enc) {
      // Lazily create decoder
      if (!this.decoders.hasOwnProperty(enc))
        this.decoders[enc] = this._createNamed(asn1.decoders[enc]);
      return this.decoders[enc];
    };
    
    Entity.prototype.decode = function decode(data, enc, options) {
      return this._getDecoder(enc).decode(data, options);
    };
    
    Entity.prototype._getEncoder = function _getEncoder(enc) {
      // Lazily create encoder
      if (!this.encoders.hasOwnProperty(enc))
        this.encoders[enc] = this._createNamed(asn1.encoders[enc]);
      return this.encoders[enc];
    };
    
    Entity.prototype.encode = function encode(data, enc, /* internal */ reporter) {
      return this._getEncoder(enc).encode(data, reporter);
    };
    
  provide("asn1.js/lib/asn1/api", module.exports);
}(global));

// pakmanager:asn1.js/lib/asn1/base
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var base = exports;
    
    base.Reporter =  require('asn1.js/lib/asn1/base/reporter').Reporter;
    base.DecoderBuffer =  require('asn1.js/lib/asn1/base/buffer').DecoderBuffer;
    base.EncoderBuffer =  require('asn1.js/lib/asn1/base/buffer').EncoderBuffer;
    base.Node =  require('asn1.js/lib/asn1/base/node');
    
  provide("asn1.js/lib/asn1/base", module.exports);
}(global));

// pakmanager:asn1.js/lib/asn1/constants
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var constants = exports;
    
    // Helper
    constants._reverse = function reverse(map) {
      var res = {};
    
      Object.keys(map).forEach(function(key) {
        // Convert key to integer if it is stringified
        if ((key | 0) == key)
          key = key | 0;
    
        var value = map[key];
        res[value] = key;
      });
    
      return res;
    };
    
    constants.der =  require('asn1.js/lib/asn1/encoders/der');
    
  provide("asn1.js/lib/asn1/constants", module.exports);
}(global));

// pakmanager:asn1.js/lib/asn1/encoders
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var encoders = exports;
    
    encoders.der =  require('asn1.js/lib/asn1/encoders/der');
    encoders.pem =  require('asn1.js/lib/asn1/encoders/pem');
    
  provide("asn1.js/lib/asn1/encoders", module.exports);
}(global));

// pakmanager:asn1.js/lib/asn1/decoders
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var decoders = exports;
    
    decoders.der =  require('asn1.js/lib/asn1/encoders/der');
    decoders.pem =  require('asn1.js/lib/asn1/encoders/pem');
    
  provide("asn1.js/lib/asn1/decoders", module.exports);
}(global));

// pakmanager:asn1.js/lib/asn1
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var asn1 = exports;
    
    asn1.bignum = require('bn.js');
    
    asn1.define =  require('asn1.js/lib/asn1/api').define;
    asn1.base =  require('asn1.js/lib/asn1/base');
    asn1.constants =  require('asn1.js/lib/asn1/constants');
    asn1.decoders =  require('asn1.js/lib/asn1/decoders');
    asn1.encoders =  require('asn1.js/lib/asn1/encoders');
    
  provide("asn1.js/lib/asn1", module.exports);
}(global));

// pakmanager:asn1.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var asn1 = exports;
    
    asn1.bignum = require('bn.js');
    
    asn1.define =  require('asn1.js/lib/asn1/api').define;
    asn1.base =  require('asn1.js/lib/asn1/base');
    asn1.constants =  require('asn1.js/lib/asn1/constants');
    asn1.decoders =  require('asn1.js/lib/asn1/decoders');
    asn1.encoders =  require('asn1.js/lib/asn1/encoders');
    
  provide("asn1.js", module.exports);
}(global));

// pakmanager:base64-url
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    var base64url = module.exports;
    
    base64url.unescape = function unescape (str) {
      return (str + Array(5 - str.length % 4)
        .join('='))
        .replace(/\-/g, '+')
        .replace(/_/g, '/');
    };
    
    base64url.escape = function escape (str) {
      return str.replace(/\+/g, '-')
        .replace(/\//g, '_')
        .replace(/=/g, '');
    };
    
    base64url.encode = function encode (str) {
      return this.escape(new Buffer(str).toString('base64'));
    };
    
    base64url.decode = function decode (str) {
      return new Buffer(this.unescape(str), 'base64').toString();
    };
    
  provide("base64-url", module.exports);
}(global));

// pakmanager:delayed-stream
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var Stream = require('stream').Stream;
    var util = require('util');
    
    module.exports = DelayedStream;
    function DelayedStream() {
      this.source = null;
      this.dataSize = 0;
      this.maxDataSize = 1024 * 1024;
      this.pauseStream = true;
    
      this._maxDataSizeExceeded = false;
      this._released = false;
      this._bufferedEvents = [];
    }
    util.inherits(DelayedStream, Stream);
    
    DelayedStream.create = function(source, options) {
      var delayedStream = new this();
    
      options = options || {};
      for (var option in options) {
        delayedStream[option] = options[option];
      }
    
      delayedStream.source = source;
    
      var realEmit = source.emit;
      source.emit = function() {
        delayedStream._handleEmit(arguments);
        return realEmit.apply(source, arguments);
      };
    
      source.on('error', function() {});
      if (delayedStream.pauseStream) {
        source.pause();
      }
    
      return delayedStream;
    };
    
    Object.defineProperty(DelayedStream.prototype, 'readable', {
      configurable: true,
      enumerable: true,
      get: function() {
        return this.source.readable;
      }
    });
    
    DelayedStream.prototype.setEncoding = function() {
      return this.source.setEncoding.apply(this.source, arguments);
    };
    
    DelayedStream.prototype.resume = function() {
      if (!this._released) {
        this.release();
      }
    
      this.source.resume();
    };
    
    DelayedStream.prototype.pause = function() {
      this.source.pause();
    };
    
    DelayedStream.prototype.release = function() {
      this._released = true;
    
      this._bufferedEvents.forEach(function(args) {
        this.emit.apply(this, args);
      }.bind(this));
      this._bufferedEvents = [];
    };
    
    DelayedStream.prototype.pipe = function() {
      var r = Stream.prototype.pipe.apply(this, arguments);
      this.resume();
      return r;
    };
    
    DelayedStream.prototype._handleEmit = function(args) {
      if (this._released) {
        this.emit.apply(this, args);
        return;
      }
    
      if (args[0] === 'data') {
        this.dataSize += args[1].length;
        this._checkIfMaxDataSizeExceeded();
      }
    
      this._bufferedEvents.push(args);
    };
    
    DelayedStream.prototype._checkIfMaxDataSizeExceeded = function() {
      if (this._maxDataSizeExceeded) {
        return;
      }
    
      if (this.dataSize <= this.maxDataSize) {
        return;
      }
    
      this._maxDataSizeExceeded = true;
      var message =
        'DelayedStream#maxDataSize of ' + this.maxDataSize + ' bytes exceeded.'
      this.emit('error', new Error(message));
    };
    
  provide("delayed-stream", module.exports);
}(global));

// pakmanager:mime-db
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*!
     * mime-db
     * Copyright(c) 2014 Jonathan Ong
     * MIT Licensed
     */
    
    /**
     * Module exports.
     */
    
    module.exports = require('./db.json')
    
  provide("mime-db", module.exports);
}(global));

// pakmanager:boom
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Load modules
    
    var Http = require('http');
    var Hoek = require('hoek');
    
    
    // Declare internals
    
    var internals = {};
    
    
    exports.wrap = function (error, statusCode, message) {
    
        Hoek.assert(error instanceof Error, 'Cannot wrap non-Error object');
        return (error.isBoom ? error : internals.initialize(error, statusCode || 500, message));
    };
    
    
    exports.create = function (statusCode, message, data) {
    
        var error = new Error(message ? message : undefined);       // Avoids settings null message
        error.data = data || null;
        internals.initialize(error, statusCode);
        return error;
    };
    
    
    internals.initialize = function (error, statusCode, message) {
    
        var numberCode = parseInt(statusCode, 10);
        Hoek.assert(!isNaN(numberCode) && numberCode >= 400, 'First argument must be a number (400+):', statusCode);
    
        error.isBoom = true;
        error.isServer = numberCode >= 500;
    
        if (!error.hasOwnProperty('data')) {
            error.data = null;
        }
    
        error.output = {
            statusCode: numberCode,
            payload: {},
            headers: {}
        };
    
        error.reformat = internals.reformat;
        error.reformat();
    
        if (!message &&
            !error.message) {
    
            message = error.output.payload.error;
        }
    
        if (message) {
            error.message = (message + (error.message ? ': ' + error.message : ''));
        }
    
        return error;
    };
    
    
    internals.reformat = function () {
    
        this.output.payload.statusCode = this.output.statusCode;
        this.output.payload.error = Http.STATUS_CODES[this.output.statusCode] || 'Unknown';
    
        if (this.output.statusCode === 500) {
            this.output.payload.message = 'An internal server error occurred';              // Hide actual error from user
        }
        else if (this.message) {
            this.output.payload.message = this.message;
        }
    };
    
    
    // 4xx Client Errors
    
    exports.badRequest = function (message, data) {
    
        return exports.create(400, message, data);
    };
    
    
    exports.unauthorized = function (message, scheme, attributes) {          // Or function (message, wwwAuthenticate[])
    
        var err = exports.create(401, message);
    
        if (!scheme) {
            return err;
        }
    
        var wwwAuthenticate = '';
        var i = 0;
        var il = 0;
    
        if (typeof scheme === 'string') {
    
            // function (message, scheme, attributes)
    
            wwwAuthenticate = scheme;
    
            if (attributes || message) {
                err.output.payload.attributes = {};
            }
    
            if (attributes) {
                var names = Object.keys(attributes);
                for (i = 0, il = names.length; i < il; ++i) {
                    var name = names[i];
                    if (i) {
                        wwwAuthenticate += ',';
                    }
    
                    var value = attributes[name];
                    if (value === null ||
                        value === undefined) {              // Value can be zero
    
                        value = '';
                    }
                    wwwAuthenticate += ' ' + name + '="' + Hoek.escapeHeaderAttribute(value.toString()) + '"';
                    err.output.payload.attributes[name] = value;
                }
            }
    
            if (message) {
                if (attributes) {
                    wwwAuthenticate += ',';
                }
                wwwAuthenticate += ' error="' + Hoek.escapeHeaderAttribute(message) + '"';
                err.output.payload.attributes.error = message;
            }
            else {
                err.isMissing = true;
            }
        }
        else {
    
            // function (message, wwwAuthenticate[])
    
            var wwwArray = scheme;
            for (i = 0, il = wwwArray.length; i < il; ++i) {
                if (i) {
                    wwwAuthenticate += ', ';
                }
    
                wwwAuthenticate += wwwArray[i];
            }
        }
    
        err.output.headers['WWW-Authenticate'] = wwwAuthenticate;
    
        return err;
    };
    
    
    exports.forbidden = function (message, data) {
    
        return exports.create(403, message, data);
    };
    
    
    exports.notFound = function (message, data) {
    
        return exports.create(404, message, data);
    };
    
    
    exports.methodNotAllowed = function (message, data) {
    
        return exports.create(405, message, data);
    };
    
    
    exports.notAcceptable = function (message, data) {
    
        return exports.create(406, message, data);
    };
    
    
    exports.proxyAuthRequired = function (message, data) {
    
        return exports.create(407, message, data);
    };
    
    
    exports.clientTimeout = function (message, data) {
    
        return exports.create(408, message, data);
    };
    
    
    exports.conflict = function (message, data) {
    
        return exports.create(409, message, data);
    };
    
    
    exports.resourceGone = function (message, data) {
    
        return exports.create(410, message, data);
    };
    
    
    exports.lengthRequired = function (message, data) {
    
        return exports.create(411, message, data);
    };
    
    
    exports.preconditionFailed = function (message, data) {
    
        return exports.create(412, message, data);
    };
    
    
    exports.entityTooLarge = function (message, data) {
    
        return exports.create(413, message, data);
    };
    
    
    exports.uriTooLong = function (message, data) {
    
        return exports.create(414, message, data);
    };
    
    
    exports.unsupportedMediaType = function (message, data) {
    
        return exports.create(415, message, data);
    };
    
    
    exports.rangeNotSatisfiable = function (message, data) {
    
        return exports.create(416, message, data);
    };
    
    
    exports.expectationFailed = function (message, data) {
    
        return exports.create(417, message, data);
    };
    
    exports.badData = function (message, data) {
    
        return exports.create(422, message, data);
    };
    
    
    exports.tooManyRequests = function (message, data) {
    
        return exports.create(429, message, data);
    };
    
    
    // 5xx Server Errors
    
    exports.internal = function (message, data, statusCode) {
    
        var error = (data instanceof Error ? exports.wrap(data, statusCode, message) : exports.create(statusCode || 500, message));
    
        if (data instanceof Error === false) {
            error.data = data;
        }
    
        return error;
    };
    
    
    exports.notImplemented = function (message, data) {
    
        return exports.internal(message, data, 501);
    };
    
    
    exports.badGateway = function (message, data) {
    
        return exports.internal(message, data, 502);
    };
    
    
    exports.serverTimeout = function (message, data) {
    
        return exports.internal(message, data, 503);
    };
    
    
    exports.gatewayTimeout = function (message, data) {
    
        return exports.internal(message, data, 504);
    };
    
    
    exports.badImplementation = function (message, data) {
    
        var err = exports.internal(message, data, 500);
        err.isDeveloperError = true;
        return err;
    };
    
  provide("boom", module.exports);
}(global));

// pakmanager:ansi-styles
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    function assembleStyles () {
    	var styles = {
    		modifiers: {
    			reset: [0, 0],
    			bold: [1, 22], // 21 isn't widely supported and 22 does the same thing
    			dim: [2, 22],
    			italic: [3, 23],
    			underline: [4, 24],
    			inverse: [7, 27],
    			hidden: [8, 28],
    			strikethrough: [9, 29]
    		},
    		colors: {
    			black: [30, 39],
    			red: [31, 39],
    			green: [32, 39],
    			yellow: [33, 39],
    			blue: [34, 39],
    			magenta: [35, 39],
    			cyan: [36, 39],
    			white: [37, 39],
    			gray: [90, 39]
    		},
    		bgColors: {
    			bgBlack: [40, 49],
    			bgRed: [41, 49],
    			bgGreen: [42, 49],
    			bgYellow: [43, 49],
    			bgBlue: [44, 49],
    			bgMagenta: [45, 49],
    			bgCyan: [46, 49],
    			bgWhite: [47, 49]
    		}
    	};
    
    	// fix humans
    	styles.colors.grey = styles.colors.gray;
    
    	Object.keys(styles).forEach(function (groupName) {
    		var group = styles[groupName];
    
    		Object.keys(group).forEach(function (styleName) {
    			var style = group[styleName];
    
    			styles[styleName] = group[styleName] = {
    				open: '\u001b[' + style[0] + 'm',
    				close: '\u001b[' + style[1] + 'm'
    			};
    		});
    
    		Object.defineProperty(styles, groupName, {
    			value: group,
    			enumerable: false
    		});
    	});
    
    	return styles;
    }
    
    Object.defineProperty(module, 'exports', {
    	enumerable: true,
    	get: assembleStyles
    });
    
  provide("ansi-styles", module.exports);
}(global));

// pakmanager:escape-string-regexp
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    var matchOperatorsRe = /[|\\{}()[\]^$+*?.]/g;
    
    module.exports = function (str) {
    	if (typeof str !== 'string') {
    		throw new TypeError('Expected a string');
    	}
    
    	return str.replace(matchOperatorsRe,  '\\$&');
    };
    
  provide("escape-string-regexp", module.exports);
}(global));

// pakmanager:has-ansi
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    var ansiRegex = require('ansi-regex');
    var re = new RegExp(ansiRegex().source); // remove the `g` flag
    module.exports = re.test.bind(re);
    
  provide("has-ansi", module.exports);
}(global));

// pakmanager:strip-ansi
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    var ansiRegex = require('ansi-regex')();
    
    module.exports = function (str) {
    	return typeof str === 'string' ? str.replace(ansiRegex, '') : str;
    };
    
  provide("strip-ansi", module.exports);
}(global));

// pakmanager:supports-color
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    var argv = process.argv;
    
    var terminator = argv.indexOf('--');
    var hasFlag = function (flag) {
    	flag = '--' + flag;
    	var pos = argv.indexOf(flag);
    	return pos !== -1 && (terminator !== -1 ? pos < terminator : true);
    };
    
    module.exports = (function () {
    	if ('FORCE_COLOR' in process.env) {
    		return true;
    	}
    
    	if (hasFlag('no-color') ||
    		hasFlag('no-colors') ||
    		hasFlag('color=false')) {
    		return false;
    	}
    
    	if (hasFlag('color') ||
    		hasFlag('colors') ||
    		hasFlag('color=true') ||
    		hasFlag('color=always')) {
    		return true;
    	}
    
    	if (process.stdout && !process.stdout.isTTY) {
    		return false;
    	}
    
    	if (process.platform === 'win32') {
    		return true;
    	}
    
    	if ('COLORTERM' in process.env) {
    		return true;
    	}
    
    	if (process.env.TERM === 'dumb') {
    		return false;
    	}
    
    	if (/^screen|^xterm|^vt100|color|ansi|cygwin|linux/i.test(process.env.TERM)) {
    		return true;
    	}
    
    	return false;
    })();
    
  provide("supports-color", module.exports);
}(global));

// pakmanager:graceful-readlink
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var fs = require('fs')
      , lstat = fs.lstatSync;
    
    exports.readlinkSync = function (p) {
      if (lstat(p).isSymbolicLink()) {
        return fs.readlinkSync(p);
      } else {
        return p;
      }
    };
    
    
    
  provide("graceful-readlink", module.exports);
}(global));

// pakmanager:generate-function
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var util = require('util')
    
    var INDENT_START = /[\{\[]/
    var INDENT_END = /[\}\]]/
    
    module.exports = function() {
      var lines = []
      var indent = 0
    
      var push = function(str) {
        var spaces = ''
        while (spaces.length < indent*2) spaces += '  '
        lines.push(spaces+str)
      }
    
      var line = function(fmt) {
        if (!fmt) return line
    
        if (INDENT_END.test(fmt.trim()[0]) && INDENT_START.test(fmt[fmt.length-1])) {
          indent--
          push(util.format.apply(util, arguments))
          indent++
          return line
        }
        if (INDENT_START.test(fmt[fmt.length-1])) {
          push(util.format.apply(util, arguments))
          indent++
          return line
        }
        if (INDENT_END.test(fmt.trim()[0])) {
          indent--
          push(util.format.apply(util, arguments))
          return line
        }
    
        push(util.format.apply(util, arguments))
        return line
      }
    
      line.toString = function() {
        return lines.join('\n')
      }
    
      line.toFunction = function(scope) {
        var src = 'return ('+line.toString()+')'
    
        var keys = Object.keys(scope || {}).map(function(key) {
          return key
        })
    
        var vals = keys.map(function(key) {
          return scope[key]
        })
    
        return Function.apply(null, keys.concat(src)).apply(null, vals)
      }
    
      if (arguments.length) line.apply(null, arguments)
    
      return line
    }
    
  provide("generate-function", module.exports);
}(global));

// pakmanager:generate-object-property
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var isProperty = require('is-property')
    
    var gen = function(obj, prop) {
      return isProperty(prop) ? obj+'.'+prop : obj+'['+JSON.stringify(prop)+']'
    }
    
    gen.valid = isProperty
    gen.property = function (prop) {
     return isProperty(prop) ? prop : JSON.stringify(prop)
    }
    
    module.exports = gen
    
  provide("generate-object-property", module.exports);
}(global));

// pakmanager:jsonpointer
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var untilde = function(str) {
      return str.replace(/~./g, function(m) {
        switch (m) {
          case "~0":
            return "~";
          case "~1":
            return "/";
        }
        throw new Error("Invalid tilde escape: " + m);
      });
    }
    
    var traverse = function(obj, pointer, value) {
      // assert(isArray(pointer))
      var part = untilde(pointer.shift());
      if(!obj.hasOwnProperty(part)) {
        return null;
      }
      if(pointer.length !== 0) { // keep traversin!
        return traverse(obj[part], pointer, value);
      }
      // we're done
      if(typeof value === "undefined") {
        // just reading
        return obj[part];
      }
      // set new value, return old value
      var old_value = obj[part];
      if(value === null) {
        delete obj[part];
      } else {
        obj[part] = value;
      }
      return old_value;
    }
    
    var validate_input = function(obj, pointer) {
      if(typeof obj !== "object") {
        throw new Error("Invalid input object.");
      }
    
      if(pointer === "") {
        return [];
      }
    
      if(!pointer) {
        throw new Error("Invalid JSON pointer.");
      }
    
      pointer = pointer.split("/");
      var first = pointer.shift();
      if (first !== "") {
        throw new Error("Invalid JSON pointer.");
      }
    
      return pointer;
    }
    
    var get = function(obj, pointer) {
      pointer = validate_input(obj, pointer);
      if (pointer.length === 0) {
        return obj;
      }
      return traverse(obj, pointer);
    }
    
    var set = function(obj, pointer, value) {
      pointer = validate_input(obj, pointer);
      if (pointer.length === 0) {
        throw new Error("Invalid JSON pointer for set.")
      }
      return traverse(obj, pointer, value);
    }
    
    exports.get = get
    exports.set = set
    
  provide("jsonpointer", module.exports);
}(global));

// pakmanager:xtend
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  module.exports = extend
    
    function extend() {
        var target = {}
    
        for (var i = 0; i < arguments.length; i++) {
            var source = arguments[i]
    
            for (var key in source) {
                if (source.hasOwnProperty(key)) {
                    target[key] = source[key]
                }
            }
        }
    
        return target
    }
    
  provide("xtend", module.exports);
}(global));

// pakmanager:once
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var wrappy = require('wrappy')
    module.exports = wrappy(once)
    
    once.proto = once(function () {
      Object.defineProperty(Function.prototype, 'once', {
        value: function () {
          return once(this)
        },
        configurable: true
      })
    })
    
    function once (fn) {
      var f = function () {
        if (f.called) return f.value
        f.called = true
        return f.value = fn.apply(this, arguments)
      }
      f.called = false
      return f
    }
    
  provide("once", module.exports);
}(global));

// pakmanager:pinkie
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    var PENDING = 'pending';
    var SETTLED = 'settled';
    var FULFILLED = 'fulfilled';
    var REJECTED = 'rejected';
    var NOOP = function () {};
    
    // async calls
    var asyncSetTimer = typeof setImmediate !== 'undefined' ? setImmediate : setTimeout;
    var asyncQueue = [];
    var asyncTimer;
    
    function asyncFlush() {
    	// run promise callbacks
    	for (var i = 0; i < asyncQueue.length; i++) {
    		asyncQueue[i][0](asyncQueue[i][1]);
    	}
    
    	// reset async asyncQueue
    	asyncQueue = [];
    	asyncTimer = false;
    }
    
    function asyncCall(callback, arg) {
    	asyncQueue.push([callback, arg]);
    
    	if (!asyncTimer) {
    		asyncTimer = true;
    		asyncSetTimer(asyncFlush, 0);
    	}
    }
    
    function invokeResolver(resolver, promise) {
    	function resolvePromise(value) {
    		resolve(promise, value);
    	}
    
    	function rejectPromise(reason) {
    		reject(promise, reason);
    	}
    
    	try {
    		resolver(resolvePromise, rejectPromise);
    	} catch (e) {
    		rejectPromise(e);
    	}
    }
    
    function invokeCallback(subscriber) {
    	var owner = subscriber.owner;
    	var settled = owner._state;
    	var value = owner._data;
    	var callback = subscriber[settled];
    	var promise = subscriber.then;
    
    	if (typeof callback === 'function') {
    		settled = FULFILLED;
    		try {
    			value = callback(value);
    		} catch (e) {
    			reject(promise, e);
    		}
    	}
    
    	if (!handleThenable(promise, value)) {
    		if (settled === FULFILLED) {
    			resolve(promise, value);
    		}
    
    		if (settled === REJECTED) {
    			reject(promise, value);
    		}
    	}
    }
    
    function handleThenable(promise, value) {
    	var resolved;
    
    	try {
    		if (promise === value) {
    			throw new TypeError('A promises callback cannot return that same promise.');
    		}
    
    		if (value && (typeof value === 'function' || typeof value === 'object')) {
    			var then = value.then; // then should be retrived only once
    
    			if (typeof then === 'function') {
    				then.call(value, function (val) {
    					if (!resolved) {
    						resolved = true;
    
    						if (value !== val) {
    							resolve(promise, val);
    						} else {
    							fulfill(promise, val);
    						}
    					}
    				}, function (reason) {
    					if (!resolved) {
    						resolved = true;
    
    						reject(promise, reason);
    					}
    				});
    
    				return true;
    			}
    		}
    	} catch (e) {
    		if (!resolved) {
    			reject(promise, e);
    		}
    
    		return true;
    	}
    
    	return false;
    }
    
    function resolve(promise, value) {
    	if (promise === value || !handleThenable(promise, value)) {
    		fulfill(promise, value);
    	}
    }
    
    function fulfill(promise, value) {
    	if (promise._state === PENDING) {
    		promise._state = SETTLED;
    		promise._data = value;
    
    		asyncCall(publishFulfillment, promise);
    	}
    }
    
    function reject(promise, reason) {
    	if (promise._state === PENDING) {
    		promise._state = SETTLED;
    		promise._data = reason;
    
    		asyncCall(publishRejection, promise);
    	}
    }
    
    function publish(promise) {
    	promise._then = promise._then.forEach(invokeCallback);
    }
    
    function publishFulfillment(promise) {
    	promise._state = FULFILLED;
    	publish(promise);
    }
    
    function publishRejection(promise) {
    	promise._state = REJECTED;
    	publish(promise);
    }
    
    /**
     * @class
     */
    function Promise(resolver) {
    	if (typeof resolver !== 'function') {
    		throw new TypeError('Promise resolver ' + resolver + ' is not a function');
    	}
    
    	if (this instanceof Promise === false) {
    		throw new TypeError('Failed to construct \'Promise\': Please use the \'new\' operator, this object constructor cannot be called as a function.');
    	}
    
    	this._then = [];
    
    	invokeResolver(resolver, this);
    }
    
    Promise.prototype = {
    	constructor: Promise,
    
    	_state: PENDING,
    	_then: null,
    	_data: undefined,
    
    	then: function (onFulfillment, onRejection) {
    		var subscriber = {
    			owner: this,
    			then: new this.constructor(NOOP),
    			fulfilled: onFulfillment,
    			rejected: onRejection
    		};
    
    		if (this._state === FULFILLED || this._state === REJECTED) {
    			// already resolved, call callback async
    			asyncCall(invokeCallback, subscriber);
    		} else {
    			// subscribe
    			this._then.push(subscriber);
    		}
    
    		return subscriber.then;
    	},
    
    	'catch': function (onRejection) {
    		return this.then(null, onRejection);
    	}
    };
    
    Promise.all = function (promises) {
    	if (!Array.isArray(promises)) {
    		throw new TypeError('You must pass an array to Promise.all().');
    	}
    
    	return new Promise(function (resolve, reject) {
    		var results = [];
    		var remaining = 0;
    
    		function resolver(index) {
    			remaining++;
    			return function (value) {
    				results[index] = value;
    				if (!--remaining) {
    					resolve(results);
    				}
    			};
    		}
    
    		for (var i = 0, promise; i < promises.length; i++) {
    			promise = promises[i];
    
    			if (promise && typeof promise.then === 'function') {
    				promise.then(resolver(i), reject);
    			} else {
    				results[i] = promise;
    			}
    		}
    
    		if (!remaining) {
    			resolve(results);
    		}
    	});
    };
    
    Promise.race = function (promises) {
    	if (!Array.isArray(promises)) {
    		throw new TypeError('You must pass an array to Promise.race().');
    	}
    
    	return new Promise(function (resolve, reject) {
    		for (var i = 0, promise; i < promises.length; i++) {
    			promise = promises[i];
    
    			if (promise && typeof promise.then === 'function') {
    				promise.then(resolve, reject);
    			} else {
    				resolve(promise);
    			}
    		}
    	});
    };
    
    Promise.resolve = function (value) {
    	if (value && typeof value === 'object' && value.constructor === Promise) {
    		return value;
    	}
    
    	return new Promise(function (resolve) {
    		resolve(value);
    	});
    };
    
    Promise.reject = function (reason) {
    	return new Promise(function (resolve, reject) {
    		reject(reason);
    	});
    };
    
    module.exports = Promise;
    
  provide("pinkie", module.exports);
}(global));

// pakmanager:is-finite
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    var numberIsNan = require('number-is-nan');
    
    module.exports = Number.isFinite || function (val) {
    	return !(typeof val !== 'number' || numberIsNan(val) || val === Infinity || val === -Infinity);
    };
    
  provide("is-finite", module.exports);
}(global));

// pakmanager:number-is-nan
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    module.exports = Number.isNaN || function (x) {
    	return x !== x;
    };
    
  provide("number-is-nan", module.exports);
}(global));

// pakmanager:wrappy
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Returns a wrapper function that returns a wrapped callback
    // The wrapper function should do some stuff, and return a
    // presumably different callback function.
    // This makes sure that own properties are retained, so that
    // decorations and such are not lost along the way.
    module.exports = wrappy
    function wrappy (fn, cb) {
      if (fn && cb) return wrappy(fn)(cb)
    
      if (typeof fn !== 'function')
        throw new TypeError('need wrapper function')
    
      Object.keys(fn).forEach(function (k) {
        wrapper[k] = fn[k]
      })
    
      return wrapper
    
      function wrapper() {
        var args = new Array(arguments.length)
        for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i]
        }
        var ret = fn.apply(this, args)
        var cb = args[args.length-1]
        if (typeof ret === 'function' && ret !== cb) {
          Object.keys(cb).forEach(function (k) {
            ret[k] = cb[k]
          })
        }
        return ret
      }
    }
    
  provide("wrappy", module.exports);
}(global));

// pakmanager:base64url
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  function fromBase64(base64string) {
      return (
        base64string
          .replace(/=/g, '')
          .replace(/\+/g, '-')
          .replace(/\//g, '_')
      );
    }
    
    function toBase64(base64UrlString) {
      if (Buffer.isBuffer(base64UrlString))
        base64UrlString = base64UrlString.toString();
    
      const b64str = padString(base64UrlString)
        .replace(/\-/g, '+')
        .replace(/_/g, '/');
      return b64str;
    }
    
    function padString(string) {
      const segmentLength = 4;
      const stringLength = string.length;
      const diff = string.length % segmentLength;
      if (!diff)
        return string;
      var position = stringLength;
      var padLength = segmentLength - diff;
      const paddedStringLength = stringLength + padLength;
      const buffer = Buffer(paddedStringLength);
      buffer.write(string);
      while (padLength--)
        buffer.write('=', position++);
      return buffer.toString();
    }
    
    function decodeBase64Url(base64UrlString, encoding) {
      return Buffer(toBase64(base64UrlString), 'base64').toString(encoding);
    }
    
    function base64url(stringOrBuffer, encoding) {
      return fromBase64(Buffer(stringOrBuffer, encoding).toString('base64'));
    }
    
    function toBuffer(base64string) {
      return Buffer(toBase64(base64string), 'base64');
    }
    
    base64url.toBase64 = toBase64;
    base64url.fromBase64 = fromBase64;
    base64url.decode = decodeBase64Url;
    base64url.encode = base64url;
    base64url.toBuffer = toBuffer;
    
    module.exports = base64url;
    
  provide("base64url", module.exports);
}(global));

// pakmanager:buffer-equal-constant-time
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*jshint node:true */
    'use strict';
    var Buffer = require('buffer').Buffer; // browserify
    var SlowBuffer = require('buffer').SlowBuffer;
    
    module.exports = bufferEq;
    
    function bufferEq(a, b) {
    
      // shortcutting on type is necessary for correctness
      if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
        return false;
      }
    
      // buffer sizes should be well-known information, so despite this
      // shortcutting, it doesn't leak any information about the *contents* of the
      // buffers.
      if (a.length !== b.length) {
        return false;
      }
    
      var c = 0;
      for (var i = 0; i < a.length; i++) {
        /*jshint bitwise:false */
        c |= a[i] ^ b[i]; // XOR
      }
      return c === 0;
    }
    
    bufferEq.install = function() {
      Buffer.prototype.equal = SlowBuffer.prototype.equal = function equal(that) {
        return bufferEq(this, that);
      };
    };
    
    var origBufEqual = Buffer.prototype.equal;
    var origSlowBufEqual = SlowBuffer.prototype.equal;
    bufferEq.restore = function() {
      Buffer.prototype.equal = origBufEqual;
      SlowBuffer.prototype.equal = origSlowBufEqual;
    };
    
  provide("buffer-equal-constant-time", module.exports);
}(global));

// pakmanager:ecdsa-sig-formatter
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    var asn1 = require('asn1.js'),
    	base64Url = require('base64-url').escape;
    
    var ECDSASigValue = asn1.define('ECDSASigValue', function () {
    	this.seq().obj(
    		this.key('r').int(),
    		this.key('s').int()
    	);
    });
    
    var seq = 0x10,
    	int = 0x02;
    
    function getParamSize (keySize) {
    	var result = ((keySize / 8) | 0) + (keySize % 8 === 0 ? 0 : 1);
    	return result;
    }
    
    var paramBytesForAlg = {
    	ES256: getParamSize(256),
    	ES384: getParamSize(384),
    	ES512: getParamSize(521)
    };
    
    function getParamBytesForAlg (alg) {
    	var paramBytes = paramBytesForAlg[alg];
    	if (paramBytes) {
    		return paramBytes;
    	}
    
    	throw new Error('Unknown algorithm "' + alg + '"');
    }
    
    function bignumToBuf (bn, numBytes) {
    	var buf = new Buffer(bn.toString('hex', numBytes), 'hex');
    	return buf;
    }
    
    function signatureAsBuffer (signature) {
    	if (Buffer.isBuffer(signature)) {
    		return new Buffer(signature);
    	} else if ('string' === typeof signature) {
    		return new Buffer(signature, 'base64');
    	}
    
    	throw new TypeError('ECDSA signature must be a Base64 string or a Buffer');
    }
    
    function derToJose(signature, alg) {
    	signature = signatureAsBuffer(signature);
    	var paramBytes = getParamBytesForAlg(alg);
    
    	signature = ECDSASigValue.decode(signature, 'der');
    
    	var r = bignumToBuf(signature.r, paramBytes);
    	var s = bignumToBuf(signature.s, paramBytes);
    
    	signature = Buffer.concat([r, s], r.length + s.length);
    	signature = signature.toString('base64');
    	signature = base64Url(signature);
    
    	return signature;
    }
    
    function reduceBuffer (buf) {
    	var padding = 0;
    	for (var n = buf.length; padding < n && buf[padding] === 0;) {
    		++padding;
    	}
    
    	var needsSign = buf[padding] >= 0x80;
    	if (needsSign) {
    		--padding;
    
    		if (padding < 0) {
    			var old = buf;
    			buf = new Buffer(1 + buf.length);
    			buf[0] = 0;
    			old.copy(buf, 1);
    
    			return buf;
    		}
    	}
    
    	if (padding === 0) {
    		return buf;
    	}
    
    	buf = buf.slice(padding);
    	return buf;
    }
    
    function joseToDer(signature, alg) {
    	signature = signatureAsBuffer(signature);
    	var paramBytes = getParamBytesForAlg(alg);
    
    	var signatureBytes = signature.length;
    	if (signatureBytes !== paramBytes * 2) {
    		throw new TypeError('"' + alg + '" signatures must be "' + paramBytes * 2 + '" bytes, saw "' + signatureBytes + '"');
    	}
    
    	var r = reduceBuffer(signature.slice(0, paramBytes));
    	var s = reduceBuffer(signature.slice(paramBytes));
    
    	var rsBytes = 1 + 1 + r.length + 1 + 1 + s.length;
    
    	var oneByteLength = rsBytes < 0x80;
    
    	signature = new Buffer((oneByteLength ? 2 : 3) + rsBytes);
    
    	var offset = 0;
    	signature[offset++] = (seq | 0x20) | 0 << 6;
    	if (oneByteLength) {
    		signature[offset++] = rsBytes;
    	} else {
    		signature[offset++] = 0x80 | 1;
    		signature[offset++] = rsBytes & 0xff;
    	}
    	signature[offset++] = int | (0 << 6);
    	signature[offset++] = r.length;
    	r.copy(signature, offset);
    	offset += r.length;
    	signature[offset++] = int | (0 << 6);
    	signature[offset++] = s.length;
    	s.copy(signature, offset);
    
    	return signature;
    }
    
    module.exports = {
    	derToJose: derToJose,
    	joseToDer: joseToDer
    };
    
  provide("ecdsa-sig-formatter", module.exports);
}(global));

// pakmanager:async
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*!
     * async
     * https://github.com/caolan/async
     *
     * Copyright 2010-2014 Caolan McMahon
     * Released under the MIT license
     */
    (function () {
    
        var async = {};
        function noop() {}
    
        // global on the server, window in the browser
        var previous_async;
    
        // Establish the root object, `window` (`self`) in the browser, `global`
        // on the server, or `this` in some virtual machines. We use `self`
        // instead of `window` for `WebWorker` support.
        var root = typeof self === 'object' && self.self === self && self ||
                typeof global === 'object' && global.global === global && global ||
                this;
    
        if (root != null) {
            previous_async = root.async;
        }
    
        async.noConflict = function () {
            root.async = previous_async;
            return async;
        };
    
        function only_once(fn) {
            var called = false;
            return function() {
                if (called) throw new Error("Callback was already called.");
                called = true;
                fn.apply(this, arguments);
            };
        }
    
        function _once(fn) {
            var called = false;
            return function() {
                if (called) return;
                called = true;
                fn.apply(this, arguments);
            };
        }
    
        //// cross-browser compatiblity functions ////
    
        var _toString = Object.prototype.toString;
    
        var _isArray = Array.isArray || function (obj) {
            return _toString.call(obj) === '[object Array]';
        };
    
        function _isArrayLike(arr) {
            return _isArray(arr) || (
                // has a positive integer length property
                typeof arr.length === "number" &&
                arr.length >= 0 &&
                arr.length % 1 === 0
            );
        }
    
        function _each(coll, iterator) {
            return _isArrayLike(coll) ?
                _arrayEach(coll, iterator) :
                _forEachOf(coll, iterator);
        }
    
        function _arrayEach(arr, iterator) {
            var index = -1,
                length = arr.length;
    
            while (++index < length) {
                iterator(arr[index], index, arr);
            }
        }
    
        function _map(arr, iterator) {
            var index = -1,
                length = arr.length,
                result = Array(length);
    
            while (++index < length) {
                result[index] = iterator(arr[index], index, arr);
            }
            return result;
        }
    
        function _range(count) {
            return _map(Array(count), function (v, i) { return i; });
        }
    
        function _reduce(arr, iterator, memo) {
            _arrayEach(arr, function (x, i, a) {
                memo = iterator(memo, x, i, a);
            });
            return memo;
        }
    
        function _forEachOf(object, iterator) {
            _arrayEach(_keys(object), function (key) {
                iterator(object[key], key);
            });
        }
    
        var _keys = Object.keys || function (obj) {
            var keys = [];
            for (var k in obj) {
                if (obj.hasOwnProperty(k)) {
                    keys.push(k);
                }
            }
            return keys;
        };
    
        function _keyIterator(coll) {
            var i = -1;
            var len;
            var keys;
            if (_isArrayLike(coll)) {
                len = coll.length;
                return function next() {
                    i++;
                    return i < len ? i : null;
                };
            } else {
                keys = _keys(coll);
                len = keys.length;
                return function next() {
                    i++;
                    return i < len ? keys[i] : null;
                };
            }
        }
    
        function _baseSlice(arr, start) {
            start = start || 0;
            var index = -1;
            var length = arr.length;
    
            if (start) {
                length -= start;
                length = length < 0 ? 0 : length;
            }
            var result = Array(length);
    
            while (++index < length) {
                result[index] = arr[index + start];
            }
            return result;
        }
    
        function _withoutIndex(iterator) {
            return function (value, index, callback) {
                return iterator(value, callback);
            };
        }
    
        //// exported async module functions ////
    
        //// nextTick implementation with browser-compatible fallback ////
    
        // capture the global reference to guard against fakeTimer mocks
        var _setImmediate;
        if (typeof setImmediate === 'function') {
            _setImmediate = setImmediate;
        }
    
        if (typeof process === 'undefined' || !(process.nextTick)) {
            if (_setImmediate) {
                async.nextTick = function (fn) {
                    // not a direct alias for IE10 compatibility
                    _setImmediate(fn);
                };
                async.setImmediate = async.nextTick;
            }
            else {
                async.nextTick = function (fn) {
                    setTimeout(fn, 0);
                };
                async.setImmediate = async.nextTick;
            }
        }
        else {
            async.nextTick = process.nextTick;
            if (_setImmediate) {
                async.setImmediate = function (fn) {
                  // not a direct alias for IE10 compatibility
                    _setImmediate(fn);
                };
            }
            else {
                async.setImmediate = async.nextTick;
            }
        }
    
        async.forEach =
        async.each = function (arr, iterator, callback) {
            return async.eachOf(arr, _withoutIndex(iterator), callback);
        };
    
        async.forEachSeries =
        async.eachSeries = function (arr, iterator, callback) {
            return async.eachOfSeries(arr, _withoutIndex(iterator), callback);
        };
    
    
        async.forEachLimit =
        async.eachLimit = function (arr, limit, iterator, callback) {
            return _eachOfLimit(limit)(arr, _withoutIndex(iterator), callback);
        };
    
        async.forEachOf =
        async.eachOf = function (object, iterator, callback) {
            callback = _once(callback || noop);
            object = object || [];
            var size = _isArrayLike(object) ? object.length : _keys(object).length;
            var completed = 0;
            if (!size) {
                return callback(null);
            }
            _each(object, function (value, key) {
                iterator(object[key], key, only_once(done));
            });
            function done(err) {
                if (err) {
                    callback(err);
                }
                else {
                    completed += 1;
                    if (completed >= size) {
                        callback(null);
                    }
                }
            }
        };
    
        async.forEachOfSeries =
        async.eachOfSeries = function (obj, iterator, callback) {
            callback = _once(callback || noop);
            obj = obj || [];
            var nextKey = _keyIterator(obj);
            var key = nextKey();
            function iterate() {
                var sync = true;
                if (key === null) {
                    return callback(null);
                }
                iterator(obj[key], key, only_once(function (err) {
                    if (err) {
                        callback(err);
                    }
                    else {
                        key = nextKey();
                        if (key === null) {
                            return callback(null);
                        } else {
                            if (sync) {
                                async.nextTick(iterate);
                            } else {
                                iterate();
                            }
                        }
                    }
                }));
                sync = false;
            }
            iterate();
        };
    
    
    
        async.forEachOfLimit =
        async.eachOfLimit = function (obj, limit, iterator, callback) {
            _eachOfLimit(limit)(obj, iterator, callback);
        };
    
        function _eachOfLimit(limit) {
    
            return function (obj, iterator, callback) {
                callback = _once(callback || noop);
                obj = obj || [];
                var nextKey = _keyIterator(obj);
                if (limit <= 0) {
                    return callback(null);
                }
                var done = false;
                var running = 0;
                var errored = false;
    
                (function replenish () {
                    if (done && running <= 0) {
                        return callback(null);
                    }
    
                    while (running < limit && !errored) {
                        var key = nextKey();
                        if (key === null) {
                            done = true;
                            if (running <= 0) {
                                callback(null);
                            }
                            return;
                        }
                        running += 1;
                        iterator(obj[key], key, only_once(function (err) {
                            running -= 1;
                            if (err) {
                                callback(err);
                                errored = true;
                            }
                            else {
                                replenish();
                            }
                        }));
                    }
                })();
            };
        }
    
    
        function doParallel(fn) {
            return function (obj, iterator, callback) {
                return fn(async.eachOf, obj, iterator, callback);
            };
        }
        function doParallelLimit(limit, fn) {
            return function (obj, iterator, callback) {
                return fn(_eachOfLimit(limit), obj, iterator, callback);
            };
        }
        function doSeries(fn) {
            return function (obj, iterator, callback) {
                return fn(async.eachOfSeries, obj, iterator, callback);
            };
        }
    
        function _asyncMap(eachfn, arr, iterator, callback) {
            callback = _once(callback || noop);
            var results = [];
            eachfn(arr, function (value, index, callback) {
                iterator(value, function (err, v) {
                    results[index] = v;
                    callback(err);
                });
            }, function (err) {
                callback(err, results);
            });
        }
    
        async.map = doParallel(_asyncMap);
        async.mapSeries = doSeries(_asyncMap);
        async.mapLimit = function (arr, limit, iterator, callback) {
            return _mapLimit(limit)(arr, iterator, callback);
        };
    
        function _mapLimit(limit) {
            return doParallelLimit(limit, _asyncMap);
        }
    
        // reduce only has a series version, as doing reduce in parallel won't
        // work in many situations.
        async.inject =
        async.foldl =
        async.reduce = function (arr, memo, iterator, callback) {
            async.eachOfSeries(arr, function (x, i, callback) {
                iterator(memo, x, function (err, v) {
                    memo = v;
                    callback(err);
                });
            }, function (err) {
                callback(err || null, memo);
            });
        };
    
        async.foldr =
        async.reduceRight = function (arr, memo, iterator, callback) {
            var reversed = _map(arr, function (x) {
                return x;
            }).reverse();
            async.reduce(reversed, memo, iterator, callback);
        };
    
        function _filter(eachfn, arr, iterator, callback) {
            var results = [];
            arr = _map(arr, function (x, i) {
                return {index: i, value: x};
            });
            eachfn(arr, function (x, index, callback) {
                iterator(x.value, function (v) {
                    if (v) {
                        results.push(x);
                    }
                    callback();
                });
            }, function () {
                callback(_map(results.sort(function (a, b) {
                    return a.index - b.index;
                }), function (x) {
                    return x.value;
                }));
            });
        }
    
        async.select =
        async.filter = doParallel(_filter);
    
        async.selectSeries =
        async.filterSeries = doSeries(_filter);
    
        function _reject(eachfn, arr, iterator, callback) {
            _filter(eachfn, arr, function(value, cb) {
                iterator(value, function(v) {
                    cb(!v);
                });
            }, callback);
        }
        async.reject = doParallel(_reject);
        async.rejectSeries = doSeries(_reject);
    
        function _detect(eachfn, arr, iterator, main_callback) {
            eachfn(arr, function (x, index, callback) {
                iterator(x, function (result) {
                    if (result) {
                        main_callback(x);
                        main_callback = noop;
                    }
                    else {
                        callback();
                    }
                });
            }, function () {
                main_callback();
            });
        }
        async.detect = doParallel(_detect);
        async.detectSeries = doSeries(_detect);
    
        async.any =
        async.some = function (arr, iterator, main_callback) {
            async.eachOf(arr, function (x, _, callback) {
                iterator(x, function (v) {
                    if (v) {
                        main_callback(true);
                        main_callback = noop;
                    }
                    callback();
                });
            }, function () {
                main_callback(false);
            });
        };
    
        async.all =
        async.every = function (arr, iterator, main_callback) {
            async.eachOf(arr, function (x, _, callback) {
                iterator(x, function (v) {
                    if (!v) {
                        main_callback(false);
                        main_callback = noop;
                    }
                    callback();
                });
            }, function () {
                main_callback(true);
            });
        };
    
        async.sortBy = function (arr, iterator, callback) {
            async.map(arr, function (x, callback) {
                iterator(x, function (err, criteria) {
                    if (err) {
                        callback(err);
                    }
                    else {
                        callback(null, {value: x, criteria: criteria});
                    }
                });
            }, function (err, results) {
                if (err) {
                    return callback(err);
                }
                else {
                    callback(null, _map(results.sort(comparator), function (x) {
                        return x.value;
                    }));
                }
    
            });
    
            function comparator(left, right) {
                var a = left.criteria, b = right.criteria;
                return a < b ? -1 : a > b ? 1 : 0;
            }
        };
    
        async.auto = function (tasks, callback) {
            callback = _once(callback || noop);
            var keys = _keys(tasks);
            var remainingTasks = keys.length;
            if (!remainingTasks) {
                return callback(null);
            }
    
            var results = {};
    
            var listeners = [];
            function addListener(fn) {
                listeners.unshift(fn);
            }
            function removeListener(fn) {
                for (var i = 0; i < listeners.length; i += 1) {
                    if (listeners[i] === fn) {
                        listeners.splice(i, 1);
                        return;
                    }
                }
            }
            function taskComplete() {
                remainingTasks--;
                _arrayEach(listeners.slice(0), function (fn) {
                    fn();
                });
            }
    
            addListener(function () {
                if (!remainingTasks) {
                    callback(null, results);
                }
            });
    
            _arrayEach(keys, function (k) {
                var task = _isArray(tasks[k]) ? tasks[k]: [tasks[k]];
                function taskCallback(err) {
                    var args = _baseSlice(arguments, 1);
                    if (args.length <= 1) {
                        args = args[0];
                    }
                    if (err) {
                        var safeResults = {};
                        _arrayEach(_keys(results), function(rkey) {
                            safeResults[rkey] = results[rkey];
                        });
                        safeResults[k] = args;
                        callback(err, safeResults);
                    }
                    else {
                        results[k] = args;
                        async.setImmediate(taskComplete);
                    }
                }
                var requires = task.slice(0, Math.abs(task.length - 1)) || [];
                // prevent dead-locks
                var len = requires.length;
                var dep;
                while (len--) {
                    if (!(dep = tasks[requires[len]])) {
                        throw new Error('Has inexistant dependency');
                    }
                    if (_isArray(dep) && !!~dep.indexOf(k)) {
                        throw new Error('Has cyclic dependencies');
                    }
                }
                function ready() {
                    return _reduce(requires, function (a, x) {
                        return (a && results.hasOwnProperty(x));
                    }, true) && !results.hasOwnProperty(k);
                }
                if (ready()) {
                    task[task.length - 1](taskCallback, results);
                }
                else {
                    addListener(listener);
                }
                function listener() {
                    if (ready()) {
                        removeListener(listener);
                        task[task.length - 1](taskCallback, results);
                    }
                }
            });
        };
    
    
    
        async.retry = function(/*[times,] task [, callback]*/) {
            var DEFAULT_TIMES = 5;
            var DEFAULT_INTERVAL = 0;
    
            var attempts = [];
    
            var opts = {
              times: DEFAULT_TIMES,
              interval: DEFAULT_INTERVAL
            };
    
            function parseTimes(acc, t){
              if(typeof t === 'number'){
                acc.times = parseInt(t, 10) || DEFAULT_TIMES;
              } else if(typeof t === 'object'){
                acc.times = parseInt(t.times, 10) || DEFAULT_TIMES;
                acc.interval = parseInt(t.interval, 10) || DEFAULT_INTERVAL;
              } else {
                throw new Error('Unsupported argument type for \'times\': ' + typeof(t));
              }
            }
    
            switch(arguments.length){
                case 1: {
                  opts.task = arguments[0];
                  break;
                }
                case 2 : {
                  if(typeof arguments[0] === 'number' || typeof arguments[0] === 'object'){
                    parseTimes(opts, arguments[0]);
                    opts.task = arguments[1];
                  } else {
                    opts.task = arguments[0];
                    opts.callback = arguments[1];
                  }
                  break;
                }
                case 3: {
                  parseTimes(opts, arguments[0]);
                  opts.task = arguments[1];
                  opts.callback = arguments[2];
                  break;
                }
                default: {
                  throw new Error('Invalid arguments - must be either (task), (task, callback), (times, task) or (times, task, callback)');
                }
              }
    
            function wrappedTask(wrappedCallback, wrappedResults) {
                function retryAttempt(task, finalAttempt) {
                    return function(seriesCallback) {
                        task(function(err, result){
                            seriesCallback(!err || finalAttempt, {err: err, result: result});
                        }, wrappedResults);
                    };
                }
    
                function retryInterval(interval){
                  return function(seriesCallback){
                    setTimeout(function(){
                      seriesCallback(null);
                    }, interval);
                  };
                }
    
                while (opts.times) {
    
                    var finalAttempt = !(opts.times-=1);
                    attempts.push(retryAttempt(opts.task, finalAttempt));
                    if(!finalAttempt && opts.interval > 0){
                      attempts.push(retryInterval(opts.interval));
                    }
                }
    
                async.series(attempts, function(done, data){
                    data = data[data.length - 1];
                    (wrappedCallback || opts.callback)(data.err, data.result);
                });
            }
    
            // If a callback is passed, run this as a controll flow
            return opts.callback ? wrappedTask() : wrappedTask;
        };
    
        async.waterfall = function (tasks, callback) {
            callback = _once(callback || noop);
            if (!_isArray(tasks)) {
                var err = new Error('First argument to waterfall must be an array of functions');
                return callback(err);
            }
            if (!tasks.length) {
                return callback();
            }
            function wrapIterator(iterator) {
                return function (err) {
                    if (err) {
                        callback.apply(null, arguments);
                    }
                    else {
                        var args = _baseSlice(arguments, 1);
                        var next = iterator.next();
                        if (next) {
                            args.push(wrapIterator(next));
                        }
                        else {
                            args.push(callback);
                        }
                        ensureAsync(iterator).apply(null, args);
                    }
                };
            }
            wrapIterator(async.iterator(tasks))();
        };
    
        function _parallel(eachfn, tasks, callback) {
            callback = callback || noop;
            var results = _isArrayLike(tasks) ? [] : {};
    
            eachfn(tasks, function (task, key, callback) {
                task(function (err) {
                    var args = _baseSlice(arguments, 1);
                    if (args.length <= 1) {
                        args = args[0];
                    }
                    results[key] = args;
                    callback(err);
                });
            }, function (err) {
                callback(err, results);
            });
        }
    
        async.parallel = function (tasks, callback) {
            _parallel(async.eachOf, tasks, callback);
        };
    
        async.parallelLimit = function(tasks, limit, callback) {
            _parallel(_eachOfLimit(limit), tasks, callback);
        };
    
        async.series = function (tasks, callback) {
            callback = callback || noop;
            var results = _isArrayLike(tasks) ? [] : {};
    
            async.eachOfSeries(tasks, function (task, key, callback) {
                task(function (err) {
                    var args = _baseSlice(arguments, 1);
                    if (args.length <= 1) {
                        args = args[0];
                    }
                    results[key] = args;
                    callback(err);
                });
            }, function (err) {
                callback(err, results);
            });
        };
    
        async.iterator = function (tasks) {
            function makeCallback(index) {
                function fn() {
                    if (tasks.length) {
                        tasks[index].apply(null, arguments);
                    }
                    return fn.next();
                }
                fn.next = function () {
                    return (index < tasks.length - 1) ? makeCallback(index + 1): null;
                };
                return fn;
            }
            return makeCallback(0);
        };
    
        async.apply = function (fn) {
            var args = _baseSlice(arguments, 1);
            return function () {
                return fn.apply(
                    null, args.concat(_baseSlice(arguments))
                );
            };
        };
    
        function _concat(eachfn, arr, fn, callback) {
            var result = [];
            eachfn(arr, function (x, index, cb) {
                fn(x, function (err, y) {
                    result = result.concat(y || []);
                    cb(err);
                });
            }, function (err) {
                callback(err, result);
            });
        }
        async.concat = doParallel(_concat);
        async.concatSeries = doSeries(_concat);
    
        async.whilst = function (test, iterator, callback) {
            callback = callback || noop;
            if (test()) {
                iterator(function (err) {
                    if (err) {
                        return callback(err);
                    }
                    async.whilst(test, iterator, callback);
                });
            }
            else {
                callback(null);
            }
        };
    
        async.doWhilst = function (iterator, test, callback) {
            callback = callback || noop;
            iterator(function (err) {
                if (err) {
                    return callback(err);
                }
                var args = _baseSlice(arguments, 1);
                if (test.apply(null, args)) {
                    async.doWhilst(iterator, test, callback);
                }
                else {
                    callback(null);
                }
            });
        };
    
        async.until = function (test, iterator, callback) {
            callback = callback || noop;
            if (!test()) {
                iterator(function (err) {
                    if (err) {
                        return callback(err);
                    }
                    async.until(test, iterator, callback);
                });
            }
            else {
                callback(null);
            }
        };
    
        async.doUntil = function (iterator, test, callback) {
            callback = callback || noop;
            iterator(function (err) {
                if (err) {
                    return callback(err);
                }
                var args = _baseSlice(arguments, 1);
                if (!test.apply(null, args)) {
                    async.doUntil(iterator, test, callback);
                }
                else {
                    callback(null);
                }
            });
        };
    
        async.during = function (test, iterator, callback) {
            callback = callback || noop;
            test(function(err, truth) {
                if (err) {
                    return callback(err);
                }
                if (truth) {
                    iterator(function (err) {
                        if (err) {
                            return callback(err);
                        }
                        async.during(test, iterator, callback);
                    });
                }
                else {
                    callback(null);
                }
            });
        };
    
        async.doDuring = function (iterator, test, callback) {
            callback = callback || noop;
            iterator(function (err) {
                if (err) {
                    return callback(err);
                }
                var args = _baseSlice(arguments, 1);
                args.push(function (err, truth) {
                    if (err) {
                       return callback(err);
                    }
                    if (truth) {
                        async.doDuring(iterator, test, callback);
                    }
                    else {
                        callback(null);
                    }
                });
                test.apply(null, args);
            });
        };
    
        function _queue(worker, concurrency, payload) {
            if (concurrency == null) {
                concurrency = 1;
            }
            else if(concurrency === 0) {
                throw new Error('Concurrency must not be zero');
            }
            function _insert(q, data, pos, callback) {
                if (callback != null && typeof callback !== "function") {
                    throw new Error("task callback must be a function");
                }
                q.started = true;
                if (!_isArray(data)) {
                    data = [data];
                }
                if(data.length === 0 && q.idle()) {
                    // call drain immediately if there are no tasks
                    return async.setImmediate(function() {
                       q.drain();
                    });
                }
                _arrayEach(data, function(task) {
                    var item = {
                        data: task,
                        callback: callback || noop
                    };
    
                    if (pos) {
                        q.tasks.unshift(item);
                    } else {
                        q.tasks.push(item);
                    }
    
                    if (q.tasks.length === q.concurrency) {
                        q.saturated();
                    }
                });
                async.setImmediate(q.process);
            }
            function _next(q, tasks) {
                return function(){
                    workers -= 1;
                    var args = arguments;
                    _arrayEach(tasks, function (task) {
                        task.callback.apply(task, args);
                    });
                    if (q.tasks.length + workers === 0) {
                        q.drain();
                    }
                    q.process();
                };
            }
    
            var workers = 0;
            var q = {
                tasks: [],
                concurrency: concurrency,
                payload: payload,
                saturated: noop,
                empty: noop,
                drain: noop,
                started: false,
                paused: false,
                push: function (data, callback) {
                    _insert(q, data, false, callback);
                },
                kill: function () {
                    q.drain = noop;
                    q.tasks = [];
                },
                unshift: function (data, callback) {
                    _insert(q, data, true, callback);
                },
                process: function () {
                    if (!q.paused && workers < q.concurrency && q.tasks.length) {
                        while(workers < q.concurrency && q.tasks.length){
                            var tasks = q.payload ?
                                q.tasks.splice(0, q.payload) :
                                q.tasks.splice(0, q.tasks.length);
    
                            var data = _map(tasks, function (task) {
                                return task.data;
                            });
    
                            if (q.tasks.length === 0) {
                                q.empty();
                            }
                            workers += 1;
                            var cb = only_once(_next(q, tasks));
                            worker(data, cb);
                        }
                    }
                },
                length: function () {
                    return q.tasks.length;
                },
                running: function () {
                    return workers;
                },
                idle: function() {
                    return q.tasks.length + workers === 0;
                },
                pause: function () {
                    q.paused = true;
                },
                resume: function () {
                    if (q.paused === false) { return; }
                    q.paused = false;
                    var resumeCount = Math.min(q.concurrency, q.tasks.length);
                    // Need to call q.process once per concurrent
                    // worker to preserve full concurrency after pause
                    for (var w = 1; w <= resumeCount; w++) {
                        async.setImmediate(q.process);
                    }
                }
            };
            return q;
        }
    
        async.queue = function (worker, concurrency) {
            var q = _queue(function (items, cb) {
                worker(items[0], cb);
            }, concurrency, 1);
    
            return q;
        };
    
        async.priorityQueue = function (worker, concurrency) {
    
            function _compareTasks(a, b){
                return a.priority - b.priority;
            }
    
            function _binarySearch(sequence, item, compare) {
              var beg = -1,
                  end = sequence.length - 1;
              while (beg < end) {
                  var mid = beg + ((end - beg + 1) >>> 1);
                  if (compare(item, sequence[mid]) >= 0) {
                      beg = mid;
                  } else {
                      end = mid - 1;
                  }
              }
              return beg;
            }
    
            function _insert(q, data, priority, callback) {
                if (callback != null && typeof callback !== "function") {
                    throw new Error("task callback must be a function");
                }
                q.started = true;
                if (!_isArray(data)) {
                    data = [data];
                }
                if(data.length === 0) {
                    // call drain immediately if there are no tasks
                    return async.setImmediate(function() {
                        q.drain();
                    });
                }
                _arrayEach(data, function(task) {
                    var item = {
                        data: task,
                        priority: priority,
                        callback: typeof callback === 'function' ? callback : noop
                    };
    
                    q.tasks.splice(_binarySearch(q.tasks, item, _compareTasks) + 1, 0, item);
    
                    if (q.tasks.length === q.concurrency) {
                        q.saturated();
                    }
                    async.setImmediate(q.process);
                });
            }
    
            // Start with a normal queue
            var q = async.queue(worker, concurrency);
    
            // Override push to accept second parameter representing priority
            q.push = function (data, priority, callback) {
                _insert(q, data, priority, callback);
            };
    
            // Remove unshift function
            delete q.unshift;
    
            return q;
        };
    
        async.cargo = function (worker, payload) {
            return _queue(worker, 1, payload);
        };
    
        function _console_fn(name) {
            return function (fn) {
                var args = _baseSlice(arguments, 1);
                fn.apply(null, args.concat([function (err) {
                    var args = _baseSlice(arguments, 1);
                    if (typeof console !== 'undefined') {
                        if (err) {
                            if (console.error) {
                                console.error(err);
                            }
                        }
                        else if (console[name]) {
                            _arrayEach(args, function (x) {
                                console[name](x);
                            });
                        }
                    }
                }]));
            };
        }
        async.log = _console_fn('log');
        async.dir = _console_fn('dir');
        /*async.info = _console_fn('info');
        async.warn = _console_fn('warn');
        async.error = _console_fn('error');*/
    
        async.memoize = function (fn, hasher) {
            var memo = {};
            var queues = {};
            hasher = hasher || function (x) {
                return x;
            };
            function memoized() {
                var args = _baseSlice(arguments);
                var callback = args.pop();
                var key = hasher.apply(null, args);
                if (key in memo) {
                    async.nextTick(function () {
                        callback.apply(null, memo[key]);
                    });
                }
                else if (key in queues) {
                    queues[key].push(callback);
                }
                else {
                    queues[key] = [callback];
                    fn.apply(null, args.concat([function () {
                        memo[key] = _baseSlice(arguments);
                        var q = queues[key];
                        delete queues[key];
                        for (var i = 0, l = q.length; i < l; i++) {
                          q[i].apply(null, arguments);
                        }
                    }]));
                }
            }
            memoized.memo = memo;
            memoized.unmemoized = fn;
            return memoized;
        };
    
        async.unmemoize = function (fn) {
            return function () {
                return (fn.unmemoized || fn).apply(null, arguments);
            };
        };
    
        function _times(mapper) {
            return function (count, iterator, callback) {
                mapper(_range(count), iterator, callback);
            };
        }
    
        async.times = _times(async.map);
        async.timesSeries = _times(async.mapSeries);
        async.timesLimit = function (count, limit, iterator, callback) {
            return async.mapLimit(_range(count), limit, iterator, callback);
        };
    
        async.seq = function (/* functions... */) {
            var fns = arguments;
            return function () {
                var that = this;
                var args = _baseSlice(arguments);
    
                var callback = args.slice(-1)[0];
                if (typeof callback == 'function') {
                    args.pop();
                } else {
                    callback = noop;
                }
    
                async.reduce(fns, args, function (newargs, fn, cb) {
                    fn.apply(that, newargs.concat([function () {
                        var err = arguments[0];
                        var nextargs = _baseSlice(arguments, 1);
                        cb(err, nextargs);
                    }]));
                },
                function (err, results) {
                    callback.apply(that, [err].concat(results));
                });
            };
        };
    
        async.compose = function (/* functions... */) {
            return async.seq.apply(null, Array.prototype.reverse.call(arguments));
        };
    
    
        function _applyEach(eachfn, fns /*args...*/) {
            function go() {
                var that = this;
                var args = _baseSlice(arguments);
                var callback = args.pop();
                return eachfn(fns, function (fn, _, cb) {
                    fn.apply(that, args.concat([cb]));
                },
                callback);
            }
            if (arguments.length > 2) {
                var args = _baseSlice(arguments, 2);
                return go.apply(this, args);
            }
            else {
                return go;
            }
        }
    
        async.applyEach = function (/*fns, args...*/) {
            var args = _baseSlice(arguments);
            return _applyEach.apply(null, [async.eachOf].concat(args));
        };
        async.applyEachSeries = function (/*fns, args...*/) {
            var args = _baseSlice(arguments);
            return _applyEach.apply(null, [async.eachOfSeries].concat(args));
        };
    
    
        async.forever = function (fn, callback) {
            var done = only_once(callback || noop);
            var task = ensureAsync(fn);
            function next(err) {
                if (err) {
                    return done(err);
                }
                task(next);
            }
            next();
        };
    
        function ensureAsync(fn) {
            return function (/*...args, callback*/) {
                var args = _baseSlice(arguments);
                var callback = args.pop();
                args.push(function () {
                    var innerArgs = arguments;
                    if (sync) {
                        async.setImmediate(function () {
                            callback.apply(null, innerArgs);
                        });
                    } else {
                        callback.apply(null, innerArgs);
                    }
                });
                var sync = true;
                fn.apply(this, args);
                sync = false;
            };
        }
    
        async.ensureAsync = ensureAsync;
    
        async.constant = function constant(/*values...*/) {
            var args = [null].concat(_baseSlice(arguments));
            return function (callback) {
                return callback.apply(this, args);
            };
        };
    
        async.wrapSync =
        async.asyncify = function asyncify(func) {
            return function (/*args..., callback*/) {
                var args = _baseSlice(arguments);
                var callback = args.pop();
                var result;
                try {
                    result = func.apply(this, args);
                } catch (e) {
                    return callback(e);
                }
                callback(null, result);
            };
        };
    
        // Node.js
        if (typeof module !== 'undefined' && module.exports) {
            module.exports = async;
        }
        // AMD / RequireJS
        else if (typeof define !== 'undefined' && define.amd) {
            define([], function () {
                return async;
            });
        }
        // included directly via <script> tag
        else {
            root.async = async;
        }
    
    }());
    
  provide("async", module.exports);
}(global));

// pakmanager:combined-stream
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var util = require('util');
    var Stream = require('stream').Stream;
    var DelayedStream = require('delayed-stream');
    
    module.exports = CombinedStream;
    function CombinedStream() {
      this.writable = false;
      this.readable = true;
      this.dataSize = 0;
      this.maxDataSize = 2 * 1024 * 1024;
      this.pauseStreams = true;
    
      this._released = false;
      this._streams = [];
      this._currentStream = null;
    }
    util.inherits(CombinedStream, Stream);
    
    CombinedStream.create = function(options) {
      var combinedStream = new this();
    
      options = options || {};
      for (var option in options) {
        combinedStream[option] = options[option];
      }
    
      return combinedStream;
    };
    
    CombinedStream.isStreamLike = function(stream) {
      return (typeof stream !== 'function')
        && (typeof stream !== 'string')
        && (typeof stream !== 'boolean')
        && (typeof stream !== 'number')
        && (!Buffer.isBuffer(stream));
    };
    
    CombinedStream.prototype.append = function(stream) {
      var isStreamLike = CombinedStream.isStreamLike(stream);
    
      if (isStreamLike) {
        if (!(stream instanceof DelayedStream)) {
          var newStream = DelayedStream.create(stream, {
            maxDataSize: Infinity,
            pauseStream: this.pauseStreams,
          });
          stream.on('data', this._checkDataSize.bind(this));
          stream = newStream;
        }
    
        this._handleErrors(stream);
    
        if (this.pauseStreams) {
          stream.pause();
        }
      }
    
      this._streams.push(stream);
      return this;
    };
    
    CombinedStream.prototype.pipe = function(dest, options) {
      Stream.prototype.pipe.call(this, dest, options);
      this.resume();
      return dest;
    };
    
    CombinedStream.prototype._getNext = function() {
      this._currentStream = null;
      var stream = this._streams.shift();
    
    
      if (typeof stream == 'undefined') {
        this.end();
        return;
      }
    
      if (typeof stream !== 'function') {
        this._pipeNext(stream);
        return;
      }
    
      var getStream = stream;
      getStream(function(stream) {
        var isStreamLike = CombinedStream.isStreamLike(stream);
        if (isStreamLike) {
          stream.on('data', this._checkDataSize.bind(this));
          this._handleErrors(stream);
        }
    
        this._pipeNext(stream);
      }.bind(this));
    };
    
    CombinedStream.prototype._pipeNext = function(stream) {
      this._currentStream = stream;
    
      var isStreamLike = CombinedStream.isStreamLike(stream);
      if (isStreamLike) {
        stream.on('end', this._getNext.bind(this));
        stream.pipe(this, {end: false});
        return;
      }
    
      var value = stream;
      this.write(value);
      this._getNext();
    };
    
    CombinedStream.prototype._handleErrors = function(stream) {
      var self = this;
      stream.on('error', function(err) {
        self._emitError(err);
      });
    };
    
    CombinedStream.prototype.write = function(data) {
      this.emit('data', data);
    };
    
    CombinedStream.prototype.pause = function() {
      if (!this.pauseStreams) {
        return;
      }
    
      if(this.pauseStreams && this._currentStream && typeof(this._currentStream.pause) == 'function') this._currentStream.pause();
      this.emit('pause');
    };
    
    CombinedStream.prototype.resume = function() {
      if (!this._released) {
        this._released = true;
        this.writable = true;
        this._getNext();
      }
    
      if(this.pauseStreams && this._currentStream && typeof(this._currentStream.resume) == 'function') this._currentStream.resume();
      this.emit('resume');
    };
    
    CombinedStream.prototype.end = function() {
      this._reset();
      this.emit('end');
    };
    
    CombinedStream.prototype.destroy = function() {
      this._reset();
      this.emit('close');
    };
    
    CombinedStream.prototype._reset = function() {
      this.writable = false;
      this._streams = [];
      this._currentStream = null;
    };
    
    CombinedStream.prototype._checkDataSize = function() {
      this._updateDataSize();
      if (this.dataSize <= this.maxDataSize) {
        return;
      }
    
      var message =
        'DelayedStream#maxDataSize of ' + this.maxDataSize + ' bytes exceeded.';
      this._emitError(new Error(message));
    };
    
    CombinedStream.prototype._updateDataSize = function() {
      this.dataSize = 0;
    
      var self = this;
      this._streams.forEach(function(stream) {
        if (!stream.dataSize) {
          return;
        }
    
        self.dataSize += stream.dataSize;
      });
    
      if (this._currentStream && this._currentStream.dataSize) {
        this.dataSize += this._currentStream.dataSize;
      }
    };
    
    CombinedStream.prototype._emitError = function(err) {
      this._reset();
      this.emit('error', err);
    };
    
  provide("combined-stream", module.exports);
}(global));

// pakmanager:mime-types
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*!
     * mime-types
     * Copyright(c) 2014 Jonathan Ong
     * Copyright(c) 2015 Douglas Christopher Wilson
     * MIT Licensed
     */
    
    'use strict'
    
    /**
     * Module dependencies.
     * @private
     */
    
    var db = require('mime-db')
    var extname = require('path').extname
    
    /**
     * Module variables.
     * @private
     */
    
    var extractTypeRegExp = /^\s*([^;\s]*)(?:;|\s|$)/
    var textTypeRegExp = /^text\//i
    
    /**
     * Module exports.
     * @public
     */
    
    exports.charset = charset
    exports.charsets = { lookup: charset }
    exports.contentType = contentType
    exports.extension = extension
    exports.extensions = Object.create(null)
    exports.lookup = lookup
    exports.types = Object.create(null)
    
    // Populate the extensions/types maps
    populateMaps(exports.extensions, exports.types)
    
    /**
     * Get the default charset for a MIME type.
     *
     * @param {string} type
     * @return {boolean|string}
     */
    
    function charset(type) {
      if (!type || typeof type !== 'string') {
        return false
      }
    
      // TODO: use media-typer
      var match = extractTypeRegExp.exec(type)
      var mime = match && db[match[1].toLowerCase()]
    
      if (mime && mime.charset) {
        return mime.charset
      }
    
      // default text/* to utf-8
      if (match && textTypeRegExp.test(match[1])) {
        return 'UTF-8'
      }
    
      return false
    }
    
    /**
     * Create a full Content-Type header given a MIME type or extension.
     *
     * @param {string} str
     * @return {boolean|string}
     */
    
    function contentType(str) {
      // TODO: should this even be in this module?
      if (!str || typeof str !== 'string') {
        return false
      }
    
      var mime = str.indexOf('/') === -1
        ? exports.lookup(str)
        : str
    
      if (!mime) {
        return false
      }
    
      // TODO: use content-type or other module
      if (mime.indexOf('charset') === -1) {
        var charset = exports.charset(mime)
        if (charset) mime += '; charset=' + charset.toLowerCase()
      }
    
      return mime
    }
    
    /**
     * Get the default extension for a MIME type.
     *
     * @param {string} type
     * @return {boolean|string}
     */
    
    function extension(type) {
      if (!type || typeof type !== 'string') {
        return false
      }
    
      // TODO: use media-typer
      var match = extractTypeRegExp.exec(type)
    
      // get extensions
      var exts = match && exports.extensions[match[1].toLowerCase()]
    
      if (!exts || !exts.length) {
        return false
      }
    
      return exts[0]
    }
    
    /**
     * Lookup the MIME type for a file path/extension.
     *
     * @param {string} path
     * @return {boolean|string}
     */
    
    function lookup(path) {
      if (!path || typeof path !== 'string') {
        return false
      }
    
      // get the extension ("ext" or ".ext" or full path)
      var extension = extname('x.' + path)
        .toLowerCase()
        .substr(1)
    
      if (!extension) {
        return false
      }
    
      return exports.types[extension] || false
    }
    
    /**
     * Populate the extensions and types maps.
     * @private
     */
    
    function populateMaps(extensions, types) {
      // source preference (least -> most)
      var preference = ['nginx', 'apache', undefined, 'iana']
    
      Object.keys(db).forEach(function forEachMimeType(type) {
        var mime = db[type]
        var exts = mime.extensions
    
        if (!exts || !exts.length) {
          return
        }
    
        // mime -> extensions
        extensions[type] = exts
    
        // extension -> mime
        for (var i = 0; i < exts.length; i++) {
          var extension = exts[i]
    
          if (types[extension]) {
            var from = preference.indexOf(db[types[extension]].source)
            var to = preference.indexOf(mime.source)
    
            if (types[extension] !== 'application/octet-stream'
              && from > to || (from === to && types[extension].substr(0, 12) === 'application/')) {
              // skip the remapping
              return
            }
          }
    
          // set the extension -> mime
          types[extension] = type
        }
      })
    }
    
  provide("mime-types", module.exports);
}(global));

// pakmanager:assert-plus
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Copyright (c) 2012, Mark Cavage. All rights reserved.
    
    var assert = require('assert');
    var Stream = require('stream').Stream;
    var util = require('util');
    
    
    
    ///--- Globals
    
    var NDEBUG = process.env.NODE_NDEBUG || false;
    var UUID_REGEXP = /^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/;
    
    
    
    ///--- Messages
    
    var ARRAY_TYPE_REQUIRED = '%s ([%s]) required';
    var TYPE_REQUIRED = '%s (%s) is required';
    
    
    
    ///--- Internal
    
    function capitalize(str) {
            return (str.charAt(0).toUpperCase() + str.slice(1));
    }
    
    function uncapitalize(str) {
            return (str.charAt(0).toLowerCase() + str.slice(1));
    }
    
    function _() {
            return (util.format.apply(util, arguments));
    }
    
    
    function _assert(arg, type, name, stackFunc) {
            if (!NDEBUG) {
                    name = name || type;
                    stackFunc = stackFunc || _assert.caller;
                    var t = typeof (arg);
    
                    if (t !== type) {
                            throw new assert.AssertionError({
                                    message: _(TYPE_REQUIRED, name, type),
                                    actual: t,
                                    expected: type,
                                    operator: '===',
                                    stackStartFunction: stackFunc
                            });
                    }
            }
    }
    
    
    function _instanceof(arg, type, name, stackFunc) {
            if (!NDEBUG) {
                    name = name || type;
                    stackFunc = stackFunc || _instanceof.caller;
    
                    if (!(arg instanceof type)) {
                            throw new assert.AssertionError({
                                    message: _(TYPE_REQUIRED, name, type.name),
                                    actual: _getClass(arg),
                                    expected: type.name,
                                    operator: 'instanceof',
                                    stackStartFunction: stackFunc
                            });
                    }
            }
    }
    
    function _getClass(object) {
            return (Object.prototype.toString.call(object).slice(8, -1));
    };
    
    
    
    ///--- API
    
    function array(arr, type, name) {
            if (!NDEBUG) {
                    name = name || type;
    
                    if (!Array.isArray(arr)) {
                            throw new assert.AssertionError({
                                    message: _(ARRAY_TYPE_REQUIRED, name, type),
                                    actual: typeof (arr),
                                    expected: 'array',
                                    operator: 'Array.isArray',
                                    stackStartFunction: array.caller
                            });
                    }
    
                    for (var i = 0; i < arr.length; i++) {
                            _assert(arr[i], type, name, array);
                    }
            }
    }
    
    
    function bool(arg, name) {
            _assert(arg, 'boolean', name, bool);
    }
    
    
    function buffer(arg, name) {
            if (!Buffer.isBuffer(arg)) {
                    throw new assert.AssertionError({
                            message: _(TYPE_REQUIRED, name || '', 'Buffer'),
                            actual: typeof (arg),
                            expected: 'buffer',
                            operator: 'Buffer.isBuffer',
                            stackStartFunction: buffer
                    });
            }
    }
    
    
    function func(arg, name) {
            _assert(arg, 'function', name);
    }
    
    
    function number(arg, name) {
            _assert(arg, 'number', name);
            if (!NDEBUG && (isNaN(arg) || !isFinite(arg))) {
                    throw new assert.AssertionError({
                            message: _(TYPE_REQUIRED, name, 'number'),
                            actual: arg,
                            expected: 'number',
                            operator: 'isNaN',
                            stackStartFunction: number
                    });
            }
    }
    
    
    function object(arg, name) {
            _assert(arg, 'object', name);
    }
    
    
    function stream(arg, name) {
            _instanceof(arg, Stream, name);
    }
    
    
    function date(arg, name) {
            _instanceof(arg, Date, name);
    }
    
    function regexp(arg, name) {
            _instanceof(arg, RegExp, name);
    }
    
    
    function string(arg, name) {
            _assert(arg, 'string', name);
    }
    
    
    function uuid(arg, name) {
            string(arg, name);
            if (!NDEBUG && !UUID_REGEXP.test(arg)) {
                    throw new assert.AssertionError({
                            message: _(TYPE_REQUIRED, name, 'uuid'),
                            actual: 'string',
                            expected: 'uuid',
                            operator: 'test',
                            stackStartFunction: uuid
                    });
            }
    }
    
    
    ///--- Exports
    
    module.exports = {
            bool: bool,
            buffer: buffer,
            date: date,
            func: func,
            number: number,
            object: object,
            regexp: regexp,
            stream: stream,
            string: string,
            uuid: uuid
    };
    
    
    Object.keys(module.exports).forEach(function (k) {
            if (k === 'buffer')
                    return;
    
            var name = 'arrayOf' + capitalize(k);
    
            if (k === 'bool')
                    k = 'boolean';
            if (k === 'func')
                    k = 'function';
            module.exports[name] = function (arg, name) {
                    array(arg, k, name);
            };
    });
    
    Object.keys(module.exports).forEach(function (k) {
            var _name = 'optional' + capitalize(k);
            var s = uncapitalize(k.replace('arrayOf', ''));
            if (s === 'bool')
                    s = 'boolean';
            if (s === 'func')
                    s = 'function';
    
            if (k.indexOf('arrayOf') !== -1) {
              module.exports[_name] = function (arg, name) {
                      if (!NDEBUG && arg !== undefined) {
                              array(arg, s, name);
                      }
              };
            } else {
              module.exports[_name] = function (arg, name) {
                      if (!NDEBUG && arg !== undefined) {
                              _assert(arg, s, name);
                      }
              };
            }
    });
    
    
    // Reexport built-in assertions
    Object.keys(assert).forEach(function (k) {
            if (k === 'AssertionError') {
                    module.exports[k] = assert[k];
                    return;
            }
    
            module.exports[k] = function () {
                    if (!NDEBUG) {
                            assert[k].apply(assert[k], arguments);
                    }
            };
    });
    
  provide("assert-plus", module.exports);
}(global));

// pakmanager:asn1/lib/ber/types
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Copyright 2011 Mark Cavage <mcavage@gmail.com> All rights reserved.
    
    
    module.exports = {
      EOC: 0,
      Boolean: 1,
      Integer: 2,
      BitString: 3,
      OctetString: 4,
      Null: 5,
      OID: 6,
      ObjectDescriptor: 7,
      External: 8,
      Real: 9, // float
      Enumeration: 10,
      PDV: 11,
      Utf8String: 12,
      RelativeOID: 13,
      Sequence: 16,
      Set: 17,
      NumericString: 18,
      PrintableString: 19,
      T61String: 20,
      VideotexString: 21,
      IA5String: 22,
      UTCTime: 23,
      GeneralizedTime: 24,
      GraphicString: 25,
      VisibleString: 26,
      GeneralString: 28,
      UniversalString: 29,
      CharacterString: 30,
      BMPString: 31,
      Constructor: 32,
      Context: 128
    };
    
  provide("asn1/lib/ber/types", module.exports);
}(global));

// pakmanager:asn1/lib/ber/errors
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Copyright 2011 Mark Cavage <mcavage@gmail.com> All rights reserved.
    
    
    module.exports = {
    
      newInvalidAsn1Error: function(msg) {
        var e = new Error();
        e.name = 'InvalidAsn1Error';
        e.message = msg || '';
        return e;
      }
    
    };
    
  provide("asn1/lib/ber/errors", module.exports);
}(global));

// pakmanager:asn1/lib/ber/reader
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Copyright 2011 Mark Cavage <mcavage@gmail.com> All rights reserved.
    
    var assert = require('assert');
    
    var ASN1 =  require('asn1/lib/ber/types');
    var errors =  require('asn1/lib/ber/errors');
    
    
    ///--- Globals
    
    var newInvalidAsn1Error = errors.newInvalidAsn1Error;
    
    
    
    ///--- API
    
    function Reader(data) {
      if (!data || !Buffer.isBuffer(data))
        throw new TypeError('data must be a node Buffer');
    
      this._buf = data;
      this._size = data.length;
    
      // These hold the "current" state
      this._len = 0;
      this._offset = 0;
    
      var self = this;
      this.__defineGetter__('length', function() { return self._len; });
      this.__defineGetter__('offset', function() { return self._offset; });
      this.__defineGetter__('remain', function() {
        return self._size - self._offset;
      });
      this.__defineGetter__('buffer', function() {
        return self._buf.slice(self._offset);
      });
    }
    
    
    /**
     * Reads a single byte and advances offset; you can pass in `true` to make this
     * a "peek" operation (i.e., get the byte, but don't advance the offset).
     *
     * @param {Boolean} peek true means don't move offset.
     * @return {Number} the next byte, null if not enough data.
     */
    Reader.prototype.readByte = function(peek) {
      if (this._size - this._offset < 1)
        return null;
    
      var b = this._buf[this._offset] & 0xff;
    
      if (!peek)
        this._offset += 1;
    
      return b;
    };
    
    
    Reader.prototype.peek = function() {
      return this.readByte(true);
    };
    
    
    /**
     * Reads a (potentially) variable length off the BER buffer.  This call is
     * not really meant to be called directly, as callers have to manipulate
     * the internal buffer afterwards.
     *
     * As a result of this call, you can call `Reader.length`, until the
     * next thing called that does a readLength.
     *
     * @return {Number} the amount of offset to advance the buffer.
     * @throws {InvalidAsn1Error} on bad ASN.1
     */
    Reader.prototype.readLength = function(offset) {
      if (offset === undefined)
        offset = this._offset;
    
      if (offset >= this._size)
        return null;
    
      var lenB = this._buf[offset++] & 0xff;
      if (lenB === null)
        return null;
    
      if ((lenB & 0x80) == 0x80) {
        lenB &= 0x7f;
    
        if (lenB == 0)
          throw newInvalidAsn1Error('Indefinite length not supported');
    
        if (lenB > 4)
          throw newInvalidAsn1Error('encoding too long');
    
        if (this._size - offset < lenB)
          return null;
    
        this._len = 0;
        for (var i = 0; i < lenB; i++)
          this._len = (this._len << 8) + (this._buf[offset++] & 0xff);
    
      } else {
        // Wasn't a variable length
        this._len = lenB;
      }
    
      return offset;
    };
    
    
    /**
     * Parses the next sequence in this BER buffer.
     *
     * To get the length of the sequence, call `Reader.length`.
     *
     * @return {Number} the sequence's tag.
     */
    Reader.prototype.readSequence = function(tag) {
      var seq = this.peek();
      if (seq === null)
        return null;
      if (tag !== undefined && tag !== seq)
        throw newInvalidAsn1Error('Expected 0x' + tag.toString(16) +
                                  ': got 0x' + seq.toString(16));
    
      var o = this.readLength(this._offset + 1); // stored in `length`
      if (o === null)
        return null;
    
      this._offset = o;
      return seq;
    };
    
    
    Reader.prototype.readInt = function() {
      return this._readTag(ASN1.Integer);
    };
    
    
    Reader.prototype.readBoolean = function() {
      return (this._readTag(ASN1.Boolean) === 0 ? false : true);
    };
    
    
    Reader.prototype.readEnumeration = function() {
      return this._readTag(ASN1.Enumeration);
    };
    
    
    Reader.prototype.readString = function(tag, retbuf) {
      if (!tag)
        tag = ASN1.OctetString;
    
      var b = this.peek();
      if (b === null)
        return null;
    
      if (b !== tag)
        throw newInvalidAsn1Error('Expected 0x' + tag.toString(16) +
                                  ': got 0x' + b.toString(16));
    
      var o = this.readLength(this._offset + 1); // stored in `length`
    
      if (o === null)
        return null;
    
      if (this.length > this._size - o)
        return null;
    
      this._offset = o;
    
      if (this.length === 0)
        return retbuf ? new Buffer(0) : '';
    
      var str = this._buf.slice(this._offset, this._offset + this.length);
      this._offset += this.length;
    
      return retbuf ? str : str.toString('utf8');
    };
    
    Reader.prototype.readOID = function(tag) {
      if (!tag)
        tag = ASN1.OID;
    
      var b = this.readString(tag, true);
      if (b === null)
        return null;
    
      var values = [];
      var value = 0;
    
      for (var i = 0; i < b.length; i++) {
        var byte = b[i] & 0xff;
    
        value <<= 7;
        value += byte & 0x7f;
        if ((byte & 0x80) == 0) {
          values.push(value);
          value = 0;
        }
      }
    
      value = values.shift();
      values.unshift(value % 40);
      values.unshift((value / 40) >> 0);
    
      return values.join('.');
    };
    
    
    Reader.prototype._readTag = function(tag) {
      assert.ok(tag !== undefined);
    
      var b = this.peek();
    
      if (b === null)
        return null;
    
      if (b !== tag)
        throw newInvalidAsn1Error('Expected 0x' + tag.toString(16) +
                                  ': got 0x' + b.toString(16));
    
      var o = this.readLength(this._offset + 1); // stored in `length`
      if (o === null)
        return null;
    
      if (this.length > 4)
        throw newInvalidAsn1Error('Integer too long: ' + this.length);
    
      if (this.length > this._size - o)
        return null;
      this._offset = o;
    
      var fb = this._buf[this._offset];
      var value = 0;
    
      for (var i = 0; i < this.length; i++) {
        value <<= 8;
        value |= (this._buf[this._offset++] & 0xff);
      }
    
      if ((fb & 0x80) == 0x80 && i !== 4)
        value -= (1 << (i * 8));
    
      return value >> 0;
    };
    
    
    
    ///--- Exported API
    
    module.exports = Reader;
    
  provide("asn1/lib/ber/reader", module.exports);
}(global));

// pakmanager:asn1/lib/ber/writer
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Copyright 2011 Mark Cavage <mcavage@gmail.com> All rights reserved.
    
    var assert = require('assert');
    var ASN1 =  require('asn1/lib/ber/types');
    var errors =  require('asn1/lib/ber/errors');
    
    
    ///--- Globals
    
    var newInvalidAsn1Error = errors.newInvalidAsn1Error;
    
    var DEFAULT_OPTS = {
      size: 1024,
      growthFactor: 8
    };
    
    
    ///--- Helpers
    
    function merge(from, to) {
      assert.ok(from);
      assert.equal(typeof(from), 'object');
      assert.ok(to);
      assert.equal(typeof(to), 'object');
    
      var keys = Object.getOwnPropertyNames(from);
      keys.forEach(function(key) {
        if (to[key])
          return;
    
        var value = Object.getOwnPropertyDescriptor(from, key);
        Object.defineProperty(to, key, value);
      });
    
      return to;
    }
    
    
    
    ///--- API
    
    function Writer(options) {
      options = merge(DEFAULT_OPTS, options || {});
    
      this._buf = new Buffer(options.size || 1024);
      this._size = this._buf.length;
      this._offset = 0;
      this._options = options;
    
      // A list of offsets in the buffer where we need to insert
      // sequence tag/len pairs.
      this._seq = [];
    
      var self = this;
      this.__defineGetter__('buffer', function() {
        if (self._seq.length)
          throw new InvalidAsn1Error(self._seq.length + ' unended sequence(s)');
    
        return self._buf.slice(0, self._offset);
      });
    }
    
    
    Writer.prototype.writeByte = function(b) {
      if (typeof(b) !== 'number')
        throw new TypeError('argument must be a Number');
    
      this._ensure(1);
      this._buf[this._offset++] = b;
    };
    
    
    Writer.prototype.writeInt = function(i, tag) {
      if (typeof(i) !== 'number')
        throw new TypeError('argument must be a Number');
      if (typeof(tag) !== 'number')
        tag = ASN1.Integer;
    
      var sz = 4;
    
      while ((((i & 0xff800000) === 0) || ((i & 0xff800000) === 0xff800000 >> 0)) &&
             (sz > 1)) {
        sz--;
        i <<= 8;
      }
    
      if (sz > 4)
        throw new InvalidAsn1Error('BER ints cannot be > 0xffffffff');
    
      this._ensure(2 + sz);
      this._buf[this._offset++] = tag;
      this._buf[this._offset++] = sz;
    
      while (sz-- > 0) {
        this._buf[this._offset++] = ((i & 0xff000000) >>> 24);
        i <<= 8;
      }
    
    };
    
    
    Writer.prototype.writeNull = function() {
      this.writeByte(ASN1.Null);
      this.writeByte(0x00);
    };
    
    
    Writer.prototype.writeEnumeration = function(i, tag) {
      if (typeof(i) !== 'number')
        throw new TypeError('argument must be a Number');
      if (typeof(tag) !== 'number')
        tag = ASN1.Enumeration;
    
      return this.writeInt(i, tag);
    };
    
    
    Writer.prototype.writeBoolean = function(b, tag) {
      if (typeof(b) !== 'boolean')
        throw new TypeError('argument must be a Boolean');
      if (typeof(tag) !== 'number')
        tag = ASN1.Boolean;
    
      this._ensure(3);
      this._buf[this._offset++] = tag;
      this._buf[this._offset++] = 0x01;
      this._buf[this._offset++] = b ? 0xff : 0x00;
    };
    
    
    Writer.prototype.writeString = function(s, tag) {
      if (typeof(s) !== 'string')
        throw new TypeError('argument must be a string (was: ' + typeof(s) + ')');
      if (typeof(tag) !== 'number')
        tag = ASN1.OctetString;
    
      var len = Buffer.byteLength(s);
      this.writeByte(tag);
      this.writeLength(len);
      if (len) {
        this._ensure(len);
        this._buf.write(s, this._offset);
        this._offset += len;
      }
    };
    
    
    Writer.prototype.writeBuffer = function(buf, tag) {
      if (typeof(tag) !== 'number')
        throw new TypeError('tag must be a number');
      if (!Buffer.isBuffer(buf))
        throw new TypeError('argument must be a buffer');
    
      this.writeByte(tag);
      this.writeLength(buf.length);
      this._ensure(buf.length);
      buf.copy(this._buf, this._offset, 0, buf.length);
      this._offset += buf.length;
    };
    
    
    Writer.prototype.writeStringArray = function(strings) {
      if ((!strings instanceof Array))
        throw new TypeError('argument must be an Array[String]');
    
      var self = this;
      strings.forEach(function(s) {
        self.writeString(s);
      });
    };
    
    // This is really to solve DER cases, but whatever for now
    Writer.prototype.writeOID = function(s, tag) {
      if (typeof(s) !== 'string')
        throw new TypeError('argument must be a string');
      if (typeof(tag) !== 'number')
        tag = ASN1.OID;
    
      if (!/^([0-9]+\.){3,}[0-9]+$/.test(s))
        throw new Error('argument is not a valid OID string');
    
      function encodeOctet(bytes, octet) {
        if (octet < 128) {
            bytes.push(octet);
        } else if (octet < 16384) {
            bytes.push((octet >>> 7) | 0x80);
            bytes.push(octet & 0x7F);
        } else if (octet < 2097152) {
          bytes.push((octet >>> 14) | 0x80);
          bytes.push(((octet >>> 7) | 0x80) & 0xFF);
          bytes.push(octet & 0x7F);
        } else if (octet < 268435456) {
          bytes.push((octet >>> 21) | 0x80);
          bytes.push(((octet >>> 14) | 0x80) & 0xFF);
          bytes.push(((octet >>> 7) | 0x80) & 0xFF);
          bytes.push(octet & 0x7F);
        } else {
          bytes.push(((octet >>> 28) | 0x80) & 0xFF);
          bytes.push(((octet >>> 21) | 0x80) & 0xFF);
          bytes.push(((octet >>> 14) | 0x80) & 0xFF);
          bytes.push(((octet >>> 7) | 0x80) & 0xFF);
          bytes.push(octet & 0x7F);
        }
      }
    
      var tmp = s.split('.');
      var bytes = [];
      bytes.push(parseInt(tmp[0], 10) * 40 + parseInt(tmp[1], 10));
      tmp.slice(2).forEach(function(b) {
        encodeOctet(bytes, parseInt(b, 10));
      });
    
      var self = this;
      this._ensure(2 + bytes.length);
      this.writeByte(tag);
      this.writeLength(bytes.length);
      bytes.forEach(function(b) {
        self.writeByte(b);
      });
    };
    
    
    Writer.prototype.writeLength = function(len) {
      if (typeof(len) !== 'number')
        throw new TypeError('argument must be a Number');
    
      this._ensure(4);
    
      if (len <= 0x7f) {
        this._buf[this._offset++] = len;
      } else if (len <= 0xff) {
        this._buf[this._offset++] = 0x81;
        this._buf[this._offset++] = len;
      } else if (len <= 0xffff) {
        this._buf[this._offset++] = 0x82;
        this._buf[this._offset++] = len >> 8;
        this._buf[this._offset++] = len;
      } else if (len <= 0xffffff) {
        this._buf[this._offset++] = 0x83;
        this._buf[this._offset++] = len >> 16;
        this._buf[this._offset++] = len >> 8;
        this._buf[this._offset++] = len;
      } else {
        throw new InvalidAsn1ERror('Length too long (> 4 bytes)');
      }
    };
    
    Writer.prototype.startSequence = function(tag) {
      if (typeof(tag) !== 'number')
        tag = ASN1.Sequence | ASN1.Constructor;
    
      this.writeByte(tag);
      this._seq.push(this._offset);
      this._ensure(3);
      this._offset += 3;
    };
    
    
    Writer.prototype.endSequence = function() {
      var seq = this._seq.pop();
      var start = seq + 3;
      var len = this._offset - start;
    
      if (len <= 0x7f) {
        this._shift(start, len, -2);
        this._buf[seq] = len;
      } else if (len <= 0xff) {
        this._shift(start, len, -1);
        this._buf[seq] = 0x81;
        this._buf[seq + 1] = len;
      } else if (len <= 0xffff) {
        this._buf[seq] = 0x82;
        this._buf[seq + 1] = len >> 8;
        this._buf[seq + 2] = len;
      } else if (len <= 0xffffff) {
        this._shift(start, len, 1);
        this._buf[seq] = 0x83;
        this._buf[seq + 1] = len >> 16;
        this._buf[seq + 2] = len >> 8;
        this._buf[seq + 3] = len;
      } else {
        throw new InvalidAsn1Error('Sequence too long');
      }
    };
    
    
    Writer.prototype._shift = function(start, len, shift) {
      assert.ok(start !== undefined);
      assert.ok(len !== undefined);
      assert.ok(shift);
    
      this._buf.copy(this._buf, start + shift, start, start + len);
      this._offset += shift;
    };
    
    Writer.prototype._ensure = function(len) {
      assert.ok(len);
    
      if (this._size - this._offset < len) {
        var sz = this._size * this._options.growthFactor;
        if (sz - this._offset < len)
          sz += len;
    
        var buf = new Buffer(sz);
    
        this._buf.copy(buf, 0, 0, this._offset);
        this._buf = buf;
        this._size = sz;
      }
    };
    
    
    
    ///--- Exported API
    
    module.exports = Writer;
    
  provide("asn1/lib/ber/writer", module.exports);
}(global));

// pakmanager:asn1/lib/ber/index
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Copyright 2011 Mark Cavage <mcavage@gmail.com> All rights reserved.
    
    var errors =  require('asn1/lib/ber/errors');
    var types =  require('asn1/lib/ber/types');
    
    var Reader =  require('asn1/lib/ber/reader');
    var Writer =  require('asn1/lib/ber/writer');
    
    
    ///--- Exports
    
    module.exports = {
    
      Reader: Reader,
    
      Writer: Writer
    
    };
    
    for (var t in types) {
      if (types.hasOwnProperty(t))
        module.exports[t] = types[t];
    }
    for (var e in errors) {
      if (errors.hasOwnProperty(e))
        module.exports[e] = errors[e];
    }
    
  provide("asn1/lib/ber/index", module.exports);
}(global));

// pakmanager:asn1
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Copyright 2011 Mark Cavage <mcavage@gmail.com> All rights reserved.
    
    // If you have no idea what ASN.1 or BER is, see this:
    // ftp://ftp.rsa.com/pub/pkcs/ascii/layman.asc
    
    var Ber =  require('asn1/lib/ber/index');
    
    
    
    ///--- Exported API
    
    module.exports = {
    
      Ber: Ber,
    
      BerReader: Ber.Reader,
    
      BerWriter: Ber.Writer
    
    };
    
  provide("asn1", module.exports);
}(global));

// pakmanager:ctype/ctf.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*
     * ctf.js
     *
     * Understand and parse all of the different JSON formats of CTF data and
     * translate that into a series of node-ctype friendly pieces. The reason for
     * the abstraction is to handle different changes in the file format.
     *
     * We have to be careful here that we don't end up using a name that is already
     * a built in type.
     */
    var mod_assert = require('assert');
    var ASSERT = mod_assert.ok;
    
    var ctf_versions = [ '1.0' ];
    var ctf_entries = [ 'integer', 'float', 'typedef', 'struct' ];
    var ctf_deftypes = [ 'int8_t', 'uint8_t', 'int16_t', 'uint16_t', 'int32_t',
        'uint32_t', 'float', 'double' ];
    
    function ctfParseInteger(entry, ctype)
    {
    	var name, sign, len, type;
    
    	name = entry['name'];
    	if (!('signed' in entry['integer']))
    		throw (new Error('Malformed CTF JSON: integer missing ' +
    		    'signed value'));
    
    
    	if (!('length' in entry['integer']))
    		throw (new Error('Malformed CTF JSON: integer missing ' +
    		    'length value'));
    
    	sign = entry['integer']['signed'];
    	len = entry['integer']['length'];
    	type = null;
    
    	if (sign && len == 1)
    		type = 'int8_t';
    	else if (len == 1)
    		type = 'uint8_t';
    	else if (sign && len == 2)
    		type = 'int16_t';
    	else if (len == 2)
    		type = 'uint16_t';
    	else if (sign && len == 4)
    		type = 'int32_t';
    	else if (len == 4)
    		type = 'uint32_t';
    	else if (sign && len == 8)
    		type = 'int64_t';
    	else if (len == 8)
    		type = 'uint64_t';
    
    	if (type === null)
    		throw (new Error('Malformed CTF JSON: integer has ' +
    		    'unsupported length and sign - ' + len + '/' + sign));
    
    	/*
    	 * This means that this is the same as one of our built in types. If
    	 * that's the case defining it would be an error. So instead of trying
    	 * to typedef it, we'll return here.
    	 */
    	if (name == type)
    		return;
    
    	if (name == 'char') {
    		ASSERT(type == 'int8_t');
    		return;
    	}
    
    	ctype.typedef(name, type);
    }
    
    function ctfParseFloat(entry, ctype)
    {
    	var name, len;
    
    	name = entry['name'];
    	if (!('length' in entry['float']))
    		throw (new Error('Malformed CTF JSON: float missing ' +
    		    'length value'));
    
    	len = entry['float']['length'];
    	if (len != 4 && len != 8)
    		throw (new Error('Malformed CTF JSON: float has invalid ' +
    		    'length value'));
    
    	if (len == 4) {
    		if (name == 'float')
    			return;
    		ctype.typedef(name, 'float');
    	} else if (len == 8) {
    		if (name == 'double')
    			return;
    		ctype.typedef(name, 'double');
    	}
    }
    
    function ctfParseTypedef(entry, ctype)
    {
    	var name, type, ii;
    
    	name = entry['name'];
    	if (typeof (entry['typedef']) != 'string')
    		throw (new Error('Malformed CTF JSON: typedef value in not ' +
    		    'a string'));
    
    	type = entry['typedef'];
    
    	/*
    	 * We need to ensure that we're not looking at type that's one of our
    	 * built in types. Traditionally in C a uint32_t would be a typedef to
    	 * some kind of integer. However, those size types are built ins.
    	 */
    	for (ii = 0; ii < ctf_deftypes.length; ii++) {
    		if (name == ctf_deftypes[ii])
    			return;
    	}
    
    	ctype.typedef(name, type);
    }
    
    function ctfParseStruct(entry, ctype)
    {
    	var name, type, ii, val, index, member, push;
    
    	member = [];
    	if (!Array.isArray(entry['struct']))
    		throw (new Error('Malformed CTF JSON: struct value is not ' +
    		    'an array'));
    
    	for (ii = 0; ii < entry['struct'].length; ii++) {
    		val = entry['struct'][ii];
    		if (!('name' in val))
    			throw (new Error('Malformed CTF JSON: struct member ' +
    			    'missing name'));
    
    		if (!('type' in val))
    			throw (new Error('Malformed CTF JSON: struct member ' +
    			    'missing type'));
    
    		if (typeof (val['name']) != 'string')
    			throw (new Error('Malformed CTF JSON: struct member ' +
    			    'name isn\'t a string'));
    
    		if (typeof (val['type']) != 'string')
    			throw (new Error('Malformed CTF JSON: struct member ' +
    			    'type isn\'t a string'));
    
    		/*
    		 * CTF version 2 specifies array names as <type> [<num>] where
    		 * as node-ctype does this as <type>[<num>].
    		 */
    		name = val['name'];
    		type = val['type'];
    		index = type.indexOf(' [');
    		if (index != -1) {
    			type = type.substring(0, index) +
    			    type.substring(index + 1, type.length);
    		}
    		push = {};
    		push[name] = { 'type': type };
    		member.push(push);
    	}
    
    	name = entry['name'];
    	ctype.typedef(name, member);
    }
    
    function ctfParseEntry(entry, ctype)
    {
    	var ii, found;
    
    	if (!('name' in entry))
    		throw (new Error('Malformed CTF JSON: entry missing "name" ' +
    		    'section'));
    
    	for (ii = 0; ii < ctf_entries.length; ii++) {
    		if (ctf_entries[ii] in entry)
    			found++;
    	}
    
    	if (found === 0)
    		throw (new Error('Malformed CTF JSON: found no entries'));
    
    	if (found >= 2)
    		throw (new Error('Malformed CTF JSON: found more than one ' +
    		    'entry'));
    
    	if ('integer' in entry) {
    		ctfParseInteger(entry, ctype);
    		return;
    	}
    
    	if ('float' in entry) {
    		ctfParseFloat(entry, ctype);
    		return;
    	}
    
    	if ('typedef' in entry) {
    		ctfParseTypedef(entry, ctype);
    		return;
    	}
    
    	if ('struct' in entry) {
    		ctfParseStruct(entry, ctype);
    		return;
    	}
    
    	ASSERT(false, 'shouldn\'t reach here');
    }
    
    function ctfParseJson(json, ctype)
    {
    	var version, ii;
    
    	ASSERT(json);
    	ASSERT(ctype);
    	if (!('metadata' in json))
    		throw (new Error('Invalid CTF JSON: missing metadata section'));
    
    	if (!('ctf2json_version' in json['metadata']))
    		throw (new Error('Invalid CTF JSON: missing ctf2json_version'));
    
    	version = json['metadata']['ctf2json_version'];
    	for (ii = 0; ii < ctf_versions.length; ii++) {
    		if (ctf_versions[ii] == version)
    			break;
    	}
    
    	if (ii == ctf_versions.length)
    		throw (new Error('Unsuported ctf2json_version: ' + version));
    
    	if (!('data' in json))
    		throw (new Error('Invalid CTF JSON: missing data section'));
    
    	if (!Array.isArray(json['data']))
    		throw (new Error('Malformed CTF JSON: data section is not ' +
    		    'an array'));
    
    	for (ii = 0; ii < json['data'].length; ii++)
    		ctfParseEntry(json['data'][ii], ctype);
    }
    
    exports.ctfParseJson = ctfParseJson;
    
  provide("ctype/ctf.js", module.exports);
}(global));

// pakmanager:ctype/ctio.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*
     * rm - Feb 2011
     * ctio.js:
     *
     * A simple way to read and write simple ctypes. Of course, as you'll find the
     * code isn't as simple as it might appear. The following types are currently
     * supported in big and little endian formats:
     *
     * 	uint8_t			int8_t
     * 	uint16_t		int16_t
     * 	uint32_t		int32_t
     *	float (single precision IEEE 754)
     *	double (double precision IEEE 754)
     *
     * This is designed to work in Node and v8. It may in fact work in other
     * Javascript interpreters (that'd be pretty neat), but it hasn't been tested.
     * If you find that it does in fact work, that's pretty cool. Try and pass word
     * back to the original author.
     *
     * Note to the reader: If you're tabstop isn't set to 8, parts of this may look
     * weird.
     */
    
    /*
     * Numbers in Javascript have a secret: all numbers must be represented with an
     * IEEE-754 double. The double has a mantissa with a length of 52 bits with an
     * implicit one. Thus the range of integers that can be represented is limited
     * to the size of the mantissa, this makes reading and writing 64-bit integers
     * difficult, but far from impossible.
     *
     * Another side effect of this representation is what happens when you use the
     * bitwise operators, i.e. shift left, shift right, and, or, etc. In Javascript,
     * each operand and the result is cast to a signed 32-bit number. However, in
     * the case of >>> the values are cast to an unsigned number.
     */
    
    /*
     * A reminder on endian related issues:
     *
     * Big Endian: MSB -> First byte
     * Little Endian: MSB->Last byte
     */
    var mod_assert = require('assert');
    
    /*
     * An 8 bit unsigned integer involves doing no significant work.
     */
    function ruint8(buffer, endian, offset)
    {
    	if (endian === undefined)
    		throw (new Error('missing endian'));
    
    	if (buffer === undefined)
    		throw (new Error('missing buffer'));
    
    	if (offset === undefined)
    		throw (new Error('missing offset'));
    
    	if (offset >= buffer.length)
    		throw (new Error('Trying to read beyond buffer length'));
    
    	return (buffer[offset]);
    }
    
    /*
     * For 16 bit unsigned numbers we can do all the casting that we want to do.
     */
    function rgint16(buffer, endian, offset)
    {
    	var val = 0;
    
    	if (endian == 'big') {
    		val = buffer[offset] << 8;
    		val |=  buffer[offset+1];
    	} else {
    		val = buffer[offset];
    		val |= buffer[offset+1] << 8;
    	}
    
    	return (val);
    
    }
    
    function ruint16(buffer, endian, offset)
    {
    	if (endian === undefined)
    		throw (new Error('missing endian'));
    
    	if (buffer === undefined)
    		throw (new Error('missing buffer'));
    
    	if (offset === undefined)
    		throw (new Error('missing offset'));
    
    	if (offset + 1 >= buffer.length)
    		throw (new Error('Trying to read beyond buffer length'));
    
    	return (rgint16(buffer, endian, offset));
    }
    
    /*
     * Because most bitshifting is done using signed numbers, if we would go into
     * the realm where we use that 32nd bit, we'll end up going into the negative
     * range. i.e.:
     * > 200 << 24
     * -939524096
     *
     * Not the value you'd expect. To work around this, we end up having to do some
     * abuse of the JavaScript standard. in this case, we know that a >>> shift is
     * defined to cast our value to an *unsigned* 32-bit number. Because of that, we
     * use that instead to save us some additional math, though it does feel a
     * little weird and it isn't obvious as to why you woul dwant to do this at
     * first.
     */
    function rgint32(buffer, endian, offset)
    {
    	var val = 0;
    
    	if (endian == 'big') {
    		val = buffer[offset+1] << 16;
    		val |= buffer[offset+2] << 8;
    		val |= buffer[offset+3];
    		val = val + (buffer[offset] << 24 >>> 0);
    	} else {
    		val = buffer[offset+2] << 16;
    		val |= buffer[offset+1] << 8;
    		val |= buffer[offset];
    		val = val + (buffer[offset + 3] << 24 >>> 0);
    	}
    
    	return (val);
    }
    
    function ruint32(buffer, endian, offset)
    {
    	if (endian === undefined)
    		throw (new Error('missing endian'));
    
    	if (buffer === undefined)
    		throw (new Error('missing buffer'));
    
    	if (offset === undefined)
    		throw (new Error('missing offset'));
    
    	if (offset + 3 >= buffer.length)
    		throw (new Error('Trying to read beyond buffer length'));
    
    	return (rgint32(buffer, endian, offset));
    }
    
    /*
     * Reads a 64-bit unsigned number. The astue observer will note that this
     * doesn't quite work. Javascript has chosen to only have numbers that can be
     * represented by a double. A double only has 52 bits of mantissa with an
     * implicit 1, thus we have up to 53 bits to represent an integer. However, 2^53
     * doesn't quite give us what we want. Isn't 53 bits enough for anyone? What
     * could you have possibly wanted to represent that was larger than that? Oh,
     * maybe a size? You mean we bypassed the 4 GB limit on file sizes, when did
     * that happen?
     *
     * To get around this egregious language issue, we're going to instead construct
     * an array of two 32 bit unsigned integers. Where arr[0] << 32 + arr[1] would
     * give the actual number. However, note that the above code probably won't
     * produce the desired results because of the way Javascript numbers are
     * doubles.
     */
    function rgint64(buffer, endian, offset)
    {
    	var val = new Array(2);
    
    	if (endian == 'big') {
    		val[0] = ruint32(buffer, endian, offset);
    		val[1] = ruint32(buffer, endian, offset+4);
    	} else {
    		val[0] = ruint32(buffer, endian, offset+4);
    		val[1] = ruint32(buffer, endian, offset);
    	}
    
    	return (val);
    }
    
    function ruint64(buffer, endian, offset)
    {
    	if (endian === undefined)
    		throw (new Error('missing endian'));
    
    	if (buffer === undefined)
    		throw (new Error('missing buffer'));
    
    	if (offset === undefined)
    		throw (new Error('missing offset'));
    
    	if (offset + 7 >= buffer.length)
    		throw (new Error('Trying to read beyond buffer length'));
    
    	return (rgint64(buffer, endian, offset));
    }
    
    
    /*
     * Signed integer types, yay team! A reminder on how two's complement actually
     * works. The first bit is the signed bit, i.e. tells us whether or not the
     * number should be positive or negative. If the two's complement value is
     * positive, then we're done, as it's equivalent to the unsigned representation.
     *
     * Now if the number is positive, you're pretty much done, you can just leverage
     * the unsigned translations and return those. Unfortunately, negative numbers
     * aren't quite that straightforward.
     *
     * At first glance, one might be inclined to use the traditional formula to
     * translate binary numbers between the positive and negative values in two's
     * complement. (Though it doesn't quite work for the most negative value)
     * Mainly:
     *  - invert all the bits
     *  - add one to the result
     *
     * Of course, this doesn't quite work in Javascript. Take for example the value
     * of -128. This could be represented in 16 bits (big-endian) as 0xff80. But of
     * course, Javascript will do the following:
     *
     * > ~0xff80
     * -65409
     *
     * Whoh there, Javascript, that's not quite right. But wait, according to
     * Javascript that's perfectly correct. When Javascript ends up seeing the
     * constant 0xff80, it has no notion that it is actually a signed number. It
     * assumes that we've input the unsigned value 0xff80. Thus, when it does the
     * binary negation, it casts it into a signed value, (positive 0xff80). Then
     * when you perform binary negation on that, it turns it into a negative number.
     *
     * Instead, we're going to have to use the following general formula, that works
     * in a rather Javascript friendly way. I'm glad we don't support this kind of
     * weird numbering scheme in the kernel.
     *
     * (BIT-MAX - (unsigned)val + 1) * -1
     *
     * The astute observer, may think that this doesn't make sense for 8-bit numbers
     * (really it isn't necessary for them). However, when you get 16-bit numbers,
     * you do. Let's go back to our prior example and see how this will look:
     *
     * (0xffff - 0xff80 + 1) * -1
     * (0x007f + 1) * -1
     * (0x0080) * -1
     *
     * Doing it this way ends up allowing us to treat it appropriately in
     * Javascript. Sigh, that's really quite ugly for what should just be a few bit
     * shifts, ~ and &.
     */
    
    /*
     * Endianness doesn't matter for 8-bit signed values. We could in fact optimize
     * this case because the more traditional methods work, but for consistency,
     * we'll keep doing this the same way.
     */
    function rsint8(buffer, endian, offset)
    {
    	var neg;
    
    	if (endian === undefined)
    		throw (new Error('missing endian'));
    
    	if (buffer === undefined)
    		throw (new Error('missing buffer'));
    
    	if (offset === undefined)
    		throw (new Error('missing offset'));
    
    	if (offset >= buffer.length)
    		throw (new Error('Trying to read beyond buffer length'));
    
    	neg = buffer[offset] & 0x80;
    	if (!neg)
    		return (buffer[offset]);
    
    	return ((0xff - buffer[offset] + 1) * -1);
    }
    
    /*
     * The 16-bit version requires a bit more effort. In this case, we can leverage
     * our unsigned code to generate the value we want to return.
     */
    function rsint16(buffer, endian, offset)
    {
    	var neg, val;
    
    	if (endian === undefined)
    		throw (new Error('missing endian'));
    
    	if (buffer === undefined)
    		throw (new Error('missing buffer'));
    
    	if (offset === undefined)
    		throw (new Error('missing offset'));
    
    	if (offset + 1 >= buffer.length)
    		throw (new Error('Trying to read beyond buffer length'));
    
    	val = rgint16(buffer, endian, offset);
    	neg = val & 0x8000;
    	if (!neg)
    		return (val);
    
    	return ((0xffff - val + 1) * -1);
    }
    
    /*
     * We really shouldn't leverage our 32-bit code here and instead utilize the
     * fact that we know that since these are signed numbers, we can do all the
     * shifting and binary anding to generate the 32-bit number. But, for
     * consistency we'll do the same. If we want to do otherwise, we should instead
     * make the 32 bit unsigned code do the optimization. But as long as there
     * aren't floats secretly under the hood for that, we /should/ be okay.
     */
    function rsint32(buffer, endian, offset)
    {
    	var neg, val;
    
    	if (endian === undefined)
    		throw (new Error('missing endian'));
    
    	if (buffer === undefined)
    		throw (new Error('missing buffer'));
    
    	if (offset === undefined)
    		throw (new Error('missing offset'));
    
    	if (offset + 3 >= buffer.length)
    		throw (new Error('Trying to read beyond buffer length'));
    
    	val = rgint32(buffer, endian, offset);
    	neg = val & 0x80000000;
    	if (!neg)
    		return (val);
    
    	return ((0xffffffff - val + 1) * -1);
    }
    
    /*
     * The signed version of this code suffers from all of the same problems of the
     * other 64 bit version.
     */
    function rsint64(buffer, endian, offset)
    {
    	var neg, val;
    
    	if (endian === undefined)
    		throw (new Error('missing endian'));
    
    	if (buffer === undefined)
    		throw (new Error('missing buffer'));
    
    	if (offset === undefined)
    		throw (new Error('missing offset'));
    
    	if (offset + 3 >= buffer.length)
    		throw (new Error('Trying to read beyond buffer length'));
    
    	val = rgint64(buffer, endian, offset);
    	neg = val[0] & 0x80000000;
    
    	if (!neg)
    		return (val);
    
    	val[0] = (0xffffffff - val[0]) * -1;
    	val[1] = (0xffffffff - val[1] + 1) * -1;
    
    	/*
    	 * If we had the key 0x8000000000000000, that would leave the lower 32
    	 * bits as 0xffffffff, however, since we're goint to add one, that would
    	 * actually leave the lower 32-bits as 0x100000000, which would break
    	 * our ability to write back a value that we received. To work around
    	 * this, if we actually get that value, we're going to bump the upper
    	 * portion by 1 and set this to zero.
    	 */
    	mod_assert.ok(val[1] <= 0x100000000);
    	if (val[1] == -0x100000000) {
    		val[1] = 0;
    		val[0]--;
    	}
    
    	return (val);
    }
    
    /*
     * We now move onto IEEE 754: The traditional form for floating point numbers
     * and what is secretly hiding at the heart of everything in this. I really hope
     * that someone is actually using this, as otherwise, this effort is probably
     * going to be more wasted.
     *
     * One might be tempted to use parseFloat here, but that wouldn't work at all
     * for several reasons. Mostly due to the way floats actually work, and
     * parseFloat only actually works in base 10. I don't see base 10 anywhere near
     * this file.
     *
     * In this case we'll implement the single and double precision versions. The
     * quadruple precision, while probably useful, wouldn't really be accepted by
     * Javascript, so let's not even waste our time.
     *
     * So let's review how this format looks like. A single precision value is 32
     * bits and has three parts:
     *   -  Sign bit
     *   -  Exponent (Using bias notation)
     *   -  Mantissa
     *
     * |s|eeeeeeee|mmmmmmmmmmmmmmmmmmmmmmmmm|
     * 31| 30-23  |  22    	-       0       |
     *
     * The exponent is stored in a biased input. The bias in this case 127.
     * Therefore, our exponent is equal to the 8-bit value - 127.
     *
     * By default, a number is normalized in IEEE, that means that the mantissa has
     * an implicit one that we don't see. So really the value stored is 1.m.
     * However, if the exponent is all zeros, then instead we have to shift
     * everything to the right one and there is no more implicit one.
     *
     * Special values:
     *  - Positive Infinity:
     *	Sign:		0
     *	Exponent: 	All 1s
     *	Mantissa:	0
     *  - Negative Infinity:
     *	Sign:		1
     *	Exponent: 	All 1s
     *	Mantissa:	0
     *  - NaN:
     *	Sign:		*
     *	Exponent: 	All 1s
     *	Mantissa:	non-zero
     *  - Zero:
     *	Sign:		*
     *	Exponent:	All 0s
     *	Mantissa:	0
     *
     * In the case of zero, the sign bit determines whether we get a positive or
     * negative zero. However, since Javascript cannot determine the difference
     * between the two: i.e. -0 == 0, we just always return 0.
     *
     */
    function rfloat(buffer, endian, offset)
    {
    	var bytes = [];
    	var sign, exponent, mantissa, val;
    	var bias = 127;
    	var maxexp = 0xff;
    
    	if (endian === undefined)
    		throw (new Error('missing endian'));
    
    	if (buffer === undefined)
    		throw (new Error('missing buffer'));
    
    	if (offset === undefined)
    		throw (new Error('missing offset'));
    
    	if (offset + 3 >= buffer.length)
    		throw (new Error('Trying to read beyond buffer length'));
    
    	/* Normalize the bytes to be in endian order */
    	if (endian == 'big') {
    		bytes[0] = buffer[offset];
    		bytes[1] = buffer[offset+1];
    		bytes[2] = buffer[offset+2];
    		bytes[3] = buffer[offset+3];
    	} else {
    		bytes[3] = buffer[offset];
    		bytes[2] = buffer[offset+1];
    		bytes[1] = buffer[offset+2];
    		bytes[0] = buffer[offset+3];
    	}
    
    	sign = bytes[0] & 0x80;
    	exponent = (bytes[0] & 0x7f) << 1;
    	exponent |= (bytes[1] & 0x80) >>> 7;
    	mantissa = (bytes[1] & 0x7f) << 16;
    	mantissa |= bytes[2] << 8;
    	mantissa |= bytes[3];
    
    	/* Check for special cases before we do general parsing */
    	if (!sign && exponent == maxexp && mantissa === 0)
    		return (Number.POSITIVE_INFINITY);
    
    	if (sign && exponent == maxexp && mantissa === 0)
    		return (Number.NEGATIVE_INFINITY);
    
    	if (exponent == maxexp && mantissa !== 0)
    		return (Number.NaN);
    
    	/*
    	 * Javascript really doesn't have support for positive or negative zero.
    	 * So we're not going to try and give it to you. That would be just
    	 * plain weird. Besides -0 == 0.
    	 */
    	if (exponent === 0 && mantissa === 0)
    		return (0);
    
    	/*
    	 * Now we can deal with the bias and the determine whether the mantissa
    	 * has the implicit one or not.
    	 */
    	exponent -= bias;
    	if (exponent == -bias) {
    		exponent++;
    		val = 0;
    	} else {
    		val = 1;
    	}
    
    	val = (val + mantissa * Math.pow(2, -23)) * Math.pow(2, exponent);
    
    	if (sign)
    		val *= -1;
    
    	return (val);
    }
    
    /*
     * Doubles in IEEE 754 are like their brothers except for a few changes and
     * increases in size:
     *   - The exponent is now 11 bits
     *   - The mantissa is now 52 bits
     *   - The bias is now 1023
     *
     * |s|eeeeeeeeeee|mmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmm|
     * 63| 62 - 52   | 	51		-			0     |
     * 63| 62 - 52   |      51              -                       0     |
     *
     * While the size has increased a fair amount, we're going to end up keeping the
     * same general formula for calculating the final value. As a reminder, this
     * formula is:
     *
     * (-1)^s * (n + m) * 2^(e-b)
     *
     * Where:
     *	s	is the sign bit
     *	n	is (exponent > 0) ? 1 : 0 -- Determines whether we're normalized
     *					     or not
     *	m	is the mantissa
     *	e	is the exponent specified
     *	b	is the bias for the exponent
     *
     */
    function rdouble(buffer, endian, offset)
    {
    	var bytes = [];
    	var sign, exponent, mantissa, val, lowmant;
    	var bias = 1023;
    	var maxexp = 0x7ff;
    
    	if (endian === undefined)
    		throw (new Error('missing endian'));
    
    	if (buffer === undefined)
    		throw (new Error('missing buffer'));
    
    	if (offset === undefined)
    		throw (new Error('missing offset'));
    
    	if (offset + 7 >= buffer.length)
    		throw (new Error('Trying to read beyond buffer length'));
    
    	/* Normalize the bytes to be in endian order */
    	if (endian == 'big') {
    		bytes[0] = buffer[offset];
    		bytes[1] = buffer[offset+1];
    		bytes[2] = buffer[offset+2];
    		bytes[3] = buffer[offset+3];
    		bytes[4] = buffer[offset+4];
    		bytes[5] = buffer[offset+5];
    		bytes[6] = buffer[offset+6];
    		bytes[7] = buffer[offset+7];
    	} else {
    		bytes[7] = buffer[offset];
    		bytes[6] = buffer[offset+1];
    		bytes[5] = buffer[offset+2];
    		bytes[4] = buffer[offset+3];
    		bytes[3] = buffer[offset+4];
    		bytes[2] = buffer[offset+5];
    		bytes[1] = buffer[offset+6];
    		bytes[0] = buffer[offset+7];
    	}
    
    	/*
    	 * We can construct the exponent and mantissa the same way as we did in
    	 * the case of a float, just increase the range of the exponent.
    	 */
    	sign = bytes[0] & 0x80;
    	exponent = (bytes[0] & 0x7f) << 4;
    	exponent |= (bytes[1] & 0xf0) >>> 4;
    
    	/*
    	 * This is going to be ugly but then again, we're dealing with IEEE 754.
    	 * This could probably be done as a node add on in a few lines of C++,
    	 * but oh we'll, we've made it this far so let's be native the rest of
    	 * the way...
    	 *
    	 * What we're going to do is break the mantissa into two parts, the
    	 * lower 24 bits and the upper 28 bits. We'll multiply the upper 28 bits
    	 * by the appropriate power and then add in the lower 24-bits. Not
    	 * really that great. It's pretty much a giant kludge to deal with
    	 * Javascript eccentricities around numbers.
    	 */
    	lowmant = bytes[7];
    	lowmant |= bytes[6] << 8;
    	lowmant |= bytes[5] << 16;
    	mantissa = bytes[4];
    	mantissa |= bytes[3] << 8;
    	mantissa |= bytes[2] << 16;
    	mantissa |= (bytes[1] & 0x0f) << 24;
    	mantissa *= Math.pow(2, 24); /* Equivalent to << 24, but JS compat */
    	mantissa += lowmant;
    
    	/* Check for special cases before we do general parsing */
    	if (!sign && exponent == maxexp && mantissa === 0)
    		return (Number.POSITIVE_INFINITY);
    
    	if (sign && exponent == maxexp && mantissa === 0)
    		return (Number.NEGATIVE_INFINITY);
    
    	if (exponent == maxexp && mantissa !== 0)
    		return (Number.NaN);
    
    	/*
    	 * Javascript really doesn't have support for positive or negative zero.
    	 * So we're not going to try and give it to you. That would be just
    	 * plain weird. Besides -0 == 0.
    	 */
    	if (exponent === 0 && mantissa === 0)
    		return (0);
    
    	/*
    	 * Now we can deal with the bias and the determine whether the mantissa
    	 * has the implicit one or not.
    	 */
    	exponent -= bias;
    	if (exponent == -bias) {
    		exponent++;
    		val = 0;
    	} else {
    		val = 1;
    	}
    
    	val = (val + mantissa * Math.pow(2, -52)) * Math.pow(2, exponent);
    
    	if (sign)
    		val *= -1;
    
    	return (val);
    }
    
    /*
     * Now that we have gone through the pain of reading the individual types, we're
     * probably going to want some way to write these back. None of this is going to
     * be good. But since we have Javascript numbers this should certainly be more
     * interesting. Though we can constrain this end a little bit more in what is
     * valid. For now, let's go back to our friends the unsigned value.
     */
    
    /*
     * Unsigned numbers seem deceptively easy. Here are the general steps and rules
     * that we are going to take:
     *   -  If the number is negative, throw an Error
     *   -  Truncate any floating point portion
     *   -  Take the modulus of the number in our base
     *   -  Write it out to the buffer in the endian format requested at the offset
     */
    
    /*
     * We have to make sure that the value is a valid integer. This means that it is
     * non-negative. It has no fractional component and that it does not exceed the
     * maximum allowed value.
     *
     *	value		The number to check for validity
     *
     *	max		The maximum value
     */
    function prepuint(value, max)
    {
    	if (typeof (value) != 'number')
    		throw (new (Error('cannot write a non-number as a number')));
    
    	if (value < 0)
    		throw (new Error('specified a negative value for writing an ' +
    		    'unsigned value'));
    
    	if (value > max)
    		throw (new Error('value is larger than maximum value for ' +
    		    'type'));
    
    	if (Math.floor(value) !== value)
    		throw (new Error('value has a fractional component'));
    
    	return (value);
    }
    
    /*
     * 8-bit version, classy. We can ignore endianness which is good.
     */
    function wuint8(value, endian, buffer, offset)
    {
    	var val;
    
    	if (value === undefined)
    		throw (new Error('missing value'));
    
    	if (endian === undefined)
    		throw (new Error('missing endian'));
    
    	if (buffer === undefined)
    		throw (new Error('missing buffer'));
    
    	if (offset === undefined)
    		throw (new Error('missing offset'));
    
    	if (offset >= buffer.length)
    		throw (new Error('Trying to read beyond buffer length'));
    
    	val = prepuint(value, 0xff);
    	buffer[offset] = val;
    }
    
    /*
     * Pretty much the same as the 8-bit version, just this time we need to worry
     * about endian related issues.
     */
    function wgint16(val, endian, buffer, offset)
    {
    	if (endian == 'big') {
    		buffer[offset] = (val & 0xff00) >>> 8;
    		buffer[offset+1] = val & 0x00ff;
    	} else {
    		buffer[offset+1] = (val & 0xff00) >>> 8;
    		buffer[offset] = val & 0x00ff;
    	}
    }
    
    function wuint16(value, endian, buffer, offset)
    {
    	var val;
    
    	if (value === undefined)
    		throw (new Error('missing value'));
    
    	if (endian === undefined)
    		throw (new Error('missing endian'));
    
    	if (buffer === undefined)
    		throw (new Error('missing buffer'));
    
    	if (offset === undefined)
    		throw (new Error('missing offset'));
    
    	if (offset + 1 >= buffer.length)
    		throw (new Error('Trying to read beyond buffer length'));
    
    	val = prepuint(value, 0xffff);
    	wgint16(val, endian, buffer, offset);
    }
    
    /*
     * The 32-bit version is going to have to be a little different unfortunately.
     * We can't quite bitshift to get the largest byte, because that would end up
     * getting us caught by the signed values.
     *
     * And yes, we do want to subtract out the lower part by default. This means
     * that when we do the division, it will be treated as a bit shift and we won't
     * end up generating a floating point value. If we did generate a floating point
     * value we'd have to truncate it intelligently, this saves us that problem and
     * may even be somewhat faster under the hood.
     */
    function wgint32(val, endian, buffer, offset)
    {
    	if (endian == 'big') {
    		buffer[offset] = (val - (val & 0x00ffffff)) / Math.pow(2, 24);
    		buffer[offset+1] = (val >>> 16) & 0xff;
    		buffer[offset+2] = (val >>> 8) & 0xff;
    		buffer[offset+3] = val & 0xff;
    	} else {
    		buffer[offset+3] = (val - (val & 0x00ffffff)) /
    		    Math.pow(2, 24);
    		buffer[offset+2] = (val >>> 16) & 0xff;
    		buffer[offset+1] = (val >>> 8) & 0xff;
    		buffer[offset] = val & 0xff;
    	}
    }
    
    function wuint32(value, endian, buffer, offset)
    {
    	var val;
    
    	if (value === undefined)
    		throw (new Error('missing value'));
    
    	if (endian === undefined)
    		throw (new Error('missing endian'));
    
    	if (buffer === undefined)
    		throw (new Error('missing buffer'));
    
    	if (offset === undefined)
    		throw (new Error('missing offset'));
    
    	if (offset + 3 >= buffer.length)
    		throw (new Error('Trying to read beyond buffer length'));
    
    	val = prepuint(value, 0xffffffff);
    	wgint32(val, endian, buffer, offset);
    }
    
    /*
     * Unlike the other versions, we expect the value to be in the form of two
     * arrays where value[0] << 32 + value[1] would result in the value that we
     * want.
     */
    function wgint64(value, endian, buffer, offset)
    {
    	if (endian == 'big') {
    		wgint32(value[0], endian, buffer, offset);
    		wgint32(value[1], endian, buffer, offset+4);
    	} else {
    		wgint32(value[0], endian, buffer, offset+4);
    		wgint32(value[1], endian, buffer, offset);
    	}
    }
    
    function wuint64(value, endian, buffer, offset)
    {
    	if (value === undefined)
    		throw (new Error('missing value'));
    
    	if (!(value instanceof Array))
    		throw (new Error('value must be an array'));
    
    	if (value.length != 2)
    		throw (new Error('value must be an array of length 2'));
    
    	if (endian === undefined)
    		throw (new Error('missing endian'));
    
    	if (buffer === undefined)
    		throw (new Error('missing buffer'));
    
    	if (offset === undefined)
    		throw (new Error('missing offset'));
    
    	if (offset + 7 >= buffer.length)
    		throw (new Error('Trying to read beyond buffer length'));
    
    	prepuint(value[0], 0xffffffff);
    	prepuint(value[1], 0xffffffff);
    	wgint64(value, endian, buffer, offset);
    }
    
    /*
     * We now move onto our friends in the signed number category. Unlike unsigned
     * numbers, we're going to have to worry a bit more about how we put values into
     * arrays. Since we are only worrying about signed 32-bit values, we're in
     * slightly better shape. Unfortunately, we really can't do our favorite binary
     * & in this system. It really seems to do the wrong thing. For example:
     *
     * > -32 & 0xff
     * 224
     *
     * What's happening above is really: 0xe0 & 0xff = 0xe0. However, the results of
     * this aren't treated as a signed number. Ultimately a bad thing.
     *
     * What we're going to want to do is basically create the unsigned equivalent of
     * our representation and pass that off to the wuint* functions. To do that
     * we're going to do the following:
     *
     *  - if the value is positive
     *	we can pass it directly off to the equivalent wuint
     *  - if the value is negative
     *	we do the following computation:
     *	mb + val + 1, where
     *	mb	is the maximum unsigned value in that byte size
     *	val	is the Javascript negative integer
     *
     *
     * As a concrete value, take -128. In signed 16 bits this would be 0xff80. If
     * you do out the computations:
     *
     * 0xffff - 128 + 1
     * 0xffff - 127
     * 0xff80
     *
     * You can then encode this value as the signed version. This is really rather
     * hacky, but it should work and get the job done which is our goal here.
     *
     * Thus the overall flow is:
     *   -  Truncate the floating point part of the number
     *   -  We don't have to take the modulus, because the unsigned versions will
     *   	take care of that for us. And we don't have to worry about that
     *   	potentially causing bad things to happen because of sign extension
     *   -  Pass it off to the appropriate unsigned version, potentially modifying
     *	the negative portions as necessary.
     */
    
    /*
     * A series of checks to make sure we actually have a signed 32-bit number
     */
    function prepsint(value, max, min)
    {
    	if (typeof (value) != 'number')
    		throw (new (Error('cannot write a non-number as a number')));
    
    	if (value > max)
    		throw (new Error('value larger than maximum allowed value'));
    
    	if (value < min)
    		throw (new Error('value smaller than minimum allowed value'));
    
    	if (Math.floor(value) !== value)
    		throw (new Error('value has a fractional component'));
    
    	return (value);
    }
    
    /*
     * The 8-bit version of the signed value. Overall, fairly straightforward.
     */
    function wsint8(value, endian, buffer, offset)
    {
    	var val;
    
    	if (value === undefined)
    		throw (new Error('missing value'));
    
    	if (endian === undefined)
    		throw (new Error('missing endian'));
    
    	if (buffer === undefined)
    		throw (new Error('missing buffer'));
    
    	if (offset === undefined)
    		throw (new Error('missing offset'));
    
    	if (offset >= buffer.length)
    		throw (new Error('Trying to read beyond buffer length'));
    
    	val = prepsint(value, 0x7f, -0x80);
    	if (val >= 0)
    		wuint8(val, endian, buffer, offset);
    	else
    		wuint8(0xff + val + 1, endian, buffer, offset);
    }
    
    /*
     * The 16-bit version of the signed value. Also, fairly straightforward.
     */
    function wsint16(value, endian, buffer, offset)
    {
    	var val;
    
    	if (value === undefined)
    		throw (new Error('missing value'));
    
    	if (endian === undefined)
    		throw (new Error('missing endian'));
    
    	if (buffer === undefined)
    		throw (new Error('missing buffer'));
    
    	if (offset === undefined)
    		throw (new Error('missing offset'));
    
    	if (offset + 1 >= buffer.length)
    		throw (new Error('Trying to read beyond buffer length'));
    
    	val = prepsint(value, 0x7fff, -0x8000);
    	if (val >= 0)
    		wgint16(val, endian, buffer, offset);
    	else
    		wgint16(0xffff + val + 1, endian, buffer, offset);
    
    }
    
    /*
     * We can do this relatively easily by leveraging the code used for 32-bit
     * unsigned code.
     */
    function wsint32(value, endian, buffer, offset)
    {
    	var val;
    
    	if (value === undefined)
    		throw (new Error('missing value'));
    
    	if (endian === undefined)
    		throw (new Error('missing endian'));
    
    	if (buffer === undefined)
    		throw (new Error('missing buffer'));
    
    	if (offset === undefined)
    		throw (new Error('missing offset'));
    
    	if (offset + 3 >= buffer.length)
    		throw (new Error('Trying to read beyond buffer length'));
    
    	val = prepsint(value, 0x7fffffff, -0x80000000);
    	if (val >= 0)
    		wgint32(val, endian, buffer, offset);
    	else
    		wgint32(0xffffffff + val + 1, endian, buffer, offset);
    }
    
    /*
     * The signed 64 bit integer should by in the same format as when received.
     * Mainly it should ensure that the value is an array of two integers where
     * value[0] << 32 + value[1] is the desired number. Furthermore, the two values
     * need to be equal.
     */
    function wsint64(value, endian, buffer, offset)
    {
    	var vzpos, vopos;
    	var vals = new Array(2);
    
    	if (value === undefined)
    		throw (new Error('missing value'));
    
    	if (!(value instanceof Array))
    		throw (new Error('value must be an array'));
    
    	if (value.length != 2)
    		throw (new Error('value must be an array of length 2'));
    
    	if (endian === undefined)
    		throw (new Error('missing endian'));
    
    	if (buffer === undefined)
    		throw (new Error('missing buffer'));
    
    	if (offset === undefined)
    		throw (new Error('missing offset'));
    
    	if (offset + 7 >= buffer.length)
    		throw (new Error('Trying to read beyond buffer length'));
    
    	/*
    	 * We need to make sure that we have the same sign on both values. The
    	 * hokiest way to to do this is to multiply the number by +inf. If we do
    	 * this, we'll get either +/-inf depending on the sign of the value.
    	 * Once we have this, we can compare it to +inf to see if the number is
    	 * positive or not.
    	 */
    	vzpos = (value[0] * Number.POSITIVE_INFINITY) ==
    	    Number.POSITIVE_INFINITY;
    	vopos = (value[1] * Number.POSITIVE_INFINITY) ==
    	    Number.POSITIVE_INFINITY;
    
    	/*
    	 * If either of these is zero, then we don't actually need this check.
    	 */
    	if (value[0] != 0 && value[1] != 0 && vzpos != vopos)
    		throw (new Error('Both entries in the array must have ' +
    		    'the same sign'));
    
    	/*
    	 * Doing verification for a signed 64-bit integer is actually a big
    	 * trickier than it appears. We can't quite use our standard techniques
    	 * because we need to compare both sets of values. The first value is
    	 * pretty straightforward. If the first value is beond the extremes than
    	 * we error out. However, the valid range of the second value varies
    	 * based on the first one. If the first value is negative, and *not* the
    	 * largest negative value, than it can be any integer within the range [
    	 * 0, 0xffffffff ]. If it is the largest negative number, it must be
    	 * zero.
    	 *
    	 * If the first number is positive, than it doesn't matter what the
    	 * value is. We just simply have to make sure we have a valid positive
    	 * integer.
    	 */
    	if (vzpos) {
    		prepuint(value[0], 0x7fffffff);
    		prepuint(value[1], 0xffffffff);
    	} else {
    		prepsint(value[0], 0, -0x80000000);
    		prepsint(value[1], 0, -0xffffffff);
    		if (value[0] == -0x80000000 && value[1] != 0)
    			throw (new Error('value smaller than minimum ' +
    			    'allowed value'));
    	}
    
    	/* Fix negative numbers */
    	if (value[0] < 0 || value[1] < 0) {
    		vals[0] = 0xffffffff - Math.abs(value[0]);
    		vals[1] = 0x100000000 - Math.abs(value[1]);
    		if (vals[1] == 0x100000000) {
    			vals[1] = 0;
    			vals[0]++;
    		}
    	} else {
    		vals[0] = value[0];
    		vals[1] = value[1];
    	}
    	wgint64(vals, endian, buffer, offset);
    }
    
    /*
     * Now we are moving onto the weirder of these, the float and double. For this
     * we're going to just have to do something that's pretty weird. First off, we
     * have no way to get at the underlying float representation, at least not
     * easily. But that doesn't mean we can't figure it out, we just have to use our
     * heads.
     *
     * One might propose to use Number.toString(2). Of course, this is not really
     * that good, because the ECMAScript 262 v3 Standard says the following Section
     * 15.7.4.2-Number.prototype.toString (radix):
     *
     * If radix is an integer from 2 to 36, but not 10, the result is a string, the
     * choice of which is implementation-dependent.
     *
     * Well that doesn't really help us one bit now does it? We could use the
     * standard base 10 version of the string, but that's just going to create more
     * errors as we end up trying to convert it back to a binary value. So, really
     * this just means we have to be non-lazy and parse the structure intelligently.
     *
     * First off, we can do the basic checks: NaN, positive and negative infinity.
     *
     * Now that those are done we can work backwards to generate the mantissa and
     * exponent.
     *
     * The first thing we need to do is determine the sign bit, easy to do, check
     * whether the value is less than 0. And convert the number to its absolute
     * value representation. Next, we need to determine if the value is less than
     * one or greater than or equal to one and from there determine what power was
     * used to get there. What follows is now specific to floats, though the general
     * ideas behind this will hold for doubles as well, but the exact numbers
     * involved will change.
     *
     * Once we have that power we can determine the exponent and the mantissa. Call
     * the value that has the number of bits to reach the power ebits. In the
     * general case they have the following values:
     *
     *	exponent	127 + ebits
     *	mantissa	value * 2^(23 - ebits) & 0x7fffff
     *
     * In the case where the value of ebits is <= -127 we are now in the case where
     * we no longer have normalized numbers. In this case the values take on the
     * following values:
     *
     * 	exponent	0
     *	mantissa	value * 2^149 & 0x7fffff
     *
     * Once we have the values for the sign, mantissa, and exponent. We reconstruct
     * the four bytes as follows:
     *
     *	byte0		sign bit and seven most significant bits from the exp
     *			sign << 7 | (exponent & 0xfe) >>> 1
     *
     *	byte1		lsb from the exponent and 7 top bits from the mantissa
     *			(exponent & 0x01) << 7 | (mantissa & 0x7f0000) >>> 16
     *
     *	byte2		bits 8-15 (zero indexing) from mantissa
     *			mantissa & 0xff00 >> 8
     *
     *	byte3		bits 0-7 from mantissa
     *			mantissa & 0xff
     *
     * Once we have this we have to assign them into the buffer in proper endian
     * order.
     */
    
    /*
     * Compute the log base 2 of the value. Now, someone who remembers basic
     * properties of logarithms will point out that we could use the change of base
     * formula for logs, and in fact that would be astute, because that's what we'll
     * do for now. It feels cleaner, albeit it may be less efficient than just
     * iterating and dividing by 2. We may want to come back and revisit that some
     * day.
     */
    function log2(value)
    {
    	return (Math.log(value) / Math.log(2));
    }
    
    /*
     * Helper to determine the exponent of the number we're looking at.
     */
    function intexp(value)
    {
    	return (Math.floor(log2(value)));
    }
    
    /*
     * Helper to determine the exponent of the fractional part of the value.
     */
    function fracexp(value)
    {
    	return (Math.floor(log2(value)));
    }
    
    function wfloat(value, endian, buffer, offset)
    {
    	var sign, exponent, mantissa, ebits;
    	var bytes = [];
    
    	if (value === undefined)
    		throw (new Error('missing value'));
    
    	if (endian === undefined)
    		throw (new Error('missing endian'));
    
    	if (buffer === undefined)
    		throw (new Error('missing buffer'));
    
    	if (offset === undefined)
    		throw (new Error('missing offset'));
    
    
    	if (offset + 3 >= buffer.length)
    		throw (new Error('Trying to read beyond buffer length'));
    
    	if (isNaN(value)) {
    		sign = 0;
    		exponent = 0xff;
    		mantissa = 23;
    	} else if (value == Number.POSITIVE_INFINITY) {
    		sign = 0;
    		exponent = 0xff;
    		mantissa = 0;
    	} else if (value == Number.NEGATIVE_INFINITY) {
    		sign = 1;
    		exponent = 0xff;
    		mantissa = 0;
    	} else {
    		/* Well we have some work to do */
    
    		/* Thankfully the sign bit is trivial */
    		if (value < 0) {
    			sign = 1;
    			value = Math.abs(value);
    		} else {
    			sign = 0;
    		}
    
    		/* Use the correct function to determine number of bits */
    		if (value < 1)
    			ebits = fracexp(value);
    		else
    			ebits = intexp(value);
    
    		/* Time to deal with the issues surrounding normalization */
    		if (ebits <= -127) {
    			exponent = 0;
    			mantissa = (value * Math.pow(2, 149)) & 0x7fffff;
    		} else {
    			exponent = 127 + ebits;
    			mantissa = value * Math.pow(2, 23 - ebits);
    			mantissa &= 0x7fffff;
    		}
    	}
    
    	bytes[0] = sign << 7 | (exponent & 0xfe) >>> 1;
    	bytes[1] = (exponent & 0x01) << 7 | (mantissa & 0x7f0000) >>> 16;
    	bytes[2] = (mantissa & 0x00ff00) >>> 8;
    	bytes[3] = mantissa & 0x0000ff;
    
    	if (endian == 'big') {
    		buffer[offset] = bytes[0];
    		buffer[offset+1] = bytes[1];
    		buffer[offset+2] = bytes[2];
    		buffer[offset+3] = bytes[3];
    	} else {
    		buffer[offset] = bytes[3];
    		buffer[offset+1] = bytes[2];
    		buffer[offset+2] = bytes[1];
    		buffer[offset+3] = bytes[0];
    	}
    }
    
    /*
     * Now we move onto doubles. Doubles are similar to floats in pretty much all
     * ways except that the processing isn't quite as straightforward because we
     * can't always use shifting, i.e. we have > 32 bit values.
     *
     * We're going to proceed in an identical fashion to floats and utilize the same
     * helper functions. All that really is changing are the specific values that we
     * use to do the calculations. Thus, to review we have to do the following.
     *
     * First get the sign bit and convert the value to its absolute value
     * representation. Next, we determine the number of bits that we used to get to
     * the value, branching whether the value is greater than or less than 1. Once
     * we have that value which we will again call ebits, we have to do the
     * following in the general case:
     *
     *	exponent	1023 + ebits
     *	mantissa	[value * 2^(52 - ebits)] % 2^52
     *
     * In the case where the value of ebits <= -1023 we no longer use normalized
     * numbers, thus like with floats we have to do slightly different processing:
     *
     *	exponent	0
     *	mantissa	[value * 2^1074] % 2^52
     *
     * Once we have determined the sign, exponent and mantissa we can construct the
     * bytes as follows:
     *
     *	byte0		sign bit and seven most significant bits form the exp
     *			sign << 7 | (exponent & 0x7f0) >>> 4
     *
     *	byte1		Remaining 4 bits from the exponent and the four most
     *			significant bits from the mantissa 48-51
     *			(exponent & 0x00f) << 4 | mantissa >>> 48
     *
     *	byte2		Bits 40-47 from the mantissa
     *			(mantissa >>> 40) & 0xff
     *
     *	byte3		Bits 32-39 from the mantissa
     *			(mantissa >>> 32) & 0xff
     *
     *	byte4		Bits 24-31 from the mantissa
     *			(mantissa >>> 24) & 0xff
     *
     *	byte5		Bits 16-23 from the Mantissa
     *			(mantissa >>> 16) & 0xff
     *
     *	byte6		Bits 8-15 from the mantissa
     *			(mantissa >>> 8) & 0xff
     *
     *	byte7		Bits 0-7 from the mantissa
     *			mantissa & 0xff
     *
     * Now we can't quite do the right shifting that we want in bytes 1 - 3, because
     * we'll have extended too far and we'll lose those values when we try and do
     * the shift. Instead we have to use an alternate approach. To try and stay out
     * of floating point, what we'll do is say that mantissa -= bytes[4-7] and then
     * divide by 2^32. Once we've done that we can use binary arithmetic. Oof,
     * that's ugly, but it seems to avoid using floating point (just based on how v8
     * seems to be optimizing for base 2 arithmetic).
     */
    function wdouble(value, endian, buffer, offset)
    {
    	var sign, exponent, mantissa, ebits;
    	var bytes = [];
    
    	if (value === undefined)
    		throw (new Error('missing value'));
    
    	if (endian === undefined)
    		throw (new Error('missing endian'));
    
    	if (buffer === undefined)
    		throw (new Error('missing buffer'));
    
    	if (offset === undefined)
    		throw (new Error('missing offset'));
    
    
    	if (offset + 7 >= buffer.length)
    		throw (new Error('Trying to read beyond buffer length'));
    
    	if (isNaN(value)) {
    		sign = 0;
    		exponent = 0x7ff;
    		mantissa = 23;
    	} else if (value == Number.POSITIVE_INFINITY) {
    		sign = 0;
    		exponent = 0x7ff;
    		mantissa = 0;
    	} else if (value == Number.NEGATIVE_INFINITY) {
    		sign = 1;
    		exponent = 0x7ff;
    		mantissa = 0;
    	} else {
    		/* Well we have some work to do */
    
    		/* Thankfully the sign bit is trivial */
    		if (value < 0) {
    			sign = 1;
    			value = Math.abs(value);
    		} else {
    			sign = 0;
    		}
    
    		/* Use the correct function to determine number of bits */
    		if (value < 1)
    			ebits = fracexp(value);
    		else
    			ebits = intexp(value);
    
    		/*
    		 * This is a total hack to determine a denormalized value.
    		 * Unfortunately, we sometimes do not get a proper value for
    		 * ebits, i.e. we lose the values that would get rounded off.
    		 *
    		 *
    		 * The astute observer may wonder why we would be
    		 * multiplying by two Math.pows rather than just summing
    		 * them. Well, that's to get around a small bug in the
    		 * way v8 seems to implement the function. On occasion
    		 * doing:
    		 *
    		 * foo * Math.pow(2, 1023 + 51)
    		 *
    		 * Causes us to overflow to infinity, where as doing:
    		 *
    		 * foo * Math.pow(2, 1023) * Math.pow(2, 51)
    		 *
    		 * Does not cause us to overflow. Go figure.
    		 *
    		 */
    		if (value <= 2.225073858507201e-308 || ebits <= -1023) {
    			exponent = 0;
    			mantissa = value * Math.pow(2, 1023) * Math.pow(2, 51);
    			mantissa %= Math.pow(2, 52);
    		} else {
    			/*
    			 * We might have gotten fucked by our floating point
    			 * logarithm magic. This is rather crappy, but that's
    			 * our luck. If we just had a log base 2 or access to
    			 * the stupid underlying representation this would have
    			 * been much easier and we wouldn't have such stupid
    			 * kludges or hacks.
    			 */
    			if (ebits > 1023)
    				ebits = 1023;
    			exponent = 1023 + ebits;
    			mantissa = value * Math.pow(2, -ebits);
    			mantissa *= Math.pow(2, 52);
    			mantissa %= Math.pow(2, 52);
    		}
    	}
    
    	/* Fill the bytes in backwards to deal with the size issues */
    	bytes[7] = mantissa & 0xff;
    	bytes[6] = (mantissa >>> 8) & 0xff;
    	bytes[5] = (mantissa >>> 16) & 0xff;
    	mantissa = (mantissa - (mantissa & 0xffffff)) / Math.pow(2, 24);
    	bytes[4] = mantissa & 0xff;
    	bytes[3] = (mantissa >>> 8) & 0xff;
    	bytes[2] = (mantissa >>> 16) & 0xff;
    	bytes[1] = (exponent & 0x00f) << 4 | mantissa >>> 24;
    	bytes[0] = (sign << 7) | (exponent & 0x7f0) >>> 4;
    
    	if (endian == 'big') {
    		buffer[offset] = bytes[0];
    		buffer[offset+1] = bytes[1];
    		buffer[offset+2] = bytes[2];
    		buffer[offset+3] = bytes[3];
    		buffer[offset+4] = bytes[4];
    		buffer[offset+5] = bytes[5];
    		buffer[offset+6] = bytes[6];
    		buffer[offset+7] = bytes[7];
    	} else {
    		buffer[offset+7] = bytes[0];
    		buffer[offset+6] = bytes[1];
    		buffer[offset+5] = bytes[2];
    		buffer[offset+4] = bytes[3];
    		buffer[offset+3] = bytes[4];
    		buffer[offset+2] = bytes[5];
    		buffer[offset+1] = bytes[6];
    		buffer[offset] = bytes[7];
    	}
    }
    
    /*
     * Actually export our work above. One might argue that we shouldn't expose
     * these interfaces and just force people to use the higher level abstractions
     * around this work. However, unlike say other libraries we've come across, this
     * interface has several properties: it makes sense, it's simple, and it's
     * useful.
     */
    exports.ruint8 = ruint8;
    exports.ruint16 = ruint16;
    exports.ruint32 = ruint32;
    exports.ruint64 = ruint64;
    exports.wuint8 = wuint8;
    exports.wuint16 = wuint16;
    exports.wuint32 = wuint32;
    exports.wuint64 = wuint64;
    
    exports.rsint8 = rsint8;
    exports.rsint16 = rsint16;
    exports.rsint32 = rsint32;
    exports.rsint64 = rsint64;
    exports.wsint8 = wsint8;
    exports.wsint16 = wsint16;
    exports.wsint32 = wsint32;
    exports.wsint64 = wsint64;
    
    exports.rfloat = rfloat;
    exports.rdouble = rdouble;
    exports.wfloat = wfloat;
    exports.wdouble = wdouble;
    
  provide("ctype/ctio.js", module.exports);
}(global));

// pakmanager:ctype
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*
     * rm - Feb 2011
     * ctype.js
     *
     * This module provides a simple abstraction towards reading and writing
     * different types of binary data. It is designed to use ctio.js and provide a
     * richer and more expressive API on top of it.
     *
     * By default we support the following as built in basic types:
     *	int8_t
     *	int16_t
     *	int32_t
     *	uint8_t
     *	uint16_t
     *	uint32_t
     *	uint64_t
     *	float
     *	double
     *	char
     *	char[]
     *
     * Each type is returned as a Number, with the exception of char and char[]
     * which are returned as Node Buffers. A char is considered a uint8_t.
     *
     * Requests to read and write data are specified as an array of JSON objects.
     * This is also the same way that one declares structs. Even if just a single
     * value is requested, it must be done as a struct. The array order determines
     * the order that we try and read values. Each entry has the following format
     * with values marked with a * being optional.
     *
     * { key: { type: /type/, value*: /value/, offset*: /offset/ }
     *
     * If offset is defined, we lseek(offset, SEEK_SET) before reading the next
     * value. Value is defined when we're writing out data, otherwise it's ignored.
     *
     */
    
    var mod_ctf =  require('ctype/ctf.js');
    var mod_ctio =  require('ctype/ctio.js');
    var mod_assert = require('assert');
    
    /*
     * This is the set of basic types that we support.
     *
     *	read		The function to call to read in a value from a buffer
     *
     *	write		The function to call to write a value to a buffer
     *
     */
    var deftypes = {
        'uint8_t':  { read: ctReadUint8, write: ctWriteUint8 },
        'uint16_t': { read: ctReadUint16, write: ctWriteUint16 },
        'uint32_t': { read: ctReadUint32, write: ctWriteUint32 },
        'uint64_t': { read: ctReadUint64, write: ctWriteUint64 },
        'int8_t': { read: ctReadSint8, write: ctWriteSint8 },
        'int16_t': { read: ctReadSint16, write: ctWriteSint16 },
        'int32_t': { read: ctReadSint32, write: ctWriteSint32 },
        'int64_t': { read: ctReadSint64, write: ctWriteSint64 },
        'float': { read: ctReadFloat, write: ctWriteFloat },
        'double': { read: ctReadDouble, write: ctWriteDouble },
        'char': { read: ctReadChar, write: ctWriteChar },
        'char[]': { read: ctReadCharArray, write: ctWriteCharArray }
    };
    
    /*
     * The following are wrappers around the CType IO low level API. They encode
     * knowledge about the size and return something in the expected format.
     */
    function ctReadUint8(endian, buffer, offset)
    {
    	var val = mod_ctio.ruint8(buffer, endian, offset);
    	return ({ value: val, size: 1 });
    }
    
    function ctReadUint16(endian, buffer, offset)
    {
    	var val = mod_ctio.ruint16(buffer, endian, offset);
    	return ({ value: val, size: 2 });
    }
    
    function ctReadUint32(endian, buffer, offset)
    {
    	var val = mod_ctio.ruint32(buffer, endian, offset);
    	return ({ value: val, size: 4 });
    }
    
    function ctReadUint64(endian, buffer, offset)
    {
    	var val = mod_ctio.ruint64(buffer, endian, offset);
    	return ({ value: val, size: 8 });
    }
    
    function ctReadSint8(endian, buffer, offset)
    {
    	var val = mod_ctio.rsint8(buffer, endian, offset);
    	return ({ value: val, size: 1 });
    }
    
    function ctReadSint16(endian, buffer, offset)
    {
    	var val = mod_ctio.rsint16(buffer, endian, offset);
    	return ({ value: val, size: 2 });
    }
    
    function ctReadSint32(endian, buffer, offset)
    {
    	var val = mod_ctio.rsint32(buffer, endian, offset);
    	return ({ value: val, size: 4 });
    }
    
    function ctReadSint64(endian, buffer, offset)
    {
    	var val = mod_ctio.rsint64(buffer, endian, offset);
    	return ({ value: val, size: 8 });
    }
    
    function ctReadFloat(endian, buffer, offset)
    {
    	var val = mod_ctio.rfloat(buffer, endian, offset);
    	return ({ value: val, size: 4 });
    }
    
    function ctReadDouble(endian, buffer, offset)
    {
    	var val = mod_ctio.rdouble(buffer, endian, offset);
    	return ({ value: val, size: 8 });
    }
    
    /*
     * Reads a single character into a node buffer
     */
    function ctReadChar(endian, buffer, offset)
    {
    	var res = new Buffer(1);
    	res[0] = mod_ctio.ruint8(buffer, endian, offset);
    	return ({ value: res, size: 1 });
    }
    
    function ctReadCharArray(length, endian, buffer, offset)
    {
    	var ii;
    	var res = new Buffer(length);
    
    	for (ii = 0; ii < length; ii++)
    		res[ii] = mod_ctio.ruint8(buffer, endian, offset + ii);
    
    	return ({ value: res, size: length });
    }
    
    function ctWriteUint8(value, endian, buffer, offset)
    {
    	mod_ctio.wuint8(value, endian, buffer, offset);
    	return (1);
    }
    
    function ctWriteUint16(value, endian, buffer, offset)
    {
    	mod_ctio.wuint16(value, endian, buffer, offset);
    	return (2);
    }
    
    function ctWriteUint32(value, endian, buffer, offset)
    {
    	mod_ctio.wuint32(value, endian, buffer, offset);
    	return (4);
    }
    
    function ctWriteUint64(value, endian, buffer, offset)
    {
    	mod_ctio.wuint64(value, endian, buffer, offset);
    	return (8);
    }
    
    function ctWriteSint8(value, endian, buffer, offset)
    {
    	mod_ctio.wsint8(value, endian, buffer, offset);
    	return (1);
    }
    
    function ctWriteSint16(value, endian, buffer, offset)
    {
    	mod_ctio.wsint16(value, endian, buffer, offset);
    	return (2);
    }
    
    function ctWriteSint32(value, endian, buffer, offset)
    {
    	mod_ctio.wsint32(value, endian, buffer, offset);
    	return (4);
    }
    
    function ctWriteSint64(value, endian, buffer, offset)
    {
    	mod_ctio.wsint64(value, endian, buffer, offset);
    	return (8);
    }
    
    function ctWriteFloat(value, endian, buffer, offset)
    {
    	mod_ctio.wfloat(value, endian, buffer, offset);
    	return (4);
    }
    
    function ctWriteDouble(value, endian, buffer, offset)
    {
    	mod_ctio.wdouble(value, endian, buffer, offset);
    	return (8);
    }
    
    /*
     * Writes a single character into a node buffer
     */
    function ctWriteChar(value, endian, buffer, offset)
    {
    	if (!(value instanceof Buffer))
    		throw (new Error('Input must be a buffer'));
    
    	mod_ctio.ruint8(value[0], endian, buffer, offset);
    	return (1);
    }
    
    /*
     * We're going to write 0s into the buffer if the string is shorter than the
     * length of the array.
     */
    function ctWriteCharArray(value, length, endian, buffer, offset)
    {
    	var ii;
    
    	if (!(value instanceof Buffer))
    		throw (new Error('Input must be a buffer'));
    
    	if (value.length > length)
    		throw (new Error('value length greater than array length'));
    
    	for (ii = 0; ii < value.length && ii < length; ii++)
    		mod_ctio.wuint8(value[ii], endian, buffer, offset + ii);
    
    	for (; ii < length; ii++)
    		mod_ctio.wuint8(0, endian, offset + ii);
    
    
    	return (length);
    }
    
    /*
     * Each parser has their own set of types. We want to make sure that they each
     * get their own copy as they may need to modify it.
     */
    function ctGetBasicTypes()
    {
    	var ret = {};
    	var key;
    	for (key in deftypes)
    		ret[key] = deftypes[key];
    
    	return (ret);
    }
    
    /*
     * Given a string in the form of type[length] we want to split this into an
     * object that extracts that information. We want to note that we could possibly
     * have nested arrays so this should only check the furthest one. It may also be
     * the case that we have no [] pieces, in which case we just return the current
     * type.
     */
    function ctParseType(str)
    {
    	var begInd, endInd;
    	var type, len;
    	if (typeof (str) != 'string')
    		throw (new Error('type must be a Javascript string'));
    
    	endInd = str.lastIndexOf(']');
    	if (endInd == -1) {
    		if (str.lastIndexOf('[') != -1)
    			throw (new Error('found invalid type with \'[\' but ' +
    			    'no corresponding \']\''));
    
    		return ({ type: str });
    	}
    
    	begInd = str.lastIndexOf('[');
    	if (begInd == -1)
    		throw (new Error('found invalid type with \']\' but ' +
    		    'no corresponding \'[\''));
    
    	if (begInd >= endInd)
    		throw (new Error('malformed type, \']\' appears before \'[\''));
    
    	type = str.substring(0, begInd);
    	len = str.substring(begInd + 1, endInd);
    
    	return ({ type: type, len: len });
    }
    
    /*
     * Given a request validate that all of the fields for it are valid and make
     * sense. This includes verifying the following notions:
     *  - Each type requested is present in types
     *  - Only allow a name for a field to be specified once
     *  - If an array is specified, validate that the requested field exists and
     *    comes before it.
     *  - If fields is defined, check that each entry has the occurrence of field
     */
    function ctCheckReq(def, types, fields)
    {
    	var ii, jj;
    	var req, keys, key;
    	var found = {};
    
    	if (!(def instanceof Array))
    		throw (new Error('definition is not an array'));
    
    	if (def.length === 0)
    		throw (new Error('definition must have at least one element'));
    
    	for (ii = 0; ii < def.length; ii++) {
    		req = def[ii];
    		if (!(req instanceof Object))
    			throw (new Error('definition must be an array of' +
    			    'objects'));
    
    		keys = Object.keys(req);
    		if (keys.length != 1)
    			throw (new Error('definition entry must only have ' +
    			    'one key'));
    
    		if (keys[0] in found)
    			throw (new Error('Specified name already ' +
    			    'specified: ' + keys[0]));
    
    		if (!('type' in req[keys[0]]))
    			throw (new Error('missing required type definition'));
    
    		key = ctParseType(req[keys[0]]['type']);
    
    		/*
    		 * We may have nested arrays, we need to check the validity of
    		 * the types until the len field is undefined in key. However,
    		 * each time len is defined we need to verify it is either an
    		 * integer or corresponds to an already seen key.
    		 */
    		while (key['len'] !== undefined) {
    			if (isNaN(parseInt(key['len'], 10))) {
    				if (!(key['len'] in found))
    					throw (new Error('Given an array ' +
    					    'length without a matching type'));
    
    			}
    
    			key = ctParseType(key['type']);
    		}
    
    		/* Now we can validate if the type is valid */
    		if (!(key['type'] in types))
    			throw (new Error('type not found or typdefed: ' +
    			    key['type']));
    
    		/* Check for any required fields */
    		if (fields !== undefined) {
    			for (jj = 0; jj < fields.length; jj++) {
    				if (!(fields[jj] in req[keys[0]]))
    					throw (new Error('Missing required ' +
    					    'field: ' + fields[jj]));
    			}
    		}
    
    		found[keys[0]] = true;
    	}
    }
    
    
    /*
     * Create a new instance of the parser. Each parser has its own store of
     * typedefs and endianness. Conf is an object with the following required
     * values:
     *
     *	endian		Either 'big' or 'little' do determine the endianness we
     *			want to read from or write to.
     *
     * And the following optional values:
     *
     * 	char-type	Valid options here are uint8 and int8. If uint8 is
     * 			specified this changes the default behavior of a single
     * 			char from being a buffer of a single character to being
     * 			a uint8_t. If int8, it becomes an int8_t instead.
     */
    function CTypeParser(conf)
    {
    	if (!conf) throw (new Error('missing required argument'));
    
    	if (!('endian' in conf))
    		throw (new Error('missing required endian value'));
    
    	if (conf['endian'] != 'big' && conf['endian'] != 'little')
    		throw (new Error('Invalid endian type'));
    
    	if ('char-type' in conf && (conf['char-type'] != 'uint8' &&
    	    conf['char-type'] != 'int8'))
    		throw (new Error('invalid option for char-type: ' +
    		    conf['char-type']));
    
    	this.endian = conf['endian'];
    	this.types = ctGetBasicTypes();
    
    	/*
    	 * There may be a more graceful way to do this, but this will have to
    	 * serve.
    	 */
    	if ('char-type' in conf && conf['char-type'] == 'uint8')
    		this.types['char'] = this.types['uint8_t'];
    
    	if ('char-type' in conf && conf['char-type'] == 'int8')
    		this.types['char'] = this.types['int8_t'];
    }
    
    /*
     * Sets the current endian value for the Parser. If the value is not valid,
     * throws an Error.
     *
     *	endian		Either 'big' or 'little' do determine the endianness we
     *			want to read from or write to.
     *
     */
    CTypeParser.prototype.setEndian = function (endian)
    {
    	if (endian != 'big' && endian != 'little')
    		throw (new Error('invalid endian type, must be big or ' +
    		    'little'));
    
    	this.endian = endian;
    };
    
    /*
     * Returns the current value of the endian value for the parser.
     */
    CTypeParser.prototype.getEndian = function ()
    {
    	return (this.endian);
    };
    
    /*
     * A user has requested to add a type, let us honor their request. Yet, if their
     * request doth spurn us, send them unto the Hells which Dante describes.
     *
     * 	name		The string for the type definition we're adding
     *
     *	value		Either a string that is a type/array name or an object
     *			that describes a struct.
     */
    CTypeParser.prototype.typedef = function (name, value)
    {
    	var type;
    
    	if (name === undefined)
    		throw (new (Error('missing required typedef argument: name')));
    
    	if (value === undefined)
    		throw (new (Error('missing required typedef argument: value')));
    
    	if (typeof (name) != 'string')
    		throw (new (Error('the name of a type must be a string')));
    
    	type = ctParseType(name);
    
    	if (type['len'] !== undefined)
    		throw (new Error('Cannot have an array in the typedef name'));
    
    	if (name in this.types)
    		throw (new Error('typedef name already present: ' + name));
    
    	if (typeof (value) != 'string' && !(value instanceof Array))
    		throw (new Error('typedef value must either be a string or ' +
    		    'struct'));
    
    	if (typeof (value) == 'string') {
    		type = ctParseType(value);
    		if (type['len'] !== undefined) {
    			if (isNaN(parseInt(type['len'], 10)))
    				throw (new (Error('typedef value must use ' +
    				    'fixed size array when outside of a ' +
    				    'struct')));
    		}
    
    		this.types[name] = value;
    	} else {
    		/* We have a struct, validate it */
    		ctCheckReq(value, this.types);
    		this.types[name] = value;
    	}
    };
    
    /*
     * Include all of the typedefs, but none of the built in types. This should be
     * treated as read-only.
     */
    CTypeParser.prototype.lstypes = function ()
    {
    	var key;
    	var ret = {};
    
    	for (key in this.types) {
    		if (key in deftypes)
    			continue;
    		ret[key] = this.types[key];
    	}
    
    	return (ret);
    };
    
    /*
     * Given a type string that may have array types that aren't numbers, try and
     * fill them in from the values object. The object should be of the format where
     * indexing into it should return a number for that type.
     *
     *	str		The type string
     *
     *	values		An object that can be used to fulfill type information
     */
    function ctResolveArray(str, values)
    {
    	var ret = '';
    	var type = ctParseType(str);
    
    	while (type['len'] !== undefined) {
    		if (isNaN(parseInt(type['len'], 10))) {
    			if (typeof (values[type['len']]) != 'number')
    				throw (new Error('cannot sawp in non-number ' +
    				    'for array value'));
    			ret = '[' + values[type['len']] + ']' + ret;
    		} else {
    			ret = '[' + type['len'] + ']' + ret;
    		}
    		type = ctParseType(type['type']);
    	}
    
    	ret = type['type'] + ret;
    
    	return (ret);
    }
    
    /*
     * [private] Either the typedef resolves to another type string or to a struct.
     * If it resolves to a struct, we just pass it off to read struct. If not, we
     * can just pass it off to read entry.
     */
    CTypeParser.prototype.resolveTypedef = function (type, dispatch, buffer,
        offset, value)
    {
    	var pt;
    
    	mod_assert.ok(type in this.types);
    	if (typeof (this.types[type]) == 'string') {
    		pt = ctParseType(this.types[type]);
    		if (dispatch == 'read')
    			return (this.readEntry(pt, buffer, offset));
    		else if (dispatch == 'write')
    			return (this.writeEntry(value, pt, buffer, offset));
    		else
    			throw (new Error('invalid dispatch type to ' +
    			    'resolveTypedef'));
    	} else {
    		if (dispatch == 'read')
    			return (this.readStruct(this.types[type], buffer,
    			    offset));
    		else if (dispatch == 'write')
    			return (this.writeStruct(value, this.types[type],
    			    buffer, offset));
    		else
    			throw (new Error('invalid dispatch type to ' +
    			    'resolveTypedef'));
    	}
    
    };
    
    /*
     * [private] Try and read in the specific entry.
     */
    CTypeParser.prototype.readEntry = function (type, buffer, offset)
    {
    	var parse, len;
    
    	/*
    	 * Because we want to special case char[]s this is unfortunately
    	 * a bit uglier than it really should be. We want to special
    	 * case char[]s so that we return a node buffer, thus they are a
    	 * first class type where as all other arrays just call into a
    	 * generic array routine which calls their data-specific routine
    	 * the specified number of times.
    	 *
    	 * The valid dispatch options we have are:
    	 *  - Array and char => char[] handler
    	 *  - Generic array handler
    	 *  - Generic typedef handler
    	 *  - Basic type handler
    	 */
    	if (type['len'] !== undefined) {
    		len = parseInt(type['len'], 10);
    		if (isNaN(len))
    			throw (new Error('somehow got a non-numeric length'));
    
    		if (type['type'] == 'char')
    			parse = this.types['char[]']['read'](len,
    			    this.endian, buffer, offset);
    		else
    			parse = this.readArray(type['type'],
    			    len, buffer, offset);
    	} else {
    		if (type['type'] in deftypes)
    			parse = this.types[type['type']]['read'](this.endian,
    			    buffer, offset);
    		else
    			parse = this.resolveTypedef(type['type'], 'read',
    			    buffer, offset);
    	}
    
    	return (parse);
    };
    
    /*
     * [private] Read an array of data
     */
    CTypeParser.prototype.readArray = function (type, length, buffer, offset)
    {
    	var ii, ent, pt;
    	var baseOffset = offset;
    	var ret = new Array(length);
    	pt = ctParseType(type);
    
    	for (ii = 0; ii < length; ii++) {
    		ent = this.readEntry(pt, buffer, offset);
    		offset += ent['size'];
    		ret[ii] = ent['value'];
    	}
    
    	return ({ value: ret, size: offset - baseOffset });
    };
    
    /*
     * [private] Read a single struct in.
     */
    CTypeParser.prototype.readStruct = function (def, buffer, offset)
    {
    	var parse, ii, type, entry, key;
    	var baseOffset = offset;
    	var ret = {};
    
    	/* Walk it and handle doing what's necessary */
    	for (ii = 0; ii < def.length; ii++) {
    		key = Object.keys(def[ii])[0];
    		entry = def[ii][key];
    
    		/* Resolve all array values */
    		type = ctParseType(ctResolveArray(entry['type'], ret));
    
    		if ('offset' in entry)
    			offset = baseOffset + entry['offset'];
    
    		parse = this.readEntry(type, buffer, offset);
    
    		offset += parse['size'];
    		ret[key] = parse['value'];
    	}
    
    	return ({ value: ret, size: (offset-baseOffset)});
    };
    
    /*
     * This is what we were born to do. We read the data from a buffer and return it
     * in an object whose keys match the values from the object.
     *
     *	def		The array definition of the data to read in
     *
     *	buffer		The buffer to read data from
     *
     *	offset		The offset to start writing to
     *
     * Returns an object where each key corresponds to an entry in def and the value
     * is the read value.
     */
    CTypeParser.prototype.readData = function (def, buffer, offset)
    {
    	/* Sanity check for arguments */
    	if (def === undefined)
    		throw (new Error('missing definition for what we should be' +
    		    'parsing'));
    
    	if (buffer === undefined)
    		throw (new Error('missing buffer for what we should be ' +
    		    'parsing'));
    
    	if (offset === undefined)
    		throw (new Error('missing offset for what we should be ' +
    		    'parsing'));
    
    	/* Sanity check the object definition */
    	ctCheckReq(def, this.types);
    
    	return (this.readStruct(def, buffer, offset)['value']);
    };
    
    /*
     * [private] Write out an array of data
     */
    CTypeParser.prototype.writeArray = function (value, type, length, buffer,
        offset)
    {
    	var ii, pt;
    	var baseOffset = offset;
    	if (!(value instanceof Array))
    		throw (new Error('asked to write an array, but value is not ' +
    		    'an array'));
    
    	if (value.length != length)
    		throw (new Error('asked to write array of length ' + length +
    		    ' but that does not match value length: ' + value.length));
    
    	pt = ctParseType(type);
    	for (ii = 0; ii < length; ii++)
    		offset += this.writeEntry(value[ii], pt, buffer, offset);
    
    	return (offset - baseOffset);
    };
    
    /*
     * [private] Write the specific entry
     */
    CTypeParser.prototype.writeEntry = function (value, type, buffer, offset)
    {
    	var len, ret;
    
    	if (type['len'] !== undefined) {
    		len = parseInt(type['len'], 10);
    		if (isNaN(len))
    			throw (new Error('somehow got a non-numeric length'));
    
    		if (type['type'] == 'char')
    			ret = this.types['char[]']['write'](value, len,
    			    this.endian, buffer, offset);
    		else
    			ret = this.writeArray(value, type['type'],
    			    len, buffer, offset);
    	} else {
    		if (type['type'] in deftypes)
    			ret = this.types[type['type']]['write'](value,
    			    this.endian, buffer, offset);
    		else
    			ret = this.resolveTypedef(type['type'], 'write',
    			    buffer, offset, value);
    	}
    
    	return (ret);
    };
    
    /*
     * [private] Write a single struct out.
     */
    CTypeParser.prototype.writeStruct = function (value, def, buffer, offset)
    {
    	var ii, entry, type, key;
    	var baseOffset = offset;
    	var vals = {};
    
    	for (ii = 0; ii < def.length; ii++) {
    		key = Object.keys(def[ii])[0];
    		entry = def[ii][key];
    
    		type = ctParseType(ctResolveArray(entry['type'], vals));
    
    		if ('offset' in entry)
    			offset = baseOffset + entry['offset'];
    
    		offset += this.writeEntry(value[ii], type, buffer, offset);
    		/* Now that we've written it out, we can use it for arrays */
    		vals[key] = value[ii];
    	}
    
    	return (offset);
    };
    
    /*
     * Unfortunately, we're stuck with the sins of an initial poor design. Because
     * of that, we are going to have to support the old way of writing data via
     * writeData. There we insert the values that you want to write into the
     * definition. A little baroque. Internally, we use the new model. So we need to
     * just get those values out of there. But to maintain the principle of least
     * surprise, we're not going to modify the input data.
     */
    function getValues(def)
    {
    	var ii, out, key;
    	out = [];
    	for (ii = 0; ii < def.length; ii++) {
    		key = Object.keys(def[ii])[0];
    		mod_assert.ok('value' in def[ii][key]);
    		out.push(def[ii][key]['value']);
    	}
    
    	return (out);
    }
    
    /*
     * This is the second half of what we were born to do, write out the data
     * itself. Historically this function required you to put your values in the
     * definition section. This was not the smartest thing to do and a bit of an
     * oversight to be honest. As such, this function now takes a values argument.
     * If values is non-null and non-undefined, it will be used to determine the
     * values. This means that the old method is still supported, but is no longer
     * acceptable.
     *
     *	def		The array definition of the data to write out with
     *			values
     *
     *	buffer		The buffer to write to
     *
     *	offset		The offset in the buffer to write to
     *
     *	values		An array of values to write.
     */
    CTypeParser.prototype.writeData = function (def, buffer, offset, values)
    {
    	var hv;
    
    	if (def === undefined)
    		throw (new Error('missing definition for what we should be' +
    		    'parsing'));
    
    	if (buffer === undefined)
    		throw (new Error('missing buffer for what we should be ' +
    		    'parsing'));
    
    	if (offset === undefined)
    		throw (new Error('missing offset for what we should be ' +
    		    'parsing'));
    
    	hv = (values != null && values != undefined);
    	if (hv) {
    		if (!Array.isArray(values))
    			throw (new Error('missing values for writing'));
    		ctCheckReq(def, this.types);
    	} else {
    		ctCheckReq(def, this.types, [ 'value' ]);
    	}
    
    	this.writeStruct(hv ? values : getValues(def), def, buffer, offset);
    };
    
    /*
     * Functions to go to and from 64 bit numbers in a way that is compatible with
     * Javascript limitations. There are two sets. One where the user is okay with
     * an approximation and one where they are definitely not okay with an
     * approximation.
     */
    
    /*
     * Attempts to convert an array of two integers returned from rsint64 / ruint64
     * into an absolute 64 bit number. If however the value would exceed 2^52 this
     * will instead throw an error. The mantissa in a double is a 52 bit number and
     * rather than potentially give you a value that is an approximation this will
     * error. If you would rather an approximation, please see toApprox64.
     *
     *	val		An array of two 32-bit integers
     */
    function toAbs64(val)
    {
    	if (val === undefined)
    		throw (new Error('missing required arg: value'));
    
    	if (!Array.isArray(val))
    		throw (new Error('value must be an array'));
    
    	if (val.length != 2)
    		throw (new Error('value must be an array of length 2'));
    
    	/* We have 20 bits worth of precision in this range */
    	if (val[0] >= 0x100000)
    		throw (new Error('value would become approximated'));
    
    	return (val[0] * Math.pow(2, 32) + val[1]);
    }
    
    /*
     * Will return the 64 bit value as returned in an array from rsint64 / ruint64
     * to a value as close as it can. Note that Javascript stores all numbers as a
     * double and the mantissa only has 52 bits. Thus this version may approximate
     * the value.
     *
     *	val		An array of two 32-bit integers
     */
    function toApprox64(val)
    {
    	if (val === undefined)
    		throw (new Error('missing required arg: value'));
    
    	if (!Array.isArray(val))
    		throw (new Error('value must be an array'));
    
    	if (val.length != 2)
    		throw (new Error('value must be an array of length 2'));
    
    	return (Math.pow(2, 32) * val[0] + val[1]);
    }
    
    function parseCTF(json, conf)
    {
    	var ctype = new CTypeParser(conf);
    	mod_ctf.ctfParseJson(json, ctype);
    
    	return (ctype);
    }
    
    /*
     * Export the few things we actually want to. Currently this is just the CType
     * Parser and ctio.
     */
    exports.Parser = CTypeParser;
    exports.toAbs64 = toAbs64;
    exports.toApprox64 = toApprox64;
    
    exports.parseCTF = parseCTF;
    
    exports.ruint8 = mod_ctio.ruint8;
    exports.ruint16 = mod_ctio.ruint16;
    exports.ruint32 = mod_ctio.ruint32;
    exports.ruint64 = mod_ctio.ruint64;
    exports.wuint8 = mod_ctio.wuint8;
    exports.wuint16 = mod_ctio.wuint16;
    exports.wuint32 = mod_ctio.wuint32;
    exports.wuint64 = mod_ctio.wuint64;
    
    exports.rsint8 = mod_ctio.rsint8;
    exports.rsint16 = mod_ctio.rsint16;
    exports.rsint32 = mod_ctio.rsint32;
    exports.rsint64 = mod_ctio.rsint64;
    exports.wsint8 = mod_ctio.wsint8;
    exports.wsint16 = mod_ctio.wsint16;
    exports.wsint32 = mod_ctio.wsint32;
    exports.wsint64 = mod_ctio.wsint64;
    
    exports.rfloat = mod_ctio.rfloat;
    exports.rdouble = mod_ctio.rdouble;
    exports.wfloat = mod_ctio.wfloat;
    exports.wdouble = mod_ctio.wdouble;
    
  provide("ctype", module.exports);
}(global));

// pakmanager:cryptiles/lib
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Load modules
    
    var Crypto = require('crypto');
    var Boom = require('boom');
    
    
    // Declare internals
    
    var internals = {};
    
    
    // Generate a cryptographically strong pseudo-random data
    
    exports.randomString = function (size) {
    
        var buffer = exports.randomBits((size + 1) * 6);
        if (buffer instanceof Error) {
            return buffer;
        }
    
        var string = buffer.toString('base64').replace(/\+/g, '-').replace(/\//g, '_').replace(/\=/g, '');
        return string.slice(0, size);
    };
    
    
    exports.randomBits = function (bits) {
    
        if (!bits ||
            bits < 0) {
    
            return Boom.internal('Invalid random bits count');
        }
    
        var bytes = Math.ceil(bits / 8);
        try {
            return Crypto.randomBytes(bytes);
        }
        catch (err) {
            return Boom.internal('Failed generating random bits: ' + err.message);
        }
    };
    
    
    // Compare two strings using fixed time algorithm (to prevent time-based analysis of MAC digest match)
    
    exports.fixedTimeComparison = function (a, b) {
    
        if (typeof a !== 'string' ||
            typeof b !== 'string') {
    
            return false;
        }
    
        var mismatch = (a.length === b.length ? 0 : 1);
        if (mismatch) {
            b = a;
        }
    
        for (var i = 0, il = a.length; i < il; ++i) {
            var ac = a.charCodeAt(i);
            var bc = b.charCodeAt(i);
            mismatch |= (ac ^ bc);
        }
    
        return (mismatch === 0);
    };
    
    
    
  provide("cryptiles/lib", module.exports);
}(global));

// pakmanager:cryptiles
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  module.exports =  require('cryptiles/lib');
  provide("cryptiles", module.exports);
}(global));

// pakmanager:sntp/lib
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Load modules
    
    var Dgram = require('dgram');
    var Dns = require('dns');
    var Hoek = require('hoek');
    
    
    // Declare internals
    
    var internals = {};
    
    
    exports.time = function (options, callback) {
    
        if (arguments.length !== 2) {
            callback = arguments[0];
            options = {};
        }
    
        var settings = Hoek.clone(options);
        settings.host = settings.host || 'pool.ntp.org';
        settings.port = settings.port || 123;
        settings.resolveReference = settings.resolveReference || false;
    
        // Declare variables used by callback
    
        var timeoutId = 0;
        var sent = 0;
    
        // Ensure callback is only called once
    
        var finish = function (err, result) {
    
            if (timeoutId) {
                clearTimeout(timeoutId);
                timeoutId = 0;
            }
    
            socket.removeAllListeners();
            socket.once('error', internals.ignore);
            socket.close();
            return callback(err, result);
        };
    
        finish = Hoek.once(finish);
    
        // Create UDP socket
    
        var socket = Dgram.createSocket('udp4');
    
        socket.once('error', function (err) {
    
            return finish(err);
        });
    
        // Listen to incoming messages
    
        socket.on('message', function (buffer, rinfo) {
    
            var received = Date.now();
    
            var message = new internals.NtpMessage(buffer);
            if (!message.isValid) {
                return finish(new Error('Invalid server response'), message);
            }
    
            if (message.originateTimestamp !== sent) {
                return finish(new Error('Wrong originate timestamp'), message);
            }
    
            // Timestamp Name          ID   When Generated
            // ------------------------------------------------------------
            // Originate Timestamp     T1   time request sent by client
            // Receive Timestamp       T2   time request received by server
            // Transmit Timestamp      T3   time reply sent by server
            // Destination Timestamp   T4   time reply received by client
            //
            // The roundtrip delay d and system clock offset t are defined as:
            //
            // d = (T4 - T1) - (T3 - T2)     t = ((T2 - T1) + (T3 - T4)) / 2
    
            var T1 = message.originateTimestamp;
            var T2 = message.receiveTimestamp;
            var T3 = message.transmitTimestamp;
            var T4 = received;
    
            message.d = (T4 - T1) - (T3 - T2);
            message.t = ((T2 - T1) + (T3 - T4)) / 2;
            message.receivedLocally = received;
    
            if (!settings.resolveReference ||
                message.stratum !== 'secondary') {
    
                return finish(null, message);
            }
    
            // Resolve reference IP address
    
            Dns.reverse(message.referenceId, function (err, domains) {
    
                if (/* $lab:coverage:off$ */ !err /* $lab:coverage:on$ */) {
                    message.referenceHost = domains[0];
                }
    
                return finish(null, message);
            });
        });
    
        // Set timeout
    
        if (settings.timeout) {
            timeoutId = setTimeout(function () {
    
                timeoutId = 0;
                return finish(new Error('Timeout'));
            }, settings.timeout);
        }
    
        // Construct NTP message
    
        var message = new Buffer(48);
        for (var i = 0; i < 48; i++) {                      // Zero message
            message[i] = 0;
        }
    
        message[0] = (0 << 6) + (4 << 3) + (3 << 0)         // Set version number to 4 and Mode to 3 (client)
        sent = Date.now();
        internals.fromMsecs(sent, message, 40);               // Set transmit timestamp (returns as originate)
    
        // Send NTP request
    
        socket.send(message, 0, message.length, settings.port, settings.host, function (err, bytes) {
    
            if (err ||
                bytes !== 48) {
    
                return finish(err || new Error('Could not send entire message'));
            }
        });
    };
    
    
    internals.NtpMessage = function (buffer) {
    
        this.isValid = false;
    
        // Validate
    
        if (buffer.length !== 48) {
            return;
        }
    
        // Leap indicator
    
        var li = (buffer[0] >> 6);
        switch (li) {
            case 0: this.leapIndicator = 'no-warning'; break;
            case 1: this.leapIndicator = 'last-minute-61'; break;
            case 2: this.leapIndicator = 'last-minute-59'; break;
            case 3: this.leapIndicator = 'alarm'; break;
        }
    
        // Version
    
        var vn = ((buffer[0] & 0x38) >> 3);
        this.version = vn;
    
        // Mode
    
        var mode = (buffer[0] & 0x7);
        switch (mode) {
            case 1: this.mode = 'symmetric-active'; break;
            case 2: this.mode = 'symmetric-passive'; break;
            case 3: this.mode = 'client'; break;
            case 4: this.mode = 'server'; break;
            case 5: this.mode = 'broadcast'; break;
            case 0:
            case 6:
            case 7: this.mode = 'reserved'; break;
        }
    
        // Stratum
    
        var stratum = buffer[1];
        if (stratum === 0) {
            this.stratum = 'death';
        }
        else if (stratum === 1) {
            this.stratum = 'primary';
        }
        else if (stratum <= 15) {
            this.stratum = 'secondary';
        }
        else {
            this.stratum = 'reserved';
        }
    
        // Poll interval (msec)
    
        this.pollInterval = Math.round(Math.pow(2, buffer[2])) * 1000;
    
        // Precision (msecs)
    
        this.precision = Math.pow(2, buffer[3]) * 1000;
    
        // Root delay (msecs)
    
        var rootDelay = 256 * (256 * (256 * buffer[4] + buffer[5]) + buffer[6]) + buffer[7];
        this.rootDelay = 1000 * (rootDelay / 0x10000);
    
        // Root dispersion (msecs)
    
        this.rootDispersion = ((buffer[8] << 8) + buffer[9] + ((buffer[10] << 8) + buffer[11]) / Math.pow(2, 16)) * 1000;
    
        // Reference identifier
    
        this.referenceId = '';
        switch (this.stratum) {
            case 'death':
            case 'primary':
                this.referenceId = String.fromCharCode(buffer[12]) + String.fromCharCode(buffer[13]) + String.fromCharCode(buffer[14]) + String.fromCharCode(buffer[15]);
                break;
            case 'secondary':
                this.referenceId = '' + buffer[12] + '.' + buffer[13] + '.' + buffer[14] + '.' + buffer[15];
                break;
        }
    
        // Reference timestamp
    
        this.referenceTimestamp = internals.toMsecs(buffer, 16);
    
        // Originate timestamp
    
        this.originateTimestamp = internals.toMsecs(buffer, 24);
    
        // Receive timestamp
    
        this.receiveTimestamp = internals.toMsecs(buffer, 32);
    
        // Transmit timestamp
    
        this.transmitTimestamp = internals.toMsecs(buffer, 40);
    
        // Validate
    
        if (this.version === 4 &&
            this.stratum !== 'reserved' &&
            this.mode === 'server' &&
            this.originateTimestamp &&
            this.receiveTimestamp &&
            this.transmitTimestamp) {
    
            this.isValid = true;
        }
    
        return this;
    };
    
    
    internals.toMsecs = function (buffer, offset) {
    
        var seconds = 0;
        var fraction = 0;
    
        for (var i = 0; i < 4; ++i) {
            seconds = (seconds * 256) + buffer[offset + i];
        }
    
        for (i = 4; i < 8; ++i) {
            fraction = (fraction * 256) + buffer[offset + i];
        }
    
        return ((seconds - 2208988800 + (fraction / Math.pow(2, 32))) * 1000);
    };
    
    
    internals.fromMsecs = function (ts, buffer, offset) {
    
        var seconds = Math.floor(ts / 1000) + 2208988800;
        var fraction = Math.round((ts % 1000) / 1000 * Math.pow(2, 32));
    
        buffer[offset + 0] = (seconds & 0xFF000000) >> 24;
        buffer[offset + 1] = (seconds & 0x00FF0000) >> 16;
        buffer[offset + 2] = (seconds & 0x0000FF00) >> 8;
        buffer[offset + 3] = (seconds & 0x000000FF);
    
        buffer[offset + 4] = (fraction & 0xFF000000) >> 24;
        buffer[offset + 5] = (fraction & 0x00FF0000) >> 16;
        buffer[offset + 6] = (fraction & 0x0000FF00) >> 8;
        buffer[offset + 7] = (fraction & 0x000000FF);
    };
    
    
    // Offset singleton
    
    internals.last = {
        offset: 0,
        expires: 0,
        host: '',
        port: 0
    };
    
    
    exports.offset = function (options, callback) {
    
        if (arguments.length !== 2) {
            callback = arguments[0];
            options = {};
        }
    
        var now = Date.now();
        var clockSyncRefresh = options.clockSyncRefresh || 24 * 60 * 60 * 1000;                    // Daily
    
        if (internals.last.offset &&
            internals.last.host === options.host &&
            internals.last.port === options.port &&
            now < internals.last.expires) {
    
            process.nextTick(function () {
    
                callback(null, internals.last.offset);
            });
    
            return;
        }
    
        exports.time(options, function (err, time) {
    
            if (err) {
                return callback(err, 0);
            }
    
            internals.last = {
                offset: Math.round(time.t),
                expires: now + clockSyncRefresh,
                host: options.host,
                port: options.port
            };
    
            return callback(null, internals.last.offset);
        });
    };
    
    
    // Now singleton
    
    internals.now = {
        intervalId: 0
    };
    
    
    exports.start = function (options, callback) {
    
        if (arguments.length !== 2) {
            callback = arguments[0];
            options = {};
        }
    
        if (internals.now.intervalId) {
            process.nextTick(function () {
    
                callback();
            });
    
            return;
        }
    
        exports.offset(options, function (err, offset) {
    
            internals.now.intervalId = setInterval(function () {
    
                exports.offset(options, function () { });
            }, options.clockSyncRefresh || 24 * 60 * 60 * 1000);                                // Daily
    
            return callback();
        });
    };
    
    
    exports.stop = function () {
    
        if (!internals.now.intervalId) {
            return;
        }
    
        clearInterval(internals.now.intervalId);
        internals.now.intervalId = 0;
    };
    
    
    exports.isLive = function () {
    
        return !!internals.now.intervalId;
    };
    
    
    exports.now = function () {
    
        var now = Date.now();
        if (!exports.isLive() ||
            now >= internals.last.expires) {
    
            return now;
        }
    
        return now + internals.last.offset;
    };
    
    
    internals.ignore = function () {
    
    };
    
  provide("sntp/lib", module.exports);
}(global));

// pakmanager:sntp
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  module.exports =  require('sntp/lib');
  provide("sntp", module.exports);
}(global));

// pakmanager:bluebird/js/main/es5.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var isES5 = (function(){
        "use strict";
        return this === undefined;
    })();
    
    if (isES5) {
        module.exports = {
            freeze: Object.freeze,
            defineProperty: Object.defineProperty,
            getDescriptor: Object.getOwnPropertyDescriptor,
            keys: Object.keys,
            names: Object.getOwnPropertyNames,
            getPrototypeOf: Object.getPrototypeOf,
            isArray: Array.isArray,
            isES5: isES5,
            propertyIsWritable: function(obj, prop) {
                var descriptor = Object.getOwnPropertyDescriptor(obj, prop);
                return !!(!descriptor || descriptor.writable || descriptor.set);
            }
        };
    } else {
        var has = {}.hasOwnProperty;
        var str = {}.toString;
        var proto = {}.constructor.prototype;
    
        var ObjectKeys = function (o) {
            var ret = [];
            for (var key in o) {
                if (has.call(o, key)) {
                    ret.push(key);
                }
            }
            return ret;
        };
    
        var ObjectGetDescriptor = function(o, key) {
            return {value: o[key]};
        };
    
        var ObjectDefineProperty = function (o, key, desc) {
            o[key] = desc.value;
            return o;
        };
    
        var ObjectFreeze = function (obj) {
            return obj;
        };
    
        var ObjectGetPrototypeOf = function (obj) {
            try {
                return Object(obj).constructor.prototype;
            }
            catch (e) {
                return proto;
            }
        };
    
        var ArrayIsArray = function (obj) {
            try {
                return str.call(obj) === "[object Array]";
            }
            catch(e) {
                return false;
            }
        };
    
        module.exports = {
            isArray: ArrayIsArray,
            keys: ObjectKeys,
            names: ObjectKeys,
            defineProperty: ObjectDefineProperty,
            getDescriptor: ObjectGetDescriptor,
            freeze: ObjectFreeze,
            getPrototypeOf: ObjectGetPrototypeOf,
            isES5: isES5,
            propertyIsWritable: function() {
                return true;
            }
        };
    }
    
  provide("bluebird/js/main/es5.js", module.exports);
}(global));

// pakmanager:bluebird/js/main/util
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  "use strict";
    var es5 =  require('bluebird/js/main/es5.js');
    var canEvaluate = typeof navigator == "undefined";
    var haveGetters = (function(){
        try {
            var o = {};
            es5.defineProperty(o, "f", {
                get: function () {
                    return 3;
                }
            });
            return o.f === 3;
        }
        catch (e) {
            return false;
        }
    
    })();
    
    var errorObj = {e: {}};
    var tryCatchTarget;
    function tryCatcher() {
        try {
            return tryCatchTarget.apply(this, arguments);
        } catch (e) {
            errorObj.e = e;
            return errorObj;
        }
    }
    function tryCatch(fn) {
        tryCatchTarget = fn;
        return tryCatcher;
    }
    
    var inherits = function(Child, Parent) {
        var hasProp = {}.hasOwnProperty;
    
        function T() {
            this.constructor = Child;
            this.constructor$ = Parent;
            for (var propertyName in Parent.prototype) {
                if (hasProp.call(Parent.prototype, propertyName) &&
                    propertyName.charAt(propertyName.length-1) !== "$"
               ) {
                    this[propertyName + "$"] = Parent.prototype[propertyName];
                }
            }
        }
        T.prototype = Parent.prototype;
        Child.prototype = new T();
        return Child.prototype;
    };
    
    
    function isPrimitive(val) {
        return val == null || val === true || val === false ||
            typeof val === "string" || typeof val === "number";
    
    }
    
    function isObject(value) {
        return !isPrimitive(value);
    }
    
    function maybeWrapAsError(maybeError) {
        if (!isPrimitive(maybeError)) return maybeError;
    
        return new Error(safeToString(maybeError));
    }
    
    function withAppended(target, appendee) {
        var len = target.length;
        var ret = new Array(len + 1);
        var i;
        for (i = 0; i < len; ++i) {
            ret[i] = target[i];
        }
        ret[i] = appendee;
        return ret;
    }
    
    function getDataPropertyOrDefault(obj, key, defaultValue) {
        if (es5.isES5) {
            var desc = Object.getOwnPropertyDescriptor(obj, key);
            if (desc != null) {
                return desc.get == null && desc.set == null
                        ? desc.value
                        : defaultValue;
            }
        } else {
            return {}.hasOwnProperty.call(obj, key) ? obj[key] : undefined;
        }
    }
    
    function notEnumerableProp(obj, name, value) {
        if (isPrimitive(obj)) return obj;
        var descriptor = {
            value: value,
            configurable: true,
            enumerable: false,
            writable: true
        };
        es5.defineProperty(obj, name, descriptor);
        return obj;
    }
    
    function thrower(r) {
        throw r;
    }
    
    var inheritedDataKeys = (function() {
        if (es5.isES5) {
            var oProto = Object.prototype;
            var getKeys = Object.getOwnPropertyNames;
            return function(obj) {
                var ret = [];
                var visitedKeys = Object.create(null);
                while (obj != null && obj !== oProto) {
                    var keys;
                    try {
                        keys = getKeys(obj);
                    } catch (e) {
                        return ret;
                    }
                    for (var i = 0; i < keys.length; ++i) {
                        var key = keys[i];
                        if (visitedKeys[key]) continue;
                        visitedKeys[key] = true;
                        var desc = Object.getOwnPropertyDescriptor(obj, key);
                        if (desc != null && desc.get == null && desc.set == null) {
                            ret.push(key);
                        }
                    }
                    obj = es5.getPrototypeOf(obj);
                }
                return ret;
            };
        } else {
            return function(obj) {
                var ret = [];
                /*jshint forin:false */
                for (var key in obj) {
                    ret.push(key);
                }
                return ret;
            };
        }
    
    })();
    
    var thisAssignmentPattern = /this\s*\.\s*\S+\s*=/;
    function isClass(fn) {
        try {
            if (typeof fn === "function") {
                var keys = es5.names(fn.prototype);
                if (((es5.isES5 && keys.length > 1) ||
                    (keys.length > 0 &&
                    !(keys.length === 1 && keys[0] === "constructor"))) ||
                    thisAssignmentPattern.test(fn + "")) {
                    return true;
                }
            }
            return false;
        } catch (e) {
            return false;
        }
    }
    
    function toFastProperties(obj) {
        /*jshint -W027,-W055,-W031*/
        function f() {}
        f.prototype = obj;
        var l = 8;
        while (l--) new f();
        return obj;
        eval(obj);
    }
    
    var rident = /^[a-z$_][a-z$_0-9]*$/i;
    function isIdentifier(str) {
        return rident.test(str);
    }
    
    function filledRange(count, prefix, suffix) {
        var ret = new Array(count);
        for(var i = 0; i < count; ++i) {
            ret[i] = prefix + i + suffix;
        }
        return ret;
    }
    
    function safeToString(obj) {
        try {
            return obj + "";
        } catch (e) {
            return "[no string representation]";
        }
    }
    
    function markAsOriginatingFromRejection(e) {
        try {
            notEnumerableProp(e, "isOperational", true);
        }
        catch(ignore) {}
    }
    
    function originatesFromRejection(e) {
        if (e == null) return false;
        return ((e instanceof Error["__BluebirdErrorTypes__"].OperationalError) ||
            e["isOperational"] === true);
    }
    
    function canAttachTrace(obj) {
        return obj instanceof Error && es5.propertyIsWritable(obj, "stack");
    }
    
    var ensureErrorObject = (function() {
        if (!("stack" in new Error())) {
            return function(value) {
                if (canAttachTrace(value)) return value;
                try {throw new Error(safeToString(value));}
                catch(err) {return err;}
            };
        } else {
            return function(value) {
                if (canAttachTrace(value)) return value;
                return new Error(safeToString(value));
            };
        }
    })();
    
    function classString(obj) {
        return {}.toString.call(obj);
    }
    
    function copyDescriptors(from, to, filter) {
        var keys = es5.names(from);
        for (var i = 0; i < keys.length; ++i) {
            var key = keys[i];
            if (filter(key)) {
                es5.defineProperty(to, key, es5.getDescriptor(from, key));
            }
        }
    }
    
    function isNativeFunctionMethod(fn) {
        return fn === fn.call ||
               fn === fn.toString ||
               fn === fn.bind ||
               fn === fn.apply;
    }
    
    var ret = {
        isClass: isClass,
        isIdentifier: isIdentifier,
        inheritedDataKeys: inheritedDataKeys,
        getDataPropertyOrDefault: getDataPropertyOrDefault,
        thrower: thrower,
        isArray: es5.isArray,
        haveGetters: haveGetters,
        notEnumerableProp: notEnumerableProp,
        isPrimitive: isPrimitive,
        isObject: isObject,
        canEvaluate: canEvaluate,
        errorObj: errorObj,
        tryCatch: tryCatch,
        inherits: inherits,
        withAppended: withAppended,
        maybeWrapAsError: maybeWrapAsError,
        toFastProperties: toFastProperties,
        filledRange: filledRange,
        toString: safeToString,
        canAttachTrace: canAttachTrace,
        ensureErrorObject: ensureErrorObject,
        originatesFromRejection: originatesFromRejection,
        markAsOriginatingFromRejection: markAsOriginatingFromRejection,
        classString: classString,
        copyDescriptors: copyDescriptors,
        hasDevTools: typeof chrome !== "undefined" && chrome &&
                     typeof chrome.loadTimes === "function",
        isNode: typeof process !== "undefined" &&
            classString(process).toLowerCase() === "[object process]",
        isNativeFunctionMethod: isNativeFunctionMethod
    };
    ret.isRecentNode = ret.isNode && (function() {
        var version = process.versions.node.split(".").map(Number);
        return (version[0] === 0 && version[1] > 10) || (version[0] > 0);
    })();
    
    if (ret.isNode) ret.toFastProperties(process);
    
    try {throw new Error(); } catch (e) {ret.lastLineError = e;}
    module.exports = ret;
    
  provide("bluebird/js/main/util", module.exports);
}(global));

// pakmanager:bluebird/js/main/util.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  "use strict";
    var es5 =  require('bluebird/js/main/es5.js');
    var canEvaluate = typeof navigator == "undefined";
    var haveGetters = (function(){
        try {
            var o = {};
            es5.defineProperty(o, "f", {
                get: function () {
                    return 3;
                }
            });
            return o.f === 3;
        }
        catch (e) {
            return false;
        }
    
    })();
    
    var errorObj = {e: {}};
    var tryCatchTarget;
    function tryCatcher() {
        try {
            return tryCatchTarget.apply(this, arguments);
        } catch (e) {
            errorObj.e = e;
            return errorObj;
        }
    }
    function tryCatch(fn) {
        tryCatchTarget = fn;
        return tryCatcher;
    }
    
    var inherits = function(Child, Parent) {
        var hasProp = {}.hasOwnProperty;
    
        function T() {
            this.constructor = Child;
            this.constructor$ = Parent;
            for (var propertyName in Parent.prototype) {
                if (hasProp.call(Parent.prototype, propertyName) &&
                    propertyName.charAt(propertyName.length-1) !== "$"
               ) {
                    this[propertyName + "$"] = Parent.prototype[propertyName];
                }
            }
        }
        T.prototype = Parent.prototype;
        Child.prototype = new T();
        return Child.prototype;
    };
    
    
    function isPrimitive(val) {
        return val == null || val === true || val === false ||
            typeof val === "string" || typeof val === "number";
    
    }
    
    function isObject(value) {
        return !isPrimitive(value);
    }
    
    function maybeWrapAsError(maybeError) {
        if (!isPrimitive(maybeError)) return maybeError;
    
        return new Error(safeToString(maybeError));
    }
    
    function withAppended(target, appendee) {
        var len = target.length;
        var ret = new Array(len + 1);
        var i;
        for (i = 0; i < len; ++i) {
            ret[i] = target[i];
        }
        ret[i] = appendee;
        return ret;
    }
    
    function getDataPropertyOrDefault(obj, key, defaultValue) {
        if (es5.isES5) {
            var desc = Object.getOwnPropertyDescriptor(obj, key);
            if (desc != null) {
                return desc.get == null && desc.set == null
                        ? desc.value
                        : defaultValue;
            }
        } else {
            return {}.hasOwnProperty.call(obj, key) ? obj[key] : undefined;
        }
    }
    
    function notEnumerableProp(obj, name, value) {
        if (isPrimitive(obj)) return obj;
        var descriptor = {
            value: value,
            configurable: true,
            enumerable: false,
            writable: true
        };
        es5.defineProperty(obj, name, descriptor);
        return obj;
    }
    
    function thrower(r) {
        throw r;
    }
    
    var inheritedDataKeys = (function() {
        if (es5.isES5) {
            var oProto = Object.prototype;
            var getKeys = Object.getOwnPropertyNames;
            return function(obj) {
                var ret = [];
                var visitedKeys = Object.create(null);
                while (obj != null && obj !== oProto) {
                    var keys;
                    try {
                        keys = getKeys(obj);
                    } catch (e) {
                        return ret;
                    }
                    for (var i = 0; i < keys.length; ++i) {
                        var key = keys[i];
                        if (visitedKeys[key]) continue;
                        visitedKeys[key] = true;
                        var desc = Object.getOwnPropertyDescriptor(obj, key);
                        if (desc != null && desc.get == null && desc.set == null) {
                            ret.push(key);
                        }
                    }
                    obj = es5.getPrototypeOf(obj);
                }
                return ret;
            };
        } else {
            return function(obj) {
                var ret = [];
                /*jshint forin:false */
                for (var key in obj) {
                    ret.push(key);
                }
                return ret;
            };
        }
    
    })();
    
    var thisAssignmentPattern = /this\s*\.\s*\S+\s*=/;
    function isClass(fn) {
        try {
            if (typeof fn === "function") {
                var keys = es5.names(fn.prototype);
                if (((es5.isES5 && keys.length > 1) ||
                    (keys.length > 0 &&
                    !(keys.length === 1 && keys[0] === "constructor"))) ||
                    thisAssignmentPattern.test(fn + "")) {
                    return true;
                }
            }
            return false;
        } catch (e) {
            return false;
        }
    }
    
    function toFastProperties(obj) {
        /*jshint -W027,-W055,-W031*/
        function f() {}
        f.prototype = obj;
        var l = 8;
        while (l--) new f();
        return obj;
        eval(obj);
    }
    
    var rident = /^[a-z$_][a-z$_0-9]*$/i;
    function isIdentifier(str) {
        return rident.test(str);
    }
    
    function filledRange(count, prefix, suffix) {
        var ret = new Array(count);
        for(var i = 0; i < count; ++i) {
            ret[i] = prefix + i + suffix;
        }
        return ret;
    }
    
    function safeToString(obj) {
        try {
            return obj + "";
        } catch (e) {
            return "[no string representation]";
        }
    }
    
    function markAsOriginatingFromRejection(e) {
        try {
            notEnumerableProp(e, "isOperational", true);
        }
        catch(ignore) {}
    }
    
    function originatesFromRejection(e) {
        if (e == null) return false;
        return ((e instanceof Error["__BluebirdErrorTypes__"].OperationalError) ||
            e["isOperational"] === true);
    }
    
    function canAttachTrace(obj) {
        return obj instanceof Error && es5.propertyIsWritable(obj, "stack");
    }
    
    var ensureErrorObject = (function() {
        if (!("stack" in new Error())) {
            return function(value) {
                if (canAttachTrace(value)) return value;
                try {throw new Error(safeToString(value));}
                catch(err) {return err;}
            };
        } else {
            return function(value) {
                if (canAttachTrace(value)) return value;
                return new Error(safeToString(value));
            };
        }
    })();
    
    function classString(obj) {
        return {}.toString.call(obj);
    }
    
    function copyDescriptors(from, to, filter) {
        var keys = es5.names(from);
        for (var i = 0; i < keys.length; ++i) {
            var key = keys[i];
            if (filter(key)) {
                es5.defineProperty(to, key, es5.getDescriptor(from, key));
            }
        }
    }
    
    function isNativeFunctionMethod(fn) {
        return fn === fn.call ||
               fn === fn.toString ||
               fn === fn.bind ||
               fn === fn.apply;
    }
    
    var ret = {
        isClass: isClass,
        isIdentifier: isIdentifier,
        inheritedDataKeys: inheritedDataKeys,
        getDataPropertyOrDefault: getDataPropertyOrDefault,
        thrower: thrower,
        isArray: es5.isArray,
        haveGetters: haveGetters,
        notEnumerableProp: notEnumerableProp,
        isPrimitive: isPrimitive,
        isObject: isObject,
        canEvaluate: canEvaluate,
        errorObj: errorObj,
        tryCatch: tryCatch,
        inherits: inherits,
        withAppended: withAppended,
        maybeWrapAsError: maybeWrapAsError,
        toFastProperties: toFastProperties,
        filledRange: filledRange,
        toString: safeToString,
        canAttachTrace: canAttachTrace,
        ensureErrorObject: ensureErrorObject,
        originatesFromRejection: originatesFromRejection,
        markAsOriginatingFromRejection: markAsOriginatingFromRejection,
        classString: classString,
        copyDescriptors: copyDescriptors,
        hasDevTools: typeof chrome !== "undefined" && chrome &&
                     typeof chrome.loadTimes === "function",
        isNode: typeof process !== "undefined" &&
            classString(process).toLowerCase() === "[object process]",
        isNativeFunctionMethod: isNativeFunctionMethod
    };
    ret.isRecentNode = ret.isNode && (function() {
        var version = process.versions.node.split(".").map(Number);
        return (version[0] === 0 && version[1] > 10) || (version[0] > 0);
    })();
    
    if (ret.isNode) ret.toFastProperties(process);
    
    try {throw new Error(); } catch (e) {ret.lastLineError = e;}
    module.exports = ret;
    
  provide("bluebird/js/main/util.js", module.exports);
}(global));

// pakmanager:bluebird/js/main/schedule.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  "use strict";
    var schedule;
    var util =  require('bluebird/js/main/util');
    var noAsyncScheduler = function() {
        throw new Error("No async scheduler available\u000a\u000a    See http://goo.gl/m3OTXk\u000a");
    };
    if (util.isNode && typeof MutationObserver === "undefined") {
        var GlobalSetImmediate = global.setImmediate;
        var ProcessNextTick = process.nextTick;
        schedule = util.isRecentNode
                    ? function(fn) { GlobalSetImmediate.call(global, fn); }
                    : function(fn) { ProcessNextTick.call(process, fn); };
    } else if ((typeof MutationObserver !== "undefined") &&
              !(typeof window !== "undefined" &&
                window.navigator &&
                window.navigator.standalone)) {
        schedule = function(fn) {
            var div = document.createElement("div");
            var observer = new MutationObserver(fn);
            observer.observe(div, {attributes: true});
            return function() { div.classList.toggle("foo"); };
        };
        schedule.isStatic = true;
    } else if (typeof setImmediate !== "undefined") {
        schedule = function (fn) {
            setImmediate(fn);
        };
    } else if (typeof setTimeout !== "undefined") {
        schedule = function (fn) {
            setTimeout(fn, 0);
        };
    } else {
        schedule = noAsyncScheduler;
    }
    module.exports = schedule;
    
  provide("bluebird/js/main/schedule.js", module.exports);
}(global));

// pakmanager:bluebird/js/main/queue.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  "use strict";
    function arrayMove(src, srcIndex, dst, dstIndex, len) {
        for (var j = 0; j < len; ++j) {
            dst[j + dstIndex] = src[j + srcIndex];
            src[j + srcIndex] = void 0;
        }
    }
    
    function Queue(capacity) {
        this._capacity = capacity;
        this._length = 0;
        this._front = 0;
    }
    
    Queue.prototype._willBeOverCapacity = function (size) {
        return this._capacity < size;
    };
    
    Queue.prototype._pushOne = function (arg) {
        var length = this.length();
        this._checkCapacity(length + 1);
        var i = (this._front + length) & (this._capacity - 1);
        this[i] = arg;
        this._length = length + 1;
    };
    
    Queue.prototype._unshiftOne = function(value) {
        var capacity = this._capacity;
        this._checkCapacity(this.length() + 1);
        var front = this._front;
        var i = (((( front - 1 ) &
                        ( capacity - 1) ) ^ capacity ) - capacity );
        this[i] = value;
        this._front = i;
        this._length = this.length() + 1;
    };
    
    Queue.prototype.unshift = function(fn, receiver, arg) {
        this._unshiftOne(arg);
        this._unshiftOne(receiver);
        this._unshiftOne(fn);
    };
    
    Queue.prototype.push = function (fn, receiver, arg) {
        var length = this.length() + 3;
        if (this._willBeOverCapacity(length)) {
            this._pushOne(fn);
            this._pushOne(receiver);
            this._pushOne(arg);
            return;
        }
        var j = this._front + length - 3;
        this._checkCapacity(length);
        var wrapMask = this._capacity - 1;
        this[(j + 0) & wrapMask] = fn;
        this[(j + 1) & wrapMask] = receiver;
        this[(j + 2) & wrapMask] = arg;
        this._length = length;
    };
    
    Queue.prototype.shift = function () {
        var front = this._front,
            ret = this[front];
    
        this[front] = undefined;
        this._front = (front + 1) & (this._capacity - 1);
        this._length--;
        return ret;
    };
    
    Queue.prototype.length = function () {
        return this._length;
    };
    
    Queue.prototype._checkCapacity = function (size) {
        if (this._capacity < size) {
            this._resizeTo(this._capacity << 1);
        }
    };
    
    Queue.prototype._resizeTo = function (capacity) {
        var oldCapacity = this._capacity;
        this._capacity = capacity;
        var front = this._front;
        var length = this._length;
        var moveItemsCount = (front + length) & (oldCapacity - 1);
        arrayMove(this, 0, this, oldCapacity, moveItemsCount);
    };
    
    module.exports = Queue;
    
  provide("bluebird/js/main/queue.js", module.exports);
}(global));

// pakmanager:bluebird/js/main/errors.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  "use strict";
    var es5 =  require('bluebird/js/main/es5.js');
    var Objectfreeze = es5.freeze;
    var util =  require('bluebird/js/main/util.js');
    var inherits = util.inherits;
    var notEnumerableProp = util.notEnumerableProp;
    
    function subError(nameProperty, defaultMessage) {
        function SubError(message) {
            if (!(this instanceof SubError)) return new SubError(message);
            notEnumerableProp(this, "message",
                typeof message === "string" ? message : defaultMessage);
            notEnumerableProp(this, "name", nameProperty);
            if (Error.captureStackTrace) {
                Error.captureStackTrace(this, this.constructor);
            } else {
                Error.call(this);
            }
        }
        inherits(SubError, Error);
        return SubError;
    }
    
    var _TypeError, _RangeError;
    var Warning = subError("Warning", "warning");
    var CancellationError = subError("CancellationError", "cancellation error");
    var TimeoutError = subError("TimeoutError", "timeout error");
    var AggregateError = subError("AggregateError", "aggregate error");
    try {
        _TypeError = TypeError;
        _RangeError = RangeError;
    } catch(e) {
        _TypeError = subError("TypeError", "type error");
        _RangeError = subError("RangeError", "range error");
    }
    
    var methods = ("join pop push shift unshift slice filter forEach some " +
        "every map indexOf lastIndexOf reduce reduceRight sort reverse").split(" ");
    
    for (var i = 0; i < methods.length; ++i) {
        if (typeof Array.prototype[methods[i]] === "function") {
            AggregateError.prototype[methods[i]] = Array.prototype[methods[i]];
        }
    }
    
    es5.defineProperty(AggregateError.prototype, "length", {
        value: 0,
        configurable: false,
        writable: true,
        enumerable: true
    });
    AggregateError.prototype["isOperational"] = true;
    var level = 0;
    AggregateError.prototype.toString = function() {
        var indent = Array(level * 4 + 1).join(" ");
        var ret = "\n" + indent + "AggregateError of:" + "\n";
        level++;
        indent = Array(level * 4 + 1).join(" ");
        for (var i = 0; i < this.length; ++i) {
            var str = this[i] === this ? "[Circular AggregateError]" : this[i] + "";
            var lines = str.split("\n");
            for (var j = 0; j < lines.length; ++j) {
                lines[j] = indent + lines[j];
            }
            str = lines.join("\n");
            ret += str + "\n";
        }
        level--;
        return ret;
    };
    
    function OperationalError(message) {
        if (!(this instanceof OperationalError))
            return new OperationalError(message);
        notEnumerableProp(this, "name", "OperationalError");
        notEnumerableProp(this, "message", message);
        this.cause = message;
        this["isOperational"] = true;
    
        if (message instanceof Error) {
            notEnumerableProp(this, "message", message.message);
            notEnumerableProp(this, "stack", message.stack);
        } else if (Error.captureStackTrace) {
            Error.captureStackTrace(this, this.constructor);
        }
    
    }
    inherits(OperationalError, Error);
    
    var errorTypes = Error["__BluebirdErrorTypes__"];
    if (!errorTypes) {
        errorTypes = Objectfreeze({
            CancellationError: CancellationError,
            TimeoutError: TimeoutError,
            OperationalError: OperationalError,
            RejectionError: OperationalError,
            AggregateError: AggregateError
        });
        notEnumerableProp(Error, "__BluebirdErrorTypes__", errorTypes);
    }
    
    module.exports = {
        Error: Error,
        TypeError: _TypeError,
        RangeError: _RangeError,
        CancellationError: errorTypes.CancellationError,
        OperationalError: errorTypes.OperationalError,
        TimeoutError: errorTypes.TimeoutError,
        AggregateError: errorTypes.AggregateError,
        Warning: Warning
    };
    
  provide("bluebird/js/main/errors.js", module.exports);
}(global));

// pakmanager:bluebird/js/main/async.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  "use strict";
    var firstLineError;
    try {throw new Error(); } catch (e) {firstLineError = e;}
    var schedule =  require('bluebird/js/main/schedule.js');
    var Queue =  require('bluebird/js/main/queue.js');
    var util =  require('bluebird/js/main/util.js');
    
    function Async() {
        this._isTickUsed = false;
        this._lateQueue = new Queue(16);
        this._normalQueue = new Queue(16);
        this._trampolineEnabled = true;
        var self = this;
        this.drainQueues = function () {
            self._drainQueues();
        };
        this._schedule =
            schedule.isStatic ? schedule(this.drainQueues) : schedule;
    }
    
    Async.prototype.disableTrampolineIfNecessary = function() {
        if (util.hasDevTools) {
            this._trampolineEnabled = false;
        }
    };
    
    Async.prototype.enableTrampoline = function() {
        if (!this._trampolineEnabled) {
            this._trampolineEnabled = true;
            this._schedule = function(fn) {
                setTimeout(fn, 0);
            };
        }
    };
    
    Async.prototype.haveItemsQueued = function () {
        return this._normalQueue.length() > 0;
    };
    
    Async.prototype.throwLater = function(fn, arg) {
        if (arguments.length === 1) {
            arg = fn;
            fn = function () { throw arg; };
        }
        if (typeof setTimeout !== "undefined") {
            setTimeout(function() {
                fn(arg);
            }, 0);
        } else try {
            this._schedule(function() {
                fn(arg);
            });
        } catch (e) {
            throw new Error("No async scheduler available\u000a\u000a    See http://goo.gl/m3OTXk\u000a");
        }
    };
    
    function AsyncInvokeLater(fn, receiver, arg) {
        this._lateQueue.push(fn, receiver, arg);
        this._queueTick();
    }
    
    function AsyncInvoke(fn, receiver, arg) {
        this._normalQueue.push(fn, receiver, arg);
        this._queueTick();
    }
    
    function AsyncSettlePromises(promise) {
        this._normalQueue._pushOne(promise);
        this._queueTick();
    }
    
    if (!util.hasDevTools) {
        Async.prototype.invokeLater = AsyncInvokeLater;
        Async.prototype.invoke = AsyncInvoke;
        Async.prototype.settlePromises = AsyncSettlePromises;
    } else {
        if (schedule.isStatic) {
            schedule = function(fn) { setTimeout(fn, 0); };
        }
        Async.prototype.invokeLater = function (fn, receiver, arg) {
            if (this._trampolineEnabled) {
                AsyncInvokeLater.call(this, fn, receiver, arg);
            } else {
                this._schedule(function() {
                    setTimeout(function() {
                        fn.call(receiver, arg);
                    }, 100);
                });
            }
        };
    
        Async.prototype.invoke = function (fn, receiver, arg) {
            if (this._trampolineEnabled) {
                AsyncInvoke.call(this, fn, receiver, arg);
            } else {
                this._schedule(function() {
                    fn.call(receiver, arg);
                });
            }
        };
    
        Async.prototype.settlePromises = function(promise) {
            if (this._trampolineEnabled) {
                AsyncSettlePromises.call(this, promise);
            } else {
                this._schedule(function() {
                    promise._settlePromises();
                });
            }
        };
    }
    
    Async.prototype.invokeFirst = function (fn, receiver, arg) {
        this._normalQueue.unshift(fn, receiver, arg);
        this._queueTick();
    };
    
    Async.prototype._drainQueue = function(queue) {
        while (queue.length() > 0) {
            var fn = queue.shift();
            if (typeof fn !== "function") {
                fn._settlePromises();
                continue;
            }
            var receiver = queue.shift();
            var arg = queue.shift();
            fn.call(receiver, arg);
        }
    };
    
    Async.prototype._drainQueues = function () {
        this._drainQueue(this._normalQueue);
        this._reset();
        this._drainQueue(this._lateQueue);
    };
    
    Async.prototype._queueTick = function () {
        if (!this._isTickUsed) {
            this._isTickUsed = true;
            this._schedule(this.drainQueues);
        }
    };
    
    Async.prototype._reset = function () {
        this._isTickUsed = false;
    };
    
    module.exports = new Async();
    module.exports.firstLineError = firstLineError;
    
  provide("bluebird/js/main/async.js", module.exports);
}(global));

// pakmanager:bluebird/js/main/promise_resolver.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  "use strict";
    var util =  require('bluebird/js/main/util.js');
    var maybeWrapAsError = util.maybeWrapAsError;
    var errors =  require('bluebird/js/main/errors.js');
    var TimeoutError = errors.TimeoutError;
    var OperationalError = errors.OperationalError;
    var haveGetters = util.haveGetters;
    var es5 =  require('bluebird/js/main/es5.js');
    
    function isUntypedError(obj) {
        return obj instanceof Error &&
            es5.getPrototypeOf(obj) === Error.prototype;
    }
    
    var rErrorKey = /^(?:name|message|stack|cause)$/;
    function wrapAsOperationalError(obj) {
        var ret;
        if (isUntypedError(obj)) {
            ret = new OperationalError(obj);
            ret.name = obj.name;
            ret.message = obj.message;
            ret.stack = obj.stack;
            var keys = es5.keys(obj);
            for (var i = 0; i < keys.length; ++i) {
                var key = keys[i];
                if (!rErrorKey.test(key)) {
                    ret[key] = obj[key];
                }
            }
            return ret;
        }
        util.markAsOriginatingFromRejection(obj);
        return obj;
    }
    
    function nodebackForPromise(promise) {
        return function(err, value) {
            if (promise === null) return;
    
            if (err) {
                var wrapped = wrapAsOperationalError(maybeWrapAsError(err));
                promise._attachExtraTrace(wrapped);
                promise._reject(wrapped);
            } else if (arguments.length > 2) {
                var $_len = arguments.length;var args = new Array($_len - 1); for(var $_i = 1; $_i < $_len; ++$_i) {args[$_i - 1] = arguments[$_i];}
                promise._fulfill(args);
            } else {
                promise._fulfill(value);
            }
    
            promise = null;
        };
    }
    
    
    var PromiseResolver;
    if (!haveGetters) {
        PromiseResolver = function (promise) {
            this.promise = promise;
            this.asCallback = nodebackForPromise(promise);
            this.callback = this.asCallback;
        };
    }
    else {
        PromiseResolver = function (promise) {
            this.promise = promise;
        };
    }
    if (haveGetters) {
        var prop = {
            get: function() {
                return nodebackForPromise(this.promise);
            }
        };
        es5.defineProperty(PromiseResolver.prototype, "asCallback", prop);
        es5.defineProperty(PromiseResolver.prototype, "callback", prop);
    }
    
    PromiseResolver._nodebackForPromise = nodebackForPromise;
    
    PromiseResolver.prototype.toString = function () {
        return "[object PromiseResolver]";
    };
    
    PromiseResolver.prototype.resolve =
    PromiseResolver.prototype.fulfill = function (value) {
        if (!(this instanceof PromiseResolver)) {
            throw new TypeError("Illegal invocation, resolver resolve/reject must be called within a resolver context. Consider using the promise constructor instead.\u000a\u000a    See http://goo.gl/sdkXL9\u000a");
        }
        this.promise._resolveCallback(value);
    };
    
    PromiseResolver.prototype.reject = function (reason) {
        if (!(this instanceof PromiseResolver)) {
            throw new TypeError("Illegal invocation, resolver resolve/reject must be called within a resolver context. Consider using the promise constructor instead.\u000a\u000a    See http://goo.gl/sdkXL9\u000a");
        }
        this.promise._rejectCallback(reason);
    };
    
    PromiseResolver.prototype.progress = function (value) {
        if (!(this instanceof PromiseResolver)) {
            throw new TypeError("Illegal invocation, resolver resolve/reject must be called within a resolver context. Consider using the promise constructor instead.\u000a\u000a    See http://goo.gl/sdkXL9\u000a");
        }
        this.promise._progress(value);
    };
    
    PromiseResolver.prototype.cancel = function (err) {
        this.promise.cancel(err);
    };
    
    PromiseResolver.prototype.timeout = function () {
        this.reject(new TimeoutError("timeout"));
    };
    
    PromiseResolver.prototype.isResolved = function () {
        return this.promise.isResolved();
    };
    
    PromiseResolver.prototype.toJSON = function () {
        return this.promise.toJSON();
    };
    
    module.exports = PromiseResolver;
    
  provide("bluebird/js/main/promise_resolver.js", module.exports);
}(global));

// pakmanager:bluebird/js/main/errors
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  "use strict";
    var es5 =  require('bluebird/js/main/es5.js');
    var Objectfreeze = es5.freeze;
    var util =  require('bluebird/js/main/util.js');
    var inherits = util.inherits;
    var notEnumerableProp = util.notEnumerableProp;
    
    function subError(nameProperty, defaultMessage) {
        function SubError(message) {
            if (!(this instanceof SubError)) return new SubError(message);
            notEnumerableProp(this, "message",
                typeof message === "string" ? message : defaultMessage);
            notEnumerableProp(this, "name", nameProperty);
            if (Error.captureStackTrace) {
                Error.captureStackTrace(this, this.constructor);
            } else {
                Error.call(this);
            }
        }
        inherits(SubError, Error);
        return SubError;
    }
    
    var _TypeError, _RangeError;
    var Warning = subError("Warning", "warning");
    var CancellationError = subError("CancellationError", "cancellation error");
    var TimeoutError = subError("TimeoutError", "timeout error");
    var AggregateError = subError("AggregateError", "aggregate error");
    try {
        _TypeError = TypeError;
        _RangeError = RangeError;
    } catch(e) {
        _TypeError = subError("TypeError", "type error");
        _RangeError = subError("RangeError", "range error");
    }
    
    var methods = ("join pop push shift unshift slice filter forEach some " +
        "every map indexOf lastIndexOf reduce reduceRight sort reverse").split(" ");
    
    for (var i = 0; i < methods.length; ++i) {
        if (typeof Array.prototype[methods[i]] === "function") {
            AggregateError.prototype[methods[i]] = Array.prototype[methods[i]];
        }
    }
    
    es5.defineProperty(AggregateError.prototype, "length", {
        value: 0,
        configurable: false,
        writable: true,
        enumerable: true
    });
    AggregateError.prototype["isOperational"] = true;
    var level = 0;
    AggregateError.prototype.toString = function() {
        var indent = Array(level * 4 + 1).join(" ");
        var ret = "\n" + indent + "AggregateError of:" + "\n";
        level++;
        indent = Array(level * 4 + 1).join(" ");
        for (var i = 0; i < this.length; ++i) {
            var str = this[i] === this ? "[Circular AggregateError]" : this[i] + "";
            var lines = str.split("\n");
            for (var j = 0; j < lines.length; ++j) {
                lines[j] = indent + lines[j];
            }
            str = lines.join("\n");
            ret += str + "\n";
        }
        level--;
        return ret;
    };
    
    function OperationalError(message) {
        if (!(this instanceof OperationalError))
            return new OperationalError(message);
        notEnumerableProp(this, "name", "OperationalError");
        notEnumerableProp(this, "message", message);
        this.cause = message;
        this["isOperational"] = true;
    
        if (message instanceof Error) {
            notEnumerableProp(this, "message", message.message);
            notEnumerableProp(this, "stack", message.stack);
        } else if (Error.captureStackTrace) {
            Error.captureStackTrace(this, this.constructor);
        }
    
    }
    inherits(OperationalError, Error);
    
    var errorTypes = Error["__BluebirdErrorTypes__"];
    if (!errorTypes) {
        errorTypes = Objectfreeze({
            CancellationError: CancellationError,
            TimeoutError: TimeoutError,
            OperationalError: OperationalError,
            RejectionError: OperationalError,
            AggregateError: AggregateError
        });
        notEnumerableProp(Error, "__BluebirdErrorTypes__", errorTypes);
    }
    
    module.exports = {
        Error: Error,
        TypeError: _TypeError,
        RangeError: _RangeError,
        CancellationError: errorTypes.CancellationError,
        OperationalError: errorTypes.OperationalError,
        TimeoutError: errorTypes.TimeoutError,
        AggregateError: errorTypes.AggregateError,
        Warning: Warning
    };
    
  provide("bluebird/js/main/errors", module.exports);
}(global));

// pakmanager:bluebird/js/main/thenables.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  "use strict";
    module.exports = function(Promise, INTERNAL) {
    var util =  require('bluebird/js/main/util.js');
    var errorObj = util.errorObj;
    var isObject = util.isObject;
    
    function tryConvertToPromise(obj, context) {
        if (isObject(obj)) {
            if (obj instanceof Promise) {
                return obj;
            }
            else if (isAnyBluebirdPromise(obj)) {
                var ret = new Promise(INTERNAL);
                obj._then(
                    ret._fulfillUnchecked,
                    ret._rejectUncheckedCheckError,
                    ret._progressUnchecked,
                    ret,
                    null
                );
                return ret;
            }
            var then = util.tryCatch(getThen)(obj);
            if (then === errorObj) {
                if (context) context._pushContext();
                var ret = Promise.reject(then.e);
                if (context) context._popContext();
                return ret;
            } else if (typeof then === "function") {
                return doThenable(obj, then, context);
            }
        }
        return obj;
    }
    
    function getThen(obj) {
        return obj.then;
    }
    
    var hasProp = {}.hasOwnProperty;
    function isAnyBluebirdPromise(obj) {
        return hasProp.call(obj, "_promise0");
    }
    
    function doThenable(x, then, context) {
        var promise = new Promise(INTERNAL);
        var ret = promise;
        if (context) context._pushContext();
        promise._captureStackTrace();
        if (context) context._popContext();
        var synchronous = true;
        var result = util.tryCatch(then).call(x,
                                            resolveFromThenable,
                                            rejectFromThenable,
                                            progressFromThenable);
        synchronous = false;
        if (promise && result === errorObj) {
            promise._rejectCallback(result.e, true, true);
            promise = null;
        }
    
        function resolveFromThenable(value) {
            if (!promise) return;
            promise._resolveCallback(value);
            promise = null;
        }
    
        function rejectFromThenable(reason) {
            if (!promise) return;
            promise._rejectCallback(reason, synchronous, true);
            promise = null;
        }
    
        function progressFromThenable(value) {
            if (!promise) return;
            if (typeof promise._progress === "function") {
                promise._progress(value);
            }
        }
        return ret;
    }
    
    return tryConvertToPromise;
    };
    
  provide("bluebird/js/main/thenables.js", module.exports);
}(global));

// pakmanager:bluebird/js/main/promise_array.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  "use strict";
    module.exports = function(Promise, INTERNAL, tryConvertToPromise,
        apiRejection) {
    var util =  require('bluebird/js/main/util.js');
    var isArray = util.isArray;
    
    function toResolutionValue(val) {
        switch(val) {
        case -2: return [];
        case -3: return {};
        }
    }
    
    function PromiseArray(values) {
        var promise = this._promise = new Promise(INTERNAL);
        var parent;
        if (values instanceof Promise) {
            parent = values;
            promise._propagateFrom(parent, 1 | 4);
        }
        this._values = values;
        this._length = 0;
        this._totalResolved = 0;
        this._init(undefined, -2);
    }
    PromiseArray.prototype.length = function () {
        return this._length;
    };
    
    PromiseArray.prototype.promise = function () {
        return this._promise;
    };
    
    PromiseArray.prototype._init = function init(_, resolveValueIfEmpty) {
        var values = tryConvertToPromise(this._values, this._promise);
        if (values instanceof Promise) {
            values = values._target();
            this._values = values;
            if (values._isFulfilled()) {
                values = values._value();
                if (!isArray(values)) {
                    var err = new Promise.TypeError("expecting an array, a promise or a thenable\u000a\u000a    See http://goo.gl/s8MMhc\u000a");
                    this.__hardReject__(err);
                    return;
                }
            } else if (values._isPending()) {
                values._then(
                    init,
                    this._reject,
                    undefined,
                    this,
                    resolveValueIfEmpty
               );
                return;
            } else {
                this._reject(values._reason());
                return;
            }
        } else if (!isArray(values)) {
            this._promise._reject(apiRejection("expecting an array, a promise or a thenable\u000a\u000a    See http://goo.gl/s8MMhc\u000a")._reason());
            return;
        }
    
        if (values.length === 0) {
            if (resolveValueIfEmpty === -5) {
                this._resolveEmptyArray();
            }
            else {
                this._resolve(toResolutionValue(resolveValueIfEmpty));
            }
            return;
        }
        var len = this.getActualLength(values.length);
        this._length = len;
        this._values = this.shouldCopyValues() ? new Array(len) : this._values;
        var promise = this._promise;
        for (var i = 0; i < len; ++i) {
            var isResolved = this._isResolved();
            var maybePromise = tryConvertToPromise(values[i], promise);
            if (maybePromise instanceof Promise) {
                maybePromise = maybePromise._target();
                if (isResolved) {
                    maybePromise._ignoreRejections();
                } else if (maybePromise._isPending()) {
                    maybePromise._proxyPromiseArray(this, i);
                } else if (maybePromise._isFulfilled()) {
                    this._promiseFulfilled(maybePromise._value(), i);
                } else {
                    this._promiseRejected(maybePromise._reason(), i);
                }
            } else if (!isResolved) {
                this._promiseFulfilled(maybePromise, i);
            }
        }
    };
    
    PromiseArray.prototype._isResolved = function () {
        return this._values === null;
    };
    
    PromiseArray.prototype._resolve = function (value) {
        this._values = null;
        this._promise._fulfill(value);
    };
    
    PromiseArray.prototype.__hardReject__ =
    PromiseArray.prototype._reject = function (reason) {
        this._values = null;
        this._promise._rejectCallback(reason, false, true);
    };
    
    PromiseArray.prototype._promiseProgressed = function (progressValue, index) {
        this._promise._progress({
            index: index,
            value: progressValue
        });
    };
    
    
    PromiseArray.prototype._promiseFulfilled = function (value, index) {
        this._values[index] = value;
        var totalResolved = ++this._totalResolved;
        if (totalResolved >= this._length) {
            this._resolve(this._values);
        }
    };
    
    PromiseArray.prototype._promiseRejected = function (reason, index) {
        this._totalResolved++;
        this._reject(reason);
    };
    
    PromiseArray.prototype.shouldCopyValues = function () {
        return true;
    };
    
    PromiseArray.prototype.getActualLength = function (len) {
        return len;
    };
    
    return PromiseArray;
    };
    
  provide("bluebird/js/main/promise_array.js", module.exports);
}(global));

// pakmanager:bluebird/js/main/captured_trace.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  "use strict";
    module.exports = function() {
    var async =  require('bluebird/js/main/async.js');
    var util =  require('bluebird/js/main/util.js');
    var bluebirdFramePattern =
        /[\\\/]bluebird[\\\/]js[\\\/](main|debug|zalgo|instrumented)/;
    var stackFramePattern = null;
    var formatStack = null;
    var indentStackFrames = false;
    var warn;
    
    function CapturedTrace(parent) {
        this._parent = parent;
        var length = this._length = 1 + (parent === undefined ? 0 : parent._length);
        captureStackTrace(this, CapturedTrace);
        if (length > 32) this.uncycle();
    }
    util.inherits(CapturedTrace, Error);
    
    CapturedTrace.prototype.uncycle = function() {
        var length = this._length;
        if (length < 2) return;
        var nodes = [];
        var stackToIndex = {};
    
        for (var i = 0, node = this; node !== undefined; ++i) {
            nodes.push(node);
            node = node._parent;
        }
        length = this._length = i;
        for (var i = length - 1; i >= 0; --i) {
            var stack = nodes[i].stack;
            if (stackToIndex[stack] === undefined) {
                stackToIndex[stack] = i;
            }
        }
        for (var i = 0; i < length; ++i) {
            var currentStack = nodes[i].stack;
            var index = stackToIndex[currentStack];
            if (index !== undefined && index !== i) {
                if (index > 0) {
                    nodes[index - 1]._parent = undefined;
                    nodes[index - 1]._length = 1;
                }
                nodes[i]._parent = undefined;
                nodes[i]._length = 1;
                var cycleEdgeNode = i > 0 ? nodes[i - 1] : this;
    
                if (index < length - 1) {
                    cycleEdgeNode._parent = nodes[index + 1];
                    cycleEdgeNode._parent.uncycle();
                    cycleEdgeNode._length =
                        cycleEdgeNode._parent._length + 1;
                } else {
                    cycleEdgeNode._parent = undefined;
                    cycleEdgeNode._length = 1;
                }
                var currentChildLength = cycleEdgeNode._length + 1;
                for (var j = i - 2; j >= 0; --j) {
                    nodes[j]._length = currentChildLength;
                    currentChildLength++;
                }
                return;
            }
        }
    };
    
    CapturedTrace.prototype.parent = function() {
        return this._parent;
    };
    
    CapturedTrace.prototype.hasParent = function() {
        return this._parent !== undefined;
    };
    
    CapturedTrace.prototype.attachExtraTrace = function(error) {
        if (error.__stackCleaned__) return;
        this.uncycle();
        var parsed = CapturedTrace.parseStackAndMessage(error);
        var message = parsed.message;
        var stacks = [parsed.stack];
    
        var trace = this;
        while (trace !== undefined) {
            stacks.push(cleanStack(trace.stack.split("\n")));
            trace = trace._parent;
        }
        removeCommonRoots(stacks);
        removeDuplicateOrEmptyJumps(stacks);
        util.notEnumerableProp(error, "stack", reconstructStack(message, stacks));
        util.notEnumerableProp(error, "__stackCleaned__", true);
    };
    
    function reconstructStack(message, stacks) {
        for (var i = 0; i < stacks.length - 1; ++i) {
            stacks[i].push("From previous event:");
            stacks[i] = stacks[i].join("\n");
        }
        if (i < stacks.length) {
            stacks[i] = stacks[i].join("\n");
        }
        return message + "\n" + stacks.join("\n");
    }
    
    function removeDuplicateOrEmptyJumps(stacks) {
        for (var i = 0; i < stacks.length; ++i) {
            if (stacks[i].length === 0 ||
                ((i + 1 < stacks.length) && stacks[i][0] === stacks[i+1][0])) {
                stacks.splice(i, 1);
                i--;
            }
        }
    }
    
    function removeCommonRoots(stacks) {
        var current = stacks[0];
        for (var i = 1; i < stacks.length; ++i) {
            var prev = stacks[i];
            var currentLastIndex = current.length - 1;
            var currentLastLine = current[currentLastIndex];
            var commonRootMeetPoint = -1;
    
            for (var j = prev.length - 1; j >= 0; --j) {
                if (prev[j] === currentLastLine) {
                    commonRootMeetPoint = j;
                    break;
                }
            }
    
            for (var j = commonRootMeetPoint; j >= 0; --j) {
                var line = prev[j];
                if (current[currentLastIndex] === line) {
                    current.pop();
                    currentLastIndex--;
                } else {
                    break;
                }
            }
            current = prev;
        }
    }
    
    function cleanStack(stack) {
        var ret = [];
        for (var i = 0; i < stack.length; ++i) {
            var line = stack[i];
            var isTraceLine = stackFramePattern.test(line) ||
                "    (No stack trace)" === line;
            var isInternalFrame = isTraceLine && shouldIgnore(line);
            if (isTraceLine && !isInternalFrame) {
                if (indentStackFrames && line.charAt(0) !== " ") {
                    line = "    " + line;
                }
                ret.push(line);
            }
        }
        return ret;
    }
    
    function stackFramesAsArray(error) {
        var stack = error.stack.replace(/\s+$/g, "").split("\n");
        for (var i = 0; i < stack.length; ++i) {
            var line = stack[i];
            if ("    (No stack trace)" === line || stackFramePattern.test(line)) {
                break;
            }
        }
        if (i > 0) {
            stack = stack.slice(i);
        }
        return stack;
    }
    
    CapturedTrace.parseStackAndMessage = function(error) {
        var stack = error.stack;
        var message = error.toString();
        stack = typeof stack === "string" && stack.length > 0
                    ? stackFramesAsArray(error) : ["    (No stack trace)"];
        return {
            message: message,
            stack: cleanStack(stack)
        };
    };
    
    CapturedTrace.formatAndLogError = function(error, title) {
        if (typeof console !== "undefined") {
            var message;
            if (typeof error === "object" || typeof error === "function") {
                var stack = error.stack;
                message = title + formatStack(stack, error);
            } else {
                message = title + String(error);
            }
            if (typeof warn === "function") {
                warn(message);
            } else if (typeof console.log === "function" ||
                typeof console.log === "object") {
                console.log(message);
            }
        }
    };
    
    CapturedTrace.unhandledRejection = function (reason) {
        CapturedTrace.formatAndLogError(reason, "^--- With additional stack trace: ");
    };
    
    CapturedTrace.isSupported = function () {
        return typeof captureStackTrace === "function";
    };
    
    CapturedTrace.fireRejectionEvent =
    function(name, localHandler, reason, promise) {
        var localEventFired = false;
        try {
            if (typeof localHandler === "function") {
                localEventFired = true;
                if (name === "rejectionHandled") {
                    localHandler(promise);
                } else {
                    localHandler(reason, promise);
                }
            }
        } catch (e) {
            async.throwLater(e);
        }
    
        var globalEventFired = false;
        try {
            globalEventFired = fireGlobalEvent(name, reason, promise);
        } catch (e) {
            globalEventFired = true;
            async.throwLater(e);
        }
    
        var domEventFired = false;
        if (fireDomEvent) {
            try {
                domEventFired = fireDomEvent(name.toLowerCase(), {
                    reason: reason,
                    promise: promise
                });
            } catch (e) {
                domEventFired = true;
                async.throwLater(e);
            }
        }
    
        if (!globalEventFired && !localEventFired && !domEventFired &&
            name === "unhandledRejection") {
            CapturedTrace.formatAndLogError(reason, "Unhandled rejection ");
        }
    };
    
    function formatNonError(obj) {
        var str;
        if (typeof obj === "function") {
            str = "[function " +
                (obj.name || "anonymous") +
                "]";
        } else {
            str = obj.toString();
            var ruselessToString = /\[object [a-zA-Z0-9$_]+\]/;
            if (ruselessToString.test(str)) {
                try {
                    var newStr = JSON.stringify(obj);
                    str = newStr;
                }
                catch(e) {
    
                }
            }
            if (str.length === 0) {
                str = "(empty array)";
            }
        }
        return ("(<" + snip(str) + ">, no stack trace)");
    }
    
    function snip(str) {
        var maxChars = 41;
        if (str.length < maxChars) {
            return str;
        }
        return str.substr(0, maxChars - 3) + "...";
    }
    
    var shouldIgnore = function() { return false; };
    var parseLineInfoRegex = /[\/<\(]([^:\/]+):(\d+):(?:\d+)\)?\s*$/;
    function parseLineInfo(line) {
        var matches = line.match(parseLineInfoRegex);
        if (matches) {
            return {
                fileName: matches[1],
                line: parseInt(matches[2], 10)
            };
        }
    }
    CapturedTrace.setBounds = function(firstLineError, lastLineError) {
        if (!CapturedTrace.isSupported()) return;
        var firstStackLines = firstLineError.stack.split("\n");
        var lastStackLines = lastLineError.stack.split("\n");
        var firstIndex = -1;
        var lastIndex = -1;
        var firstFileName;
        var lastFileName;
        for (var i = 0; i < firstStackLines.length; ++i) {
            var result = parseLineInfo(firstStackLines[i]);
            if (result) {
                firstFileName = result.fileName;
                firstIndex = result.line;
                break;
            }
        }
        for (var i = 0; i < lastStackLines.length; ++i) {
            var result = parseLineInfo(lastStackLines[i]);
            if (result) {
                lastFileName = result.fileName;
                lastIndex = result.line;
                break;
            }
        }
        if (firstIndex < 0 || lastIndex < 0 || !firstFileName || !lastFileName ||
            firstFileName !== lastFileName || firstIndex >= lastIndex) {
            return;
        }
    
        shouldIgnore = function(line) {
            if (bluebirdFramePattern.test(line)) return true;
            var info = parseLineInfo(line);
            if (info) {
                if (info.fileName === firstFileName &&
                    (firstIndex <= info.line && info.line <= lastIndex)) {
                    return true;
                }
            }
            return false;
        };
    };
    
    var captureStackTrace = (function stackDetection() {
        var v8stackFramePattern = /^\s*at\s*/;
        var v8stackFormatter = function(stack, error) {
            if (typeof stack === "string") return stack;
    
            if (error.name !== undefined &&
                error.message !== undefined) {
                return error.toString();
            }
            return formatNonError(error);
        };
    
        if (typeof Error.stackTraceLimit === "number" &&
            typeof Error.captureStackTrace === "function") {
            Error.stackTraceLimit = Error.stackTraceLimit + 6;
            stackFramePattern = v8stackFramePattern;
            formatStack = v8stackFormatter;
            var captureStackTrace = Error.captureStackTrace;
    
            shouldIgnore = function(line) {
                return bluebirdFramePattern.test(line);
            };
            return function(receiver, ignoreUntil) {
                Error.stackTraceLimit = Error.stackTraceLimit + 6;
                captureStackTrace(receiver, ignoreUntil);
                Error.stackTraceLimit = Error.stackTraceLimit - 6;
            };
        }
        var err = new Error();
    
        if (typeof err.stack === "string" &&
            err.stack.split("\n")[0].indexOf("stackDetection@") >= 0) {
            stackFramePattern = /@/;
            formatStack = v8stackFormatter;
            indentStackFrames = true;
            return function captureStackTrace(o) {
                o.stack = new Error().stack;
            };
        }
    
        var hasStackAfterThrow;
        try { throw new Error(); }
        catch(e) {
            hasStackAfterThrow = ("stack" in e);
        }
        if (!("stack" in err) && hasStackAfterThrow) {
            stackFramePattern = v8stackFramePattern;
            formatStack = v8stackFormatter;
            return function captureStackTrace(o) {
                Error.stackTraceLimit = Error.stackTraceLimit + 6;
                try { throw new Error(); }
                catch(e) { o.stack = e.stack; }
                Error.stackTraceLimit = Error.stackTraceLimit - 6;
            };
        }
    
        formatStack = function(stack, error) {
            if (typeof stack === "string") return stack;
    
            if ((typeof error === "object" ||
                typeof error === "function") &&
                error.name !== undefined &&
                error.message !== undefined) {
                return error.toString();
            }
            return formatNonError(error);
        };
    
        return null;
    
    })([]);
    
    var fireDomEvent;
    var fireGlobalEvent = (function() {
        if (util.isNode) {
            return function(name, reason, promise) {
                if (name === "rejectionHandled") {
                    return process.emit(name, promise);
                } else {
                    return process.emit(name, reason, promise);
                }
            };
        } else {
            var customEventWorks = false;
            var anyEventWorks = true;
            try {
                var ev = new self.CustomEvent("test");
                customEventWorks = ev instanceof CustomEvent;
            } catch (e) {}
            if (!customEventWorks) {
                try {
                    var event = document.createEvent("CustomEvent");
                    event.initCustomEvent("testingtheevent", false, true, {});
                    self.dispatchEvent(event);
                } catch (e) {
                    anyEventWorks = false;
                }
            }
            if (anyEventWorks) {
                fireDomEvent = function(type, detail) {
                    var event;
                    if (customEventWorks) {
                        event = new self.CustomEvent(type, {
                            detail: detail,
                            bubbles: false,
                            cancelable: true
                        });
                    } else if (self.dispatchEvent) {
                        event = document.createEvent("CustomEvent");
                        event.initCustomEvent(type, false, true, detail);
                    }
    
                    return event ? !self.dispatchEvent(event) : false;
                };
            }
    
            var toWindowMethodNameMap = {};
            toWindowMethodNameMap["unhandledRejection"] = ("on" +
                "unhandledRejection").toLowerCase();
            toWindowMethodNameMap["rejectionHandled"] = ("on" +
                "rejectionHandled").toLowerCase();
    
            return function(name, reason, promise) {
                var methodName = toWindowMethodNameMap[name];
                var method = self[methodName];
                if (!method) return false;
                if (name === "rejectionHandled") {
                    method.call(self, promise);
                } else {
                    method.call(self, reason, promise);
                }
                return true;
            };
        }
    })();
    
    if (typeof console !== "undefined" && typeof console.warn !== "undefined") {
        warn = function (message) {
            console.warn(message);
        };
        if (util.isNode && process.stderr.isTTY) {
            warn = function(message) {
                process.stderr.write("\u001b[31m" + message + "\u001b[39m\n");
            };
        } else if (!util.isNode && typeof (new Error().stack) === "string") {
            warn = function(message) {
                console.warn("%c" + message, "color: red");
            };
        }
    }
    
    return CapturedTrace;
    };
    
  provide("bluebird/js/main/captured_trace.js", module.exports);
}(global));

// pakmanager:bluebird/js/main/debuggability.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  "use strict";
    module.exports = function(Promise, CapturedTrace) {
    var getDomain = Promise._getDomain;
    var async =  require('bluebird/js/main/async.js');
    var Warning =  require('bluebird/js/main/errors.js').Warning;
    var util =  require('bluebird/js/main/util.js');
    var canAttachTrace = util.canAttachTrace;
    var unhandledRejectionHandled;
    var possiblyUnhandledRejection;
    var debugging = false || (util.isNode &&
                        (!!process.env["BLUEBIRD_DEBUG"] ||
                         process.env["NODE_ENV"] === "development"));
    
    if (debugging) {
        async.disableTrampolineIfNecessary();
    }
    
    Promise.prototype._ignoreRejections = function() {
        this._unsetRejectionIsUnhandled();
        this._bitField = this._bitField | 16777216;
    };
    
    Promise.prototype._ensurePossibleRejectionHandled = function () {
        if ((this._bitField & 16777216) !== 0) return;
        this._setRejectionIsUnhandled();
        async.invokeLater(this._notifyUnhandledRejection, this, undefined);
    };
    
    Promise.prototype._notifyUnhandledRejectionIsHandled = function () {
        CapturedTrace.fireRejectionEvent("rejectionHandled",
                                      unhandledRejectionHandled, undefined, this);
    };
    
    Promise.prototype._notifyUnhandledRejection = function () {
        if (this._isRejectionUnhandled()) {
            var reason = this._getCarriedStackTrace() || this._settledValue;
            this._setUnhandledRejectionIsNotified();
            CapturedTrace.fireRejectionEvent("unhandledRejection",
                                          possiblyUnhandledRejection, reason, this);
        }
    };
    
    Promise.prototype._setUnhandledRejectionIsNotified = function () {
        this._bitField = this._bitField | 524288;
    };
    
    Promise.prototype._unsetUnhandledRejectionIsNotified = function () {
        this._bitField = this._bitField & (~524288);
    };
    
    Promise.prototype._isUnhandledRejectionNotified = function () {
        return (this._bitField & 524288) > 0;
    };
    
    Promise.prototype._setRejectionIsUnhandled = function () {
        this._bitField = this._bitField | 2097152;
    };
    
    Promise.prototype._unsetRejectionIsUnhandled = function () {
        this._bitField = this._bitField & (~2097152);
        if (this._isUnhandledRejectionNotified()) {
            this._unsetUnhandledRejectionIsNotified();
            this._notifyUnhandledRejectionIsHandled();
        }
    };
    
    Promise.prototype._isRejectionUnhandled = function () {
        return (this._bitField & 2097152) > 0;
    };
    
    Promise.prototype._setCarriedStackTrace = function (capturedTrace) {
        this._bitField = this._bitField | 1048576;
        this._fulfillmentHandler0 = capturedTrace;
    };
    
    Promise.prototype._isCarryingStackTrace = function () {
        return (this._bitField & 1048576) > 0;
    };
    
    Promise.prototype._getCarriedStackTrace = function () {
        return this._isCarryingStackTrace()
            ? this._fulfillmentHandler0
            : undefined;
    };
    
    Promise.prototype._captureStackTrace = function () {
        if (debugging) {
            this._trace = new CapturedTrace(this._peekContext());
        }
        return this;
    };
    
    Promise.prototype._attachExtraTrace = function (error, ignoreSelf) {
        if (debugging && canAttachTrace(error)) {
            var trace = this._trace;
            if (trace !== undefined) {
                if (ignoreSelf) trace = trace._parent;
            }
            if (trace !== undefined) {
                trace.attachExtraTrace(error);
            } else if (!error.__stackCleaned__) {
                var parsed = CapturedTrace.parseStackAndMessage(error);
                util.notEnumerableProp(error, "stack",
                    parsed.message + "\n" + parsed.stack.join("\n"));
                util.notEnumerableProp(error, "__stackCleaned__", true);
            }
        }
    };
    
    Promise.prototype._warn = function(message) {
        var warning = new Warning(message);
        var ctx = this._peekContext();
        if (ctx) {
            ctx.attachExtraTrace(warning);
        } else {
            var parsed = CapturedTrace.parseStackAndMessage(warning);
            warning.stack = parsed.message + "\n" + parsed.stack.join("\n");
        }
        CapturedTrace.formatAndLogError(warning, "");
    };
    
    Promise.onPossiblyUnhandledRejection = function (fn) {
        var domain = getDomain();
        possiblyUnhandledRejection =
            typeof fn === "function" ? (domain === null ? fn : domain.bind(fn))
                                     : undefined;
    };
    
    Promise.onUnhandledRejectionHandled = function (fn) {
        var domain = getDomain();
        unhandledRejectionHandled =
            typeof fn === "function" ? (domain === null ? fn : domain.bind(fn))
                                     : undefined;
    };
    
    Promise.longStackTraces = function () {
        if (async.haveItemsQueued() &&
            debugging === false
       ) {
            throw new Error("cannot enable long stack traces after promises have been created\u000a\u000a    See http://goo.gl/DT1qyG\u000a");
        }
        debugging = CapturedTrace.isSupported();
        if (debugging) {
            async.disableTrampolineIfNecessary();
        }
    };
    
    Promise.hasLongStackTraces = function () {
        return debugging && CapturedTrace.isSupported();
    };
    
    if (!CapturedTrace.isSupported()) {
        Promise.longStackTraces = function(){};
        debugging = false;
    }
    
    return function() {
        return debugging;
    };
    };
    
  provide("bluebird/js/main/debuggability.js", module.exports);
}(global));

// pakmanager:bluebird/js/main/context.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  "use strict";
    module.exports = function(Promise, CapturedTrace, isDebugging) {
    var contextStack = [];
    function Context() {
        this._trace = new CapturedTrace(peekContext());
    }
    Context.prototype._pushContext = function () {
        if (!isDebugging()) return;
        if (this._trace !== undefined) {
            contextStack.push(this._trace);
        }
    };
    
    Context.prototype._popContext = function () {
        if (!isDebugging()) return;
        if (this._trace !== undefined) {
            contextStack.pop();
        }
    };
    
    function createContext() {
        if (isDebugging()) return new Context();
    }
    
    function peekContext() {
        var lastIndex = contextStack.length - 1;
        if (lastIndex >= 0) {
            return contextStack[lastIndex];
        }
        return undefined;
    }
    
    Promise.prototype._peekContext = peekContext;
    Promise.prototype._pushContext = Context.prototype._pushContext;
    Promise.prototype._popContext = Context.prototype._popContext;
    
    return createContext;
    };
    
  provide("bluebird/js/main/context.js", module.exports);
}(global));

// pakmanager:bluebird/js/main/catch_filter.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  "use strict";
    module.exports = function(NEXT_FILTER) {
    var util =  require('bluebird/js/main/util.js');
    var errors =  require('bluebird/js/main/errors.js');
    var tryCatch = util.tryCatch;
    var errorObj = util.errorObj;
    var keys =  require('bluebird/js/main/es5.js').keys;
    var TypeError = errors.TypeError;
    
    function CatchFilter(instances, callback, promise) {
        this._instances = instances;
        this._callback = callback;
        this._promise = promise;
    }
    
    function safePredicate(predicate, e) {
        var safeObject = {};
        var retfilter = tryCatch(predicate).call(safeObject, e);
    
        if (retfilter === errorObj) return retfilter;
    
        var safeKeys = keys(safeObject);
        if (safeKeys.length) {
            errorObj.e = new TypeError("Catch filter must inherit from Error or be a simple predicate function\u000a\u000a    See http://goo.gl/o84o68\u000a");
            return errorObj;
        }
        return retfilter;
    }
    
    CatchFilter.prototype.doFilter = function (e) {
        var cb = this._callback;
        var promise = this._promise;
        var boundTo = promise._boundTo;
        for (var i = 0, len = this._instances.length; i < len; ++i) {
            var item = this._instances[i];
            var itemIsErrorType = item === Error ||
                (item != null && item.prototype instanceof Error);
    
            if (itemIsErrorType && e instanceof item) {
                var ret = tryCatch(cb).call(boundTo, e);
                if (ret === errorObj) {
                    NEXT_FILTER.e = ret.e;
                    return NEXT_FILTER;
                }
                return ret;
            } else if (typeof item === "function" && !itemIsErrorType) {
                var shouldHandle = safePredicate(item, e);
                if (shouldHandle === errorObj) {
                    e = errorObj.e;
                    break;
                } else if (shouldHandle) {
                    var ret = tryCatch(cb).call(boundTo, e);
                    if (ret === errorObj) {
                        NEXT_FILTER.e = ret.e;
                        return NEXT_FILTER;
                    }
                    return ret;
                }
            }
        }
        NEXT_FILTER.e = e;
        return NEXT_FILTER;
    };
    
    return CatchFilter;
    };
    
  provide("bluebird/js/main/catch_filter.js", module.exports);
}(global));

// pakmanager:bluebird/js/main/progress.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  "use strict";
    module.exports = function(Promise, PromiseArray) {
    var util =  require('bluebird/js/main/util.js');
    var async =  require('bluebird/js/main/async.js');
    var tryCatch = util.tryCatch;
    var errorObj = util.errorObj;
    
    Promise.prototype.progressed = function (handler) {
        return this._then(undefined, undefined, handler, undefined, undefined);
    };
    
    Promise.prototype._progress = function (progressValue) {
        if (this._isFollowingOrFulfilledOrRejected()) return;
        this._target()._progressUnchecked(progressValue);
    
    };
    
    Promise.prototype._progressHandlerAt = function (index) {
        return index === 0
            ? this._progressHandler0
            : this[(index << 2) + index - 5 + 2];
    };
    
    Promise.prototype._doProgressWith = function (progression) {
        var progressValue = progression.value;
        var handler = progression.handler;
        var promise = progression.promise;
        var receiver = progression.receiver;
    
        var ret = tryCatch(handler).call(receiver, progressValue);
        if (ret === errorObj) {
            if (ret.e != null &&
                ret.e.name !== "StopProgressPropagation") {
                var trace = util.canAttachTrace(ret.e)
                    ? ret.e : new Error(util.toString(ret.e));
                promise._attachExtraTrace(trace);
                promise._progress(ret.e);
            }
        } else if (ret instanceof Promise) {
            ret._then(promise._progress, null, null, promise, undefined);
        } else {
            promise._progress(ret);
        }
    };
    
    
    Promise.prototype._progressUnchecked = function (progressValue) {
        var len = this._length();
        var progress = this._progress;
        for (var i = 0; i < len; i++) {
            var handler = this._progressHandlerAt(i);
            var promise = this._promiseAt(i);
            if (!(promise instanceof Promise)) {
                var receiver = this._receiverAt(i);
                if (typeof handler === "function") {
                    handler.call(receiver, progressValue, promise);
                } else if (receiver instanceof PromiseArray &&
                           !receiver._isResolved()) {
                    receiver._promiseProgressed(progressValue, promise);
                }
                continue;
            }
    
            if (typeof handler === "function") {
                async.invoke(this._doProgressWith, this, {
                    handler: handler,
                    promise: promise,
                    receiver: this._receiverAt(i),
                    value: progressValue
                });
            } else {
                async.invoke(progress, promise, progressValue);
            }
        }
    };
    };
    
  provide("bluebird/js/main/progress.js", module.exports);
}(global));

// pakmanager:bluebird/js/main/method.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  "use strict";
    module.exports =
    function(Promise, INTERNAL, tryConvertToPromise, apiRejection) {
    var util =  require('bluebird/js/main/util.js');
    var tryCatch = util.tryCatch;
    
    Promise.method = function (fn) {
        if (typeof fn !== "function") {
            throw new Promise.TypeError("fn must be a function\u000a\u000a    See http://goo.gl/916lJJ\u000a");
        }
        return function () {
            var ret = new Promise(INTERNAL);
            ret._captureStackTrace();
            ret._pushContext();
            var value = tryCatch(fn).apply(this, arguments);
            ret._popContext();
            ret._resolveFromSyncValue(value);
            return ret;
        };
    };
    
    Promise.attempt = Promise["try"] = function (fn, args, ctx) {
        if (typeof fn !== "function") {
            return apiRejection("fn must be a function\u000a\u000a    See http://goo.gl/916lJJ\u000a");
        }
        var ret = new Promise(INTERNAL);
        ret._captureStackTrace();
        ret._pushContext();
        var value = util.isArray(args)
            ? tryCatch(fn).apply(ctx, args)
            : tryCatch(fn).call(ctx, args);
        ret._popContext();
        ret._resolveFromSyncValue(value);
        return ret;
    };
    
    Promise.prototype._resolveFromSyncValue = function (value) {
        if (value === util.errorObj) {
            this._rejectCallback(value.e, false, true);
        } else {
            this._resolveCallback(value, true);
        }
    };
    };
    
  provide("bluebird/js/main/method.js", module.exports);
}(global));

// pakmanager:bluebird/js/main/bind.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  "use strict";
    module.exports = function(Promise, INTERNAL, tryConvertToPromise) {
    var rejectThis = function(_, e) {
        this._reject(e);
    };
    
    var targetRejected = function(e, context) {
        context.promiseRejectionQueued = true;
        context.bindingPromise._then(rejectThis, rejectThis, null, this, e);
    };
    
    var bindingResolved = function(thisArg, context) {
        this._setBoundTo(thisArg);
        if (this._isPending()) {
            this._resolveCallback(context.target);
        }
    };
    
    var bindingRejected = function(e, context) {
        if (!context.promiseRejectionQueued) this._reject(e);
    };
    
    Promise.prototype.bind = function (thisArg) {
        var maybePromise = tryConvertToPromise(thisArg);
        var ret = new Promise(INTERNAL);
        ret._propagateFrom(this, 1);
        var target = this._target();
        if (maybePromise instanceof Promise) {
            var context = {
                promiseRejectionQueued: false,
                promise: ret,
                target: target,
                bindingPromise: maybePromise
            };
            target._then(INTERNAL, targetRejected, ret._progress, ret, context);
            maybePromise._then(
                bindingResolved, bindingRejected, ret._progress, ret, context);
        } else {
            ret._setBoundTo(thisArg);
            ret._resolveCallback(target);
        }
        return ret;
    };
    
    Promise.prototype._setBoundTo = function (obj) {
        if (obj !== undefined) {
            this._bitField = this._bitField | 131072;
            this._boundTo = obj;
        } else {
            this._bitField = this._bitField & (~131072);
        }
    };
    
    Promise.prototype._isBound = function () {
        return (this._bitField & 131072) === 131072;
    };
    
    Promise.bind = function (thisArg, value) {
        var maybePromise = tryConvertToPromise(thisArg);
        var ret = new Promise(INTERNAL);
    
        if (maybePromise instanceof Promise) {
            maybePromise._then(function(thisArg) {
                ret._setBoundTo(thisArg);
                ret._resolveCallback(value);
            }, ret._reject, ret._progress, ret, null);
        } else {
            ret._setBoundTo(thisArg);
            ret._resolveCallback(value);
        }
        return ret;
    };
    };
    
  provide("bluebird/js/main/bind.js", module.exports);
}(global));

// pakmanager:bluebird/js/main/finally.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  "use strict";
    module.exports = function(Promise, NEXT_FILTER, tryConvertToPromise) {
    var util =  require('bluebird/js/main/util.js');
    var isPrimitive = util.isPrimitive;
    var thrower = util.thrower;
    
    function returnThis() {
        return this;
    }
    function throwThis() {
        throw this;
    }
    function return$(r) {
        return function() {
            return r;
        };
    }
    function throw$(r) {
        return function() {
            throw r;
        };
    }
    function promisedFinally(ret, reasonOrValue, isFulfilled) {
        var then;
        if (isPrimitive(reasonOrValue)) {
            then = isFulfilled ? return$(reasonOrValue) : throw$(reasonOrValue);
        } else {
            then = isFulfilled ? returnThis : throwThis;
        }
        return ret._then(then, thrower, undefined, reasonOrValue, undefined);
    }
    
    function finallyHandler(reasonOrValue) {
        var promise = this.promise;
        var handler = this.handler;
    
        var ret = promise._isBound()
                        ? handler.call(promise._boundTo)
                        : handler();
    
        if (ret !== undefined) {
            var maybePromise = tryConvertToPromise(ret, promise);
            if (maybePromise instanceof Promise) {
                maybePromise = maybePromise._target();
                return promisedFinally(maybePromise, reasonOrValue,
                                        promise.isFulfilled());
            }
        }
    
        if (promise.isRejected()) {
            NEXT_FILTER.e = reasonOrValue;
            return NEXT_FILTER;
        } else {
            return reasonOrValue;
        }
    }
    
    function tapHandler(value) {
        var promise = this.promise;
        var handler = this.handler;
    
        var ret = promise._isBound()
                        ? handler.call(promise._boundTo, value)
                        : handler(value);
    
        if (ret !== undefined) {
            var maybePromise = tryConvertToPromise(ret, promise);
            if (maybePromise instanceof Promise) {
                maybePromise = maybePromise._target();
                return promisedFinally(maybePromise, value, true);
            }
        }
        return value;
    }
    
    Promise.prototype._passThroughHandler = function (handler, isFinally) {
        if (typeof handler !== "function") return this.then();
    
        var promiseAndHandler = {
            promise: this,
            handler: handler
        };
    
        return this._then(
                isFinally ? finallyHandler : tapHandler,
                isFinally ? finallyHandler : undefined, undefined,
                promiseAndHandler, undefined);
    };
    
    Promise.prototype.lastly =
    Promise.prototype["finally"] = function (handler) {
        return this._passThroughHandler(handler, true);
    };
    
    Promise.prototype.tap = function (handler) {
        return this._passThroughHandler(handler, false);
    };
    };
    
  provide("bluebird/js/main/finally.js", module.exports);
}(global));

// pakmanager:bluebird/js/main/direct_resolve.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  "use strict";
    var util =  require('bluebird/js/main/util.js');
    var isPrimitive = util.isPrimitive;
    
    module.exports = function(Promise) {
    var returner = function () {
        return this;
    };
    var thrower = function () {
        throw this;
    };
    var returnUndefined = function() {};
    var throwUndefined = function() {
        throw undefined;
    };
    
    var wrapper = function (value, action) {
        if (action === 1) {
            return function () {
                throw value;
            };
        } else if (action === 2) {
            return function () {
                return value;
            };
        }
    };
    
    
    Promise.prototype["return"] =
    Promise.prototype.thenReturn = function (value) {
        if (value === undefined) return this.then(returnUndefined);
    
        if (isPrimitive(value)) {
            return this._then(
                wrapper(value, 2),
                undefined,
                undefined,
                undefined,
                undefined
           );
        }
        return this._then(returner, undefined, undefined, value, undefined);
    };
    
    Promise.prototype["throw"] =
    Promise.prototype.thenThrow = function (reason) {
        if (reason === undefined) return this.then(throwUndefined);
    
        if (isPrimitive(reason)) {
            return this._then(
                wrapper(reason, 1),
                undefined,
                undefined,
                undefined,
                undefined
           );
        }
        return this._then(thrower, undefined, undefined, reason, undefined);
    };
    };
    
  provide("bluebird/js/main/direct_resolve.js", module.exports);
}(global));

// pakmanager:bluebird/js/main/synchronous_inspection.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  "use strict";
    module.exports = function(Promise) {
    function PromiseInspection(promise) {
        if (promise !== undefined) {
            promise = promise._target();
            this._bitField = promise._bitField;
            this._settledValue = promise._settledValue;
        }
        else {
            this._bitField = 0;
            this._settledValue = undefined;
        }
    }
    
    PromiseInspection.prototype.value = function () {
        if (!this.isFulfilled()) {
            throw new TypeError("cannot get fulfillment value of a non-fulfilled promise\u000a\u000a    See http://goo.gl/hc1DLj\u000a");
        }
        return this._settledValue;
    };
    
    PromiseInspection.prototype.error =
    PromiseInspection.prototype.reason = function () {
        if (!this.isRejected()) {
            throw new TypeError("cannot get rejection reason of a non-rejected promise\u000a\u000a    See http://goo.gl/hPuiwB\u000a");
        }
        return this._settledValue;
    };
    
    PromiseInspection.prototype.isFulfilled =
    Promise.prototype._isFulfilled = function () {
        return (this._bitField & 268435456) > 0;
    };
    
    PromiseInspection.prototype.isRejected =
    Promise.prototype._isRejected = function () {
        return (this._bitField & 134217728) > 0;
    };
    
    PromiseInspection.prototype.isPending =
    Promise.prototype._isPending = function () {
        return (this._bitField & 402653184) === 0;
    };
    
    PromiseInspection.prototype.isResolved =
    Promise.prototype._isResolved = function () {
        return (this._bitField & 402653184) > 0;
    };
    
    Promise.prototype.isPending = function() {
        return this._target()._isPending();
    };
    
    Promise.prototype.isRejected = function() {
        return this._target()._isRejected();
    };
    
    Promise.prototype.isFulfilled = function() {
        return this._target()._isFulfilled();
    };
    
    Promise.prototype.isResolved = function() {
        return this._target()._isResolved();
    };
    
    Promise.prototype._value = function() {
        return this._settledValue;
    };
    
    Promise.prototype._reason = function() {
        this._unsetRejectionIsUnhandled();
        return this._settledValue;
    };
    
    Promise.prototype.value = function() {
        var target = this._target();
        if (!target.isFulfilled()) {
            throw new TypeError("cannot get fulfillment value of a non-fulfilled promise\u000a\u000a    See http://goo.gl/hc1DLj\u000a");
        }
        return target._settledValue;
    };
    
    Promise.prototype.reason = function() {
        var target = this._target();
        if (!target.isRejected()) {
            throw new TypeError("cannot get rejection reason of a non-rejected promise\u000a\u000a    See http://goo.gl/hPuiwB\u000a");
        }
        target._unsetRejectionIsUnhandled();
        return target._settledValue;
    };
    
    
    Promise.PromiseInspection = PromiseInspection;
    };
    
  provide("bluebird/js/main/synchronous_inspection.js", module.exports);
}(global));

// pakmanager:bluebird/js/main/join.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  "use strict";
    module.exports =
    function(Promise, PromiseArray, tryConvertToPromise, INTERNAL) {
    var util =  require('bluebird/js/main/util.js');
    var canEvaluate = util.canEvaluate;
    var tryCatch = util.tryCatch;
    var errorObj = util.errorObj;
    var reject;
    
    if (!false) {
    if (canEvaluate) {
        var thenCallback = function(i) {
            return new Function("value", "holder", "                             \n\
                'use strict';                                                    \n\
                holder.pIndex = value;                                           \n\
                holder.checkFulfillment(this);                                   \n\
                ".replace(/Index/g, i));
        };
    
        var caller = function(count) {
            var values = [];
            for (var i = 1; i <= count; ++i) values.push("holder.p" + i);
            return new Function("holder", "                                      \n\
                'use strict';                                                    \n\
                var callback = holder.fn;                                        \n\
                return callback(values);                                         \n\
                ".replace(/values/g, values.join(", ")));
        };
        var thenCallbacks = [];
        var callers = [undefined];
        for (var i = 1; i <= 5; ++i) {
            thenCallbacks.push(thenCallback(i));
            callers.push(caller(i));
        }
    
        var Holder = function(total, fn) {
            this.p1 = this.p2 = this.p3 = this.p4 = this.p5 = null;
            this.fn = fn;
            this.total = total;
            this.now = 0;
        };
    
        Holder.prototype.callers = callers;
        Holder.prototype.checkFulfillment = function(promise) {
            var now = this.now;
            now++;
            var total = this.total;
            if (now >= total) {
                var handler = this.callers[total];
                promise._pushContext();
                var ret = tryCatch(handler)(this);
                promise._popContext();
                if (ret === errorObj) {
                    promise._rejectCallback(ret.e, false, true);
                } else {
                    promise._resolveCallback(ret);
                }
            } else {
                this.now = now;
            }
        };
    
        var reject = function (reason) {
            this._reject(reason);
        };
    }
    }
    
    Promise.join = function () {
        var last = arguments.length - 1;
        var fn;
        if (last > 0 && typeof arguments[last] === "function") {
            fn = arguments[last];
            if (!false) {
                if (last < 6 && canEvaluate) {
                    var ret = new Promise(INTERNAL);
                    ret._captureStackTrace();
                    var holder = new Holder(last, fn);
                    var callbacks = thenCallbacks;
                    for (var i = 0; i < last; ++i) {
                        var maybePromise = tryConvertToPromise(arguments[i], ret);
                        if (maybePromise instanceof Promise) {
                            maybePromise = maybePromise._target();
                            if (maybePromise._isPending()) {
                                maybePromise._then(callbacks[i], reject,
                                                   undefined, ret, holder);
                            } else if (maybePromise._isFulfilled()) {
                                callbacks[i].call(ret,
                                                  maybePromise._value(), holder);
                            } else {
                                ret._reject(maybePromise._reason());
                            }
                        } else {
                            callbacks[i].call(ret, maybePromise, holder);
                        }
                    }
                    return ret;
                }
            }
        }
        var $_len = arguments.length;var args = new Array($_len); for(var $_i = 0; $_i < $_len; ++$_i) {args[$_i] = arguments[$_i];}
        if (fn) args.pop();
        var ret = new PromiseArray(args).promise();
        return fn !== undefined ? ret.spread(fn) : ret;
    };
    
    };
    
  provide("bluebird/js/main/join.js", module.exports);
}(global));

// pakmanager:bluebird/js/main/map.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  "use strict";
    module.exports = function(Promise,
                              PromiseArray,
                              apiRejection,
                              tryConvertToPromise,
                              INTERNAL) {
    var async =  require('bluebird/js/main/async.js');
    var util =  require('bluebird/js/main/util.js');
    var tryCatch = util.tryCatch;
    var errorObj = util.errorObj;
    var PENDING = {};
    var EMPTY_ARRAY = [];
    
    function MappingPromiseArray(promises, fn, limit, _filter) {
        this.constructor$(promises);
        this._promise._captureStackTrace();
        this._callback = fn;
        this._preservedValues = _filter === INTERNAL
            ? new Array(this.length())
            : null;
        this._limit = limit;
        this._inFlight = 0;
        this._queue = limit >= 1 ? [] : EMPTY_ARRAY;
        async.invoke(init, this, undefined);
    }
    util.inherits(MappingPromiseArray, PromiseArray);
    function init() {this._init$(undefined, -2);}
    
    MappingPromiseArray.prototype._init = function () {};
    
    MappingPromiseArray.prototype._promiseFulfilled = function (value, index) {
        var values = this._values;
        var length = this.length();
        var preservedValues = this._preservedValues;
        var limit = this._limit;
        if (values[index] === PENDING) {
            values[index] = value;
            if (limit >= 1) {
                this._inFlight--;
                this._drainQueue();
                if (this._isResolved()) return;
            }
        } else {
            if (limit >= 1 && this._inFlight >= limit) {
                values[index] = value;
                this._queue.push(index);
                return;
            }
            if (preservedValues !== null) preservedValues[index] = value;
    
            var callback = this._callback;
            var receiver = this._promise._boundTo;
            this._promise._pushContext();
            var ret = tryCatch(callback).call(receiver, value, index, length);
            this._promise._popContext();
            if (ret === errorObj) return this._reject(ret.e);
    
            var maybePromise = tryConvertToPromise(ret, this._promise);
            if (maybePromise instanceof Promise) {
                maybePromise = maybePromise._target();
                if (maybePromise._isPending()) {
                    if (limit >= 1) this._inFlight++;
                    values[index] = PENDING;
                    return maybePromise._proxyPromiseArray(this, index);
                } else if (maybePromise._isFulfilled()) {
                    ret = maybePromise._value();
                } else {
                    return this._reject(maybePromise._reason());
                }
            }
            values[index] = ret;
        }
        var totalResolved = ++this._totalResolved;
        if (totalResolved >= length) {
            if (preservedValues !== null) {
                this._filter(values, preservedValues);
            } else {
                this._resolve(values);
            }
    
        }
    };
    
    MappingPromiseArray.prototype._drainQueue = function () {
        var queue = this._queue;
        var limit = this._limit;
        var values = this._values;
        while (queue.length > 0 && this._inFlight < limit) {
            if (this._isResolved()) return;
            var index = queue.pop();
            this._promiseFulfilled(values[index], index);
        }
    };
    
    MappingPromiseArray.prototype._filter = function (booleans, values) {
        var len = values.length;
        var ret = new Array(len);
        var j = 0;
        for (var i = 0; i < len; ++i) {
            if (booleans[i]) ret[j++] = values[i];
        }
        ret.length = j;
        this._resolve(ret);
    };
    
    MappingPromiseArray.prototype.preservedValues = function () {
        return this._preservedValues;
    };
    
    function map(promises, fn, options, _filter) {
        var limit = typeof options === "object" && options !== null
            ? options.concurrency
            : 0;
        limit = typeof limit === "number" &&
            isFinite(limit) && limit >= 1 ? limit : 0;
        return new MappingPromiseArray(promises, fn, limit, _filter);
    }
    
    Promise.prototype.map = function (fn, options) {
        if (typeof fn !== "function") return apiRejection("fn must be a function\u000a\u000a    See http://goo.gl/916lJJ\u000a");
    
        return map(this, fn, options, null).promise();
    };
    
    Promise.map = function (promises, fn, options, _filter) {
        if (typeof fn !== "function") return apiRejection("fn must be a function\u000a\u000a    See http://goo.gl/916lJJ\u000a");
        return map(promises, fn, options, _filter).promise();
    };
    
    
    };
    
  provide("bluebird/js/main/map.js", module.exports);
}(global));

// pakmanager:bluebird/js/main/cancel.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  "use strict";
    module.exports = function(Promise) {
    var errors =  require('bluebird/js/main/errors.js');
    var async =  require('bluebird/js/main/async.js');
    var CancellationError = errors.CancellationError;
    
    Promise.prototype._cancel = function (reason) {
        if (!this.isCancellable()) return this;
        var parent;
        var promiseToReject = this;
        while ((parent = promiseToReject._cancellationParent) !== undefined &&
            parent.isCancellable()) {
            promiseToReject = parent;
        }
        this._unsetCancellable();
        promiseToReject._target()._rejectCallback(reason, false, true);
    };
    
    Promise.prototype.cancel = function (reason) {
        if (!this.isCancellable()) return this;
        if (reason === undefined) reason = new CancellationError();
        async.invokeLater(this._cancel, this, reason);
        return this;
    };
    
    Promise.prototype.cancellable = function () {
        if (this._cancellable()) return this;
        async.enableTrampoline();
        this._setCancellable();
        this._cancellationParent = undefined;
        return this;
    };
    
    Promise.prototype.uncancellable = function () {
        var ret = this.then();
        ret._unsetCancellable();
        return ret;
    };
    
    Promise.prototype.fork = function (didFulfill, didReject, didProgress) {
        var ret = this._then(didFulfill, didReject, didProgress,
                             undefined, undefined);
    
        ret._setCancellable();
        ret._cancellationParent = undefined;
        return ret;
    };
    };
    
  provide("bluebird/js/main/cancel.js", module.exports);
}(global));

// pakmanager:bluebird/js/main/using.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  "use strict";
    module.exports = function (Promise, apiRejection, tryConvertToPromise,
        createContext) {
        var TypeError =  require('bluebird/js/main/errors.js').TypeError;
        var inherits =  require('bluebird/js/main/util.js').inherits;
        var PromiseInspection = Promise.PromiseInspection;
    
        function inspectionMapper(inspections) {
            var len = inspections.length;
            for (var i = 0; i < len; ++i) {
                var inspection = inspections[i];
                if (inspection.isRejected()) {
                    return Promise.reject(inspection.error());
                }
                inspections[i] = inspection._settledValue;
            }
            return inspections;
        }
    
        function thrower(e) {
            setTimeout(function(){throw e;}, 0);
        }
    
        function castPreservingDisposable(thenable) {
            var maybePromise = tryConvertToPromise(thenable);
            if (maybePromise !== thenable &&
                typeof thenable._isDisposable === "function" &&
                typeof thenable._getDisposer === "function" &&
                thenable._isDisposable()) {
                maybePromise._setDisposable(thenable._getDisposer());
            }
            return maybePromise;
        }
        function dispose(resources, inspection) {
            var i = 0;
            var len = resources.length;
            var ret = Promise.defer();
            function iterator() {
                if (i >= len) return ret.resolve();
                var maybePromise = castPreservingDisposable(resources[i++]);
                if (maybePromise instanceof Promise &&
                    maybePromise._isDisposable()) {
                    try {
                        maybePromise = tryConvertToPromise(
                            maybePromise._getDisposer().tryDispose(inspection),
                            resources.promise);
                    } catch (e) {
                        return thrower(e);
                    }
                    if (maybePromise instanceof Promise) {
                        return maybePromise._then(iterator, thrower,
                                                  null, null, null);
                    }
                }
                iterator();
            }
            iterator();
            return ret.promise;
        }
    
        function disposerSuccess(value) {
            var inspection = new PromiseInspection();
            inspection._settledValue = value;
            inspection._bitField = 268435456;
            return dispose(this, inspection).thenReturn(value);
        }
    
        function disposerFail(reason) {
            var inspection = new PromiseInspection();
            inspection._settledValue = reason;
            inspection._bitField = 134217728;
            return dispose(this, inspection).thenThrow(reason);
        }
    
        function Disposer(data, promise, context) {
            this._data = data;
            this._promise = promise;
            this._context = context;
        }
    
        Disposer.prototype.data = function () {
            return this._data;
        };
    
        Disposer.prototype.promise = function () {
            return this._promise;
        };
    
        Disposer.prototype.resource = function () {
            if (this.promise().isFulfilled()) {
                return this.promise().value();
            }
            return null;
        };
    
        Disposer.prototype.tryDispose = function(inspection) {
            var resource = this.resource();
            var context = this._context;
            if (context !== undefined) context._pushContext();
            var ret = resource !== null
                ? this.doDispose(resource, inspection) : null;
            if (context !== undefined) context._popContext();
            this._promise._unsetDisposable();
            this._data = null;
            return ret;
        };
    
        Disposer.isDisposer = function (d) {
            return (d != null &&
                    typeof d.resource === "function" &&
                    typeof d.tryDispose === "function");
        };
    
        function FunctionDisposer(fn, promise, context) {
            this.constructor$(fn, promise, context);
        }
        inherits(FunctionDisposer, Disposer);
    
        FunctionDisposer.prototype.doDispose = function (resource, inspection) {
            var fn = this.data();
            return fn.call(resource, resource, inspection);
        };
    
        function maybeUnwrapDisposer(value) {
            if (Disposer.isDisposer(value)) {
                this.resources[this.index]._setDisposable(value);
                return value.promise();
            }
            return value;
        }
    
        Promise.using = function () {
            var len = arguments.length;
            if (len < 2) return apiRejection(
                            "you must pass at least 2 arguments to Promise.using");
            var fn = arguments[len - 1];
            if (typeof fn !== "function") return apiRejection("fn must be a function\u000a\u000a    See http://goo.gl/916lJJ\u000a");
            len--;
            var resources = new Array(len);
            for (var i = 0; i < len; ++i) {
                var resource = arguments[i];
                if (Disposer.isDisposer(resource)) {
                    var disposer = resource;
                    resource = resource.promise();
                    resource._setDisposable(disposer);
                } else {
                    var maybePromise = tryConvertToPromise(resource);
                    if (maybePromise instanceof Promise) {
                        resource =
                            maybePromise._then(maybeUnwrapDisposer, null, null, {
                                resources: resources,
                                index: i
                        }, undefined);
                    }
                }
                resources[i] = resource;
            }
    
            var promise = Promise.settle(resources)
                .then(inspectionMapper)
                .then(function(vals) {
                    promise._pushContext();
                    var ret;
                    try {
                        ret = fn.apply(undefined, vals);
                    } finally {
                        promise._popContext();
                    }
                    return ret;
                })
                ._then(
                    disposerSuccess, disposerFail, undefined, resources, undefined);
            resources.promise = promise;
            return promise;
        };
    
        Promise.prototype._setDisposable = function (disposer) {
            this._bitField = this._bitField | 262144;
            this._disposer = disposer;
        };
    
        Promise.prototype._isDisposable = function () {
            return (this._bitField & 262144) > 0;
        };
    
        Promise.prototype._getDisposer = function () {
            return this._disposer;
        };
    
        Promise.prototype._unsetDisposable = function () {
            this._bitField = this._bitField & (~262144);
            this._disposer = undefined;
        };
    
        Promise.prototype.disposer = function (fn) {
            if (typeof fn === "function") {
                return new FunctionDisposer(fn, this, createContext());
            }
            throw new TypeError();
        };
    
    };
    
  provide("bluebird/js/main/using.js", module.exports);
}(global));

// pakmanager:bluebird/js/main/generators.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  "use strict";
    module.exports = function(Promise,
                              apiRejection,
                              INTERNAL,
                              tryConvertToPromise) {
    var errors =  require('bluebird/js/main/errors.js');
    var TypeError = errors.TypeError;
    var util =  require('bluebird/js/main/util.js');
    var errorObj = util.errorObj;
    var tryCatch = util.tryCatch;
    var yieldHandlers = [];
    
    function promiseFromYieldHandler(value, yieldHandlers, traceParent) {
        for (var i = 0; i < yieldHandlers.length; ++i) {
            traceParent._pushContext();
            var result = tryCatch(yieldHandlers[i])(value);
            traceParent._popContext();
            if (result === errorObj) {
                traceParent._pushContext();
                var ret = Promise.reject(errorObj.e);
                traceParent._popContext();
                return ret;
            }
            var maybePromise = tryConvertToPromise(result, traceParent);
            if (maybePromise instanceof Promise) return maybePromise;
        }
        return null;
    }
    
    function PromiseSpawn(generatorFunction, receiver, yieldHandler, stack) {
        var promise = this._promise = new Promise(INTERNAL);
        promise._captureStackTrace();
        this._stack = stack;
        this._generatorFunction = generatorFunction;
        this._receiver = receiver;
        this._generator = undefined;
        this._yieldHandlers = typeof yieldHandler === "function"
            ? [yieldHandler].concat(yieldHandlers)
            : yieldHandlers;
    }
    
    PromiseSpawn.prototype.promise = function () {
        return this._promise;
    };
    
    PromiseSpawn.prototype._run = function () {
        this._generator = this._generatorFunction.call(this._receiver);
        this._receiver =
            this._generatorFunction = undefined;
        this._next(undefined);
    };
    
    PromiseSpawn.prototype._continue = function (result) {
        if (result === errorObj) {
            return this._promise._rejectCallback(result.e, false, true);
        }
    
        var value = result.value;
        if (result.done === true) {
            this._promise._resolveCallback(value);
        } else {
            var maybePromise = tryConvertToPromise(value, this._promise);
            if (!(maybePromise instanceof Promise)) {
                maybePromise =
                    promiseFromYieldHandler(maybePromise,
                                            this._yieldHandlers,
                                            this._promise);
                if (maybePromise === null) {
                    this._throw(
                        new TypeError(
                            "A value %s was yielded that could not be treated as a promise\u000a\u000a    See http://goo.gl/4Y4pDk\u000a\u000a".replace("%s", value) +
                            "From coroutine:\u000a" +
                            this._stack.split("\n").slice(1, -7).join("\n")
                        )
                    );
                    return;
                }
            }
            maybePromise._then(
                this._next,
                this._throw,
                undefined,
                this,
                null
           );
        }
    };
    
    PromiseSpawn.prototype._throw = function (reason) {
        this._promise._attachExtraTrace(reason);
        this._promise._pushContext();
        var result = tryCatch(this._generator["throw"])
            .call(this._generator, reason);
        this._promise._popContext();
        this._continue(result);
    };
    
    PromiseSpawn.prototype._next = function (value) {
        this._promise._pushContext();
        var result = tryCatch(this._generator.next).call(this._generator, value);
        this._promise._popContext();
        this._continue(result);
    };
    
    Promise.coroutine = function (generatorFunction, options) {
        if (typeof generatorFunction !== "function") {
            throw new TypeError("generatorFunction must be a function\u000a\u000a    See http://goo.gl/6Vqhm0\u000a");
        }
        var yieldHandler = Object(options).yieldHandler;
        var PromiseSpawn$ = PromiseSpawn;
        var stack = new Error().stack;
        return function () {
            var generator = generatorFunction.apply(this, arguments);
            var spawn = new PromiseSpawn$(undefined, undefined, yieldHandler,
                                          stack);
            spawn._generator = generator;
            spawn._next(undefined);
            return spawn.promise();
        };
    };
    
    Promise.coroutine.addYieldHandler = function(fn) {
        if (typeof fn !== "function") throw new TypeError("fn must be a function\u000a\u000a    See http://goo.gl/916lJJ\u000a");
        yieldHandlers.push(fn);
    };
    
    Promise.spawn = function (generatorFunction) {
        if (typeof generatorFunction !== "function") {
            return apiRejection("generatorFunction must be a function\u000a\u000a    See http://goo.gl/6Vqhm0\u000a");
        }
        var spawn = new PromiseSpawn(generatorFunction, this);
        var ret = spawn.promise();
        spawn._run(Promise.spawn);
        return ret;
    };
    };
    
  provide("bluebird/js/main/generators.js", module.exports);
}(global));

// pakmanager:bluebird/js/main/nodeify.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  "use strict";
    module.exports = function(Promise) {
    var util =  require('bluebird/js/main/util.js');
    var async =  require('bluebird/js/main/async.js');
    var tryCatch = util.tryCatch;
    var errorObj = util.errorObj;
    
    function spreadAdapter(val, nodeback) {
        var promise = this;
        if (!util.isArray(val)) return successAdapter.call(promise, val, nodeback);
        var ret = tryCatch(nodeback).apply(promise._boundTo, [null].concat(val));
        if (ret === errorObj) {
            async.throwLater(ret.e);
        }
    }
    
    function successAdapter(val, nodeback) {
        var promise = this;
        var receiver = promise._boundTo;
        var ret = val === undefined
            ? tryCatch(nodeback).call(receiver, null)
            : tryCatch(nodeback).call(receiver, null, val);
        if (ret === errorObj) {
            async.throwLater(ret.e);
        }
    }
    function errorAdapter(reason, nodeback) {
        var promise = this;
        if (!reason) {
            var target = promise._target();
            var newReason = target._getCarriedStackTrace();
            newReason.cause = reason;
            reason = newReason;
        }
        var ret = tryCatch(nodeback).call(promise._boundTo, reason);
        if (ret === errorObj) {
            async.throwLater(ret.e);
        }
    }
    
    Promise.prototype.asCallback = 
    Promise.prototype.nodeify = function (nodeback, options) {
        if (typeof nodeback == "function") {
            var adapter = successAdapter;
            if (options !== undefined && Object(options).spread) {
                adapter = spreadAdapter;
            }
            this._then(
                adapter,
                errorAdapter,
                undefined,
                this,
                nodeback
            );
        }
        return this;
    };
    };
    
  provide("bluebird/js/main/nodeify.js", module.exports);
}(global));

// pakmanager:bluebird/js/main/call_get.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  "use strict";
    var cr = Object.create;
    if (cr) {
        var callerCache = cr(null);
        var getterCache = cr(null);
        callerCache[" size"] = getterCache[" size"] = 0;
    }
    
    module.exports = function(Promise) {
    var util =  require('bluebird/js/main/util.js');
    var canEvaluate = util.canEvaluate;
    var isIdentifier = util.isIdentifier;
    
    var getMethodCaller;
    var getGetter;
    if (!false) {
    var makeMethodCaller = function (methodName) {
        return new Function("ensureMethod", "                                    \n\
            return function(obj) {                                               \n\
                'use strict'                                                     \n\
                var len = this.length;                                           \n\
                ensureMethod(obj, 'methodName');                                 \n\
                switch(len) {                                                    \n\
                    case 1: return obj.methodName(this[0]);                      \n\
                    case 2: return obj.methodName(this[0], this[1]);             \n\
                    case 3: return obj.methodName(this[0], this[1], this[2]);    \n\
                    case 0: return obj.methodName();                             \n\
                    default:                                                     \n\
                        return obj.methodName.apply(obj, this);                  \n\
                }                                                                \n\
            };                                                                   \n\
            ".replace(/methodName/g, methodName))(ensureMethod);
    };
    
    var makeGetter = function (propertyName) {
        return new Function("obj", "                                             \n\
            'use strict';                                                        \n\
            return obj.propertyName;                                             \n\
            ".replace("propertyName", propertyName));
    };
    
    var getCompiled = function(name, compiler, cache) {
        var ret = cache[name];
        if (typeof ret !== "function") {
            if (!isIdentifier(name)) {
                return null;
            }
            ret = compiler(name);
            cache[name] = ret;
            cache[" size"]++;
            if (cache[" size"] > 512) {
                var keys = Object.keys(cache);
                for (var i = 0; i < 256; ++i) delete cache[keys[i]];
                cache[" size"] = keys.length - 256;
            }
        }
        return ret;
    };
    
    getMethodCaller = function(name) {
        return getCompiled(name, makeMethodCaller, callerCache);
    };
    
    getGetter = function(name) {
        return getCompiled(name, makeGetter, getterCache);
    };
    }
    
    function ensureMethod(obj, methodName) {
        var fn;
        if (obj != null) fn = obj[methodName];
        if (typeof fn !== "function") {
            var message = "Object " + util.classString(obj) + " has no method '" +
                util.toString(methodName) + "'";
            throw new Promise.TypeError(message);
        }
        return fn;
    }
    
    function caller(obj) {
        var methodName = this.pop();
        var fn = ensureMethod(obj, methodName);
        return fn.apply(obj, this);
    }
    Promise.prototype.call = function (methodName) {
        var $_len = arguments.length;var args = new Array($_len - 1); for(var $_i = 1; $_i < $_len; ++$_i) {args[$_i - 1] = arguments[$_i];}
        if (!false) {
            if (canEvaluate) {
                var maybeCaller = getMethodCaller(methodName);
                if (maybeCaller !== null) {
                    return this._then(
                        maybeCaller, undefined, undefined, args, undefined);
                }
            }
        }
        args.push(methodName);
        return this._then(caller, undefined, undefined, args, undefined);
    };
    
    function namedGetter(obj) {
        return obj[this];
    }
    function indexedGetter(obj) {
        var index = +this;
        if (index < 0) index = Math.max(0, index + obj.length);
        return obj[index];
    }
    Promise.prototype.get = function (propertyName) {
        var isIndex = (typeof propertyName === "number");
        var getter;
        if (!isIndex) {
            if (canEvaluate) {
                var maybeGetter = getGetter(propertyName);
                getter = maybeGetter !== null ? maybeGetter : namedGetter;
            } else {
                getter = namedGetter;
            }
        } else {
            getter = indexedGetter;
        }
        return this._then(getter, undefined, undefined, propertyName, undefined);
    };
    };
    
  provide("bluebird/js/main/call_get.js", module.exports);
}(global));

// pakmanager:bluebird/js/main/props.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  "use strict";
    module.exports = function(
        Promise, PromiseArray, tryConvertToPromise, apiRejection) {
    var util =  require('bluebird/js/main/util.js');
    var isObject = util.isObject;
    var es5 =  require('bluebird/js/main/es5.js');
    
    function PropertiesPromiseArray(obj) {
        var keys = es5.keys(obj);
        var len = keys.length;
        var values = new Array(len * 2);
        for (var i = 0; i < len; ++i) {
            var key = keys[i];
            values[i] = obj[key];
            values[i + len] = key;
        }
        this.constructor$(values);
    }
    util.inherits(PropertiesPromiseArray, PromiseArray);
    
    PropertiesPromiseArray.prototype._init = function () {
        this._init$(undefined, -3) ;
    };
    
    PropertiesPromiseArray.prototype._promiseFulfilled = function (value, index) {
        this._values[index] = value;
        var totalResolved = ++this._totalResolved;
        if (totalResolved >= this._length) {
            var val = {};
            var keyOffset = this.length();
            for (var i = 0, len = this.length(); i < len; ++i) {
                val[this._values[i + keyOffset]] = this._values[i];
            }
            this._resolve(val);
        }
    };
    
    PropertiesPromiseArray.prototype._promiseProgressed = function (value, index) {
        this._promise._progress({
            key: this._values[index + this.length()],
            value: value
        });
    };
    
    PropertiesPromiseArray.prototype.shouldCopyValues = function () {
        return false;
    };
    
    PropertiesPromiseArray.prototype.getActualLength = function (len) {
        return len >> 1;
    };
    
    function props(promises) {
        var ret;
        var castValue = tryConvertToPromise(promises);
    
        if (!isObject(castValue)) {
            return apiRejection("cannot await properties of a non-object\u000a\u000a    See http://goo.gl/OsFKC8\u000a");
        } else if (castValue instanceof Promise) {
            ret = castValue._then(
                Promise.props, undefined, undefined, undefined, undefined);
        } else {
            ret = new PropertiesPromiseArray(castValue).promise();
        }
    
        if (castValue instanceof Promise) {
            ret._propagateFrom(castValue, 4);
        }
        return ret;
    }
    
    Promise.prototype.props = function () {
        return props(this);
    };
    
    Promise.props = function (promises) {
        return props(promises);
    };
    };
    
  provide("bluebird/js/main/props.js", module.exports);
}(global));

// pakmanager:bluebird/js/main/race.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  "use strict";
    module.exports = function(
        Promise, INTERNAL, tryConvertToPromise, apiRejection) {
    var isArray =  require('bluebird/js/main/util.js').isArray;
    
    var raceLater = function (promise) {
        return promise.then(function(array) {
            return race(array, promise);
        });
    };
    
    function race(promises, parent) {
        var maybePromise = tryConvertToPromise(promises);
    
        if (maybePromise instanceof Promise) {
            return raceLater(maybePromise);
        } else if (!isArray(promises)) {
            return apiRejection("expecting an array, a promise or a thenable\u000a\u000a    See http://goo.gl/s8MMhc\u000a");
        }
    
        var ret = new Promise(INTERNAL);
        if (parent !== undefined) {
            ret._propagateFrom(parent, 4 | 1);
        }
        var fulfill = ret._fulfill;
        var reject = ret._reject;
        for (var i = 0, len = promises.length; i < len; ++i) {
            var val = promises[i];
    
            if (val === undefined && !(i in promises)) {
                continue;
            }
    
            Promise.cast(val)._then(fulfill, reject, undefined, ret, null);
        }
        return ret;
    }
    
    Promise.race = function (promises) {
        return race(promises, undefined);
    };
    
    Promise.prototype.race = function () {
        return race(this, undefined);
    };
    
    };
    
  provide("bluebird/js/main/race.js", module.exports);
}(global));

// pakmanager:bluebird/js/main/reduce.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  "use strict";
    module.exports = function(Promise,
                              PromiseArray,
                              apiRejection,
                              tryConvertToPromise,
                              INTERNAL) {
    var async =  require('bluebird/js/main/async.js');
    var util =  require('bluebird/js/main/util.js');
    var tryCatch = util.tryCatch;
    var errorObj = util.errorObj;
    function ReductionPromiseArray(promises, fn, accum, _each) {
        this.constructor$(promises);
        this._promise._captureStackTrace();
        this._preservedValues = _each === INTERNAL ? [] : null;
        this._zerothIsAccum = (accum === undefined);
        this._gotAccum = false;
        this._reducingIndex = (this._zerothIsAccum ? 1 : 0);
        this._valuesPhase = undefined;
        var maybePromise = tryConvertToPromise(accum, this._promise);
        var rejected = false;
        var isPromise = maybePromise instanceof Promise;
        if (isPromise) {
            maybePromise = maybePromise._target();
            if (maybePromise._isPending()) {
                maybePromise._proxyPromiseArray(this, -1);
            } else if (maybePromise._isFulfilled()) {
                accum = maybePromise._value();
                this._gotAccum = true;
            } else {
                this._reject(maybePromise._reason());
                rejected = true;
            }
        }
        if (!(isPromise || this._zerothIsAccum)) this._gotAccum = true;
        this._callback = fn;
        this._accum = accum;
        if (!rejected) async.invoke(init, this, undefined);
    }
    function init() {
        this._init$(undefined, -5);
    }
    util.inherits(ReductionPromiseArray, PromiseArray);
    
    ReductionPromiseArray.prototype._init = function () {};
    
    ReductionPromiseArray.prototype._resolveEmptyArray = function () {
        if (this._gotAccum || this._zerothIsAccum) {
            this._resolve(this._preservedValues !== null
                            ? [] : this._accum);
        }
    };
    
    ReductionPromiseArray.prototype._promiseFulfilled = function (value, index) {
        var values = this._values;
        values[index] = value;
        var length = this.length();
        var preservedValues = this._preservedValues;
        var isEach = preservedValues !== null;
        var gotAccum = this._gotAccum;
        var valuesPhase = this._valuesPhase;
        var valuesPhaseIndex;
        if (!valuesPhase) {
            valuesPhase = this._valuesPhase = new Array(length);
            for (valuesPhaseIndex=0; valuesPhaseIndex<length; ++valuesPhaseIndex) {
                valuesPhase[valuesPhaseIndex] = 0;
            }
        }
        valuesPhaseIndex = valuesPhase[index];
    
        if (index === 0 && this._zerothIsAccum) {
            this._accum = value;
            this._gotAccum = gotAccum = true;
            valuesPhase[index] = ((valuesPhaseIndex === 0)
                ? 1 : 2);
        } else if (index === -1) {
            this._accum = value;
            this._gotAccum = gotAccum = true;
        } else {
            if (valuesPhaseIndex === 0) {
                valuesPhase[index] = 1;
            } else {
                valuesPhase[index] = 2;
                this._accum = value;
            }
        }
        if (!gotAccum) return;
    
        var callback = this._callback;
        var receiver = this._promise._boundTo;
        var ret;
    
        for (var i = this._reducingIndex; i < length; ++i) {
            valuesPhaseIndex = valuesPhase[i];
            if (valuesPhaseIndex === 2) {
                this._reducingIndex = i + 1;
                continue;
            }
            if (valuesPhaseIndex !== 1) return;
            value = values[i];
            this._promise._pushContext();
            if (isEach) {
                preservedValues.push(value);
                ret = tryCatch(callback).call(receiver, value, i, length);
            }
            else {
                ret = tryCatch(callback)
                    .call(receiver, this._accum, value, i, length);
            }
            this._promise._popContext();
    
            if (ret === errorObj) return this._reject(ret.e);
    
            var maybePromise = tryConvertToPromise(ret, this._promise);
            if (maybePromise instanceof Promise) {
                maybePromise = maybePromise._target();
                if (maybePromise._isPending()) {
                    valuesPhase[i] = 4;
                    return maybePromise._proxyPromiseArray(this, i);
                } else if (maybePromise._isFulfilled()) {
                    ret = maybePromise._value();
                } else {
                    return this._reject(maybePromise._reason());
                }
            }
    
            this._reducingIndex = i + 1;
            this._accum = ret;
        }
    
        this._resolve(isEach ? preservedValues : this._accum);
    };
    
    function reduce(promises, fn, initialValue, _each) {
        if (typeof fn !== "function") return apiRejection("fn must be a function\u000a\u000a    See http://goo.gl/916lJJ\u000a");
        var array = new ReductionPromiseArray(promises, fn, initialValue, _each);
        return array.promise();
    }
    
    Promise.prototype.reduce = function (fn, initialValue) {
        return reduce(this, fn, initialValue, null);
    };
    
    Promise.reduce = function (promises, fn, initialValue, _each) {
        return reduce(promises, fn, initialValue, _each);
    };
    };
    
  provide("bluebird/js/main/reduce.js", module.exports);
}(global));

// pakmanager:bluebird/js/main/settle.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  "use strict";
    module.exports =
        function(Promise, PromiseArray) {
    var PromiseInspection = Promise.PromiseInspection;
    var util =  require('bluebird/js/main/util.js');
    
    function SettledPromiseArray(values) {
        this.constructor$(values);
    }
    util.inherits(SettledPromiseArray, PromiseArray);
    
    SettledPromiseArray.prototype._promiseResolved = function (index, inspection) {
        this._values[index] = inspection;
        var totalResolved = ++this._totalResolved;
        if (totalResolved >= this._length) {
            this._resolve(this._values);
        }
    };
    
    SettledPromiseArray.prototype._promiseFulfilled = function (value, index) {
        var ret = new PromiseInspection();
        ret._bitField = 268435456;
        ret._settledValue = value;
        this._promiseResolved(index, ret);
    };
    SettledPromiseArray.prototype._promiseRejected = function (reason, index) {
        var ret = new PromiseInspection();
        ret._bitField = 134217728;
        ret._settledValue = reason;
        this._promiseResolved(index, ret);
    };
    
    Promise.settle = function (promises) {
        return new SettledPromiseArray(promises).promise();
    };
    
    Promise.prototype.settle = function () {
        return new SettledPromiseArray(this).promise();
    };
    };
    
  provide("bluebird/js/main/settle.js", module.exports);
}(global));

// pakmanager:bluebird/js/main/some.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  "use strict";
    module.exports =
    function(Promise, PromiseArray, apiRejection) {
    var util =  require('bluebird/js/main/util.js');
    var RangeError =  require('bluebird/js/main/errors.js').RangeError;
    var AggregateError =  require('bluebird/js/main/errors.js').AggregateError;
    var isArray = util.isArray;
    
    
    function SomePromiseArray(values) {
        this.constructor$(values);
        this._howMany = 0;
        this._unwrap = false;
        this._initialized = false;
    }
    util.inherits(SomePromiseArray, PromiseArray);
    
    SomePromiseArray.prototype._init = function () {
        if (!this._initialized) {
            return;
        }
        if (this._howMany === 0) {
            this._resolve([]);
            return;
        }
        this._init$(undefined, -5);
        var isArrayResolved = isArray(this._values);
        if (!this._isResolved() &&
            isArrayResolved &&
            this._howMany > this._canPossiblyFulfill()) {
            this._reject(this._getRangeError(this.length()));
        }
    };
    
    SomePromiseArray.prototype.init = function () {
        this._initialized = true;
        this._init();
    };
    
    SomePromiseArray.prototype.setUnwrap = function () {
        this._unwrap = true;
    };
    
    SomePromiseArray.prototype.howMany = function () {
        return this._howMany;
    };
    
    SomePromiseArray.prototype.setHowMany = function (count) {
        this._howMany = count;
    };
    
    SomePromiseArray.prototype._promiseFulfilled = function (value) {
        this._addFulfilled(value);
        if (this._fulfilled() === this.howMany()) {
            this._values.length = this.howMany();
            if (this.howMany() === 1 && this._unwrap) {
                this._resolve(this._values[0]);
            } else {
                this._resolve(this._values);
            }
        }
    
    };
    SomePromiseArray.prototype._promiseRejected = function (reason) {
        this._addRejected(reason);
        if (this.howMany() > this._canPossiblyFulfill()) {
            var e = new AggregateError();
            for (var i = this.length(); i < this._values.length; ++i) {
                e.push(this._values[i]);
            }
            this._reject(e);
        }
    };
    
    SomePromiseArray.prototype._fulfilled = function () {
        return this._totalResolved;
    };
    
    SomePromiseArray.prototype._rejected = function () {
        return this._values.length - this.length();
    };
    
    SomePromiseArray.prototype._addRejected = function (reason) {
        this._values.push(reason);
    };
    
    SomePromiseArray.prototype._addFulfilled = function (value) {
        this._values[this._totalResolved++] = value;
    };
    
    SomePromiseArray.prototype._canPossiblyFulfill = function () {
        return this.length() - this._rejected();
    };
    
    SomePromiseArray.prototype._getRangeError = function (count) {
        var message = "Input array must contain at least " +
                this._howMany + " items but contains only " + count + " items";
        return new RangeError(message);
    };
    
    SomePromiseArray.prototype._resolveEmptyArray = function () {
        this._reject(this._getRangeError(0));
    };
    
    function some(promises, howMany) {
        if ((howMany | 0) !== howMany || howMany < 0) {
            return apiRejection("expecting a positive integer\u000a\u000a    See http://goo.gl/1wAmHx\u000a");
        }
        var ret = new SomePromiseArray(promises);
        var promise = ret.promise();
        ret.setHowMany(howMany);
        ret.init();
        return promise;
    }
    
    Promise.some = function (promises, howMany) {
        return some(promises, howMany);
    };
    
    Promise.prototype.some = function (howMany) {
        return some(this, howMany);
    };
    
    Promise._SomePromiseArray = SomePromiseArray;
    };
    
  provide("bluebird/js/main/some.js", module.exports);
}(global));

// pakmanager:bluebird/js/main/promisify.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  "use strict";
    module.exports = function(Promise, INTERNAL) {
    var THIS = {};
    var util =  require('bluebird/js/main/util.js');
    var nodebackForPromise =  require('bluebird/js/main/promise_resolver.js')
        ._nodebackForPromise;
    var withAppended = util.withAppended;
    var maybeWrapAsError = util.maybeWrapAsError;
    var canEvaluate = util.canEvaluate;
    var TypeError =  require('bluebird/js/main/errors').TypeError;
    var defaultSuffix = "Async";
    var defaultPromisified = {__isPromisified__: true};
    var noCopyPropsPattern =
        /^(?:length|name|arguments|caller|callee|prototype|__isPromisified__)$/;
    var defaultFilter = function(name) {
        return util.isIdentifier(name) &&
            name.charAt(0) !== "_" &&
            name !== "constructor";
    };
    
    function propsFilter(key) {
        return !noCopyPropsPattern.test(key);
    }
    
    function isPromisified(fn) {
        try {
            return fn.__isPromisified__ === true;
        }
        catch (e) {
            return false;
        }
    }
    
    function hasPromisified(obj, key, suffix) {
        var val = util.getDataPropertyOrDefault(obj, key + suffix,
                                                defaultPromisified);
        return val ? isPromisified(val) : false;
    }
    function checkValid(ret, suffix, suffixRegexp) {
        for (var i = 0; i < ret.length; i += 2) {
            var key = ret[i];
            if (suffixRegexp.test(key)) {
                var keyWithoutAsyncSuffix = key.replace(suffixRegexp, "");
                for (var j = 0; j < ret.length; j += 2) {
                    if (ret[j] === keyWithoutAsyncSuffix) {
                        throw new TypeError("Cannot promisify an API that has normal methods with '%s'-suffix\u000a\u000a    See http://goo.gl/iWrZbw\u000a"
                            .replace("%s", suffix));
                    }
                }
            }
        }
    }
    
    function promisifiableMethods(obj, suffix, suffixRegexp, filter) {
        var keys = util.inheritedDataKeys(obj);
        var ret = [];
        for (var i = 0; i < keys.length; ++i) {
            var key = keys[i];
            var value = obj[key];
            var passesDefaultFilter = filter === defaultFilter
                ? true : defaultFilter(key, value, obj);
            if (typeof value === "function" &&
                !util.isNativeFunctionMethod(value) &&
                !isPromisified(value) &&
                !hasPromisified(obj, key, suffix) &&
                filter(key, value, obj, passesDefaultFilter)) {
                ret.push(key, value);
            }
        }
        checkValid(ret, suffix, suffixRegexp);
        return ret;
    }
    
    var escapeIdentRegex = function(str) {
        return str.replace(/([$])/, "\\$");
    };
    
    var makeNodePromisifiedEval;
    if (!false) {
    var switchCaseArgumentOrder = function(likelyArgumentCount) {
        var ret = [likelyArgumentCount];
        var min = Math.max(0, likelyArgumentCount - 1 - 3);
        for(var i = likelyArgumentCount - 1; i >= min; --i) {
            ret.push(i);
        }
        for(var i = likelyArgumentCount + 1; i <= 3; ++i) {
            ret.push(i);
        }
        return ret;
    };
    
    var argumentSequence = function(argumentCount) {
        return util.filledRange(argumentCount, "_arg", "");
    };
    
    var parameterDeclaration = function(parameterCount) {
        return util.filledRange(
            Math.max(parameterCount, 3), "_arg", "");
    };
    
    var parameterCount = function(fn) {
        if (typeof fn.length === "number") {
            return Math.max(Math.min(fn.length, 1023 + 1), 0);
        }
        return 0;
    };
    
    makeNodePromisifiedEval =
    function(callback, receiver, originalName, fn) {
        var newParameterCount = Math.max(0, parameterCount(fn) - 1);
        var argumentOrder = switchCaseArgumentOrder(newParameterCount);
        var shouldProxyThis = typeof callback === "string" || receiver === THIS;
    
        function generateCallForArgumentCount(count) {
            var args = argumentSequence(count).join(", ");
            var comma = count > 0 ? ", " : "";
            var ret;
            if (shouldProxyThis) {
                ret = "ret = callback.call(this, {{args}}, nodeback); break;\n";
            } else {
                ret = receiver === undefined
                    ? "ret = callback({{args}}, nodeback); break;\n"
                    : "ret = callback.call(receiver, {{args}}, nodeback); break;\n";
            }
            return ret.replace("{{args}}", args).replace(", ", comma);
        }
    
        function generateArgumentSwitchCase() {
            var ret = "";
            for (var i = 0; i < argumentOrder.length; ++i) {
                ret += "case " + argumentOrder[i] +":" +
                    generateCallForArgumentCount(argumentOrder[i]);
            }
    
            ret += "                                                             \n\
            default:                                                             \n\
                var args = new Array(len + 1);                                   \n\
                var i = 0;                                                       \n\
                for (var i = 0; i < len; ++i) {                                  \n\
                   args[i] = arguments[i];                                       \n\
                }                                                                \n\
                args[i] = nodeback;                                              \n\
                [CodeForCall]                                                    \n\
                break;                                                           \n\
            ".replace("[CodeForCall]", (shouldProxyThis
                                    ? "ret = callback.apply(this, args);\n"
                                    : "ret = callback.apply(receiver, args);\n"));
            return ret;
        }
    
        var getFunctionCode = typeof callback === "string"
                                    ? ("this != null ? this['"+callback+"'] : fn")
                                    : "fn";
    
        return new Function("Promise",
                            "fn",
                            "receiver",
                            "withAppended",
                            "maybeWrapAsError",
                            "nodebackForPromise",
                            "tryCatch",
                            "errorObj",
                            "notEnumerableProp",
                            "INTERNAL","'use strict';                            \n\
            var ret = function (Parameters) {                                    \n\
                'use strict';                                                    \n\
                var len = arguments.length;                                      \n\
                var promise = new Promise(INTERNAL);                             \n\
                promise._captureStackTrace();                                    \n\
                var nodeback = nodebackForPromise(promise);                      \n\
                var ret;                                                         \n\
                var callback = tryCatch([GetFunctionCode]);                      \n\
                switch(len) {                                                    \n\
                    [CodeForSwitchCase]                                          \n\
                }                                                                \n\
                if (ret === errorObj) {                                          \n\
                    promise._rejectCallback(maybeWrapAsError(ret.e), true, true);\n\
                }                                                                \n\
                return promise;                                                  \n\
            };                                                                   \n\
            notEnumerableProp(ret, '__isPromisified__', true);                   \n\
            return ret;                                                          \n\
            "
            .replace("Parameters", parameterDeclaration(newParameterCount))
            .replace("[CodeForSwitchCase]", generateArgumentSwitchCase())
            .replace("[GetFunctionCode]", getFunctionCode))(
                Promise,
                fn,
                receiver,
                withAppended,
                maybeWrapAsError,
                nodebackForPromise,
                util.tryCatch,
                util.errorObj,
                util.notEnumerableProp,
                INTERNAL
            );
    };
    }
    
    function makeNodePromisifiedClosure(callback, receiver, _, fn) {
        var defaultThis = (function() {return this;})();
        var method = callback;
        if (typeof method === "string") {
            callback = fn;
        }
        function promisified() {
            var _receiver = receiver;
            if (receiver === THIS) _receiver = this;
            var promise = new Promise(INTERNAL);
            promise._captureStackTrace();
            var cb = typeof method === "string" && this !== defaultThis
                ? this[method] : callback;
            var fn = nodebackForPromise(promise);
            try {
                cb.apply(_receiver, withAppended(arguments, fn));
            } catch(e) {
                promise._rejectCallback(maybeWrapAsError(e), true, true);
            }
            return promise;
        }
        util.notEnumerableProp(promisified, "__isPromisified__", true);
        return promisified;
    }
    
    var makeNodePromisified = canEvaluate
        ? makeNodePromisifiedEval
        : makeNodePromisifiedClosure;
    
    function promisifyAll(obj, suffix, filter, promisifier) {
        var suffixRegexp = new RegExp(escapeIdentRegex(suffix) + "$");
        var methods =
            promisifiableMethods(obj, suffix, suffixRegexp, filter);
    
        for (var i = 0, len = methods.length; i < len; i+= 2) {
            var key = methods[i];
            var fn = methods[i+1];
            var promisifiedKey = key + suffix;
            obj[promisifiedKey] = promisifier === makeNodePromisified
                    ? makeNodePromisified(key, THIS, key, fn, suffix)
                    : promisifier(fn, function() {
                        return makeNodePromisified(key, THIS, key, fn, suffix);
                    });
        }
        util.toFastProperties(obj);
        return obj;
    }
    
    function promisify(callback, receiver) {
        return makeNodePromisified(callback, receiver, undefined, callback);
    }
    
    Promise.promisify = function (fn, receiver) {
        if (typeof fn !== "function") {
            throw new TypeError("fn must be a function\u000a\u000a    See http://goo.gl/916lJJ\u000a");
        }
        if (isPromisified(fn)) {
            return fn;
        }
        var ret = promisify(fn, arguments.length < 2 ? THIS : receiver);
        util.copyDescriptors(fn, ret, propsFilter);
        return ret;
    };
    
    Promise.promisifyAll = function (target, options) {
        if (typeof target !== "function" && typeof target !== "object") {
            throw new TypeError("the target of promisifyAll must be an object or a function\u000a\u000a    See http://goo.gl/9ITlV0\u000a");
        }
        options = Object(options);
        var suffix = options.suffix;
        if (typeof suffix !== "string") suffix = defaultSuffix;
        var filter = options.filter;
        if (typeof filter !== "function") filter = defaultFilter;
        var promisifier = options.promisifier;
        if (typeof promisifier !== "function") promisifier = makeNodePromisified;
    
        if (!util.isIdentifier(suffix)) {
            throw new RangeError("suffix must be a valid identifier\u000a\u000a    See http://goo.gl/8FZo5V\u000a");
        }
    
        var keys = util.inheritedDataKeys(target);
        for (var i = 0; i < keys.length; ++i) {
            var value = target[keys[i]];
            if (keys[i] !== "constructor" &&
                util.isClass(value)) {
                promisifyAll(value.prototype, suffix, filter, promisifier);
                promisifyAll(value, suffix, filter, promisifier);
            }
        }
    
        return promisifyAll(target, suffix, filter, promisifier);
    };
    };
    
    
  provide("bluebird/js/main/promisify.js", module.exports);
}(global));

// pakmanager:bluebird/js/main/any.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  "use strict";
    module.exports = function(Promise) {
    var SomePromiseArray = Promise._SomePromiseArray;
    function any(promises) {
        var ret = new SomePromiseArray(promises);
        var promise = ret.promise();
        ret.setHowMany(1);
        ret.setUnwrap();
        ret.init();
        return promise;
    }
    
    Promise.any = function (promises) {
        return any(promises);
    };
    
    Promise.prototype.any = function () {
        return any(this);
    };
    
    };
    
  provide("bluebird/js/main/any.js", module.exports);
}(global));

// pakmanager:bluebird/js/main/each.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  "use strict";
    module.exports = function(Promise, INTERNAL) {
    var PromiseReduce = Promise.reduce;
    
    Promise.prototype.each = function (fn) {
        return PromiseReduce(this, fn, null, INTERNAL);
    };
    
    Promise.each = function (promises, fn) {
        return PromiseReduce(promises, fn, null, INTERNAL);
    };
    };
    
  provide("bluebird/js/main/each.js", module.exports);
}(global));

// pakmanager:bluebird/js/main/timers.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  "use strict";
    module.exports = function(Promise, INTERNAL) {
    var util =  require('bluebird/js/main/util.js');
    var TimeoutError = Promise.TimeoutError;
    
    var afterTimeout = function (promise, message) {
        if (!promise.isPending()) return;
        if (typeof message !== "string") {
            message = "operation timed out";
        }
        var err = new TimeoutError(message);
        util.markAsOriginatingFromRejection(err);
        promise._attachExtraTrace(err);
        promise._cancel(err);
    };
    
    var afterValue = function(value) { return delay(+this).thenReturn(value); };
    var delay = Promise.delay = function (value, ms) {
        if (ms === undefined) {
            ms = value;
            value = undefined;
            var ret = new Promise(INTERNAL);
            setTimeout(function() { ret._fulfill(); }, ms);
            return ret;
        }
        ms = +ms;
        return Promise.resolve(value)._then(afterValue, null, null, ms, undefined);
    };
    
    Promise.prototype.delay = function (ms) {
        return delay(this, ms);
    };
    
    function successClear(value) {
        var handle = this;
        if (handle instanceof Number) handle = +handle;
        clearTimeout(handle);
        return value;
    }
    
    function failureClear(reason) {
        var handle = this;
        if (handle instanceof Number) handle = +handle;
        clearTimeout(handle);
        throw reason;
    }
    
    Promise.prototype.timeout = function (ms, message) {
        ms = +ms;
        var ret = this.then().cancellable();
        ret._cancellationParent = this;
        var handle = setTimeout(function timeoutTimeout() {
            afterTimeout(ret, message);
        }, ms);
        return ret._then(successClear, failureClear, undefined, handle, undefined);
    };
    
    };
    
  provide("bluebird/js/main/timers.js", module.exports);
}(global));

// pakmanager:bluebird/js/main/filter.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  "use strict";
    module.exports = function(Promise, INTERNAL) {
    var PromiseMap = Promise.map;
    
    Promise.prototype.filter = function (fn, options) {
        return PromiseMap(this, fn, options, INTERNAL);
    };
    
    Promise.filter = function (promises, fn, options) {
        return PromiseMap(promises, fn, options, INTERNAL);
    };
    };
    
  provide("bluebird/js/main/filter.js", module.exports);
}(global));

// pakmanager:bluebird/js/main/promise.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  "use strict";
    module.exports = function() {
    var makeSelfResolutionError = function () {
        return new TypeError("circular promise resolution chain\u000a\u000a    See http://goo.gl/LhFpo0\u000a");
    };
    var reflect = function() {
        return new Promise.PromiseInspection(this._target());
    };
    var apiRejection = function(msg) {
        return Promise.reject(new TypeError(msg));
    };
    
    var util =  require('bluebird/js/main/util.js');
    
    var getDomain;
    if (util.isNode) {
        getDomain = function() {
            var ret = process.domain;
            if (ret === undefined) ret = null;
            return ret;
        };
    } else {
        getDomain = function() {
            return null;
        };
    }
    util.notEnumerableProp(Promise, "_getDomain", getDomain);
    
    var async =  require('bluebird/js/main/async.js');
    var errors =  require('bluebird/js/main/errors.js');
    var TypeError = Promise.TypeError = errors.TypeError;
    Promise.RangeError = errors.RangeError;
    Promise.CancellationError = errors.CancellationError;
    Promise.TimeoutError = errors.TimeoutError;
    Promise.OperationalError = errors.OperationalError;
    Promise.RejectionError = errors.OperationalError;
    Promise.AggregateError = errors.AggregateError;
    var INTERNAL = function(){};
    var APPLY = {};
    var NEXT_FILTER = {e: null};
    var tryConvertToPromise =  require('bluebird/js/main/thenables.js')(Promise, INTERNAL);
    var PromiseArray =
         require('bluebird/js/main/promise_array.js')(Promise, INTERNAL,
                                        tryConvertToPromise, apiRejection);
    var CapturedTrace =  require('bluebird/js/main/captured_trace.js')();
    var isDebugging =  require('bluebird/js/main/debuggability.js')(Promise, CapturedTrace);
     /*jshint unused:false*/
    var createContext =
         require('bluebird/js/main/context.js')(Promise, CapturedTrace, isDebugging);
    var CatchFilter =  require('bluebird/js/main/catch_filter.js')(NEXT_FILTER);
    var PromiseResolver =  require('bluebird/js/main/promise_resolver.js');
    var nodebackForPromise = PromiseResolver._nodebackForPromise;
    var errorObj = util.errorObj;
    var tryCatch = util.tryCatch;
    function Promise(resolver) {
        if (typeof resolver !== "function") {
            throw new TypeError("the promise constructor requires a resolver function\u000a\u000a    See http://goo.gl/EC22Yn\u000a");
        }
        if (this.constructor !== Promise) {
            throw new TypeError("the promise constructor cannot be invoked directly\u000a\u000a    See http://goo.gl/KsIlge\u000a");
        }
        this._bitField = 0;
        this._fulfillmentHandler0 = undefined;
        this._rejectionHandler0 = undefined;
        this._progressHandler0 = undefined;
        this._promise0 = undefined;
        this._receiver0 = undefined;
        this._settledValue = undefined;
        if (resolver !== INTERNAL) this._resolveFromResolver(resolver);
    }
    
    Promise.prototype.toString = function () {
        return "[object Promise]";
    };
    
    Promise.prototype.caught = Promise.prototype["catch"] = function (fn) {
        var len = arguments.length;
        if (len > 1) {
            var catchInstances = new Array(len - 1),
                j = 0, i;
            for (i = 0; i < len - 1; ++i) {
                var item = arguments[i];
                if (typeof item === "function") {
                    catchInstances[j++] = item;
                } else {
                    return Promise.reject(
                        new TypeError("Catch filter must inherit from Error or be a simple predicate function\u000a\u000a    See http://goo.gl/o84o68\u000a"));
                }
            }
            catchInstances.length = j;
            fn = arguments[i];
            var catchFilter = new CatchFilter(catchInstances, fn, this);
            return this._then(undefined, catchFilter.doFilter, undefined,
                catchFilter, undefined);
        }
        return this._then(undefined, fn, undefined, undefined, undefined);
    };
    
    Promise.prototype.reflect = function () {
        return this._then(reflect, reflect, undefined, this, undefined);
    };
    
    Promise.prototype.then = function (didFulfill, didReject, didProgress) {
        if (isDebugging() && arguments.length > 0 &&
            typeof didFulfill !== "function" &&
            typeof didReject !== "function") {
            var msg = ".then() only accepts functions but was passed: " +
                    util.classString(didFulfill);
            if (arguments.length > 1) {
                msg += ", " + util.classString(didReject);
            }
            this._warn(msg);
        }
        return this._then(didFulfill, didReject, didProgress,
            undefined, undefined);
    };
    
    Promise.prototype.done = function (didFulfill, didReject, didProgress) {
        var promise = this._then(didFulfill, didReject, didProgress,
            undefined, undefined);
        promise._setIsFinal();
    };
    
    Promise.prototype.spread = function (didFulfill, didReject) {
        return this.all()._then(didFulfill, didReject, undefined, APPLY, undefined);
    };
    
    Promise.prototype.isCancellable = function () {
        return !this.isResolved() &&
            this._cancellable();
    };
    
    Promise.prototype.toJSON = function () {
        var ret = {
            isFulfilled: false,
            isRejected: false,
            fulfillmentValue: undefined,
            rejectionReason: undefined
        };
        if (this.isFulfilled()) {
            ret.fulfillmentValue = this.value();
            ret.isFulfilled = true;
        } else if (this.isRejected()) {
            ret.rejectionReason = this.reason();
            ret.isRejected = true;
        }
        return ret;
    };
    
    Promise.prototype.all = function () {
        return new PromiseArray(this).promise();
    };
    
    Promise.prototype.error = function (fn) {
        return this.caught(util.originatesFromRejection, fn);
    };
    
    Promise.is = function (val) {
        return val instanceof Promise;
    };
    
    Promise.fromNode = function(fn) {
        var ret = new Promise(INTERNAL);
        var result = tryCatch(fn)(nodebackForPromise(ret));
        if (result === errorObj) {
            ret._rejectCallback(result.e, true, true);
        }
        return ret;
    };
    
    Promise.all = function (promises) {
        return new PromiseArray(promises).promise();
    };
    
    Promise.defer = Promise.pending = function () {
        var promise = new Promise(INTERNAL);
        return new PromiseResolver(promise);
    };
    
    Promise.cast = function (obj) {
        var ret = tryConvertToPromise(obj);
        if (!(ret instanceof Promise)) {
            var val = ret;
            ret = new Promise(INTERNAL);
            ret._fulfillUnchecked(val);
        }
        return ret;
    };
    
    Promise.resolve = Promise.fulfilled = Promise.cast;
    
    Promise.reject = Promise.rejected = function (reason) {
        var ret = new Promise(INTERNAL);
        ret._captureStackTrace();
        ret._rejectCallback(reason, true);
        return ret;
    };
    
    Promise.setScheduler = function(fn) {
        if (typeof fn !== "function") throw new TypeError("fn must be a function\u000a\u000a    See http://goo.gl/916lJJ\u000a");
        var prev = async._schedule;
        async._schedule = fn;
        return prev;
    };
    
    Promise.prototype._then = function (
        didFulfill,
        didReject,
        didProgress,
        receiver,
        internalData
    ) {
        var haveInternalData = internalData !== undefined;
        var ret = haveInternalData ? internalData : new Promise(INTERNAL);
    
        if (!haveInternalData) {
            ret._propagateFrom(this, 4 | 1);
            ret._captureStackTrace();
        }
    
        var target = this._target();
        if (target !== this) {
            if (receiver === undefined) receiver = this._boundTo;
            if (!haveInternalData) ret._setIsMigrated();
        }
    
        var callbackIndex = target._addCallbacks(didFulfill,
                                                 didReject,
                                                 didProgress,
                                                 ret,
                                                 receiver,
                                                 getDomain());
    
        if (target._isResolved() && !target._isSettlePromisesQueued()) {
            async.invoke(
                target._settlePromiseAtPostResolution, target, callbackIndex);
        }
    
        return ret;
    };
    
    Promise.prototype._settlePromiseAtPostResolution = function (index) {
        if (this._isRejectionUnhandled()) this._unsetRejectionIsUnhandled();
        this._settlePromiseAt(index);
    };
    
    Promise.prototype._length = function () {
        return this._bitField & 131071;
    };
    
    Promise.prototype._isFollowingOrFulfilledOrRejected = function () {
        return (this._bitField & 939524096) > 0;
    };
    
    Promise.prototype._isFollowing = function () {
        return (this._bitField & 536870912) === 536870912;
    };
    
    Promise.prototype._setLength = function (len) {
        this._bitField = (this._bitField & -131072) |
            (len & 131071);
    };
    
    Promise.prototype._setFulfilled = function () {
        this._bitField = this._bitField | 268435456;
    };
    
    Promise.prototype._setRejected = function () {
        this._bitField = this._bitField | 134217728;
    };
    
    Promise.prototype._setFollowing = function () {
        this._bitField = this._bitField | 536870912;
    };
    
    Promise.prototype._setIsFinal = function () {
        this._bitField = this._bitField | 33554432;
    };
    
    Promise.prototype._isFinal = function () {
        return (this._bitField & 33554432) > 0;
    };
    
    Promise.prototype._cancellable = function () {
        return (this._bitField & 67108864) > 0;
    };
    
    Promise.prototype._setCancellable = function () {
        this._bitField = this._bitField | 67108864;
    };
    
    Promise.prototype._unsetCancellable = function () {
        this._bitField = this._bitField & (~67108864);
    };
    
    Promise.prototype._setIsMigrated = function () {
        this._bitField = this._bitField | 4194304;
    };
    
    Promise.prototype._unsetIsMigrated = function () {
        this._bitField = this._bitField & (~4194304);
    };
    
    Promise.prototype._isMigrated = function () {
        return (this._bitField & 4194304) > 0;
    };
    
    Promise.prototype._receiverAt = function (index) {
        var ret = index === 0
            ? this._receiver0
            : this[
                index * 5 - 5 + 4];
        if (ret === undefined && this._isBound()) {
            return this._boundTo;
        }
        return ret;
    };
    
    Promise.prototype._promiseAt = function (index) {
        return index === 0
            ? this._promise0
            : this[index * 5 - 5 + 3];
    };
    
    Promise.prototype._fulfillmentHandlerAt = function (index) {
        return index === 0
            ? this._fulfillmentHandler0
            : this[index * 5 - 5 + 0];
    };
    
    Promise.prototype._rejectionHandlerAt = function (index) {
        return index === 0
            ? this._rejectionHandler0
            : this[index * 5 - 5 + 1];
    };
    
    Promise.prototype._migrateCallbacks = function (follower, index) {
        var fulfill = follower._fulfillmentHandlerAt(index);
        var reject = follower._rejectionHandlerAt(index);
        var progress = follower._progressHandlerAt(index);
        var promise = follower._promiseAt(index);
        var receiver = follower._receiverAt(index);
        if (promise instanceof Promise) promise._setIsMigrated();
        this._addCallbacks(fulfill, reject, progress, promise, receiver, null);
    };
    
    Promise.prototype._addCallbacks = function (
        fulfill,
        reject,
        progress,
        promise,
        receiver,
        domain
    ) {
        var index = this._length();
    
        if (index >= 131071 - 5) {
            index = 0;
            this._setLength(0);
        }
    
        if (index === 0) {
            this._promise0 = promise;
            if (receiver !== undefined) this._receiver0 = receiver;
            if (typeof fulfill === "function" && !this._isCarryingStackTrace()) {
                this._fulfillmentHandler0 =
                    domain === null ? fulfill : domain.bind(fulfill);
            }
            if (typeof reject === "function") {
                this._rejectionHandler0 =
                    domain === null ? reject : domain.bind(reject);
            }
            if (typeof progress === "function") {
                this._progressHandler0 =
                    domain === null ? progress : domain.bind(progress);
            }
        } else {
            var base = index * 5 - 5;
            this[base + 3] = promise;
            this[base + 4] = receiver;
            if (typeof fulfill === "function") {
                this[base + 0] =
                    domain === null ? fulfill : domain.bind(fulfill);
            }
            if (typeof reject === "function") {
                this[base + 1] =
                    domain === null ? reject : domain.bind(reject);
            }
            if (typeof progress === "function") {
                this[base + 2] =
                    domain === null ? progress : domain.bind(progress);
            }
        }
        this._setLength(index + 1);
        return index;
    };
    
    Promise.prototype._setProxyHandlers = function (receiver, promiseSlotValue) {
        var index = this._length();
    
        if (index >= 131071 - 5) {
            index = 0;
            this._setLength(0);
        }
        if (index === 0) {
            this._promise0 = promiseSlotValue;
            this._receiver0 = receiver;
        } else {
            var base = index * 5 - 5;
            this[base + 3] = promiseSlotValue;
            this[base + 4] = receiver;
        }
        this._setLength(index + 1);
    };
    
    Promise.prototype._proxyPromiseArray = function (promiseArray, index) {
        this._setProxyHandlers(promiseArray, index);
    };
    
    Promise.prototype._resolveCallback = function(value, shouldBind) {
        if (this._isFollowingOrFulfilledOrRejected()) return;
        if (value === this)
            return this._rejectCallback(makeSelfResolutionError(), false, true);
        var maybePromise = tryConvertToPromise(value, this);
        if (!(maybePromise instanceof Promise)) return this._fulfill(value);
    
        var propagationFlags = 1 | (shouldBind ? 4 : 0);
        this._propagateFrom(maybePromise, propagationFlags);
        var promise = maybePromise._target();
        if (promise._isPending()) {
            var len = this._length();
            for (var i = 0; i < len; ++i) {
                promise._migrateCallbacks(this, i);
            }
            this._setFollowing();
            this._setLength(0);
            this._setFollowee(promise);
        } else if (promise._isFulfilled()) {
            this._fulfillUnchecked(promise._value());
        } else {
            this._rejectUnchecked(promise._reason(),
                promise._getCarriedStackTrace());
        }
    };
    
    Promise.prototype._rejectCallback =
    function(reason, synchronous, shouldNotMarkOriginatingFromRejection) {
        if (!shouldNotMarkOriginatingFromRejection) {
            util.markAsOriginatingFromRejection(reason);
        }
        var trace = util.ensureErrorObject(reason);
        var hasStack = trace === reason;
        this._attachExtraTrace(trace, synchronous ? hasStack : false);
        this._reject(reason, hasStack ? undefined : trace);
    };
    
    Promise.prototype._resolveFromResolver = function (resolver) {
        var promise = this;
        this._captureStackTrace();
        this._pushContext();
        var synchronous = true;
        var r = tryCatch(resolver)(function(value) {
            if (promise === null) return;
            promise._resolveCallback(value);
            promise = null;
        }, function (reason) {
            if (promise === null) return;
            promise._rejectCallback(reason, synchronous);
            promise = null;
        });
        synchronous = false;
        this._popContext();
    
        if (r !== undefined && r === errorObj && promise !== null) {
            promise._rejectCallback(r.e, true, true);
            promise = null;
        }
    };
    
    Promise.prototype._settlePromiseFromHandler = function (
        handler, receiver, value, promise
    ) {
        if (promise._isRejected()) return;
        promise._pushContext();
        var x;
        if (receiver === APPLY && !this._isRejected()) {
            x = tryCatch(handler).apply(this._boundTo, value);
        } else {
            x = tryCatch(handler).call(receiver, value);
        }
        promise._popContext();
    
        if (x === errorObj || x === promise || x === NEXT_FILTER) {
            var err = x === promise ? makeSelfResolutionError() : x.e;
            promise._rejectCallback(err, false, true);
        } else {
            promise._resolveCallback(x);
        }
    };
    
    Promise.prototype._target = function() {
        var ret = this;
        while (ret._isFollowing()) ret = ret._followee();
        return ret;
    };
    
    Promise.prototype._followee = function() {
        return this._rejectionHandler0;
    };
    
    Promise.prototype._setFollowee = function(promise) {
        this._rejectionHandler0 = promise;
    };
    
    Promise.prototype._cleanValues = function () {
        if (this._cancellable()) {
            this._cancellationParent = undefined;
        }
    };
    
    Promise.prototype._propagateFrom = function (parent, flags) {
        if ((flags & 1) > 0 && parent._cancellable()) {
            this._setCancellable();
            this._cancellationParent = parent;
        }
        if ((flags & 4) > 0 && parent._isBound()) {
            this._setBoundTo(parent._boundTo);
        }
    };
    
    Promise.prototype._fulfill = function (value) {
        if (this._isFollowingOrFulfilledOrRejected()) return;
        this._fulfillUnchecked(value);
    };
    
    Promise.prototype._reject = function (reason, carriedStackTrace) {
        if (this._isFollowingOrFulfilledOrRejected()) return;
        this._rejectUnchecked(reason, carriedStackTrace);
    };
    
    Promise.prototype._settlePromiseAt = function (index) {
        var promise = this._promiseAt(index);
        var isPromise = promise instanceof Promise;
    
        if (isPromise && promise._isMigrated()) {
            promise._unsetIsMigrated();
            return async.invoke(this._settlePromiseAt, this, index);
        }
        var handler = this._isFulfilled()
            ? this._fulfillmentHandlerAt(index)
            : this._rejectionHandlerAt(index);
    
        var carriedStackTrace =
            this._isCarryingStackTrace() ? this._getCarriedStackTrace() : undefined;
        var value = this._settledValue;
        var receiver = this._receiverAt(index);
    
    
        this._clearCallbackDataAtIndex(index);
    
        if (typeof handler === "function") {
            if (!isPromise) {
                handler.call(receiver, value, promise);
            } else {
                this._settlePromiseFromHandler(handler, receiver, value, promise);
            }
        } else if (receiver instanceof PromiseArray) {
            if (!receiver._isResolved()) {
                if (this._isFulfilled()) {
                    receiver._promiseFulfilled(value, promise);
                }
                else {
                    receiver._promiseRejected(value, promise);
                }
            }
        } else if (isPromise) {
            if (this._isFulfilled()) {
                promise._fulfill(value);
            } else {
                promise._reject(value, carriedStackTrace);
            }
        }
    
        if (index >= 4 && (index & 31) === 4)
            async.invokeLater(this._setLength, this, 0);
    };
    
    Promise.prototype._clearCallbackDataAtIndex = function(index) {
        if (index === 0) {
            if (!this._isCarryingStackTrace()) {
                this._fulfillmentHandler0 = undefined;
            }
            this._rejectionHandler0 =
            this._progressHandler0 =
            this._receiver0 =
            this._promise0 = undefined;
        } else {
            var base = index * 5 - 5;
            this[base + 3] =
            this[base + 4] =
            this[base + 0] =
            this[base + 1] =
            this[base + 2] = undefined;
        }
    };
    
    Promise.prototype._isSettlePromisesQueued = function () {
        return (this._bitField &
                -1073741824) === -1073741824;
    };
    
    Promise.prototype._setSettlePromisesQueued = function () {
        this._bitField = this._bitField | -1073741824;
    };
    
    Promise.prototype._unsetSettlePromisesQueued = function () {
        this._bitField = this._bitField & (~-1073741824);
    };
    
    Promise.prototype._queueSettlePromises = function() {
        async.settlePromises(this);
        this._setSettlePromisesQueued();
    };
    
    Promise.prototype._fulfillUnchecked = function (value) {
        if (value === this) {
            var err = makeSelfResolutionError();
            this._attachExtraTrace(err);
            return this._rejectUnchecked(err, undefined);
        }
        this._setFulfilled();
        this._settledValue = value;
        this._cleanValues();
    
        if (this._length() > 0) {
            this._queueSettlePromises();
        }
    };
    
    Promise.prototype._rejectUncheckedCheckError = function (reason) {
        var trace = util.ensureErrorObject(reason);
        this._rejectUnchecked(reason, trace === reason ? undefined : trace);
    };
    
    Promise.prototype._rejectUnchecked = function (reason, trace) {
        if (reason === this) {
            var err = makeSelfResolutionError();
            this._attachExtraTrace(err);
            return this._rejectUnchecked(err);
        }
        this._setRejected();
        this._settledValue = reason;
        this._cleanValues();
    
        if (this._isFinal()) {
            async.throwLater(function(e) {
                if ("stack" in e) {
                    async.invokeFirst(
                        CapturedTrace.unhandledRejection, undefined, e);
                }
                throw e;
            }, trace === undefined ? reason : trace);
            return;
        }
    
        if (trace !== undefined && trace !== reason) {
            this._setCarriedStackTrace(trace);
        }
    
        if (this._length() > 0) {
            this._queueSettlePromises();
        } else {
            this._ensurePossibleRejectionHandled();
        }
    };
    
    Promise.prototype._settlePromises = function () {
        this._unsetSettlePromisesQueued();
        var len = this._length();
        for (var i = 0; i < len; i++) {
            this._settlePromiseAt(i);
        }
    };
    
    util.notEnumerableProp(Promise,
                           "_makeSelfResolutionError",
                           makeSelfResolutionError);
    
     require('bluebird/js/main/progress.js')(Promise, PromiseArray);
     require('bluebird/js/main/method.js')(Promise, INTERNAL, tryConvertToPromise, apiRejection);
     require('bluebird/js/main/bind.js')(Promise, INTERNAL, tryConvertToPromise);
     require('bluebird/js/main/finally.js')(Promise, NEXT_FILTER, tryConvertToPromise);
     require('bluebird/js/main/direct_resolve.js')(Promise);
     require('bluebird/js/main/synchronous_inspection.js')(Promise);
     require('bluebird/js/main/join.js')(Promise, PromiseArray, tryConvertToPromise, INTERNAL);
    Promise.Promise = Promise;
     require('bluebird/js/main/map.js')(Promise, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL);
     require('bluebird/js/main/cancel.js')(Promise);
     require('bluebird/js/main/using.js')(Promise, apiRejection, tryConvertToPromise, createContext);
     require('bluebird/js/main/generators.js')(Promise, apiRejection, INTERNAL, tryConvertToPromise);
     require('bluebird/js/main/nodeify.js')(Promise);
     require('bluebird/js/main/call_get.js')(Promise);
     require('bluebird/js/main/props.js')(Promise, PromiseArray, tryConvertToPromise, apiRejection);
     require('bluebird/js/main/race.js')(Promise, INTERNAL, tryConvertToPromise, apiRejection);
     require('bluebird/js/main/reduce.js')(Promise, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL);
     require('bluebird/js/main/settle.js')(Promise, PromiseArray);
     require('bluebird/js/main/some.js')(Promise, PromiseArray, apiRejection);
     require('bluebird/js/main/promisify.js')(Promise, INTERNAL);
     require('bluebird/js/main/any.js')(Promise);
     require('bluebird/js/main/each.js')(Promise, INTERNAL);
     require('bluebird/js/main/timers.js')(Promise, INTERNAL);
     require('bluebird/js/main/filter.js')(Promise, INTERNAL);
                                                             
        util.toFastProperties(Promise);                                          
        util.toFastProperties(Promise.prototype);                                
        function fillTypes(value) {                                              
            var p = new Promise(INTERNAL);                                       
            p._fulfillmentHandler0 = value;                                      
            p._rejectionHandler0 = value;                                        
            p._progressHandler0 = value;                                         
            p._promise0 = value;                                                 
            p._receiver0 = value;                                                
            p._settledValue = value;                                             
        }                                                                        
        // Complete slack tracking, opt out of field-type tracking and           
        // stabilize map                                                         
        fillTypes({a: 1});                                                       
        fillTypes({b: 2});                                                       
        fillTypes({c: 3});                                                       
        fillTypes(1);                                                            
        fillTypes(function(){});                                                 
        fillTypes(undefined);                                                    
        fillTypes(false);                                                        
        fillTypes(new Promise(INTERNAL));                                        
        CapturedTrace.setBounds(async.firstLineError, util.lastLineError);       
        return Promise;                                                          
    
    };
    
  provide("bluebird/js/main/promise.js", module.exports);
}(global));

// pakmanager:bluebird
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  "use strict";
    var old;
    if (typeof Promise !== "undefined") old = Promise;
    function noConflict() {
        try { if (Promise === bluebird) Promise = old; }
        catch (e) {}
        return bluebird;
    }
    var bluebird =  require('bluebird/js/main/promise.js')();
    bluebird.noConflict = noConflict;
    module.exports = bluebird;
    
  provide("bluebird", module.exports);
}(global));

// pakmanager:chalk
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    var escapeStringRegexp = require('escape-string-regexp');
    var ansiStyles = require('ansi-styles');
    var stripAnsi = require('strip-ansi');
    var hasAnsi = require('has-ansi');
    var supportsColor = require('supports-color');
    var defineProps = Object.defineProperties;
    var isSimpleWindowsTerm = process.platform === 'win32' && !/^xterm/i.test(process.env.TERM);
    
    function Chalk(options) {
    	// detect mode if not set manually
    	this.enabled = !options || options.enabled === undefined ? supportsColor : options.enabled;
    }
    
    // use bright blue on Windows as the normal blue color is illegible
    if (isSimpleWindowsTerm) {
    	ansiStyles.blue.open = '\u001b[94m';
    }
    
    var styles = (function () {
    	var ret = {};
    
    	Object.keys(ansiStyles).forEach(function (key) {
    		ansiStyles[key].closeRe = new RegExp(escapeStringRegexp(ansiStyles[key].close), 'g');
    
    		ret[key] = {
    			get: function () {
    				return build.call(this, this._styles.concat(key));
    			}
    		};
    	});
    
    	return ret;
    })();
    
    var proto = defineProps(function chalk() {}, styles);
    
    function build(_styles) {
    	var builder = function builder() {
    		return applyStyle.apply(builder, arguments);
    	};
    
    	builder._styles = _styles;
    	builder.enabled = this.enabled;
    	// __proto__ is used because we must return a function, but there is
    	// no way to create a function with a different prototype.
    	/*eslint no-proto: 0 */
    	builder.__proto__ = proto;
    
    	return builder;
    }
    
    function applyStyle() {
    	// support varags, but simply cast to string in case there's only one arg
    	var args = arguments;
    	var argsLen = args.length;
    	var str = argsLen !== 0 && String(arguments[0]);
    
    	if (argsLen > 1) {
    		// don't slice `arguments`, it prevents v8 optimizations
    		for (var a = 1; a < argsLen; a++) {
    			str += ' ' + args[a];
    		}
    	}
    
    	if (!this.enabled || !str) {
    		return str;
    	}
    
    	var nestedStyles = this._styles;
    	var i = nestedStyles.length;
    
    	// Turns out that on Windows dimmed gray text becomes invisible in cmd.exe,
    	// see https://github.com/chalk/chalk/issues/58
    	// If we're on Windows and we're dealing with a gray color, temporarily make 'dim' a noop.
    	var originalDim = ansiStyles.dim.open;
    	if (isSimpleWindowsTerm && (nestedStyles.indexOf('gray') !== -1 || nestedStyles.indexOf('grey') !== -1)) {
    		ansiStyles.dim.open = '';
    	}
    
    	while (i--) {
    		var code = ansiStyles[nestedStyles[i]];
    
    		// Replace any instances already present with a re-opening code
    		// otherwise only the part of the string until said closing code
    		// will be colored, and the rest will simply be 'plain'.
    		str = code.open + str.replace(code.closeRe, code.open) + code.close;
    	}
    
    	// Reset the original 'dim' if we changed it to work around the Windows dimmed gray issue.
    	ansiStyles.dim.open = originalDim;
    
    	return str;
    }
    
    function init() {
    	var ret = {};
    
    	Object.keys(styles).forEach(function (name) {
    		ret[name] = {
    			get: function () {
    				return build.call(this, [name]);
    			}
    		};
    	});
    
    	return ret;
    }
    
    defineProps(Chalk.prototype, init());
    
    module.exports = new Chalk();
    module.exports.styles = ansiStyles;
    module.exports.hasColor = hasAnsi;
    module.exports.stripColor = stripAnsi;
    module.exports.supportsColor = supportsColor;
    
  provide("chalk", module.exports);
}(global));

// pakmanager:commander
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  
    /**
     * Module dependencies.
     */
    
    var EventEmitter = require('events').EventEmitter;
    var spawn = require('child_process').spawn;
    var readlink = require('graceful-readlink').readlinkSync;
    var path = require('path');
    var dirname = path.dirname;
    var basename = path.basename;
    var fs = require('fs');
    
    /**
     * Expose the root command.
     */
    
    exports = module.exports = new Command();
    
    /**
     * Expose `Command`.
     */
    
    exports.Command = Command;
    
    /**
     * Expose `Option`.
     */
    
    exports.Option = Option;
    
    /**
     * Initialize a new `Option` with the given `flags` and `description`.
     *
     * @param {String} flags
     * @param {String} description
     * @api public
     */
    
    function Option(flags, description) {
      this.flags = flags;
      this.required = ~flags.indexOf('<');
      this.optional = ~flags.indexOf('[');
      this.bool = !~flags.indexOf('-no-');
      flags = flags.split(/[ ,|]+/);
      if (flags.length > 1 && !/^[[<]/.test(flags[1])) this.short = flags.shift();
      this.long = flags.shift();
      this.description = description || '';
    }
    
    /**
     * Return option name.
     *
     * @return {String}
     * @api private
     */
    
    Option.prototype.name = function() {
      return this.long
        .replace('--', '')
        .replace('no-', '');
    };
    
    /**
     * Check if `arg` matches the short or long flag.
     *
     * @param {String} arg
     * @return {Boolean}
     * @api private
     */
    
    Option.prototype.is = function(arg) {
      return arg == this.short || arg == this.long;
    };
    
    /**
     * Initialize a new `Command`.
     *
     * @param {String} name
     * @api public
     */
    
    function Command(name) {
      this.commands = [];
      this.options = [];
      this._execs = [];
      this._allowUnknownOption = false;
      this._args = [];
      this._name = name;
    }
    
    /**
     * Inherit from `EventEmitter.prototype`.
     */
    
    Command.prototype.__proto__ = EventEmitter.prototype;
    
    /**
     * Add command `name`.
     *
     * The `.action()` callback is invoked when the
     * command `name` is specified via __ARGV__,
     * and the remaining arguments are applied to the
     * function for access.
     *
     * When the `name` is "*" an un-matched command
     * will be passed as the first arg, followed by
     * the rest of __ARGV__ remaining.
     *
     * Examples:
     *
     *      program
     *        .version('0.0.1')
     *        .option('-C, --chdir <path>', 'change the working directory')
     *        .option('-c, --config <path>', 'set config path. defaults to ./deploy.conf')
     *        .option('-T, --no-tests', 'ignore test hook')
     *
     *      program
     *        .command('setup')
     *        .description('run remote setup commands')
     *        .action(function() {
     *          console.log('setup');
     *        });
     *
     *      program
     *        .command('exec <cmd>')
     *        .description('run the given remote command')
     *        .action(function(cmd) {
     *          console.log('exec "%s"', cmd);
     *        });
     *
     *      program
     *        .command('teardown <dir> [otherDirs...]')
     *        .description('run teardown commands')
     *        .action(function(dir, otherDirs) {
     *          console.log('dir "%s"', dir);
     *          if (otherDirs) {
     *            otherDirs.forEach(function (oDir) {
     *              console.log('dir "%s"', oDir);
     *            });
     *          }
     *        });
     *
     *      program
     *        .command('*')
     *        .description('deploy the given env')
     *        .action(function(env) {
     *          console.log('deploying "%s"', env);
     *        });
     *
     *      program.parse(process.argv);
      *
     * @param {String} name
     * @param {String} [desc] for git-style sub-commands
     * @return {Command} the new command
     * @api public
     */
    
    Command.prototype.command = function(name, desc, opts) {
      opts = opts || {};
      var args = name.split(/ +/);
      var cmd = new Command(args.shift());
    
      if (desc) {
        cmd.description(desc);
        this.executables = true;
        this._execs[cmd._name] = true;
      }
    
      cmd._noHelp = !!opts.noHelp;
      this.commands.push(cmd);
      cmd.parseExpectedArgs(args);
      cmd.parent = this;
    
      if (desc) return this;
      return cmd;
    };
    
    /**
     * Define argument syntax for the top-level command.
     *
     * @api public
     */
    
    Command.prototype.arguments = function (desc) {
      return this.parseExpectedArgs(desc.split(/ +/));
    }
    
    /**
     * Add an implicit `help [cmd]` subcommand
     * which invokes `--help` for the given command.
     *
     * @api private
     */
    
    Command.prototype.addImplicitHelpCommand = function() {
      this.command('help [cmd]', 'display help for [cmd]');
    };
    
    /**
     * Parse expected `args`.
     *
     * For example `["[type]"]` becomes `[{ required: false, name: 'type' }]`.
     *
     * @param {Array} args
     * @return {Command} for chaining
     * @api public
     */
    
    Command.prototype.parseExpectedArgs = function(args) {
      if (!args.length) return;
      var self = this;
      args.forEach(function(arg) {
        var argDetails = {
          required: false,
          name: '',
          variadic: false
        };
    
        switch (arg[0]) {
          case '<':
            argDetails.required = true;
            argDetails.name = arg.slice(1, -1);
            break;
          case '[':
            argDetails.name = arg.slice(1, -1);
            break;
        }
    
        if (argDetails.name.length > 3 && argDetails.name.slice(-3) === '...') {
          argDetails.variadic = true;
          argDetails.name = argDetails.name.slice(0, -3);
        }
        if (argDetails.name) {
          self._args.push(argDetails);
        }
      });
      return this;
    };
    
    /**
     * Register callback `fn` for the command.
     *
     * Examples:
     *
     *      program
     *        .command('help')
     *        .description('display verbose help')
     *        .action(function() {
     *           // output help here
     *        });
     *
     * @param {Function} fn
     * @return {Command} for chaining
     * @api public
     */
    
    Command.prototype.action = function(fn) {
      var self = this;
      var listener = function(args, unknown) {
        // Parse any so-far unknown options
        args = args || [];
        unknown = unknown || [];
    
        var parsed = self.parseOptions(unknown);
    
        // Output help if necessary
        outputHelpIfNecessary(self, parsed.unknown);
    
        // If there are still any unknown options, then we simply
        // die, unless someone asked for help, in which case we give it
        // to them, and then we die.
        if (parsed.unknown.length > 0) {
          self.unknownOption(parsed.unknown[0]);
        }
    
        // Leftover arguments need to be pushed back. Fixes issue #56
        if (parsed.args.length) args = parsed.args.concat(args);
    
        self._args.forEach(function(arg, i) {
          if (arg.required && null == args[i]) {
            self.missingArgument(arg.name);
          } else if (arg.variadic) {
            if (i !== self._args.length - 1) {
              self.variadicArgNotLast(arg.name);
            }
    
            args[i] = args.splice(i);
          }
        });
    
        // Always append ourselves to the end of the arguments,
        // to make sure we match the number of arguments the user
        // expects
        if (self._args.length) {
          args[self._args.length] = self;
        } else {
          args.push(self);
        }
    
        fn.apply(self, args);
      };
      var parent = this.parent || this;
      var name = parent === this ? '*' : this._name;
      parent.on(name, listener);
      if (this._alias) parent.on(this._alias, listener);
      return this;
    };
    
    /**
     * Define option with `flags`, `description` and optional
     * coercion `fn`.
     *
     * The `flags` string should contain both the short and long flags,
     * separated by comma, a pipe or space. The following are all valid
     * all will output this way when `--help` is used.
     *
     *    "-p, --pepper"
     *    "-p|--pepper"
     *    "-p --pepper"
     *
     * Examples:
     *
     *     // simple boolean defaulting to false
     *     program.option('-p, --pepper', 'add pepper');
     *
     *     --pepper
     *     program.pepper
     *     // => Boolean
     *
     *     // simple boolean defaulting to true
     *     program.option('-C, --no-cheese', 'remove cheese');
     *
     *     program.cheese
     *     // => true
     *
     *     --no-cheese
     *     program.cheese
     *     // => false
     *
     *     // required argument
     *     program.option('-C, --chdir <path>', 'change the working directory');
     *
     *     --chdir /tmp
     *     program.chdir
     *     // => "/tmp"
     *
     *     // optional argument
     *     program.option('-c, --cheese [type]', 'add cheese [marble]');
     *
     * @param {String} flags
     * @param {String} description
     * @param {Function|Mixed} fn or default
     * @param {Mixed} defaultValue
     * @return {Command} for chaining
     * @api public
     */
    
    Command.prototype.option = function(flags, description, fn, defaultValue) {
      var self = this
        , option = new Option(flags, description)
        , oname = option.name()
        , name = camelcase(oname);
    
      // default as 3rd arg
      if (typeof fn != 'function') {
        if (fn instanceof RegExp) {
          var regex = fn;
          fn = function(val, def) {
            var m = regex.exec(val);
            return m ? m[0] : def;
          }
        }
        else {
          defaultValue = fn;
          fn = null;
        }
      }
    
      // preassign default value only for --no-*, [optional], or <required>
      if (false == option.bool || option.optional || option.required) {
        // when --no-* we make sure default is true
        if (false == option.bool) defaultValue = true;
        // preassign only if we have a default
        if (undefined !== defaultValue) self[name] = defaultValue;
      }
    
      // register the option
      this.options.push(option);
    
      // when it's passed assign the value
      // and conditionally invoke the callback
      this.on(oname, function(val) {
        // coercion
        if (null !== val && fn) val = fn(val, undefined === self[name]
          ? defaultValue
          : self[name]);
    
        // unassigned or bool
        if ('boolean' == typeof self[name] || 'undefined' == typeof self[name]) {
          // if no value, bool true, and we have a default, then use it!
          if (null == val) {
            self[name] = option.bool
              ? defaultValue || true
              : false;
          } else {
            self[name] = val;
          }
        } else if (null !== val) {
          // reassign
          self[name] = val;
        }
      });
    
      return this;
    };
    
    /**
     * Allow unknown options on the command line.
     *
     * @param {Boolean} arg if `true` or omitted, no error will be thrown
     * for unknown options.
     * @api public
     */
    Command.prototype.allowUnknownOption = function(arg) {
        this._allowUnknownOption = arguments.length === 0 || arg;
        return this;
    };
    
    /**
     * Parse `argv`, settings options and invoking commands when defined.
     *
     * @param {Array} argv
     * @return {Command} for chaining
     * @api public
     */
    
    Command.prototype.parse = function(argv) {
      // implicit help
      if (this.executables) this.addImplicitHelpCommand();
    
      // store raw args
      this.rawArgs = argv;
    
      // guess name
      this._name = this._name || basename(argv[1], '.js');
    
      // github-style sub-commands with no sub-command
      if (this.executables && argv.length < 3) {
        // this user needs help
        argv.push('--help');
      }
    
      // process argv
      var parsed = this.parseOptions(this.normalize(argv.slice(2)));
      var args = this.args = parsed.args;
    
      var result = this.parseArgs(this.args, parsed.unknown);
    
      // executable sub-commands
      var name = result.args[0];
      if (this._execs[name] && typeof this._execs[name] != "function") {
        return this.executeSubCommand(argv, args, parsed.unknown);
      }
    
      return result;
    };
    
    /**
     * Execute a sub-command executable.
     *
     * @param {Array} argv
     * @param {Array} args
     * @param {Array} unknown
     * @api private
     */
    
    Command.prototype.executeSubCommand = function(argv, args, unknown) {
      args = args.concat(unknown);
    
      if (!args.length) this.help();
      if ('help' == args[0] && 1 == args.length) this.help();
    
      // <cmd> --help
      if ('help' == args[0]) {
        args[0] = args[1];
        args[1] = '--help';
      }
    
      // executable
      var f = argv[1];
      // name of the subcommand, link `pm-install`
      var bin = basename(f, '.js') + '-' + args[0];
    
    
      // In case of globally installed, get the base dir where executable
      //  subcommand file should be located at
      var baseDir
        , link = readlink(f);
    
      // when symbolink is relative path
      if (link !== f && link.charAt(0) !== '/') {
        link = path.join(dirname(f), link)
      }
      baseDir = dirname(link);
    
      // prefer local `./<bin>` to bin in the $PATH
      var localBin = path.join(baseDir, bin);
    
      // whether bin file is a js script with explicit `.js` extension
      var isExplicitJS = false;
      if (exists(localBin + '.js')) {
        bin = localBin + '.js';
        isExplicitJS = true;
      } else if (exists(localBin)) {
        bin = localBin;
      }
    
      args = args.slice(1);
    
      var proc;
      if (process.platform !== 'win32') {
        if (isExplicitJS) {
          args.unshift(localBin);
          // add executable arguments to spawn
          args = (process.execArgv || []).concat(args);
    
          proc = spawn('node', args, { stdio: 'inherit', customFds: [0, 1, 2] });
        } else {
          proc = spawn(bin, args, { stdio: 'inherit', customFds: [0, 1, 2] });
        }
      } else {
        args.unshift(localBin);
        proc = spawn(process.execPath, args, { stdio: 'inherit'});
      }
    
      proc.on('close', process.exit.bind(process));
      proc.on('error', function(err) {
        if (err.code == "ENOENT") {
          console.error('\n  %s(1) does not exist, try --help\n', bin);
        } else if (err.code == "EACCES") {
          console.error('\n  %s(1) not executable. try chmod or run with root\n', bin);
        }
        process.exit(1);
      });
    
      this.runningCommand = proc;
    };
    
    /**
     * Normalize `args`, splitting joined short flags. For example
     * the arg "-abc" is equivalent to "-a -b -c".
     * This also normalizes equal sign and splits "--abc=def" into "--abc def".
     *
     * @param {Array} args
     * @return {Array}
     * @api private
     */
    
    Command.prototype.normalize = function(args) {
      var ret = []
        , arg
        , lastOpt
        , index;
    
      for (var i = 0, len = args.length; i < len; ++i) {
        arg = args[i];
        if (i > 0) {
          lastOpt = this.optionFor(args[i-1]);
        }
    
        if (arg === '--') {
          // Honor option terminator
          ret = ret.concat(args.slice(i));
          break;
        } else if (lastOpt && lastOpt.required) {
          ret.push(arg);
        } else if (arg.length > 1 && '-' == arg[0] && '-' != arg[1]) {
          arg.slice(1).split('').forEach(function(c) {
            ret.push('-' + c);
          });
        } else if (/^--/.test(arg) && ~(index = arg.indexOf('='))) {
          ret.push(arg.slice(0, index), arg.slice(index + 1));
        } else {
          ret.push(arg);
        }
      }
    
      return ret;
    };
    
    /**
     * Parse command `args`.
     *
     * When listener(s) are available those
     * callbacks are invoked, otherwise the "*"
     * event is emitted and those actions are invoked.
     *
     * @param {Array} args
     * @return {Command} for chaining
     * @api private
     */
    
    Command.prototype.parseArgs = function(args, unknown) {
      var name;
    
      if (args.length) {
        name = args[0];
        if (this.listeners(name).length) {
          this.emit(args.shift(), args, unknown);
        } else {
          this.emit('*', args);
        }
      } else {
        outputHelpIfNecessary(this, unknown);
    
        // If there were no args and we have unknown options,
        // then they are extraneous and we need to error.
        if (unknown.length > 0) {
          this.unknownOption(unknown[0]);
        }
      }
    
      return this;
    };
    
    /**
     * Return an option matching `arg` if any.
     *
     * @param {String} arg
     * @return {Option}
     * @api private
     */
    
    Command.prototype.optionFor = function(arg) {
      for (var i = 0, len = this.options.length; i < len; ++i) {
        if (this.options[i].is(arg)) {
          return this.options[i];
        }
      }
    };
    
    /**
     * Parse options from `argv` returning `argv`
     * void of these options.
     *
     * @param {Array} argv
     * @return {Array}
     * @api public
     */
    
    Command.prototype.parseOptions = function(argv) {
      var args = []
        , len = argv.length
        , literal
        , option
        , arg;
    
      var unknownOptions = [];
    
      // parse options
      for (var i = 0; i < len; ++i) {
        arg = argv[i];
    
        // literal args after --
        if ('--' == arg) {
          literal = true;
          continue;
        }
    
        if (literal) {
          args.push(arg);
          continue;
        }
    
        // find matching Option
        option = this.optionFor(arg);
    
        // option is defined
        if (option) {
          // requires arg
          if (option.required) {
            arg = argv[++i];
            if (null == arg) return this.optionMissingArgument(option);
            this.emit(option.name(), arg);
          // optional arg
          } else if (option.optional) {
            arg = argv[i+1];
            if (null == arg || ('-' == arg[0] && '-' != arg)) {
              arg = null;
            } else {
              ++i;
            }
            this.emit(option.name(), arg);
          // bool
          } else {
            this.emit(option.name());
          }
          continue;
        }
    
        // looks like an option
        if (arg.length > 1 && '-' == arg[0]) {
          unknownOptions.push(arg);
    
          // If the next argument looks like it might be
          // an argument for this option, we pass it on.
          // If it isn't, then it'll simply be ignored
          if (argv[i+1] && '-' != argv[i+1][0]) {
            unknownOptions.push(argv[++i]);
          }
          continue;
        }
    
        // arg
        args.push(arg);
      }
    
      return { args: args, unknown: unknownOptions };
    };
    
    /**
     * Return an object containing options as key-value pairs
     *
     * @return {Object}
     * @api public
     */
    Command.prototype.opts = function() {
      var result = {}
        , len = this.options.length;
    
      for (var i = 0 ; i < len; i++) {
        var key = camelcase(this.options[i].name());
        result[key] = key === 'version' ? this._version : this[key];
      }
      return result;
    };
    
    /**
     * Argument `name` is missing.
     *
     * @param {String} name
     * @api private
     */
    
    Command.prototype.missingArgument = function(name) {
      console.error();
      console.error("  error: missing required argument `%s'", name);
      console.error();
      process.exit(1);
    };
    
    /**
     * `Option` is missing an argument, but received `flag` or nothing.
     *
     * @param {String} option
     * @param {String} flag
     * @api private
     */
    
    Command.prototype.optionMissingArgument = function(option, flag) {
      console.error();
      if (flag) {
        console.error("  error: option `%s' argument missing, got `%s'", option.flags, flag);
      } else {
        console.error("  error: option `%s' argument missing", option.flags);
      }
      console.error();
      process.exit(1);
    };
    
    /**
     * Unknown option `flag`.
     *
     * @param {String} flag
     * @api private
     */
    
    Command.prototype.unknownOption = function(flag) {
      if (this._allowUnknownOption) return;
      console.error();
      console.error("  error: unknown option `%s'", flag);
      console.error();
      process.exit(1);
    };
    
    /**
     * Variadic argument with `name` is not the last argument as required.
     *
     * @param {String} name
     * @api private
     */
    
    Command.prototype.variadicArgNotLast = function(name) {
      console.error();
      console.error("  error: variadic arguments must be last `%s'", name);
      console.error();
      process.exit(1);
    };
    
    /**
     * Set the program version to `str`.
     *
     * This method auto-registers the "-V, --version" flag
     * which will print the version number when passed.
     *
     * @param {String} str
     * @param {String} flags
     * @return {Command} for chaining
     * @api public
     */
    
    Command.prototype.version = function(str, flags) {
      if (0 == arguments.length) return this._version;
      this._version = str;
      flags = flags || '-V, --version';
      this.option(flags, 'output the version number');
      this.on('version', function() {
        process.stdout.write(str + '\n');
        process.exit(0);
      });
      return this;
    };
    
    /**
     * Set the description to `str`.
     *
     * @param {String} str
     * @return {String|Command}
     * @api public
     */
    
    Command.prototype.description = function(str) {
      if (0 == arguments.length) return this._description;
      this._description = str;
      return this;
    };
    
    /**
     * Set an alias for the command
     *
     * @param {String} alias
     * @return {String|Command}
     * @api public
     */
    
    Command.prototype.alias = function(alias) {
      if (0 == arguments.length) return this._alias;
      this._alias = alias;
      return this;
    };
    
    /**
     * Set / get the command usage `str`.
     *
     * @param {String} str
     * @return {String|Command}
     * @api public
     */
    
    Command.prototype.usage = function(str) {
      var args = this._args.map(function(arg) {
        return humanReadableArgName(arg);
      });
    
      var usage = '[options]'
        + (this.commands.length ? ' [command]' : '')
        + (this._args.length ? ' ' + args.join(' ') : '');
    
      if (0 == arguments.length) return this._usage || usage;
      this._usage = str;
    
      return this;
    };
    
    /**
     * Get the name of the command
     *
     * @param {String} name
     * @return {String|Command}
     * @api public
     */
    
    Command.prototype.name = function() {
      return this._name;
    };
    
    /**
     * Return the largest option length.
     *
     * @return {Number}
     * @api private
     */
    
    Command.prototype.largestOptionLength = function() {
      return this.options.reduce(function(max, option) {
        return Math.max(max, option.flags.length);
      }, 0);
    };
    
    /**
     * Return help for options.
     *
     * @return {String}
     * @api private
     */
    
    Command.prototype.optionHelp = function() {
      var width = this.largestOptionLength();
    
      // Prepend the help information
      return [pad('-h, --help', width) + '  ' + 'output usage information']
        .concat(this.options.map(function(option) {
          return pad(option.flags, width) + '  ' + option.description;
          }))
        .join('\n');
    };
    
    /**
     * Return command help documentation.
     *
     * @return {String}
     * @api private
     */
    
    Command.prototype.commandHelp = function() {
      if (!this.commands.length) return '';
    
      var commands = this.commands.filter(function(cmd) {
        return !cmd._noHelp;
      }).map(function(cmd) {
        var args = cmd._args.map(function(arg) {
          return humanReadableArgName(arg);
        }).join(' ');
    
        return [
          cmd._name
            + (cmd._alias
              ? '|' + cmd._alias
              : '')
            + (cmd.options.length
              ? ' [options]'
              : '')
            + ' ' + args
        , cmd.description()
        ];
      });
    
      var width = commands.reduce(function(max, command) {
        return Math.max(max, command[0].length);
      }, 0);
    
      return [
          ''
        , '  Commands:'
        , ''
        , commands.map(function(cmd) {
          return pad(cmd[0], width) + '  ' + cmd[1];
        }).join('\n').replace(/^/gm, '    ')
        , ''
      ].join('\n');
    };
    
    /**
     * Return program help documentation.
     *
     * @return {String}
     * @api private
     */
    
    Command.prototype.helpInformation = function() {
      var desc = [];
      if (this._description) {
        desc = [
          '  ' + this._description
          , ''
        ];
      }
    
      var cmdName = this._name;
      if (this._alias) {
        cmdName = cmdName + '|' + this._alias;
      }
      var usage = [
        ''
        ,'  Usage: ' + cmdName + ' ' + this.usage()
        , ''
      ];
    
      var cmds = [];
      var commandHelp = this.commandHelp();
      if (commandHelp) cmds = [commandHelp];
    
      var options = [
        '  Options:'
        , ''
        , '' + this.optionHelp().replace(/^/gm, '    ')
        , ''
        , ''
      ];
    
      return usage
        .concat(cmds)
        .concat(desc)
        .concat(options)
        .join('\n');
    };
    
    /**
     * Output help information for this command
     *
     * @api public
     */
    
    Command.prototype.outputHelp = function() {
      process.stdout.write(this.helpInformation());
      this.emit('--help');
    };
    
    /**
     * Output help information and exit.
     *
     * @api public
     */
    
    Command.prototype.help = function() {
      this.outputHelp();
      process.exit();
    };
    
    /**
     * Camel-case the given `flag`
     *
     * @param {String} flag
     * @return {String}
     * @api private
     */
    
    function camelcase(flag) {
      return flag.split('-').reduce(function(str, word) {
        return str + word[0].toUpperCase() + word.slice(1);
      });
    }
    
    /**
     * Pad `str` to `width`.
     *
     * @param {String} str
     * @param {Number} width
     * @return {String}
     * @api private
     */
    
    function pad(str, width) {
      var len = Math.max(0, width - str.length);
      return str + Array(len + 1).join(' ');
    }
    
    /**
     * Output help information if necessary
     *
     * @param {Command} command to output help for
     * @param {Array} array of options to search for -h or --help
     * @api private
     */
    
    function outputHelpIfNecessary(cmd, options) {
      options = options || [];
      for (var i = 0; i < options.length; i++) {
        if (options[i] == '--help' || options[i] == '-h') {
          cmd.outputHelp();
          process.exit(0);
        }
      }
    }
    
    /**
     * Takes an argument an returns its human readable equivalent for help usage.
     *
     * @param {Object} arg
     * @return {String}
     * @api private
     */
    
    function humanReadableArgName(arg) {
      var nameOutput = arg.name + (arg.variadic === true ? '...' : '');
    
      return arg.required
        ? '<' + nameOutput + '>'
        : '[' + nameOutput + ']'
    }
    
    // for versions before node v0.8 when there weren't `fs.existsSync`
    function exists(file) {
      try {
        if (fs.statSync(file).isFile()) {
          return true;
        }
      } catch (e) {
        return false;
      }
    }
    
    
  provide("commander", module.exports);
}(global));

// pakmanager:is-my-json-valid/formats
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  exports['date-time'] = /^\d{4}-(?:0[0-9]{1}|1[0-2]{1})-[0-9]{2}[tT ]\d{2}:\d{2}:\d{2}(\.\d+)?([zZ]|[+-]\d{2}:\d{2})$/
    exports['date'] = /^\d{4}-(?:0[0-9]{1}|1[0-2]{1})-[0-9]{2}$/
    exports['time'] = /^\d{2}:\d{2}:\d{2}$/
    exports['email'] = /^\S+@\S+$/
    exports['ip-address'] = exports['ipv4'] = /^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/
    exports['ipv6'] = /^\s*((([0-9A-Fa-f]{1,4}:){7}([0-9A-Fa-f]{1,4}|:))|(([0-9A-Fa-f]{1,4}:){6}(:[0-9A-Fa-f]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){1,3})|((:[0-9A-Fa-f]{1,4})?:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){1,4})|((:[0-9A-Fa-f]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){1,5})|((:[0-9A-Fa-f]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){1,6})|((:[0-9A-Fa-f]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9A-Fa-f]{1,4}){1,7})|((:[0-9A-Fa-f]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(%.+)?\s*$/
    exports['uri'] = /^[a-zA-Z][a-zA-Z0-9+-.]*:[^\s]*$/
    exports['color'] = /(#?([0-9A-Fa-f]{3,6})\b)|(aqua)|(black)|(blue)|(fuchsia)|(gray)|(green)|(lime)|(maroon)|(navy)|(olive)|(orange)|(purple)|(red)|(silver)|(teal)|(white)|(yellow)|(rgb\(\s*\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\b\s*,\s*\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\b\s*,\s*\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\b\s*\))|(rgb\(\s*(\d?\d%|100%)+\s*,\s*(\d?\d%|100%)+\s*,\s*(\d?\d%|100%)+\s*\))/
    exports['hostname'] = /^([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9\-]{0,61}[a-zA-Z0-9])(\.([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9\-]{0,61}[a-zA-Z0-9]))*$/
    exports['alpha'] = /^[a-zA-Z]+$/
    exports['alphanumeric'] = /^[a-zA-Z0-9]+$/
    exports['style'] = /\s*(.+?):\s*([^;]+);?/g
    exports['phone'] = /^\+(?:[0-9] ?){6,14}[0-9]$/
    exports['utc-millisec'] = /^[0-9]+(\.?[0-9]+)?$/
    
  provide("is-my-json-valid/formats", module.exports);
}(global));

// pakmanager:is-my-json-valid
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var genobj = require('generate-object-property')
    var genfun = require('generate-function')
    var jsonpointer = require('jsonpointer')
    var xtend = require('xtend')
    var formats =  require('is-my-json-valid/formats')
    
    var get = function(obj, additionalSchemas, ptr) {
      if (/^https?:\/\//.test(ptr)) return null
    
      var visit = function(sub) {
        if (sub && sub.id === ptr) return sub
        if (typeof sub !== 'object' || !sub) return null
        return Object.keys(sub).reduce(function(res, k) {
          return res || visit(sub[k])
        }, null)
      }
    
      var res = visit(obj)
      if (res) return res
    
      ptr = ptr.replace(/^#/, '')
      ptr = ptr.replace(/\/$/, '')
    
      try {
        return jsonpointer.get(obj, decodeURI(ptr))
      } catch (err) {
        var end = ptr.indexOf('#')
        var other
        // external reference
        if (end !== 0) {
          // fragment doesn't exist.
          if (end === -1) {
            other = additionalSchemas[ptr]
          } else {
            var ext = ptr.slice(0, end)
            other = additionalSchemas[ext]
            var fragment = ptr.slice(end).replace(/^#/, '')
            try {
              return jsonpointer.get(other, fragment)
            } catch (err) {}
          }
        } else {
          other = additionalSchemas[ptr]
        }
        return other || null
      }
    }
    
    var formatName = function(field) {
      field = JSON.stringify(field)
      var pattern = /\[([^\[\]"]+)\]/
      while (pattern.test(field)) field = field.replace(pattern, '."+$1+"')
      return field
    }
    
    var types = {}
    
    types.any = function() {
      return 'true'
    }
    
    types.null = function(name) {
      return name+' === null'
    }
    
    types.boolean = function(name) {
      return 'typeof '+name+' === "boolean"'
    }
    
    types.array = function(name) {
      return 'Array.isArray('+name+')'
    }
    
    types.object = function(name) {
      return 'typeof '+name+' === "object" && '+name+' && !Array.isArray('+name+')'
    }
    
    types.number = function(name) {
      return 'typeof '+name+' === "number"'
    }
    
    types.integer = function(name) {
      return 'typeof '+name+' === "number" && (Math.floor('+name+') === '+name+' || '+name+' > 9007199254740992 || '+name+' < -9007199254740992)'
    }
    
    types.string = function(name) {
      return 'typeof '+name+' === "string"'
    }
    
    var unique = function(array) {
      var list = []
      for (var i = 0; i < array.length; i++) {
        list.push(typeof array[i] === 'object' ? JSON.stringify(array[i]) : array[i])
      }
      for (var i = 1; i < list.length; i++) {
        if (list.indexOf(list[i]) !== i) return false
      }
      return true
    }
    
    var toType = function(node) {
      return node.type
    }
    
    var compile = function(schema, cache, root, reporter, opts) {
      var fmts = opts ? xtend(formats, opts.formats) : formats
      var scope = {unique:unique, formats:fmts}
      var verbose = opts ? !!opts.verbose : false;
      var greedy = opts && opts.greedy !== undefined ?
        opts.greedy : false;
    
      var syms = {}
      var gensym = function(name) {
        return name+(syms[name] = (syms[name] || 0)+1)
      }
    
      var reversePatterns = {}
      var patterns = function(p) {
        if (reversePatterns[p]) return reversePatterns[p]
        var n = gensym('pattern')
        scope[n] = new RegExp(p)
        reversePatterns[p] = n
        return n
      }
    
      var vars = ['i','j','k','l','m','n','o','p','q','r','s','t','u','v','x','y','z']
      var genloop = function() {
        var v = vars.shift()
        vars.push(v+v[0])
        return v
      }
    
      var visit = function(name, node, reporter, filter) {
        var properties = node.properties
        var type = node.type
        var tuple = false
    
        if (Array.isArray(node.items)) { // tuple type
          properties = {}
          node.items.forEach(function(item, i) {
            properties[i] = item
          })
          type = 'array'
          tuple = true
        }
    
        var indent = 0
        var error = function(msg, prop, value) {
          validate('errors++')
          if (reporter === true) {
            validate('if (validate.errors === null) validate.errors = []')
            if (verbose) {
              validate('validate.errors.push({field:%s,message:%s,value:%s})', formatName(prop || name), JSON.stringify(msg), value || name)
            } else {
              validate('validate.errors.push({field:%s,message:%s})', formatName(prop || name), JSON.stringify(msg))
            }
          }
        }
    
        if (node.required === true) {
          indent++
          validate('if (%s === undefined) {', name)
          error('is required')
          validate('} else {')
        } else {
          indent++
          validate('if (%s !== undefined) {', name)
        }
    
        var valid = [].concat(type)
          .map(function(t) {
            return types[t || 'any'](name)
          })
          .join(' || ') || 'true'
    
        if (valid !== 'true') {
          indent++
          validate('if (!(%s)) {', valid)
          error('is the wrong type')
          validate('} else {')
        }
    
        if (tuple) {
          if (node.additionalItems === false) {
            validate('if (%s.length > %d) {', name, node.items.length)
            error('has additional items')
            validate('}')
          } else if (node.additionalItems) {
            var i = genloop()
            validate('for (var %s = %d; %s < %s.length; %s++) {', i, node.items.length, i, name, i)
            visit(name+'['+i+']', node.additionalItems, reporter, filter)
            validate('}')
          }   
        }
    
        if (node.format && fmts[node.format]) {
          if (type !== 'string' && formats[node.format]) validate('if (%s) {', types.string(name))
          var n = gensym('format')
          scope[n] = fmts[node.format]
    
          if (typeof scope[n] === 'function') validate('if (!%s(%s)) {', n, name)
          else validate('if (!%s.test(%s)) {', n, name)
          error('must be '+node.format+' format')
          validate('}')
          if (type !== 'string' && formats[node.format]) validate('}')
        }
    
        if (Array.isArray(node.required)) {
          var isUndefined = function(req) {
            return genobj(name, req) + ' === undefined'
          }
    
          var checkRequired = function (req) {
            var prop = genobj(name, req);
            validate('if (%s === undefined) {', prop)
            error('is required', prop)
            validate('missing++')
            validate('}')
          }
          validate('if ((%s)) {', type !== 'object' ? types.object(name) : 'true')
          validate('var missing = 0')
          node.required.map(checkRequired)
          validate('}');
          if (!greedy) {
            validate('if (missing === 0) {')
            indent++
          }
        }
    
        if (node.uniqueItems) {
          if (type !== 'array') validate('if (%s) {', types.array(name))
          validate('if (!(unique(%s))) {', name)
          error('must be unique')
          validate('}')
          if (type !== 'array') validate('}')
        }
    
        if (node.enum) {
          var complex = node.enum.some(function(e) {
            return typeof e === 'object'
          })
    
          var compare = complex ?
            function(e) {
              return 'JSON.stringify('+name+')'+' !== JSON.stringify('+JSON.stringify(e)+')'
            } :
            function(e) {
              return name+' !== '+JSON.stringify(e)
            }
    
          validate('if (%s) {', node.enum.map(compare).join(' && ') || 'false')
          error('must be an enum value')
          validate('}')
        }
    
        if (node.dependencies) {
          if (type !== 'object') validate('if (%s) {', types.object(name))
    
          Object.keys(node.dependencies).forEach(function(key) {
            var deps = node.dependencies[key]
            if (typeof deps === 'string') deps = [deps]
    
            var exists = function(k) {
              return genobj(name, k) + ' !== undefined'
            }
    
            if (Array.isArray(deps)) {
              validate('if (%s !== undefined && !(%s)) {', genobj(name, key), deps.map(exists).join(' && ') || 'true')
              error('dependencies not set')
              validate('}')
            }
            if (typeof deps === 'object') {
              validate('if (%s !== undefined) {', genobj(name, key))
              visit(name, deps, reporter, filter)
              validate('}')
            }
          })
    
          if (type !== 'object') validate('}')
        }
    
        if (node.additionalProperties || node.additionalProperties === false) {
          if (type !== 'object') validate('if (%s) {', types.object(name))
    
          var i = genloop()
          var keys = gensym('keys')
    
          var toCompare = function(p) {
            return keys+'['+i+'] !== '+JSON.stringify(p)
          }
    
          var toTest = function(p) {
            return '!'+patterns(p)+'.test('+keys+'['+i+'])'
          }
    
          var additionalProp = Object.keys(properties || {}).map(toCompare)
            .concat(Object.keys(node.patternProperties || {}).map(toTest))
            .join(' && ') || 'true'
    
          validate('var %s = Object.keys(%s)', keys, name)
            ('for (var %s = 0; %s < %s.length; %s++) {', i, i, keys, i)
              ('if (%s) {', additionalProp)
    
          if (node.additionalProperties === false) {
            if (filter) validate('delete %s', name+'['+keys+'['+i+']]')
            error('has additional properties', null, JSON.stringify(name+'.') + ' + ' + keys + '['+i+']')
          } else {
            visit(name+'['+keys+'['+i+']]', node.additionalProperties, reporter, filter)
          }
    
          validate
              ('}')
            ('}')
    
          if (type !== 'object') validate('}')
        }
    
        if (node.$ref) {
          var sub = get(root, opts && opts.schemas || {}, node.$ref)
          if (sub) {
            var fn = cache[node.$ref]
            if (!fn) {
              cache[node.$ref] = function proxy(data) {
                return fn(data)
              }
              fn = compile(sub, cache, root, false, opts)
            }
            var n = gensym('ref')
            scope[n] = fn
            validate('if (!(%s(%s))) {', n, name)
            error('referenced schema does not match')
            validate('}')
          }
        }
    
        if (node.not) {
          var prev = gensym('prev')
          validate('var %s = errors', prev)
          visit(name, node.not, false, filter)
          validate('if (%s === errors) {', prev)
          error('negative schema matches')
          validate('} else {')
            ('errors = %s', prev)
          ('}')
        }
    
        if (node.items && !tuple) {
          if (type !== 'array') validate('if (%s) {', types.array(name))
    
          var i = genloop()
          validate('for (var %s = 0; %s < %s.length; %s++) {', i, i, name, i)
          visit(name+'['+i+']', node.items, reporter, filter)
          validate('}')
    
          if (type !== 'array') validate('}')
        }
    
        if (node.patternProperties) {
          if (type !== 'object') validate('if (%s) {', types.object(name))
          var keys = gensym('keys')
          var i = genloop()
          validate
            ('var %s = Object.keys(%s)', keys, name)
            ('for (var %s = 0; %s < %s.length; %s++) {', i, i, keys, i)
    
          Object.keys(node.patternProperties).forEach(function(key) {
            var p = patterns(key)
            validate('if (%s.test(%s)) {', p, keys+'['+i+']')
            visit(name+'['+keys+'['+i+']]', node.patternProperties[key], reporter, filter)
            validate('}')
          })
    
          validate('}')
          if (type !== 'object') validate('}')
        }
    
        if (node.pattern) {
          var p = patterns(node.pattern)
          if (type !== 'string') validate('if (%s) {', types.string(name))
          validate('if (!(%s.test(%s))) {', p, name)
          error('pattern mismatch')
          validate('}')
          if (type !== 'string') validate('}')
        }
    
        if (node.allOf) {
          node.allOf.forEach(function(sch) {
            visit(name, sch, reporter, filter)
          })
        }
    
        if (node.anyOf && node.anyOf.length) {
          var prev = gensym('prev')
    
          node.anyOf.forEach(function(sch, i) {
            if (i === 0) {
              validate('var %s = errors', prev)
            } else {          
              validate('if (errors !== %s) {', prev)
                ('errors = %s', prev)
            }
            visit(name, sch, false, false)
          })
          node.anyOf.forEach(function(sch, i) {
            if (i) validate('}')
          })
          validate('if (%s !== errors) {', prev)
          error('no schemas match')
          validate('}')
        }
    
        if (node.oneOf && node.oneOf.length) {
          var prev = gensym('prev')
          var passes = gensym('passes')
    
          validate
            ('var %s = errors', prev)
            ('var %s = 0', passes)
    
          node.oneOf.forEach(function(sch, i) {
            visit(name, sch, false, false)
            validate('if (%s === errors) {', prev)
              ('%s++', passes)
            ('} else {')
              ('errors = %s', prev)
            ('}')
          })
    
          validate('if (%s !== 1) {', passes)
          error('no (or more than one) schemas match')
          validate('}')
        }
    
        if (node.multipleOf !== undefined) {
          if (type !== 'number' && type !== 'integer') validate('if (%s) {', types.number(name))
    
          var factor = ((node.multipleOf | 0) !== node.multipleOf) ? Math.pow(10, node.multipleOf.toString().split('.').pop().length) : 1
          if (factor > 1) validate('if ((%d*%s) % %d) {', factor, name, factor*node.multipleOf)
          else validate('if (%s % %d) {', name, node.multipleOf)
    
          error('has a remainder')
          validate('}')
    
          if (type !== 'number' && type !== 'integer') validate('}')
        }
    
        if (node.maxProperties !== undefined) {
          if (type !== 'object') validate('if (%s) {', types.object(name))
          
          validate('if (Object.keys(%s).length > %d) {', name, node.maxProperties)
          error('has more properties than allowed')
          validate('}')
    
          if (type !== 'object') validate('}')
        }
    
        if (node.minProperties !== undefined) {
          if (type !== 'object') validate('if (%s) {', types.object(name))
          
          validate('if (Object.keys(%s).length < %d) {', name, node.minProperties)
          error('has less properties than allowed')
          validate('}')
    
          if (type !== 'object') validate('}')
        }
    
        if (node.maxItems !== undefined) {
          if (type !== 'array') validate('if (%s) {', types.array(name))
          
          validate('if (%s.length > %d) {', name, node.maxItems)
          error('has more items than allowed')
          validate('}')
    
          if (type !== 'array') validate('}')
        }
    
        if (node.minItems !== undefined) {
          if (type !== 'array') validate('if (%s) {', types.array(name))
          
          validate('if (%s.length < %d) {', name, node.minItems)
          error('has less items than allowed')
          validate('}')
    
          if (type !== 'array') validate('}')
        }
    
        if (node.maxLength !== undefined) {
          if (type !== 'string') validate('if (%s) {', types.string(name))
    
          validate('if (%s.length > %d) {', name, node.maxLength)
          error('has longer length than allowed')
          validate('}')
    
          if (type !== 'string') validate('}')
        }
    
        if (node.minLength !== undefined) {
          if (type !== 'string') validate('if (%s) {', types.string(name))
    
          validate('if (%s.length < %d) {', name, node.minLength)
          error('has less length than allowed')
          validate('}')
    
          if (type !== 'string') validate('}')
        }
    
        if (node.minimum !== undefined) {
          validate('if (%s %s %d) {', name, node.exclusiveMinimum ? '<=' : '<', node.minimum)
          error('is less than minimum')
          validate('}')
        }
    
        if (node.maximum !== undefined) {
          validate('if (%s %s %d) {', name, node.exclusiveMaximum ? '>=' : '>', node.maximum)
          error('is more than maximum')
          validate('}')
        }
    
        if (properties) {
          Object.keys(properties).forEach(function(p) {
            visit(genobj(name, p), properties[p], reporter, filter)
          })
        }
    
        while (indent--) validate('}')
      }
    
      var validate = genfun
        ('function validate(data) {')
          ('validate.errors = null')
          ('var errors = 0')
    
      visit('data', schema, reporter, opts && opts.filter)
    
      validate
          ('return errors === 0')
        ('}')
    
      validate = validate.toFunction(scope)
      validate.errors = null
    
      validate.__defineGetter__('error', function() {
        if (!validate.errors) return ''
        return validate.errors
          .map(function(err) {
            return err.field+' '+err.message
          })
          .join('\n')
      })
    
      validate.toJSON = function() {
        return schema
      }
    
      return validate
    }
    
    module.exports = function(schema, opts) {
      if (typeof schema === 'string') schema = JSON.parse(schema)
      return compile(schema, {}, schema, true, opts)
    }
    
    module.exports.filter = function(schema, opts) {
      var validate = module.exports(schema, xtend(opts, {filter: true}))
      return function(sch) {
        validate(sch)
        return sch
      }
    }
    
  provide("is-my-json-valid", module.exports);
}(global));

// pakmanager:end-of-stream
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var once = require('once');
    
    var noop = function() {};
    
    var isRequest = function(stream) {
    	return stream.setHeader && typeof stream.abort === 'function';
    };
    
    var isChildProcess = function(stream) {
    	return stream.stdio && Array.isArray(stream.stdio) && stream.stdio.length === 3
    };
    
    var eos = function(stream, opts, callback) {
    	if (typeof opts === 'function') return eos(stream, null, opts);
    	if (!opts) opts = {};
    
    	callback = once(callback || noop);
    
    	var ws = stream._writableState;
    	var rs = stream._readableState;
    	var readable = opts.readable || (opts.readable !== false && stream.readable);
    	var writable = opts.writable || (opts.writable !== false && stream.writable);
    
    	var onlegacyfinish = function() {
    		if (!stream.writable) onfinish();
    	};
    
    	var onfinish = function() {
    		writable = false;
    		if (!readable) callback();
    	};
    
    	var onend = function() {
    		readable = false;
    		if (!writable) callback();
    	};
    
    	var onexit = function(exitCode) {
    		callback(exitCode ? new Error('exited with error code: ' + exitCode) : null);
    	};
    
    	var onclose = function() {
    		if (readable && !(rs && rs.ended)) return callback(new Error('premature close'));
    		if (writable && !(ws && ws.ended)) return callback(new Error('premature close'));
    	};
    
    	var onrequest = function() {
    		stream.req.on('finish', onfinish);
    	};
    
    	if (isRequest(stream)) {
    		stream.on('complete', onfinish);
    		stream.on('abort', onclose);
    		if (stream.req) onrequest();
    		else stream.on('request', onrequest);
    	} else if (writable && !ws) { // legacy streams
    		stream.on('end', onlegacyfinish);
    		stream.on('close', onlegacyfinish);
    	}
    
    	if (isChildProcess(stream)) stream.on('exit', onexit);
    
    	stream.on('end', onend);
    	stream.on('finish', onfinish);
    	if (opts.error !== false) stream.on('error', callback);
    	stream.on('close', onclose);
    
    	return function() {
    		stream.removeListener('complete', onfinish);
    		stream.removeListener('abort', onclose);
    		stream.removeListener('request', onrequest);
    		if (stream.req) stream.req.removeListener('finish', onfinish);
    		stream.removeListener('end', onlegacyfinish);
    		stream.removeListener('close', onlegacyfinish);
    		stream.removeListener('finish', onfinish);
    		stream.removeListener('exit', onexit);
    		stream.removeListener('end', onend);
    		stream.removeListener('error', callback);
    		stream.removeListener('close', onclose);
    	};
    };
    
    module.exports = eos;
  provide("end-of-stream", module.exports);
}(global));

// pakmanager:pinkie-promise
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    module.exports = global.Promise || require('pinkie');
    
  provide("pinkie-promise", module.exports);
}(global));

// pakmanager:deep-extend
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*!
     * @description Recursive object extending
     * @author Viacheslav Lotsmanov <lotsmanov89@gmail.com>
     * @license MIT
     *
     * The MIT License (MIT)
     *
     * Copyright (c) 2013-2015 Viacheslav Lotsmanov
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy of
     * this software and associated documentation files (the "Software"), to deal in
     * the Software without restriction, including without limitation the rights to
     * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
     * the Software, and to permit persons to whom the Software is furnished to do so,
     * subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in all
     * copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
     * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
     * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
     * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
     * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
     */
    
    'use strict';
    
    function isSpecificValue(val) {
    	return (
    		val instanceof Buffer
    		|| val instanceof Date
    		|| val instanceof RegExp
    	) ? true : false;
    }
    
    function cloneSpecificValue(val) {
    	if (val instanceof Buffer) {
    		var x = new Buffer(val.length);
    		val.copy(x);
    		return x;
    	} else if (val instanceof Date) {
    		return new Date(val.getTime());
    	} else if (val instanceof RegExp) {
    		return new RegExp(val);
    	} else {
    		throw new Error('Unexpected situation');
    	}
    }
    
    /**
     * Recursive cloning array.
     */
    function deepCloneArray(arr) {
    	var clone = [];
    	arr.forEach(function (item, index) {
    		if (typeof item === 'object' && item !== null) {
    			if (Array.isArray(item)) {
    				clone[index] = deepCloneArray(item);
    			} else if (isSpecificValue(item)) {
    				clone[index] = cloneSpecificValue(item);
    			} else {
    				clone[index] = deepExtend({}, item);
    			}
    		} else {
    			clone[index] = item;
    		}
    	});
    	return clone;
    }
    
    /**
     * Extening object that entered in first argument.
     *
     * Returns extended object or false if have no target object or incorrect type.
     *
     * If you wish to clone source object (without modify it), just use empty new
     * object as first argument, like this:
     *   deepExtend({}, yourObj_1, [yourObj_N]);
     */
    var deepExtend = module.exports = function (/*obj_1, [obj_2], [obj_N]*/) {
    	if (arguments.length < 1 || typeof arguments[0] !== 'object') {
    		return false;
    	}
    
    	if (arguments.length < 2) {
    		return arguments[0];
    	}
    
    	var target = arguments[0];
    
    	// convert arguments to array and cut off target object
    	var args = Array.prototype.slice.call(arguments, 1);
    
    	var val, src, clone;
    
    	args.forEach(function (obj) {
    		// skip argument if it is array or isn't object
    		if (typeof obj !== 'object' || Array.isArray(obj)) {
    			return;
    		}
    
    		Object.keys(obj).forEach(function (key) {
    			src = target[key]; // source value
    			val = obj[key]; // new value
    
    			// recursion prevention
    			if (val === target) {
    				return;
    
    			/**
    			 * if new value isn't object then just overwrite by new value
    			 * instead of extending.
    			 */
    			} else if (typeof val !== 'object' || val === null) {
    				target[key] = val;
    				return;
    
    			// just clone arrays (and recursive clone objects inside)
    			} else if (Array.isArray(val)) {
    				target[key] = deepCloneArray(val);
    				return;
    
    			// custom cloning and overwrite for specific objects
    			} else if (isSpecificValue(val)) {
    				target[key] = cloneSpecificValue(val);
    				return;
    
    			// overwrite by new value if source isn't object or array
    			} else if (typeof src !== 'object' || src === null || Array.isArray(src)) {
    				target[key] = deepExtend({}, val);
    				return;
    
    			// source value and new value is objects both, extending...
    			} else {
    				target[key] = deepExtend(src, val);
    				return;
    			}
    		});
    	});
    
    	return target;
    }
    
  provide("deep-extend", module.exports);
}(global));

// pakmanager:strip-json-comments
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*!
    	strip-json-comments
    	Strip comments from JSON. Lets you use comments in your JSON files!
    	https://github.com/sindresorhus/strip-json-comments
    	by Sindre Sorhus
    	MIT License
    */
    (function () {
    	'use strict';
    
    	function stripJsonComments(str) {
    		var currentChar;
    		var nextChar;
    		var insideString = false;
    		var insideComment = false;
    		var ret = '';
    
    		for (var i = 0; i < str.length; i++) {
    			currentChar = str[i];
    			nextChar = str[i + 1];
    
    			if (!insideComment && str[i - 1] !== '\\' && currentChar === '"') {
    				insideString = !insideString;
    			}
    
    			if (insideString) {
    				ret += currentChar;
    				continue;
    			}
    
    			if (!insideComment && currentChar + nextChar === '//') {
    				insideComment = 'single';
    				i++;
    			} else if (insideComment === 'single' && currentChar + nextChar === '\r\n') {
    				insideComment = false;
    				i++;
    				ret += currentChar;
    				ret += nextChar;
    				continue;
    			} else if (insideComment === 'single' && currentChar === '\n') {
    				insideComment = false;
    			} else if (!insideComment && currentChar + nextChar === '/*') {
    				insideComment = 'multi';
    				i++;
    				continue;
    			} else if (insideComment === 'multi' && currentChar + nextChar === '*/') {
    				insideComment = false;
    				i++;
    				continue;
    			}
    
    			if (insideComment) {
    				continue;
    			}
    
    			ret += currentChar;
    		}
    
    		return ret;
    	}
    
    	if (typeof module !== 'undefined' && module.exports) {
    		module.exports = stripJsonComments;
    	} else {
    		window.stripJsonComments = stripJsonComments;
    	}
    })();
    
  provide("strip-json-comments", module.exports);
}(global));

// pakmanager:ini
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  
    exports.parse = exports.decode = decode
    exports.stringify = exports.encode = encode
    
    exports.safe = safe
    exports.unsafe = unsafe
    
    var eol = process.platform === "win32" ? "\r\n" : "\n"
    
    function encode (obj, opt) {
      var children = []
        , out = ""
    
      if (typeof opt === "string") {
        opt = {
          section: opt,
          whitespace: false
        }
      } else {
        opt = opt || {}
        opt.whitespace = opt.whitespace === true
      }
    
      var separator = opt.whitespace ? " = " : "="
    
      Object.keys(obj).forEach(function (k, _, __) {
        var val = obj[k]
        if (val && Array.isArray(val)) {
            val.forEach(function(item) {
                out += safe(k + "[]") + separator + safe(item) + "\n"
            })
        }
        else if (val && typeof val === "object") {
          children.push(k)
        } else {
          out += safe(k) + separator + safe(val) + eol
        }
      })
    
      if (opt.section && out.length) {
        out = "[" + safe(opt.section) + "]" + eol + out
      }
    
      children.forEach(function (k, _, __) {
        var nk = dotSplit(k).join('\\.')
        var section = (opt.section ? opt.section + "." : "") + nk
        var child = encode(obj[k], {
          section: section,
          whitespace: opt.whitespace
        })
        if (out.length && child.length) {
          out += eol
        }
        out += child
      })
    
      return out
    }
    
    function dotSplit (str) {
      return str.replace(/\1/g, '\u0002LITERAL\\1LITERAL\u0002')
             .replace(/\\\./g, '\u0001')
             .split(/\./).map(function (part) {
               return part.replace(/\1/g, '\\.')
                      .replace(/\2LITERAL\\1LITERAL\2/g, '\u0001')
            })
    }
    
    function decode (str) {
      var out = {}
        , p = out
        , section = null
        , state = "START"
               // section     |key = value
        , re = /^\[([^\]]*)\]$|^([^=]+)(=(.*))?$/i
        , lines = str.split(/[\r\n]+/g)
        , section = null
    
      lines.forEach(function (line, _, __) {
        if (!line || line.match(/^\s*[;#]/)) return
        var match = line.match(re)
        if (!match) return
        if (match[1] !== undefined) {
          section = unsafe(match[1])
          p = out[section] = out[section] || {}
          return
        }
        var key = unsafe(match[2])
          , value = match[3] ? unsafe((match[4] || "")) : true
        switch (value) {
          case 'true':
          case 'false':
          case 'null': value = JSON.parse(value)
        }
    
        // Convert keys with '[]' suffix to an array
        if (key.length > 2 && key.slice(-2) === "[]") {
            key = key.substring(0, key.length - 2)
            if (!p[key]) {
              p[key] = []
            }
            else if (!Array.isArray(p[key])) {
              p[key] = [p[key]]
            }
        }
    
        // safeguard against resetting a previously defined
        // array by accidentally forgetting the brackets
        if (Array.isArray(p[key])) {
          p[key].push(value)
        }
        else {
          p[key] = value
        }
      })
    
      // {a:{y:1},"a.b":{x:2}} --> {a:{y:1,b:{x:2}}}
      // use a filter to return the keys that have to be deleted.
      Object.keys(out).filter(function (k, _, __) {
        if (!out[k] || typeof out[k] !== "object" || Array.isArray(out[k])) return false
        // see if the parent section is also an object.
        // if so, add it to that, and mark this one for deletion
        var parts = dotSplit(k)
          , p = out
          , l = parts.pop()
          , nl = l.replace(/\\\./g, '.')
        parts.forEach(function (part, _, __) {
          if (!p[part] || typeof p[part] !== "object") p[part] = {}
          p = p[part]
        })
        if (p === out && nl === l) return false
        p[nl] = out[k]
        return true
      }).forEach(function (del, _, __) {
        delete out[del]
      })
    
      return out
    }
    
    function isQuoted (val) {
      return (val.charAt(0) === "\"" && val.slice(-1) === "\"")
             || (val.charAt(0) === "'" && val.slice(-1) === "'")
    }
    
    function safe (val) {
      return ( typeof val !== "string"
             || val.match(/[=\r\n]/)
             || val.match(/^\[/)
             || (val.length > 1
                 && isQuoted(val))
             || val !== val.trim() )
             ? JSON.stringify(val)
             : val.replace(/;/g, '\\;').replace(/#/g, "\\#")
    }
    
    function unsafe (val, doUnesc) {
      val = (val || "").trim()
      if (isQuoted(val)) {
        // remove the single quotes before calling JSON.parse
        if (val.charAt(0) === "'") {
          val = val.substr(1, val.length - 2);
        }
        try { val = JSON.parse(val) } catch (_) {}
      } else {
        // walk the val to find the first not-escaped ; character
        var esc = false
        var unesc = "";
        for (var i = 0, l = val.length; i < l; i++) {
          var c = val.charAt(i)
          if (esc) {
            if ("\\;#".indexOf(c) !== -1)
              unesc += c
            else
              unesc += "\\" + c
            esc = false
          } else if (";#".indexOf(c) !== -1) {
            break
          } else if (c === "\\") {
            esc = true
          } else {
            unesc += c
          }
        }
        if (esc)
          unesc += "\\"
        return unesc
      }
      return val
    }
    
  provide("ini", module.exports);
}(global));

// pakmanager:node-forge
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Node.js module for Forge.
     *
     * @author Dave Longley
     *
     * Copyright 2011-2014 Digital Bazaar, Inc.
     */
    (function() {
    var name = 'forge';
    if(typeof define !== 'function') {
      // NodeJS -> AMD
      if(typeof module === 'object' && module.exports) {
        var nodeJS = true;
        define = function(ids, factory) {
          factory(require, module);
        };
      } else {
        // <script>
        if(typeof forge === 'undefined') {
          // set to true to disable native code if even it's available
          forge = {disableNativeCode: false};
        }
        return;
      }
    }
    // AMD
    var deps;
    var defineFunc = function(require, module) {
      module.exports = function(forge) {
        var mods = deps.map(function(dep) {
          return require(dep);
        });
        // handle circular dependencies
        forge = forge || {};
        forge.defined = forge.defined || {};
        if(forge.defined[name]) {
          return forge[name];
        }
        forge.defined[name] = true;
        for(var i = 0; i < mods.length; ++i) {
          mods[i](forge);
        }
        return forge;
      };
      // set to true to disable native code if even it's available
      module.exports.disableNativeCode = false;
      module.exports(module.exports);
    };
    var tmpDefine = define;
    define = function(ids, factory) {
      deps = (typeof ids === 'string') ? factory.slice(2) : ids.slice(2);
      if(nodeJS) {
        delete define;
        return tmpDefine.apply(null, Array.prototype.slice.call(arguments, 0));
      }
      define = tmpDefine;
      return define.apply(null, Array.prototype.slice.call(arguments, 0));
    };
    define([
      'require',
      'module',
      './aes',
      './aesCipherSuites',
      './asn1',
      './cipher',
      './cipherModes',
      './debug',
      './des',
      './hmac',
      './kem',
      './log',
      './md',
      './mgf1',
      './pbkdf2',
      './pem',
      './pkcs7',
      './pkcs1',
      './pkcs12',
      './pki',
      './prime',
      './prng',
      './pss',
      './random',
      './rc2',
      './ssh',
      './task',
      './tls',
      './util'
    ], function() {
      defineFunc.apply(null, Array.prototype.slice.call(arguments, 0));
    });
    })();
    
  provide("node-forge", module.exports);
}(global));

// pakmanager:jwa
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  const bufferEqual = require('buffer-equal-constant-time');
    const base64url = require('base64url');
    const crypto = require('crypto');
    const formatEcdsa = require('ecdsa-sig-formatter');
    const util = require('util');
    
    const MSG_INVALID_ALGORITHM = '"%s" is not a valid algorithm.\n  Supported algorithms are:\n  "HS256", "HS384", "HS512", "RS256", "RS384", "RS512" and "none".'
    const MSG_INVALID_SECRET = 'secret must be a string or buffer';
    const MSG_INVALID_KEY = 'key must be a string or buffer';
    
    function typeError(template) {
      const args = [].slice.call(arguments, 1);
      const errMsg = util.format.bind(util, template).apply(null, args);
      return new TypeError(errMsg);
    }
    
    function bufferOrString(obj) {
      return Buffer.isBuffer(obj) || typeof obj === 'string';
    }
    
    function normalizeInput(thing) {
      if (!bufferOrString(thing))
        thing = JSON.stringify(thing);
      return thing;
    }
    
    function createHmacSigner(bits) {
      return function sign(thing, secret) {
        if (!bufferOrString(secret))
          throw typeError(MSG_INVALID_SECRET);
        thing = normalizeInput(thing);
        const hmac = crypto.createHmac('SHA' + bits, secret);
        const sig = (hmac.update(thing), hmac.digest('base64'))
        return base64url.fromBase64(sig);
      }
    }
    
    function createHmacVerifier(bits) {
      return function verify(thing, signature, secret) {
        const computedSig = createHmacSigner(bits)(thing, secret);
        return bufferEqual(Buffer(signature), Buffer(computedSig));
      }
    }
    
    function createKeySigner(bits) {
      return function sign(thing, privateKey) {
        if (!bufferOrString(privateKey))
          throw typeError(MSG_INVALID_KEY);
        thing = normalizeInput(thing);
        // Even though we are specifying "RSA" here, this works with ECDSA
        // keys as well.
        const signer = crypto.createSign('RSA-SHA' + bits);
        const sig = (signer.update(thing), signer.sign(privateKey, 'base64'));
        return base64url.fromBase64(sig);
      }
    }
    
    function createKeyVerifier(bits) {
      return function verify(thing, signature, publicKey) {
        if (!bufferOrString(publicKey))
          throw typeError(MSG_INVALID_KEY);
        thing = normalizeInput(thing);
        signature = base64url.toBase64(signature);
        const verifier = crypto.createVerify('RSA-SHA' + bits);
        verifier.update(thing);
        return verifier.verify(publicKey, signature, 'base64');
      }
    }
    
    function createECDSASigner(bits) {
      const inner = createKeySigner(bits);
      return function sign() {
        var signature = inner.apply(null, arguments);
        signature = formatEcdsa.derToJose(signature, 'ES' + bits);
        return signature;
      };
    }
    
    function createECDSAVerifer(bits) {
      const inner = createKeyVerifier(bits);
      return function verify(thing, signature, publicKey) {
        signature = formatEcdsa.joseToDer(signature, 'ES' + bits).toString('base64');
        const result = inner(thing, signature, publicKey);
        return result;
      };
    }
    
    function createNoneSigner() {
      return function sign() {
        return '';
      }
    }
    
    function createNoneVerifier() {
      return function verify(thing, signature) {
        return signature === '';
      }
    }
    
    module.exports = function jwa(algorithm) {
      const signerFactories = {
        hs: createHmacSigner,
        rs: createKeySigner,
        es: createECDSASigner,
        none: createNoneSigner,
      }
      const verifierFactories = {
        hs: createHmacVerifier,
        rs: createKeyVerifier,
        es: createECDSAVerifer,
        none: createNoneVerifier,
      }
      const match = algorithm.match(/(RS|ES|HS|none)(256|384|512)?/i);
      if (!match)
        throw typeError(MSG_INVALID_ALGORITHM, algorithm);
      const algo = match[1].toLowerCase();
      const bits = match[2];
    
      return {
        sign: signerFactories[algo](bits),
        verify: verifierFactories[algo](bits),
      }
    };
    
  provide("jwa", module.exports);
}(global));

// pakmanager:bl
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var DuplexStream = require('readable-stream/duplex')
      , util         = require('util')
    
    function BufferList (callback) {
      if (!(this instanceof BufferList))
        return new BufferList(callback)
    
      this._bufs  = []
      this.length = 0
    
      if (typeof callback == 'function') {
        this._callback = callback
    
        var piper = function (err) {
          if (this._callback) {
            this._callback(err)
            this._callback = null
          }
        }.bind(this)
    
        this.on('pipe', function (src) {
          src.on('error', piper)
        })
        this.on('unpipe', function (src) {
          src.removeListener('error', piper)
        })
      }
      else if (Buffer.isBuffer(callback))
        this.append(callback)
      else if (Array.isArray(callback)) {
        callback.forEach(function (b) {
          Buffer.isBuffer(b) && this.append(b)
        }.bind(this))
      }
    
      DuplexStream.call(this)
    }
    
    util.inherits(BufferList, DuplexStream)
    
    BufferList.prototype._offset = function (offset) {
      var tot = 0, i = 0, _t
      for (; i < this._bufs.length; i++) {
        _t = tot + this._bufs[i].length
        if (offset < _t)
          return [ i, offset - tot ]
        tot = _t
      }
    }
    
    BufferList.prototype.append = function (buf) {
      var isBuffer = Buffer.isBuffer(buf) ||
                     buf instanceof BufferList
    
      this._bufs.push(isBuffer ? buf : new Buffer(buf))
      this.length += buf.length
      return this
    }
    
    BufferList.prototype._write = function (buf, encoding, callback) {
      this.append(buf)
      if (callback)
        callback()
    }
    
    BufferList.prototype._read = function (size) {
      if (!this.length)
        return this.push(null)
      size = Math.min(size, this.length)
      this.push(this.slice(0, size))
      this.consume(size)
    }
    
    BufferList.prototype.end = function (chunk) {
      DuplexStream.prototype.end.call(this, chunk)
    
      if (this._callback) {
        this._callback(null, this.slice())
        this._callback = null
      }
    }
    
    BufferList.prototype.get = function (index) {
      return this.slice(index, index + 1)[0]
    }
    
    BufferList.prototype.slice = function (start, end) {
      return this.copy(null, 0, start, end)
    }
    
    BufferList.prototype.copy = function (dst, dstStart, srcStart, srcEnd) {
      if (typeof srcStart != 'number' || srcStart < 0)
        srcStart = 0
      if (typeof srcEnd != 'number' || srcEnd > this.length)
        srcEnd = this.length
      if (srcStart >= this.length)
        return dst || new Buffer(0)
      if (srcEnd <= 0)
        return dst || new Buffer(0)
    
      var copy   = !!dst
        , off    = this._offset(srcStart)
        , len    = srcEnd - srcStart
        , bytes  = len
        , bufoff = (copy && dstStart) || 0
        , start  = off[1]
        , l
        , i
    
      // copy/slice everything
      if (srcStart === 0 && srcEnd == this.length) {
        if (!copy) // slice, just return a full concat
          return Buffer.concat(this._bufs)
    
        // copy, need to copy individual buffers
        for (i = 0; i < this._bufs.length; i++) {
          this._bufs[i].copy(dst, bufoff)
          bufoff += this._bufs[i].length
        }
    
        return dst
      }
    
      // easy, cheap case where it's a subset of one of the buffers
      if (bytes <= this._bufs[off[0]].length - start) {
        return copy
          ? this._bufs[off[0]].copy(dst, dstStart, start, start + bytes)
          : this._bufs[off[0]].slice(start, start + bytes)
      }
    
      if (!copy) // a slice, we need something to copy in to
        dst = new Buffer(len)
    
      for (i = off[0]; i < this._bufs.length; i++) {
        l = this._bufs[i].length - start
    
        if (bytes > l) {
          this._bufs[i].copy(dst, bufoff, start)
        } else {
          this._bufs[i].copy(dst, bufoff, start, start + bytes)
          break
        }
    
        bufoff += l
        bytes -= l
    
        if (start)
          start = 0
      }
    
      return dst
    }
    
    BufferList.prototype.toString = function (encoding, start, end) {
      return this.slice(start, end).toString(encoding)
    }
    
    BufferList.prototype.consume = function (bytes) {
      while (this._bufs.length) {
        if (bytes > this._bufs[0].length) {
          bytes -= this._bufs[0].length
          this.length -= this._bufs[0].length
          this._bufs.shift()
        } else {
          this._bufs[0] = this._bufs[0].slice(bytes)
          this.length -= bytes
          break
        }
      }
      return this
    }
    
    BufferList.prototype.duplicate = function () {
      var i = 0
        , copy = new BufferList()
    
      for (; i < this._bufs.length; i++)
        copy.append(this._bufs[i])
    
      return copy
    }
    
    BufferList.prototype.destroy = function () {
      this._bufs.length = 0;
      this.length = 0;
      this.push(null);
    }
    
    ;(function () {
      var methods = {
          'readDoubleBE' : 8
        , 'readDoubleLE' : 8
        , 'readFloatBE'  : 4
        , 'readFloatLE'  : 4
        , 'readInt32BE'  : 4
        , 'readInt32LE'  : 4
        , 'readUInt32BE' : 4
        , 'readUInt32LE' : 4
        , 'readInt16BE'  : 2
        , 'readInt16LE'  : 2
        , 'readUInt16BE' : 2
        , 'readUInt16LE' : 2
        , 'readInt8'     : 1
        , 'readUInt8'    : 1
      }
    
      for (var m in methods) {
        (function (m) {
          BufferList.prototype[m] = function (offset) {
            return this.slice(offset, offset + methods[m])[m](0)
          }
        }(m))
      }
    }())
    
    module.exports = BufferList
    
  provide("bl", module.exports);
}(global));

// pakmanager:caseless
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  function Caseless (dict) {
      this.dict = dict || {}
    }
    Caseless.prototype.set = function (name, value, clobber) {
      if (typeof name === 'object') {
        for (var i in name) {
          this.set(i, name[i], value)
        }
      } else {
        if (typeof clobber === 'undefined') clobber = true
        var has = this.has(name)
    
        if (!clobber && has) this.dict[has] = this.dict[has] + ',' + value
        else this.dict[has || name] = value
        return has
      }
    }
    Caseless.prototype.has = function (name) {
      var keys = Object.keys(this.dict)
        , name = name.toLowerCase()
        ;
      for (var i=0;i<keys.length;i++) {
        if (keys[i].toLowerCase() === name) return keys[i]
      }
      return false
    }
    Caseless.prototype.get = function (name) {
      name = name.toLowerCase()
      var result, _key
      var headers = this.dict
      Object.keys(headers).forEach(function (key) {
        _key = key.toLowerCase()
        if (name === _key) result = headers[key]
      })
      return result
    }
    Caseless.prototype.swap = function (name) {
      var has = this.has(name)
      if (!has) throw new Error('There is no header than matches "'+name+'"')
      this.dict[name] = this.dict[has]
      delete this.dict[has]
    }
    Caseless.prototype.del = function (name) {
      var has = this.has(name)
      return delete this.dict[has || name]
    }
    
    module.exports = function (dict) {return new Caseless(dict)}
    module.exports.httpify = function (resp, headers) {
      var c = new Caseless(headers)
      resp.setHeader = function (key, value, clobber) {
        if (typeof value === 'undefined') return
        return c.set(key, value, clobber)
      }
      resp.hasHeader = function (key) {
        return c.has(key)
      }
      resp.getHeader = function (key) {
        return c.get(key)
      }
      resp.removeHeader = function (key) {
        return c.del(key)
      }
      resp.headers = c.dict
      return c
    }
    
  provide("caseless", module.exports);
}(global));

// pakmanager:extend
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    var hasOwn = Object.prototype.hasOwnProperty;
    var toStr = Object.prototype.toString;
    
    var isArray = function isArray(arr) {
    	if (typeof Array.isArray === 'function') {
    		return Array.isArray(arr);
    	}
    
    	return toStr.call(arr) === '[object Array]';
    };
    
    var isPlainObject = function isPlainObject(obj) {
    	if (!obj || toStr.call(obj) !== '[object Object]') {
    		return false;
    	}
    
    	var hasOwnConstructor = hasOwn.call(obj, 'constructor');
    	var hasIsPrototypeOf = obj.constructor && obj.constructor.prototype && hasOwn.call(obj.constructor.prototype, 'isPrototypeOf');
    	// Not own constructor property must be Object
    	if (obj.constructor && !hasOwnConstructor && !hasIsPrototypeOf) {
    		return false;
    	}
    
    	// Own properties are enumerated firstly, so to speed up,
    	// if last one is own, then all properties are own.
    	var key;
    	for (key in obj) {/**/}
    
    	return typeof key === 'undefined' || hasOwn.call(obj, key);
    };
    
    module.exports = function extend() {
    	var options, name, src, copy, copyIsArray, clone,
    		target = arguments[0],
    		i = 1,
    		length = arguments.length,
    		deep = false;
    
    	// Handle a deep copy situation
    	if (typeof target === 'boolean') {
    		deep = target;
    		target = arguments[1] || {};
    		// skip the boolean and the target
    		i = 2;
    	} else if ((typeof target !== 'object' && typeof target !== 'function') || target == null) {
    		target = {};
    	}
    
    	for (; i < length; ++i) {
    		options = arguments[i];
    		// Only deal with non-null/undefined values
    		if (options != null) {
    			// Extend the base object
    			for (name in options) {
    				src = target[name];
    				copy = options[name];
    
    				// Prevent never-ending loop
    				if (target !== copy) {
    					// Recurse if we're merging plain objects or arrays
    					if (deep && copy && (isPlainObject(copy) || (copyIsArray = isArray(copy)))) {
    						if (copyIsArray) {
    							copyIsArray = false;
    							clone = src && isArray(src) ? src : [];
    						} else {
    							clone = src && isPlainObject(src) ? src : {};
    						}
    
    						// Never move original objects, clone them
    						target[name] = extend(deep, clone, copy);
    
    					// Don't bring in undefined values
    					} else if (typeof copy !== 'undefined') {
    						target[name] = copy;
    					}
    				}
    			}
    		}
    	}
    
    	// Return the modified object
    	return target;
    };
    
    
  provide("extend", module.exports);
}(global));

// pakmanager:forever-agent
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  module.exports = ForeverAgent
    ForeverAgent.SSL = ForeverAgentSSL
    
    var util = require('util')
      , Agent = require('http').Agent
      , net = require('net')
      , tls = require('tls')
      , AgentSSL = require('https').Agent
      
    function getConnectionName(host, port) {  
      var name = ''
      if (typeof host === 'string') {
        name = host + ':' + port
      } else {
        // For node.js v012.0 and iojs-v1.5.1, host is an object. And any existing localAddress is part of the connection name.
        name = host.host + ':' + host.port + ':' + (host.localAddress ? (host.localAddress + ':') : ':')
      }
      return name
    }    
    
    function ForeverAgent(options) {
      var self = this
      self.options = options || {}
      self.requests = {}
      self.sockets = {}
      self.freeSockets = {}
      self.maxSockets = self.options.maxSockets || Agent.defaultMaxSockets
      self.minSockets = self.options.minSockets || ForeverAgent.defaultMinSockets
      self.on('free', function(socket, host, port) {
        var name = getConnectionName(host, port)
    
        if (self.requests[name] && self.requests[name].length) {
          self.requests[name].shift().onSocket(socket)
        } else if (self.sockets[name].length < self.minSockets) {
          if (!self.freeSockets[name]) self.freeSockets[name] = []
          self.freeSockets[name].push(socket)
          
          // if an error happens while we don't use the socket anyway, meh, throw the socket away
          var onIdleError = function() {
            socket.destroy()
          }
          socket._onIdleError = onIdleError
          socket.on('error', onIdleError)
        } else {
          // If there are no pending requests just destroy the
          // socket and it will get removed from the pool. This
          // gets us out of timeout issues and allows us to
          // default to Connection:keep-alive.
          socket.destroy()
        }
      })
    
    }
    util.inherits(ForeverAgent, Agent)
    
    ForeverAgent.defaultMinSockets = 5
    
    
    ForeverAgent.prototype.createConnection = net.createConnection
    ForeverAgent.prototype.addRequestNoreuse = Agent.prototype.addRequest
    ForeverAgent.prototype.addRequest = function(req, host, port) {
      var name = getConnectionName(host, port)
      
      if (typeof host !== 'string') {
        var options = host
        port = options.port
        host = options.host
      }
    
      if (this.freeSockets[name] && this.freeSockets[name].length > 0 && !req.useChunkedEncodingByDefault) {
        var idleSocket = this.freeSockets[name].pop()
        idleSocket.removeListener('error', idleSocket._onIdleError)
        delete idleSocket._onIdleError
        req._reusedSocket = true
        req.onSocket(idleSocket)
      } else {
        this.addRequestNoreuse(req, host, port)
      }
    }
    
    ForeverAgent.prototype.removeSocket = function(s, name, host, port) {
      if (this.sockets[name]) {
        var index = this.sockets[name].indexOf(s)
        if (index !== -1) {
          this.sockets[name].splice(index, 1)
        }
      } else if (this.sockets[name] && this.sockets[name].length === 0) {
        // don't leak
        delete this.sockets[name]
        delete this.requests[name]
      }
      
      if (this.freeSockets[name]) {
        var index = this.freeSockets[name].indexOf(s)
        if (index !== -1) {
          this.freeSockets[name].splice(index, 1)
          if (this.freeSockets[name].length === 0) {
            delete this.freeSockets[name]
          }
        }
      }
    
      if (this.requests[name] && this.requests[name].length) {
        // If we have pending requests and a socket gets closed a new one
        // needs to be created to take over in the pool for the one that closed.
        this.createSocket(name, host, port).emit('free')
      }
    }
    
    function ForeverAgentSSL (options) {
      ForeverAgent.call(this, options)
    }
    util.inherits(ForeverAgentSSL, ForeverAgent)
    
    ForeverAgentSSL.prototype.createConnection = createConnectionSSL
    ForeverAgentSSL.prototype.addRequestNoreuse = AgentSSL.prototype.addRequest
    
    function createConnectionSSL (port, host, options) {
      if (typeof port === 'object') {
        options = port;
      } else if (typeof host === 'object') {
        options = host;
      } else if (typeof options === 'object') {
        options = options;
      } else {
        options = {};
      }
    
      if (typeof port === 'number') {
        options.port = port;
      }
    
      if (typeof host === 'string') {
        options.host = host;
      }
    
      return tls.connect(options);
    }
    
  provide("forever-agent", module.exports);
}(global));

// pakmanager:form-data
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var CombinedStream = require('combined-stream');
    var util = require('util');
    var path = require('path');
    var http = require('http');
    var https = require('https');
    var parseUrl = require('url').parse;
    var fs = require('fs');
    var mime = require('mime-types');
    var async = require('async');
    
    module.exports = FormData;
    function FormData() {
      this._overheadLength = 0;
      this._valueLength = 0;
      this._lengthRetrievers = [];
    
      CombinedStream.call(this);
    }
    util.inherits(FormData, CombinedStream);
    
    FormData.LINE_BREAK = '\r\n';
    
    FormData.prototype.append = function(field, value, options) {
      options = options || {};
    
      var append = CombinedStream.prototype.append.bind(this);
    
      // all that streamy business can't handle numbers
      if (typeof value == 'number') value = ''+value;
    
      // https://github.com/felixge/node-form-data/issues/38
      if (util.isArray(value)) {
        // Please convert your array into string
        // the way web server expects it
        this._error(new Error('Arrays are not supported.'));
        return;
      }
    
      var header = this._multiPartHeader(field, value, options);
      var footer = this._multiPartFooter(field, value, options);
    
      append(header);
      append(value);
      append(footer);
    
      // pass along options.knownLength
      this._trackLength(header, value, options);
    };
    
    FormData.prototype._trackLength = function(header, value, options) {
      var valueLength = 0;
    
      // used w/ getLengthSync(), when length is known.
      // e.g. for streaming directly from a remote server,
      // w/ a known file a size, and not wanting to wait for
      // incoming file to finish to get its size.
      if (options.knownLength != null) {
        valueLength += +options.knownLength;
      } else if (Buffer.isBuffer(value)) {
        valueLength = value.length;
      } else if (typeof value === 'string') {
        valueLength = Buffer.byteLength(value);
      }
    
      this._valueLength += valueLength;
    
      // @check why add CRLF? does this account for custom/multiple CRLFs?
      this._overheadLength +=
        Buffer.byteLength(header) +
        FormData.LINE_BREAK.length;
    
      // empty or either doesn't have path or not an http response
      if (!value || ( !value.path && !(value.readable && value.hasOwnProperty('httpVersion')) )) {
        return;
      }
    
      // no need to bother with the length
      if (!options.knownLength)
      this._lengthRetrievers.push(function(next) {
    
        if (value.hasOwnProperty('fd')) {
    
          // take read range into a account
          // `end` = Infinity –> read file till the end
          //
          // TODO: Looks like there is bug in Node fs.createReadStream
          // it doesn't respect `end` options without `start` options
          // Fix it when node fixes it.
          // https://github.com/joyent/node/issues/7819
          if (value.end != undefined && value.end != Infinity && value.start != undefined) {
    
            // when end specified
            // no need to calculate range
            // inclusive, starts with 0
            next(null, value.end+1 - (value.start ? value.start : 0));
    
          // not that fast snoopy
          } else {
            // still need to fetch file size from fs
            fs.stat(value.path, function(err, stat) {
    
              var fileSize;
    
              if (err) {
                next(err);
                return;
              }
    
              // update final size based on the range options
              fileSize = stat.size - (value.start ? value.start : 0);
              next(null, fileSize);
            });
          }
    
        // or http response
        } else if (value.hasOwnProperty('httpVersion')) {
          next(null, +value.headers['content-length']);
    
        // or request stream http://github.com/mikeal/request
        } else if (value.hasOwnProperty('httpModule')) {
          // wait till response come back
          value.on('response', function(response) {
            value.pause();
            next(null, +response.headers['content-length']);
          });
          value.resume();
    
        // something else
        } else {
          next('Unknown stream');
        }
      });
    };
    
    FormData.prototype._multiPartHeader = function(field, value, options) {
      var boundary = this.getBoundary();
      var header = '';
    
      // custom header specified (as string)?
      // it becomes responsible for boundary
      // (e.g. to handle extra CRLFs on .NET servers)
      if (options.header != null) {
        header = options.header;
      } else {
        header += '--' + boundary + FormData.LINE_BREAK +
          'Content-Disposition: form-data; name="' + field + '"';
    
        // fs- and request- streams have path property
        // or use custom filename and/or contentType
        // TODO: Use request's response mime-type
        if (options.filename || value.path) {
          header +=
            '; filename="' + path.basename(options.filename || value.path) + '"' + FormData.LINE_BREAK +
            'Content-Type: ' +  (options.contentType || mime.lookup(options.filename || value.path));
    
        // http response has not
        } else if (value.readable && value.hasOwnProperty('httpVersion')) {
          header +=
            '; filename="' + path.basename(value.client._httpMessage.path) + '"' + FormData.LINE_BREAK +
            'Content-Type: ' + value.headers['content-type'];
        }
    
        header += FormData.LINE_BREAK + FormData.LINE_BREAK;
      }
    
      return header;
    };
    
    FormData.prototype._multiPartFooter = function(field, value, options) {
      return function(next) {
        var footer = FormData.LINE_BREAK;
    
        var lastPart = (this._streams.length === 0);
        if (lastPart) {
          footer += this._lastBoundary();
        }
    
        next(footer);
      }.bind(this);
    };
    
    FormData.prototype._lastBoundary = function() {
      return '--' + this.getBoundary() + '--';
    };
    
    FormData.prototype.getHeaders = function(userHeaders) {
      var formHeaders = {
        'content-type': 'multipart/form-data; boundary=' + this.getBoundary()
      };
    
      for (var header in userHeaders) {
        formHeaders[header.toLowerCase()] = userHeaders[header];
      }
    
      return formHeaders;
    }
    
    FormData.prototype.getCustomHeaders = function(contentType) {
        contentType = contentType ? contentType : 'multipart/form-data';
    
        var formHeaders = {
            'content-type': contentType + '; boundary=' + this.getBoundary(),
            'content-length': this.getLengthSync()
        };
    
        return formHeaders;
    }
    
    FormData.prototype.getBoundary = function() {
      if (!this._boundary) {
        this._generateBoundary();
      }
    
      return this._boundary;
    };
    
    FormData.prototype._generateBoundary = function() {
      // This generates a 50 character boundary similar to those used by Firefox.
      // They are optimized for boyer-moore parsing.
      var boundary = '--------------------------';
      for (var i = 0; i < 24; i++) {
        boundary += Math.floor(Math.random() * 10).toString(16);
      }
    
      this._boundary = boundary;
    };
    
    // Note: getLengthSync DOESN'T calculate streams length
    // As workaround one can calculate file size manually
    // and add it as knownLength option
    FormData.prototype.getLengthSync = function(debug) {
      var knownLength = this._overheadLength + this._valueLength;
    
      // Don't get confused, there are 3 "internal" streams for each keyval pair
      // so it basically checks if there is any value added to the form
      if (this._streams.length) {
        knownLength += this._lastBoundary().length;
      }
    
      // https://github.com/felixge/node-form-data/issues/40
      if (this._lengthRetrievers.length) {
        // Some async length retrivers are present
        // therefore synchronous length calculation is false.
        // Please use getLength(callback) to get proper length
        this._error(new Error('Cannot calculate proper length in synchronous way.'));
      }
    
      return knownLength;
    };
    
    FormData.prototype.getLength = function(cb) {
      var knownLength = this._overheadLength + this._valueLength;
    
      if (this._streams.length) {
        knownLength += this._lastBoundary().length;
      }
    
      if (!this._lengthRetrievers.length) {
        process.nextTick(cb.bind(this, null, knownLength));
        return;
      }
    
      async.parallel(this._lengthRetrievers, function(err, values) {
        if (err) {
          cb(err);
          return;
        }
    
        values.forEach(function(length) {
          knownLength += length;
        });
    
        cb(null, knownLength);
      });
    };
    
    FormData.prototype.submit = function(params, cb) {
    
      var request
        , options
        , defaults = {
            method : 'post'
        };
    
      // parse provided url if it's string
      // or treat it as options object
      if (typeof params == 'string') {
        params = parseUrl(params);
    
        options = populate({
          port: params.port,
          path: params.pathname,
          host: params.hostname
        }, defaults);
      }
      else // use custom params
      {
        options = populate(params, defaults);
        // if no port provided use default one
        if (!options.port) {
          options.port = options.protocol == 'https:' ? 443 : 80;
        }
      }
    
      // put that good code in getHeaders to some use
      options.headers = this.getHeaders(params.headers);
    
      // https if specified, fallback to http in any other case
      if (options.protocol == 'https:') {
        request = https.request(options);
      } else {
        request = http.request(options);
      }
    
      // get content length and fire away
      this.getLength(function(err, length) {
    
        // TODO: Add chunked encoding when no length (if err)
    
        // add content length
        request.setHeader('Content-Length', length);
    
        this.pipe(request);
        if (cb) {
          request.on('error', cb);
          request.on('response', cb.bind(this, null));
        }
      }.bind(this));
    
      return request;
    };
    
    FormData.prototype._error = function(err) {
      if (this.error) return;
    
      this.error = err;
      this.pause();
      this.emit('error', err);
    };
    
    /*
     * Santa's little helpers
     */
    
    // populates missing values
    function populate(dst, src) {
      for (var prop in src) {
        if (!dst[prop]) dst[prop] = src[prop];
      }
      return dst;
    }
    
  provide("form-data", module.exports);
}(global));

// pakmanager:json-stringify-safe
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  exports = module.exports = stringify
    exports.getSerialize = serializer
    
    function stringify(obj, replacer, spaces, cycleReplacer) {
      return JSON.stringify(obj, serializer(replacer, cycleReplacer), spaces)
    }
    
    function serializer(replacer, cycleReplacer) {
      var stack = [], keys = []
    
      if (cycleReplacer == null) cycleReplacer = function(key, value) {
        if (stack[0] === value) return "[Circular ~]"
        return "[Circular ~." + keys.slice(0, stack.indexOf(value)).join(".") + "]"
      }
    
      return function(key, value) {
        if (stack.length > 0) {
          var thisPos = stack.indexOf(this)
          ~thisPos ? stack.splice(thisPos + 1) : stack.push(this)
          ~thisPos ? keys.splice(thisPos, Infinity, key) : keys.push(key)
          if (~stack.indexOf(value)) value = cycleReplacer.call(this, key, value)
        }
        else stack.push(value)
    
        return replacer == null ? value : replacer.call(this, key, value)
      }
    }
    
  provide("json-stringify-safe", module.exports);
}(global));

// pakmanager:node-uuid
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  //     uuid.js
    //
    //     Copyright (c) 2010-2012 Robert Kieffer
    //     MIT License - http://opensource.org/licenses/mit-license.php
    
    (function() {
      var _global = this;
    
      // Unique ID creation requires a high quality random # generator.  We feature
      // detect to determine the best RNG source, normalizing to a function that
      // returns 128-bits of randomness, since that's what's usually required
      var _rng;
    
      // Node.js crypto-based RNG - http://nodejs.org/docs/v0.6.2/api/crypto.html
      //
      // Moderately fast, high quality
      if (typeof(_global.require) == 'function') {
        try {
          var _rb = _global.require('crypto').randomBytes;
          _rng = _rb && function() {return _rb(16);};
        } catch(e) {}
      }
    
      if (!_rng && _global.crypto && crypto.getRandomValues) {
        // WHATWG crypto-based RNG - http://wiki.whatwg.org/wiki/Crypto
        //
        // Moderately fast, high quality
        var _rnds8 = new Uint8Array(16);
        _rng = function whatwgRNG() {
          crypto.getRandomValues(_rnds8);
          return _rnds8;
        };
      }
    
      if (!_rng) {
        // Math.random()-based (RNG)
        //
        // If all else fails, use Math.random().  It's fast, but is of unspecified
        // quality.
        var  _rnds = new Array(16);
        _rng = function() {
          for (var i = 0, r; i < 16; i++) {
            if ((i & 0x03) === 0) r = Math.random() * 0x100000000;
            _rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;
          }
    
          return _rnds;
        };
      }
    
      // Buffer class to use
      var BufferClass = typeof(_global.Buffer) == 'function' ? _global.Buffer : Array;
    
      // Maps for number <-> hex string conversion
      var _byteToHex = [];
      var _hexToByte = {};
      for (var i = 0; i < 256; i++) {
        _byteToHex[i] = (i + 0x100).toString(16).substr(1);
        _hexToByte[_byteToHex[i]] = i;
      }
    
      // **`parse()` - Parse a UUID into it's component bytes**
      function parse(s, buf, offset) {
        var i = (buf && offset) || 0, ii = 0;
    
        buf = buf || [];
        s.toLowerCase().replace(/[0-9a-f]{2}/g, function(oct) {
          if (ii < 16) { // Don't overflow!
            buf[i + ii++] = _hexToByte[oct];
          }
        });
    
        // Zero out remaining bytes if string was short
        while (ii < 16) {
          buf[i + ii++] = 0;
        }
    
        return buf;
      }
    
      // **`unparse()` - Convert UUID byte array (ala parse()) into a string**
      function unparse(buf, offset) {
        var i = offset || 0, bth = _byteToHex;
        return  bth[buf[i++]] + bth[buf[i++]] +
                bth[buf[i++]] + bth[buf[i++]] + '-' +
                bth[buf[i++]] + bth[buf[i++]] + '-' +
                bth[buf[i++]] + bth[buf[i++]] + '-' +
                bth[buf[i++]] + bth[buf[i++]] + '-' +
                bth[buf[i++]] + bth[buf[i++]] +
                bth[buf[i++]] + bth[buf[i++]] +
                bth[buf[i++]] + bth[buf[i++]];
      }
    
      // **`v1()` - Generate time-based UUID**
      //
      // Inspired by https://github.com/LiosK/UUID.js
      // and http://docs.python.org/library/uuid.html
    
      // random #'s we need to init node and clockseq
      var _seedBytes = _rng();
    
      // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)
      var _nodeId = [
        _seedBytes[0] | 0x01,
        _seedBytes[1], _seedBytes[2], _seedBytes[3], _seedBytes[4], _seedBytes[5]
      ];
    
      // Per 4.2.2, randomize (14 bit) clockseq
      var _clockseq = (_seedBytes[6] << 8 | _seedBytes[7]) & 0x3fff;
    
      // Previous uuid creation time
      var _lastMSecs = 0, _lastNSecs = 0;
    
      // See https://github.com/broofa/node-uuid for API details
      function v1(options, buf, offset) {
        var i = buf && offset || 0;
        var b = buf || [];
    
        options = options || {};
    
        var clockseq = options.clockseq != null ? options.clockseq : _clockseq;
    
        // UUID timestamps are 100 nano-second units since the Gregorian epoch,
        // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so
        // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'
        // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.
        var msecs = options.msecs != null ? options.msecs : new Date().getTime();
    
        // Per 4.2.1.2, use count of uuid's generated during the current clock
        // cycle to simulate higher resolution clock
        var nsecs = options.nsecs != null ? options.nsecs : _lastNSecs + 1;
    
        // Time since last uuid creation (in msecs)
        var dt = (msecs - _lastMSecs) + (nsecs - _lastNSecs)/10000;
    
        // Per 4.2.1.2, Bump clockseq on clock regression
        if (dt < 0 && options.clockseq == null) {
          clockseq = clockseq + 1 & 0x3fff;
        }
    
        // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new
        // time interval
        if ((dt < 0 || msecs > _lastMSecs) && options.nsecs == null) {
          nsecs = 0;
        }
    
        // Per 4.2.1.2 Throw error if too many uuids are requested
        if (nsecs >= 10000) {
          throw new Error('uuid.v1(): Can\'t create more than 10M uuids/sec');
        }
    
        _lastMSecs = msecs;
        _lastNSecs = nsecs;
        _clockseq = clockseq;
    
        // Per 4.1.4 - Convert from unix epoch to Gregorian epoch
        msecs += 12219292800000;
    
        // `time_low`
        var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;
        b[i++] = tl >>> 24 & 0xff;
        b[i++] = tl >>> 16 & 0xff;
        b[i++] = tl >>> 8 & 0xff;
        b[i++] = tl & 0xff;
    
        // `time_mid`
        var tmh = (msecs / 0x100000000 * 10000) & 0xfffffff;
        b[i++] = tmh >>> 8 & 0xff;
        b[i++] = tmh & 0xff;
    
        // `time_high_and_version`
        b[i++] = tmh >>> 24 & 0xf | 0x10; // include version
        b[i++] = tmh >>> 16 & 0xff;
    
        // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)
        b[i++] = clockseq >>> 8 | 0x80;
    
        // `clock_seq_low`
        b[i++] = clockseq & 0xff;
    
        // `node`
        var node = options.node || _nodeId;
        for (var n = 0; n < 6; n++) {
          b[i + n] = node[n];
        }
    
        return buf ? buf : unparse(b);
      }
    
      // **`v4()` - Generate random UUID**
    
      // See https://github.com/broofa/node-uuid for API details
      function v4(options, buf, offset) {
        // Deprecated - 'format' argument, as supported in v1.2
        var i = buf && offset || 0;
    
        if (typeof(options) == 'string') {
          buf = options == 'binary' ? new BufferClass(16) : null;
          options = null;
        }
        options = options || {};
    
        var rnds = options.random || (options.rng || _rng)();
    
        // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`
        rnds[6] = (rnds[6] & 0x0f) | 0x40;
        rnds[8] = (rnds[8] & 0x3f) | 0x80;
    
        // Copy bytes to buffer, if provided
        if (buf) {
          for (var ii = 0; ii < 16; ii++) {
            buf[i + ii] = rnds[ii];
          }
        }
    
        return buf || unparse(rnds);
      }
    
      // Export public API
      var uuid = v4;
      uuid.v1 = v1;
      uuid.v4 = v4;
      uuid.parse = parse;
      uuid.unparse = unparse;
      uuid.BufferClass = BufferClass;
    
      if (typeof(module) != 'undefined' && module.exports) {
        // Publish as node.js module
        module.exports = uuid;
      } else  if (typeof define === 'function' && define.amd) {
        // Publish as AMD module
        define(function() {return uuid;});
     
    
      } else {
        // Publish as global (in browsers)
        var _previousRoot = _global.uuid;
    
        // **`noConflict()` - (browser only) to reset global 'uuid' var**
        uuid.noConflict = function() {
          _global.uuid = _previousRoot;
          return uuid;
        };
    
        _global.uuid = uuid;
      }
    }).call(this);
    
  provide("node-uuid", module.exports);
}(global));

// pakmanager:qs/lib/utils
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Load modules
    
    
    // Declare internals
    
    var internals = {};
    internals.hexTable = new Array(256);
    for (var h = 0; h < 256; ++h) {
        internals.hexTable[h] = '%' + ((h < 16 ? '0' : '') + h.toString(16)).toUpperCase();
    }
    
    
    exports.arrayToObject = function (source, options) {
    
        var obj = options.plainObjects ? Object.create(null) : {};
        for (var i = 0, il = source.length; i < il; ++i) {
            if (typeof source[i] !== 'undefined') {
    
                obj[i] = source[i];
            }
        }
    
        return obj;
    };
    
    
    exports.merge = function (target, source, options) {
    
        if (!source) {
            return target;
        }
    
        if (typeof source !== 'object') {
            if (Array.isArray(target)) {
                target.push(source);
            }
            else if (typeof target === 'object') {
                target[source] = true;
            }
            else {
                target = [target, source];
            }
    
            return target;
        }
    
        if (typeof target !== 'object') {
            target = [target].concat(source);
            return target;
        }
    
        if (Array.isArray(target) &&
            !Array.isArray(source)) {
    
            target = exports.arrayToObject(target, options);
        }
    
        var keys = Object.keys(source);
        for (var k = 0, kl = keys.length; k < kl; ++k) {
            var key = keys[k];
            var value = source[key];
    
            if (!Object.prototype.hasOwnProperty.call(target, key)) {
                target[key] = value;
            }
            else {
                target[key] = exports.merge(target[key], value, options);
            }
        }
    
        return target;
    };
    
    
    exports.decode = function (str) {
    
        try {
            return decodeURIComponent(str.replace(/\+/g, ' '));
        } catch (e) {
            return str;
        }
    };
    
    exports.encode = function (str) {
    
        // This code was originally written by Brian White (mscdex) for the io.js core querystring library.
        // It has been adapted here for stricter adherence to RFC 3986
        if (str.length === 0) {
            return str;
        }
    
        if (typeof str !== 'string') {
            str = '' + str;
        }
    
        var out = '';
        for (var i = 0, il = str.length; i < il; ++i) {
            var c = str.charCodeAt(i);
    
            if (c === 0x2D || // -
                c === 0x2E || // .
                c === 0x5F || // _
                c === 0x7E || // ~
                (c >= 0x30 && c <= 0x39) || // 0-9
                (c >= 0x41 && c <= 0x5A) || // a-z
                (c >= 0x61 && c <= 0x7A)) { // A-Z
    
                out += str[i];
                continue;
            }
    
            if (c < 0x80) {
                out += internals.hexTable[c];
                continue;
            }
    
            if (c < 0x800) {
                out += internals.hexTable[0xC0 | (c >> 6)] + internals.hexTable[0x80 | (c & 0x3F)];
                continue;
            }
    
            if (c < 0xD800 || c >= 0xE000) {
                out += internals.hexTable[0xE0 | (c >> 12)] + internals.hexTable[0x80 | ((c >> 6) & 0x3F)] + internals.hexTable[0x80 | (c & 0x3F)];
                continue;
            }
    
            ++i;
            c = 0x10000 + (((c & 0x3FF) << 10) | (str.charCodeAt(i) & 0x3FF));
            out += internals.hexTable[0xF0 | (c >> 18)] + internals.hexTable[0x80 | ((c >> 12) & 0x3F)] + internals.hexTable[0x80 | ((c >> 6) & 0x3F)] + internals.hexTable[0x80 | (c & 0x3F)];
        }
    
        return out;
    };
    
    exports.compact = function (obj, refs) {
    
        if (typeof obj !== 'object' ||
            obj === null) {
    
            return obj;
        }
    
        refs = refs || [];
        var lookup = refs.indexOf(obj);
        if (lookup !== -1) {
            return refs[lookup];
        }
    
        refs.push(obj);
    
        if (Array.isArray(obj)) {
            var compacted = [];
    
            for (var i = 0, il = obj.length; i < il; ++i) {
                if (typeof obj[i] !== 'undefined') {
                    compacted.push(obj[i]);
                }
            }
    
            return compacted;
        }
    
        var keys = Object.keys(obj);
        for (i = 0, il = keys.length; i < il; ++i) {
            var key = keys[i];
            obj[key] = exports.compact(obj[key], refs);
        }
    
        return obj;
    };
    
    
    exports.isRegExp = function (obj) {
    
        return Object.prototype.toString.call(obj) === '[object RegExp]';
    };
    
    
    exports.isBuffer = function (obj) {
    
        if (obj === null ||
            typeof obj === 'undefined') {
    
            return false;
        }
    
        return !!(obj.constructor &&
                  obj.constructor.isBuffer &&
                  obj.constructor.isBuffer(obj));
    };
    
  provide("qs/lib/utils", module.exports);
}(global));

// pakmanager:qs/lib/stringify
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Load modules
    
    var Utils =  require('qs/lib/utils');
    
    
    // Declare internals
    
    var internals = {
        delimiter: '&',
        arrayPrefixGenerators: {
            brackets: function (prefix, key) {
    
                return prefix + '[]';
            },
            indices: function (prefix, key) {
    
                return prefix + '[' + key + ']';
            },
            repeat: function (prefix, key) {
    
                return prefix;
            }
        },
        strictNullHandling: false
    };
    
    
    internals.stringify = function (obj, prefix, generateArrayPrefix, strictNullHandling, filter) {
    
        if (typeof filter === 'function') {
            obj = filter(prefix, obj);
        }
        else if (Utils.isBuffer(obj)) {
            obj = obj.toString();
        }
        else if (obj instanceof Date) {
            obj = obj.toISOString();
        }
        else if (obj === null) {
            if (strictNullHandling) {
                return Utils.encode(prefix);
            }
    
            obj = '';
        }
    
        if (typeof obj === 'string' ||
            typeof obj === 'number' ||
            typeof obj === 'boolean') {
    
            return [Utils.encode(prefix) + '=' + Utils.encode(obj)];
        }
    
        var values = [];
    
        if (typeof obj === 'undefined') {
            return values;
        }
    
        var objKeys = Array.isArray(filter) ? filter : Object.keys(obj);
        for (var i = 0, il = objKeys.length; i < il; ++i) {
            var key = objKeys[i];
    
            if (Array.isArray(obj)) {
                values = values.concat(internals.stringify(obj[key], generateArrayPrefix(prefix, key), generateArrayPrefix, strictNullHandling, filter));
            }
            else {
                values = values.concat(internals.stringify(obj[key], prefix + '[' + key + ']', generateArrayPrefix, strictNullHandling, filter));
            }
        }
    
        return values;
    };
    
    
    module.exports = function (obj, options) {
    
        options = options || {};
        var delimiter = typeof options.delimiter === 'undefined' ? internals.delimiter : options.delimiter;
        var strictNullHandling = typeof options.strictNullHandling === 'boolean' ? options.strictNullHandling : internals.strictNullHandling;
        var objKeys;
        var filter;
        if (typeof options.filter === 'function') {
            filter = options.filter;
            obj = filter('', obj);
        }
        else if (Array.isArray(options.filter)) {
            objKeys = filter = options.filter;
        }
    
        var keys = [];
    
        if (typeof obj !== 'object' ||
            obj === null) {
    
            return '';
        }
    
        var arrayFormat;
        if (options.arrayFormat in internals.arrayPrefixGenerators) {
            arrayFormat = options.arrayFormat;
        }
        else if ('indices' in options) {
            arrayFormat = options.indices ? 'indices' : 'repeat';
        }
        else {
            arrayFormat = 'indices';
        }
    
        var generateArrayPrefix = internals.arrayPrefixGenerators[arrayFormat];
    
        if (!objKeys) {
            objKeys = Object.keys(obj);
        }
        for (var i = 0, il = objKeys.length; i < il; ++i) {
            var key = objKeys[i];
            keys = keys.concat(internals.stringify(obj[key], key, generateArrayPrefix, strictNullHandling, filter));
        }
    
        return keys.join(delimiter);
    };
    
  provide("qs/lib/stringify", module.exports);
}(global));

// pakmanager:qs/lib/parse
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Load modules
    
    var Utils =  require('qs/lib/utils');
    
    
    // Declare internals
    
    var internals = {
        delimiter: '&',
        depth: 5,
        arrayLimit: 20,
        parameterLimit: 1000,
        strictNullHandling: false,
        plainObjects: false,
        allowPrototypes: false
    };
    
    
    internals.parseValues = function (str, options) {
    
        var obj = {};
        var parts = str.split(options.delimiter, options.parameterLimit === Infinity ? undefined : options.parameterLimit);
    
        for (var i = 0, il = parts.length; i < il; ++i) {
            var part = parts[i];
            var pos = part.indexOf(']=') === -1 ? part.indexOf('=') : part.indexOf(']=') + 1;
    
            if (pos === -1) {
                obj[Utils.decode(part)] = '';
    
                if (options.strictNullHandling) {
                    obj[Utils.decode(part)] = null;
                }
            }
            else {
                var key = Utils.decode(part.slice(0, pos));
                var val = Utils.decode(part.slice(pos + 1));
    
                if (!Object.prototype.hasOwnProperty.call(obj, key)) {
                    obj[key] = val;
                }
                else {
                    obj[key] = [].concat(obj[key]).concat(val);
                }
            }
        }
    
        return obj;
    };
    
    
    internals.parseObject = function (chain, val, options) {
    
        if (!chain.length) {
            return val;
        }
    
        var root = chain.shift();
    
        var obj;
        if (root === '[]') {
            obj = [];
            obj = obj.concat(internals.parseObject(chain, val, options));
        }
        else {
            obj = options.plainObjects ? Object.create(null) : {};
            var cleanRoot = root[0] === '[' && root[root.length - 1] === ']' ? root.slice(1, root.length - 1) : root;
            var index = parseInt(cleanRoot, 10);
            var indexString = '' + index;
            if (!isNaN(index) &&
                root !== cleanRoot &&
                indexString === cleanRoot &&
                index >= 0 &&
                (options.parseArrays &&
                 index <= options.arrayLimit)) {
    
                obj = [];
                obj[index] = internals.parseObject(chain, val, options);
            }
            else {
                obj[cleanRoot] = internals.parseObject(chain, val, options);
            }
        }
    
        return obj;
    };
    
    
    internals.parseKeys = function (key, val, options) {
    
        if (!key) {
            return;
        }
    
        // Transform dot notation to bracket notation
    
        if (options.allowDots) {
            key = key.replace(/\.([^\.\[]+)/g, '[$1]');
        }
    
        // The regex chunks
    
        var parent = /^([^\[\]]*)/;
        var child = /(\[[^\[\]]*\])/g;
    
        // Get the parent
    
        var segment = parent.exec(key);
    
        // Stash the parent if it exists
    
        var keys = [];
        if (segment[1]) {
            // If we aren't using plain objects, optionally prefix keys
            // that would overwrite object prototype properties
            if (!options.plainObjects &&
                Object.prototype.hasOwnProperty(segment[1])) {
    
                if (!options.allowPrototypes) {
                    return;
                }
            }
    
            keys.push(segment[1]);
        }
    
        // Loop through children appending to the array until we hit depth
    
        var i = 0;
        while ((segment = child.exec(key)) !== null && i < options.depth) {
    
            ++i;
            if (!options.plainObjects &&
                Object.prototype.hasOwnProperty(segment[1].replace(/\[|\]/g, ''))) {
    
                if (!options.allowPrototypes) {
                    continue;
                }
            }
            keys.push(segment[1]);
        }
    
        // If there's a remainder, just add whatever is left
    
        if (segment) {
            keys.push('[' + key.slice(segment.index) + ']');
        }
    
        return internals.parseObject(keys, val, options);
    };
    
    
    module.exports = function (str, options) {
    
        options = options || {};
        options.delimiter = typeof options.delimiter === 'string' || Utils.isRegExp(options.delimiter) ? options.delimiter : internals.delimiter;
        options.depth = typeof options.depth === 'number' ? options.depth : internals.depth;
        options.arrayLimit = typeof options.arrayLimit === 'number' ? options.arrayLimit : internals.arrayLimit;
        options.parseArrays = options.parseArrays !== false;
        options.allowDots = options.allowDots !== false;
        options.plainObjects = typeof options.plainObjects === 'boolean' ? options.plainObjects : internals.plainObjects;
        options.allowPrototypes = typeof options.allowPrototypes === 'boolean' ? options.allowPrototypes : internals.allowPrototypes;
        options.parameterLimit = typeof options.parameterLimit === 'number' ? options.parameterLimit : internals.parameterLimit;
        options.strictNullHandling = typeof options.strictNullHandling === 'boolean' ? options.strictNullHandling : internals.strictNullHandling;
    
        if (str === '' ||
            str === null ||
            typeof str === 'undefined') {
    
            return options.plainObjects ? Object.create(null) : {};
        }
    
        var tempObj = typeof str === 'string' ? internals.parseValues(str, options) : str;
        var obj = options.plainObjects ? Object.create(null) : {};
    
        // Iterate over the keys and setup the new object
    
        var keys = Object.keys(tempObj);
        for (var i = 0, il = keys.length; i < il; ++i) {
            var key = keys[i];
            var newObj = internals.parseKeys(key, tempObj[key], options);
            obj = Utils.merge(obj, newObj, options);
        }
    
        return Utils.compact(obj);
    };
    
  provide("qs/lib/parse", module.exports);
}(global));

// pakmanager:qs
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Load modules
    
    var Stringify =  require('qs/lib/stringify');
    var Parse =  require('qs/lib/parse');
    
    
    // Declare internals
    
    var internals = {};
    
    
    module.exports = {
        stringify: Stringify,
        parse: Parse
    };
    
  provide("qs", module.exports);
}(global));

// pakmanager:tunnel-agent
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict'
    
    var net = require('net')
      , tls = require('tls')
      , http = require('http')
      , https = require('https')
      , events = require('events')
      , assert = require('assert')
      , util = require('util')
      ;
    
    exports.httpOverHttp = httpOverHttp
    exports.httpsOverHttp = httpsOverHttp
    exports.httpOverHttps = httpOverHttps
    exports.httpsOverHttps = httpsOverHttps
    
    
    function httpOverHttp(options) {
      var agent = new TunnelingAgent(options)
      agent.request = http.request
      return agent
    }
    
    function httpsOverHttp(options) {
      var agent = new TunnelingAgent(options)
      agent.request = http.request
      agent.createSocket = createSecureSocket
      return agent
    }
    
    function httpOverHttps(options) {
      var agent = new TunnelingAgent(options)
      agent.request = https.request
      return agent
    }
    
    function httpsOverHttps(options) {
      var agent = new TunnelingAgent(options)
      agent.request = https.request
      agent.createSocket = createSecureSocket
      return agent
    }
    
    
    function TunnelingAgent(options) {
      var self = this
      self.options = options || {}
      self.proxyOptions = self.options.proxy || {}
      self.maxSockets = self.options.maxSockets || http.Agent.defaultMaxSockets
      self.requests = []
      self.sockets = []
    
      self.on('free', function onFree(socket, host, port) {
        for (var i = 0, len = self.requests.length; i < len; ++i) {
          var pending = self.requests[i]
          if (pending.host === host && pending.port === port) {
            // Detect the request to connect same origin server,
            // reuse the connection.
            self.requests.splice(i, 1)
            pending.request.onSocket(socket)
            return
          }
        }
        socket.destroy()
        self.removeSocket(socket)
      })
    }
    util.inherits(TunnelingAgent, events.EventEmitter)
    
    TunnelingAgent.prototype.addRequest = function addRequest(req, options) {
      var self = this
    
       // Legacy API: addRequest(req, host, port, path)
      if (typeof options === 'string') {
        options = {
          host: options,
          port: arguments[2],
          path: arguments[3]
        };
      }
    
      if (self.sockets.length >= this.maxSockets) {
        // We are over limit so we'll add it to the queue.
        self.requests.push({host: options.host, port: options.port, request: req})
        return
      }
    
      // If we are under maxSockets create a new one.
      self.createConnection({host: options.host, port: options.port, request: req})
    }
    
    TunnelingAgent.prototype.createConnection = function createConnection(pending) {
      var self = this
    
      self.createSocket(pending, function(socket) {
        socket.on('free', onFree)
        socket.on('close', onCloseOrRemove)
        socket.on('agentRemove', onCloseOrRemove)
        pending.request.onSocket(socket)
    
        function onFree() {
          self.emit('free', socket, pending.host, pending.port)
        }
    
        function onCloseOrRemove(err) {
          self.removeSocket(socket)
          socket.removeListener('free', onFree)
          socket.removeListener('close', onCloseOrRemove)
          socket.removeListener('agentRemove', onCloseOrRemove)
        }
      })
    }
    
    TunnelingAgent.prototype.createSocket = function createSocket(options, cb) {
      var self = this
      var placeholder = {}
      self.sockets.push(placeholder)
    
      var connectOptions = mergeOptions({}, self.proxyOptions, 
        { method: 'CONNECT'
        , path: options.host + ':' + options.port
        , agent: false
        }
      )
      if (connectOptions.proxyAuth) {
        connectOptions.headers = connectOptions.headers || {}
        connectOptions.headers['Proxy-Authorization'] = 'Basic ' +
            new Buffer(connectOptions.proxyAuth).toString('base64')
      }
    
      debug('making CONNECT request')
      var connectReq = self.request(connectOptions)
      connectReq.useChunkedEncodingByDefault = false // for v0.6
      connectReq.once('response', onResponse) // for v0.6
      connectReq.once('upgrade', onUpgrade)   // for v0.6
      connectReq.once('connect', onConnect)   // for v0.7 or later
      connectReq.once('error', onError)
      connectReq.end()
    
      function onResponse(res) {
        // Very hacky. This is necessary to avoid http-parser leaks.
        res.upgrade = true
      }
    
      function onUpgrade(res, socket, head) {
        // Hacky.
        process.nextTick(function() {
          onConnect(res, socket, head)
        })
      }
    
      function onConnect(res, socket, head) {
        connectReq.removeAllListeners()
        socket.removeAllListeners()
    
        if (res.statusCode === 200) {
          assert.equal(head.length, 0)
          debug('tunneling connection has established')
          self.sockets[self.sockets.indexOf(placeholder)] = socket
          cb(socket)
        } else {
          debug('tunneling socket could not be established, statusCode=%d', res.statusCode)
          var error = new Error('tunneling socket could not be established, ' + 'statusCode=' + res.statusCode)
          error.code = 'ECONNRESET'
          options.request.emit('error', error)
          self.removeSocket(placeholder)
        }
      }
    
      function onError(cause) {
        connectReq.removeAllListeners()
    
        debug('tunneling socket could not be established, cause=%s\n', cause.message, cause.stack)
        var error = new Error('tunneling socket could not be established, ' + 'cause=' + cause.message)
        error.code = 'ECONNRESET'
        options.request.emit('error', error)
        self.removeSocket(placeholder)
      }
    }
    
    TunnelingAgent.prototype.removeSocket = function removeSocket(socket) {
      var pos = this.sockets.indexOf(socket)
      if (pos === -1) return
      
      this.sockets.splice(pos, 1)
    
      var pending = this.requests.shift()
      if (pending) {
        // If we have pending requests and a socket gets closed a new one
        // needs to be created to take over in the pool for the one that closed.
        this.createConnection(pending)
      }
    }
    
    function createSecureSocket(options, cb) {
      var self = this
      TunnelingAgent.prototype.createSocket.call(self, options, function(socket) {
        // 0 is dummy port for v0.6
        var secureSocket = tls.connect(0, mergeOptions({}, self.options, 
          { servername: options.host
          , socket: socket
          }
        ))
        self.sockets[self.sockets.indexOf(socket)] = secureSocket
        cb(secureSocket)
      })
    }
    
    
    function mergeOptions(target) {
      for (var i = 1, len = arguments.length; i < len; ++i) {
        var overrides = arguments[i]
        if (typeof overrides === 'object') {
          var keys = Object.keys(overrides)
          for (var j = 0, keyLen = keys.length; j < keyLen; ++j) {
            var k = keys[j]
            if (overrides[k] !== undefined) {
              target[k] = overrides[k]
            }
          }
        }
      }
      return target
    }
    
    
    var debug
    if (process.env.NODE_DEBUG && /\btunnel\b/.test(process.env.NODE_DEBUG)) {
      debug = function() {
        var args = Array.prototype.slice.call(arguments)
        if (typeof args[0] === 'string') {
          args[0] = 'TUNNEL: ' + args[0]
        } else {
          args.unshift('TUNNEL:')
        }
        console.error.apply(console, args)
      }
    } else {
      debug = function() {}
    }
    exports.debug = debug // for test
    
  provide("tunnel-agent", module.exports);
}(global));

// pakmanager:tough-cookie/lib/pubsuffix
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /****************************************************
     * AUTOMATICALLY GENERATED by generate-pubsuffix.js *
     *                  DO NOT EDIT!                    *
     ****************************************************/
    
    "use strict";
    
    var punycode = require('punycode');
    
    module.exports.getPublicSuffix = function getPublicSuffix(domain) {
      /*!
       * Copyright (c) 2015, Salesforce.com, Inc.
       * All rights reserved.
       *
       * Redistribution and use in source and binary forms, with or without
       * modification, are permitted provided that the following conditions are met:
       *
       * 1. Redistributions of source code must retain the above copyright notice,
       * this list of conditions and the following disclaimer.
       *
       * 2. Redistributions in binary form must reproduce the above copyright notice,
       * this list of conditions and the following disclaimer in the documentation
       * and/or other materials provided with the distribution.
       *
       * 3. Neither the name of Salesforce.com nor the names of its contributors may
       * be used to endorse or promote products derived from this software without
       * specific prior written permission.
       *
       * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
       * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
       * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
       * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
       * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
       * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
       * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
       * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
       * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
       * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
       * POSSIBILITY OF SUCH DAMAGE.
       */
      if (!domain) {
        return null;
      }
      if (domain.match(/^\./)) {
        return null;
      }
      var asciiDomain = punycode.toASCII(domain);
      var converted = false;
      if (asciiDomain !== domain) {
        domain = asciiDomain;
        converted = true;
      }
      if (index[domain]) {
        return null;
      }
    
      domain = domain.toLowerCase();
      var parts = domain.split('.').reverse();
    
      var suffix = '';
      var suffixLen = 0;
      for (var i=0; i<parts.length; i++) {
        var part = parts[i];
        var starstr = '*'+suffix;
        var partstr = part+suffix;
    
        if (index[starstr]) { // star rule matches
          suffixLen = i+1;
          if (index[partstr] === false) { // exception rule matches (NB: false, not undefined)
            suffixLen--;
          }
        } else if (index[partstr]) { // exact match, not exception
          suffixLen = i+1;
        }
    
        suffix = '.'+partstr;
      }
    
      if (index['*'+suffix]) { // *.domain exists (e.g. *.kyoto.jp for domain='kyoto.jp');
        return null;
      }
    
      suffixLen = suffixLen || 1;
      if (parts.length > suffixLen) {
        var publicSuffix = parts.slice(0,suffixLen+1).reverse().join('.');
        return converted ? punycode.toUnicode(publicSuffix) : publicSuffix;
      }
    
      return null;
    };
    
    // The following generated structure is used under the MPL version 1.1
    // See public-suffix.txt for more information
    
    var index = module.exports.index = Object.freeze(
    {"ac":true,"com.ac":true,"edu.ac":true,"gov.ac":true,"net.ac":true,"mil.ac":true,"org.ac":true,"ad":true,"nom.ad":true,"ae":true,"co.ae":true,"net.ae":true,"org.ae":true,"sch.ae":true,"ac.ae":true,"gov.ae":true,"mil.ae":true,"aero":true,"accident-investigation.aero":true,"accident-prevention.aero":true,"aerobatic.aero":true,"aeroclub.aero":true,"aerodrome.aero":true,"agents.aero":true,"aircraft.aero":true,"airline.aero":true,"airport.aero":true,"air-surveillance.aero":true,"airtraffic.aero":true,"air-traffic-control.aero":true,"ambulance.aero":true,"amusement.aero":true,"association.aero":true,"author.aero":true,"ballooning.aero":true,"broker.aero":true,"caa.aero":true,"cargo.aero":true,"catering.aero":true,"certification.aero":true,"championship.aero":true,"charter.aero":true,"civilaviation.aero":true,"club.aero":true,"conference.aero":true,"consultant.aero":true,"consulting.aero":true,"control.aero":true,"council.aero":true,"crew.aero":true,"design.aero":true,"dgca.aero":true,"educator.aero":true,"emergency.aero":true,"engine.aero":true,"engineer.aero":true,"entertainment.aero":true,"equipment.aero":true,"exchange.aero":true,"express.aero":true,"federation.aero":true,"flight.aero":true,"freight.aero":true,"fuel.aero":true,"gliding.aero":true,"government.aero":true,"groundhandling.aero":true,"group.aero":true,"hanggliding.aero":true,"homebuilt.aero":true,"insurance.aero":true,"journal.aero":true,"journalist.aero":true,"leasing.aero":true,"logistics.aero":true,"magazine.aero":true,"maintenance.aero":true,"marketplace.aero":true,"media.aero":true,"microlight.aero":true,"modelling.aero":true,"navigation.aero":true,"parachuting.aero":true,"paragliding.aero":true,"passenger-association.aero":true,"pilot.aero":true,"press.aero":true,"production.aero":true,"recreation.aero":true,"repbody.aero":true,"res.aero":true,"research.aero":true,"rotorcraft.aero":true,"safety.aero":true,"scientist.aero":true,"services.aero":true,"show.aero":true,"skydiving.aero":true,"software.aero":true,"student.aero":true,"taxi.aero":true,"trader.aero":true,"trading.aero":true,"trainer.aero":true,"union.aero":true,"workinggroup.aero":true,"works.aero":true,"af":true,"gov.af":true,"com.af":true,"org.af":true,"net.af":true,"edu.af":true,"ag":true,"com.ag":true,"org.ag":true,"net.ag":true,"co.ag":true,"nom.ag":true,"ai":true,"off.ai":true,"com.ai":true,"net.ai":true,"org.ai":true,"al":true,"com.al":true,"edu.al":true,"gov.al":true,"mil.al":true,"net.al":true,"org.al":true,"am":true,"an":true,"com.an":true,"net.an":true,"org.an":true,"edu.an":true,"ao":true,"ed.ao":true,"gv.ao":true,"og.ao":true,"co.ao":true,"pb.ao":true,"it.ao":true,"aq":true,"ar":true,"com.ar":true,"edu.ar":true,"gob.ar":true,"gov.ar":true,"int.ar":true,"mil.ar":true,"net.ar":true,"org.ar":true,"tur.ar":true,"arpa":true,"e164.arpa":true,"in-addr.arpa":true,"ip6.arpa":true,"iris.arpa":true,"uri.arpa":true,"urn.arpa":true,"as":true,"gov.as":true,"asia":true,"at":true,"ac.at":true,"co.at":true,"gv.at":true,"or.at":true,"au":true,"com.au":true,"net.au":true,"org.au":true,"edu.au":true,"gov.au":true,"asn.au":true,"id.au":true,"info.au":true,"conf.au":true,"oz.au":true,"act.au":true,"nsw.au":true,"nt.au":true,"qld.au":true,"sa.au":true,"tas.au":true,"vic.au":true,"wa.au":true,"act.edu.au":true,"nsw.edu.au":true,"nt.edu.au":true,"qld.edu.au":true,"sa.edu.au":true,"tas.edu.au":true,"vic.edu.au":true,"wa.edu.au":true,"qld.gov.au":true,"sa.gov.au":true,"tas.gov.au":true,"vic.gov.au":true,"wa.gov.au":true,"aw":true,"com.aw":true,"ax":true,"az":true,"com.az":true,"net.az":true,"int.az":true,"gov.az":true,"org.az":true,"edu.az":true,"info.az":true,"pp.az":true,"mil.az":true,"name.az":true,"pro.az":true,"biz.az":true,"ba":true,"org.ba":true,"net.ba":true,"edu.ba":true,"gov.ba":true,"mil.ba":true,"unsa.ba":true,"unbi.ba":true,"co.ba":true,"com.ba":true,"rs.ba":true,"bb":true,"biz.bb":true,"co.bb":true,"com.bb":true,"edu.bb":true,"gov.bb":true,"info.bb":true,"net.bb":true,"org.bb":true,"store.bb":true,"tv.bb":true,"*.bd":true,"be":true,"ac.be":true,"bf":true,"gov.bf":true,"bg":true,"a.bg":true,"b.bg":true,"c.bg":true,"d.bg":true,"e.bg":true,"f.bg":true,"g.bg":true,"h.bg":true,"i.bg":true,"j.bg":true,"k.bg":true,"l.bg":true,"m.bg":true,"n.bg":true,"o.bg":true,"p.bg":true,"q.bg":true,"r.bg":true,"s.bg":true,"t.bg":true,"u.bg":true,"v.bg":true,"w.bg":true,"x.bg":true,"y.bg":true,"z.bg":true,"0.bg":true,"1.bg":true,"2.bg":true,"3.bg":true,"4.bg":true,"5.bg":true,"6.bg":true,"7.bg":true,"8.bg":true,"9.bg":true,"bh":true,"com.bh":true,"edu.bh":true,"net.bh":true,"org.bh":true,"gov.bh":true,"bi":true,"co.bi":true,"com.bi":true,"edu.bi":true,"or.bi":true,"org.bi":true,"biz":true,"bj":true,"asso.bj":true,"barreau.bj":true,"gouv.bj":true,"bm":true,"com.bm":true,"edu.bm":true,"gov.bm":true,"net.bm":true,"org.bm":true,"*.bn":true,"bo":true,"com.bo":true,"edu.bo":true,"gov.bo":true,"gob.bo":true,"int.bo":true,"org.bo":true,"net.bo":true,"mil.bo":true,"tv.bo":true,"br":true,"adm.br":true,"adv.br":true,"agr.br":true,"am.br":true,"arq.br":true,"art.br":true,"ato.br":true,"b.br":true,"bio.br":true,"blog.br":true,"bmd.br":true,"cim.br":true,"cng.br":true,"cnt.br":true,"com.br":true,"coop.br":true,"ecn.br":true,"eco.br":true,"edu.br":true,"emp.br":true,"eng.br":true,"esp.br":true,"etc.br":true,"eti.br":true,"far.br":true,"flog.br":true,"fm.br":true,"fnd.br":true,"fot.br":true,"fst.br":true,"g12.br":true,"ggf.br":true,"gov.br":true,"imb.br":true,"ind.br":true,"inf.br":true,"jor.br":true,"jus.br":true,"leg.br":true,"lel.br":true,"mat.br":true,"med.br":true,"mil.br":true,"mp.br":true,"mus.br":true,"net.br":true,"*.nom.br":true,"not.br":true,"ntr.br":true,"odo.br":true,"org.br":true,"ppg.br":true,"pro.br":true,"psc.br":true,"psi.br":true,"qsl.br":true,"radio.br":true,"rec.br":true,"slg.br":true,"srv.br":true,"taxi.br":true,"teo.br":true,"tmp.br":true,"trd.br":true,"tur.br":true,"tv.br":true,"vet.br":true,"vlog.br":true,"wiki.br":true,"zlg.br":true,"bs":true,"com.bs":true,"net.bs":true,"org.bs":true,"edu.bs":true,"gov.bs":true,"bt":true,"com.bt":true,"edu.bt":true,"gov.bt":true,"net.bt":true,"org.bt":true,"bv":true,"bw":true,"co.bw":true,"org.bw":true,"by":true,"gov.by":true,"mil.by":true,"com.by":true,"of.by":true,"bz":true,"com.bz":true,"net.bz":true,"org.bz":true,"edu.bz":true,"gov.bz":true,"ca":true,"ab.ca":true,"bc.ca":true,"mb.ca":true,"nb.ca":true,"nf.ca":true,"nl.ca":true,"ns.ca":true,"nt.ca":true,"nu.ca":true,"on.ca":true,"pe.ca":true,"qc.ca":true,"sk.ca":true,"yk.ca":true,"gc.ca":true,"cat":true,"cc":true,"cd":true,"gov.cd":true,"cf":true,"cg":true,"ch":true,"ci":true,"org.ci":true,"or.ci":true,"com.ci":true,"co.ci":true,"edu.ci":true,"ed.ci":true,"ac.ci":true,"net.ci":true,"go.ci":true,"asso.ci":true,"xn--aroport-bya.ci":true,"int.ci":true,"presse.ci":true,"md.ci":true,"gouv.ci":true,"*.ck":true,"www.ck":false,"cl":true,"gov.cl":true,"gob.cl":true,"co.cl":true,"mil.cl":true,"cm":true,"co.cm":true,"com.cm":true,"gov.cm":true,"net.cm":true,"cn":true,"ac.cn":true,"com.cn":true,"edu.cn":true,"gov.cn":true,"net.cn":true,"org.cn":true,"mil.cn":true,"xn--55qx5d.cn":true,"xn--io0a7i.cn":true,"xn--od0alg.cn":true,"ah.cn":true,"bj.cn":true,"cq.cn":true,"fj.cn":true,"gd.cn":true,"gs.cn":true,"gz.cn":true,"gx.cn":true,"ha.cn":true,"hb.cn":true,"he.cn":true,"hi.cn":true,"hl.cn":true,"hn.cn":true,"jl.cn":true,"js.cn":true,"jx.cn":true,"ln.cn":true,"nm.cn":true,"nx.cn":true,"qh.cn":true,"sc.cn":true,"sd.cn":true,"sh.cn":true,"sn.cn":true,"sx.cn":true,"tj.cn":true,"xj.cn":true,"xz.cn":true,"yn.cn":true,"zj.cn":true,"hk.cn":true,"mo.cn":true,"tw.cn":true,"co":true,"arts.co":true,"com.co":true,"edu.co":true,"firm.co":true,"gov.co":true,"info.co":true,"int.co":true,"mil.co":true,"net.co":true,"nom.co":true,"org.co":true,"rec.co":true,"web.co":true,"com":true,"coop":true,"cr":true,"ac.cr":true,"co.cr":true,"ed.cr":true,"fi.cr":true,"go.cr":true,"or.cr":true,"sa.cr":true,"cu":true,"com.cu":true,"edu.cu":true,"org.cu":true,"net.cu":true,"gov.cu":true,"inf.cu":true,"cv":true,"cw":true,"com.cw":true,"edu.cw":true,"net.cw":true,"org.cw":true,"cx":true,"gov.cx":true,"*.cy":true,"cz":true,"de":true,"dj":true,"dk":true,"dm":true,"com.dm":true,"net.dm":true,"org.dm":true,"edu.dm":true,"gov.dm":true,"do":true,"art.do":true,"com.do":true,"edu.do":true,"gob.do":true,"gov.do":true,"mil.do":true,"net.do":true,"org.do":true,"sld.do":true,"web.do":true,"dz":true,"com.dz":true,"org.dz":true,"net.dz":true,"gov.dz":true,"edu.dz":true,"asso.dz":true,"pol.dz":true,"art.dz":true,"ec":true,"com.ec":true,"info.ec":true,"net.ec":true,"fin.ec":true,"k12.ec":true,"med.ec":true,"pro.ec":true,"org.ec":true,"edu.ec":true,"gov.ec":true,"gob.ec":true,"mil.ec":true,"edu":true,"ee":true,"edu.ee":true,"gov.ee":true,"riik.ee":true,"lib.ee":true,"med.ee":true,"com.ee":true,"pri.ee":true,"aip.ee":true,"org.ee":true,"fie.ee":true,"eg":true,"com.eg":true,"edu.eg":true,"eun.eg":true,"gov.eg":true,"mil.eg":true,"name.eg":true,"net.eg":true,"org.eg":true,"sci.eg":true,"*.er":true,"es":true,"com.es":true,"nom.es":true,"org.es":true,"gob.es":true,"edu.es":true,"et":true,"com.et":true,"gov.et":true,"org.et":true,"edu.et":true,"biz.et":true,"name.et":true,"info.et":true,"eu":true,"fi":true,"aland.fi":true,"*.fj":true,"*.fk":true,"fm":true,"fo":true,"fr":true,"com.fr":true,"asso.fr":true,"nom.fr":true,"prd.fr":true,"presse.fr":true,"tm.fr":true,"aeroport.fr":true,"assedic.fr":true,"avocat.fr":true,"avoues.fr":true,"cci.fr":true,"chambagri.fr":true,"chirurgiens-dentistes.fr":true,"experts-comptables.fr":true,"geometre-expert.fr":true,"gouv.fr":true,"greta.fr":true,"huissier-justice.fr":true,"medecin.fr":true,"notaires.fr":true,"pharmacien.fr":true,"port.fr":true,"veterinaire.fr":true,"ga":true,"gb":true,"gd":true,"ge":true,"com.ge":true,"edu.ge":true,"gov.ge":true,"org.ge":true,"mil.ge":true,"net.ge":true,"pvt.ge":true,"gf":true,"gg":true,"co.gg":true,"net.gg":true,"org.gg":true,"gh":true,"com.gh":true,"edu.gh":true,"gov.gh":true,"org.gh":true,"mil.gh":true,"gi":true,"com.gi":true,"ltd.gi":true,"gov.gi":true,"mod.gi":true,"edu.gi":true,"org.gi":true,"gl":true,"gm":true,"gn":true,"ac.gn":true,"com.gn":true,"edu.gn":true,"gov.gn":true,"org.gn":true,"net.gn":true,"gov":true,"gp":true,"com.gp":true,"net.gp":true,"mobi.gp":true,"edu.gp":true,"org.gp":true,"asso.gp":true,"gq":true,"gr":true,"com.gr":true,"edu.gr":true,"net.gr":true,"org.gr":true,"gov.gr":true,"gs":true,"gt":true,"com.gt":true,"edu.gt":true,"gob.gt":true,"ind.gt":true,"mil.gt":true,"net.gt":true,"org.gt":true,"*.gu":true,"gw":true,"gy":true,"co.gy":true,"com.gy":true,"net.gy":true,"hk":true,"com.hk":true,"edu.hk":true,"gov.hk":true,"idv.hk":true,"net.hk":true,"org.hk":true,"xn--55qx5d.hk":true,"xn--wcvs22d.hk":true,"xn--lcvr32d.hk":true,"xn--mxtq1m.hk":true,"xn--gmqw5a.hk":true,"xn--ciqpn.hk":true,"xn--gmq050i.hk":true,"xn--zf0avx.hk":true,"xn--io0a7i.hk":true,"xn--mk0axi.hk":true,"xn--od0alg.hk":true,"xn--od0aq3b.hk":true,"xn--tn0ag.hk":true,"xn--uc0atv.hk":true,"xn--uc0ay4a.hk":true,"hm":true,"hn":true,"com.hn":true,"edu.hn":true,"org.hn":true,"net.hn":true,"mil.hn":true,"gob.hn":true,"hr":true,"iz.hr":true,"from.hr":true,"name.hr":true,"com.hr":true,"ht":true,"com.ht":true,"shop.ht":true,"firm.ht":true,"info.ht":true,"adult.ht":true,"net.ht":true,"pro.ht":true,"org.ht":true,"med.ht":true,"art.ht":true,"coop.ht":true,"pol.ht":true,"asso.ht":true,"edu.ht":true,"rel.ht":true,"gouv.ht":true,"perso.ht":true,"hu":true,"co.hu":true,"info.hu":true,"org.hu":true,"priv.hu":true,"sport.hu":true,"tm.hu":true,"2000.hu":true,"agrar.hu":true,"bolt.hu":true,"casino.hu":true,"city.hu":true,"erotica.hu":true,"erotika.hu":true,"film.hu":true,"forum.hu":true,"games.hu":true,"hotel.hu":true,"ingatlan.hu":true,"jogasz.hu":true,"konyvelo.hu":true,"lakas.hu":true,"media.hu":true,"news.hu":true,"reklam.hu":true,"sex.hu":true,"shop.hu":true,"suli.hu":true,"szex.hu":true,"tozsde.hu":true,"utazas.hu":true,"video.hu":true,"id":true,"ac.id":true,"biz.id":true,"co.id":true,"desa.id":true,"go.id":true,"mil.id":true,"my.id":true,"net.id":true,"or.id":true,"sch.id":true,"web.id":true,"ie":true,"gov.ie":true,"*.il":true,"im":true,"ac.im":true,"co.im":true,"com.im":true,"ltd.co.im":true,"net.im":true,"org.im":true,"plc.co.im":true,"tt.im":true,"tv.im":true,"in":true,"co.in":true,"firm.in":true,"net.in":true,"org.in":true,"gen.in":true,"ind.in":true,"nic.in":true,"ac.in":true,"edu.in":true,"res.in":true,"gov.in":true,"mil.in":true,"info":true,"int":true,"eu.int":true,"io":true,"com.io":true,"iq":true,"gov.iq":true,"edu.iq":true,"mil.iq":true,"com.iq":true,"org.iq":true,"net.iq":true,"ir":true,"ac.ir":true,"co.ir":true,"gov.ir":true,"id.ir":true,"net.ir":true,"org.ir":true,"sch.ir":true,"xn--mgba3a4f16a.ir":true,"xn--mgba3a4fra.ir":true,"is":true,"net.is":true,"com.is":true,"edu.is":true,"gov.is":true,"org.is":true,"int.is":true,"it":true,"gov.it":true,"edu.it":true,"abr.it":true,"abruzzo.it":true,"aosta-valley.it":true,"aostavalley.it":true,"bas.it":true,"basilicata.it":true,"cal.it":true,"calabria.it":true,"cam.it":true,"campania.it":true,"emilia-romagna.it":true,"emiliaromagna.it":true,"emr.it":true,"friuli-v-giulia.it":true,"friuli-ve-giulia.it":true,"friuli-vegiulia.it":true,"friuli-venezia-giulia.it":true,"friuli-veneziagiulia.it":true,"friuli-vgiulia.it":true,"friuliv-giulia.it":true,"friulive-giulia.it":true,"friulivegiulia.it":true,"friulivenezia-giulia.it":true,"friuliveneziagiulia.it":true,"friulivgiulia.it":true,"fvg.it":true,"laz.it":true,"lazio.it":true,"lig.it":true,"liguria.it":true,"lom.it":true,"lombardia.it":true,"lombardy.it":true,"lucania.it":true,"mar.it":true,"marche.it":true,"mol.it":true,"molise.it":true,"piedmont.it":true,"piemonte.it":true,"pmn.it":true,"pug.it":true,"puglia.it":true,"sar.it":true,"sardegna.it":true,"sardinia.it":true,"sic.it":true,"sicilia.it":true,"sicily.it":true,"taa.it":true,"tos.it":true,"toscana.it":true,"trentino-a-adige.it":true,"trentino-aadige.it":true,"trentino-alto-adige.it":true,"trentino-altoadige.it":true,"trentino-s-tirol.it":true,"trentino-stirol.it":true,"trentino-sud-tirol.it":true,"trentino-sudtirol.it":true,"trentino-sued-tirol.it":true,"trentino-suedtirol.it":true,"trentinoa-adige.it":true,"trentinoaadige.it":true,"trentinoalto-adige.it":true,"trentinoaltoadige.it":true,"trentinos-tirol.it":true,"trentinostirol.it":true,"trentinosud-tirol.it":true,"trentinosudtirol.it":true,"trentinosued-tirol.it":true,"trentinosuedtirol.it":true,"tuscany.it":true,"umb.it":true,"umbria.it":true,"val-d-aosta.it":true,"val-daosta.it":true,"vald-aosta.it":true,"valdaosta.it":true,"valle-aosta.it":true,"valle-d-aosta.it":true,"valle-daosta.it":true,"valleaosta.it":true,"valled-aosta.it":true,"valledaosta.it":true,"vallee-aoste.it":true,"valleeaoste.it":true,"vao.it":true,"vda.it":true,"ven.it":true,"veneto.it":true,"ag.it":true,"agrigento.it":true,"al.it":true,"alessandria.it":true,"alto-adige.it":true,"altoadige.it":true,"an.it":true,"ancona.it":true,"andria-barletta-trani.it":true,"andria-trani-barletta.it":true,"andriabarlettatrani.it":true,"andriatranibarletta.it":true,"ao.it":true,"aosta.it":true,"aoste.it":true,"ap.it":true,"aq.it":true,"aquila.it":true,"ar.it":true,"arezzo.it":true,"ascoli-piceno.it":true,"ascolipiceno.it":true,"asti.it":true,"at.it":true,"av.it":true,"avellino.it":true,"ba.it":true,"balsan.it":true,"bari.it":true,"barletta-trani-andria.it":true,"barlettatraniandria.it":true,"belluno.it":true,"benevento.it":true,"bergamo.it":true,"bg.it":true,"bi.it":true,"biella.it":true,"bl.it":true,"bn.it":true,"bo.it":true,"bologna.it":true,"bolzano.it":true,"bozen.it":true,"br.it":true,"brescia.it":true,"brindisi.it":true,"bs.it":true,"bt.it":true,"bz.it":true,"ca.it":true,"cagliari.it":true,"caltanissetta.it":true,"campidano-medio.it":true,"campidanomedio.it":true,"campobasso.it":true,"carbonia-iglesias.it":true,"carboniaiglesias.it":true,"carrara-massa.it":true,"carraramassa.it":true,"caserta.it":true,"catania.it":true,"catanzaro.it":true,"cb.it":true,"ce.it":true,"cesena-forli.it":true,"cesenaforli.it":true,"ch.it":true,"chieti.it":true,"ci.it":true,"cl.it":true,"cn.it":true,"co.it":true,"como.it":true,"cosenza.it":true,"cr.it":true,"cremona.it":true,"crotone.it":true,"cs.it":true,"ct.it":true,"cuneo.it":true,"cz.it":true,"dell-ogliastra.it":true,"dellogliastra.it":true,"en.it":true,"enna.it":true,"fc.it":true,"fe.it":true,"fermo.it":true,"ferrara.it":true,"fg.it":true,"fi.it":true,"firenze.it":true,"florence.it":true,"fm.it":true,"foggia.it":true,"forli-cesena.it":true,"forlicesena.it":true,"fr.it":true,"frosinone.it":true,"ge.it":true,"genoa.it":true,"genova.it":true,"go.it":true,"gorizia.it":true,"gr.it":true,"grosseto.it":true,"iglesias-carbonia.it":true,"iglesiascarbonia.it":true,"im.it":true,"imperia.it":true,"is.it":true,"isernia.it":true,"kr.it":true,"la-spezia.it":true,"laquila.it":true,"laspezia.it":true,"latina.it":true,"lc.it":true,"le.it":true,"lecce.it":true,"lecco.it":true,"li.it":true,"livorno.it":true,"lo.it":true,"lodi.it":true,"lt.it":true,"lu.it":true,"lucca.it":true,"macerata.it":true,"mantova.it":true,"massa-carrara.it":true,"massacarrara.it":true,"matera.it":true,"mb.it":true,"mc.it":true,"me.it":true,"medio-campidano.it":true,"mediocampidano.it":true,"messina.it":true,"mi.it":true,"milan.it":true,"milano.it":true,"mn.it":true,"mo.it":true,"modena.it":true,"monza-brianza.it":true,"monza-e-della-brianza.it":true,"monza.it":true,"monzabrianza.it":true,"monzaebrianza.it":true,"monzaedellabrianza.it":true,"ms.it":true,"mt.it":true,"na.it":true,"naples.it":true,"napoli.it":true,"no.it":true,"novara.it":true,"nu.it":true,"nuoro.it":true,"og.it":true,"ogliastra.it":true,"olbia-tempio.it":true,"olbiatempio.it":true,"or.it":true,"oristano.it":true,"ot.it":true,"pa.it":true,"padova.it":true,"padua.it":true,"palermo.it":true,"parma.it":true,"pavia.it":true,"pc.it":true,"pd.it":true,"pe.it":true,"perugia.it":true,"pesaro-urbino.it":true,"pesarourbino.it":true,"pescara.it":true,"pg.it":true,"pi.it":true,"piacenza.it":true,"pisa.it":true,"pistoia.it":true,"pn.it":true,"po.it":true,"pordenone.it":true,"potenza.it":true,"pr.it":true,"prato.it":true,"pt.it":true,"pu.it":true,"pv.it":true,"pz.it":true,"ra.it":true,"ragusa.it":true,"ravenna.it":true,"rc.it":true,"re.it":true,"reggio-calabria.it":true,"reggio-emilia.it":true,"reggiocalabria.it":true,"reggioemilia.it":true,"rg.it":true,"ri.it":true,"rieti.it":true,"rimini.it":true,"rm.it":true,"rn.it":true,"ro.it":true,"roma.it":true,"rome.it":true,"rovigo.it":true,"sa.it":true,"salerno.it":true,"sassari.it":true,"savona.it":true,"si.it":true,"siena.it":true,"siracusa.it":true,"so.it":true,"sondrio.it":true,"sp.it":true,"sr.it":true,"ss.it":true,"suedtirol.it":true,"sv.it":true,"ta.it":true,"taranto.it":true,"te.it":true,"tempio-olbia.it":true,"tempioolbia.it":true,"teramo.it":true,"terni.it":true,"tn.it":true,"to.it":true,"torino.it":true,"tp.it":true,"tr.it":true,"trani-andria-barletta.it":true,"trani-barletta-andria.it":true,"traniandriabarletta.it":true,"tranibarlettaandria.it":true,"trapani.it":true,"trentino.it":true,"trento.it":true,"treviso.it":true,"trieste.it":true,"ts.it":true,"turin.it":true,"tv.it":true,"ud.it":true,"udine.it":true,"urbino-pesaro.it":true,"urbinopesaro.it":true,"va.it":true,"varese.it":true,"vb.it":true,"vc.it":true,"ve.it":true,"venezia.it":true,"venice.it":true,"verbania.it":true,"vercelli.it":true,"verona.it":true,"vi.it":true,"vibo-valentia.it":true,"vibovalentia.it":true,"vicenza.it":true,"viterbo.it":true,"vr.it":true,"vs.it":true,"vt.it":true,"vv.it":true,"je":true,"co.je":true,"net.je":true,"org.je":true,"*.jm":true,"jo":true,"com.jo":true,"org.jo":true,"net.jo":true,"edu.jo":true,"sch.jo":true,"gov.jo":true,"mil.jo":true,"name.jo":true,"jobs":true,"jp":true,"ac.jp":true,"ad.jp":true,"co.jp":true,"ed.jp":true,"go.jp":true,"gr.jp":true,"lg.jp":true,"ne.jp":true,"or.jp":true,"aichi.jp":true,"akita.jp":true,"aomori.jp":true,"chiba.jp":true,"ehime.jp":true,"fukui.jp":true,"fukuoka.jp":true,"fukushima.jp":true,"gifu.jp":true,"gunma.jp":true,"hiroshima.jp":true,"hokkaido.jp":true,"hyogo.jp":true,"ibaraki.jp":true,"ishikawa.jp":true,"iwate.jp":true,"kagawa.jp":true,"kagoshima.jp":true,"kanagawa.jp":true,"kochi.jp":true,"kumamoto.jp":true,"kyoto.jp":true,"mie.jp":true,"miyagi.jp":true,"miyazaki.jp":true,"nagano.jp":true,"nagasaki.jp":true,"nara.jp":true,"niigata.jp":true,"oita.jp":true,"okayama.jp":true,"okinawa.jp":true,"osaka.jp":true,"saga.jp":true,"saitama.jp":true,"shiga.jp":true,"shimane.jp":true,"shizuoka.jp":true,"tochigi.jp":true,"tokushima.jp":true,"tokyo.jp":true,"tottori.jp":true,"toyama.jp":true,"wakayama.jp":true,"yamagata.jp":true,"yamaguchi.jp":true,"yamanashi.jp":true,"xn--4pvxs.jp":true,"xn--vgu402c.jp":true,"xn--c3s14m.jp":true,"xn--f6qx53a.jp":true,"xn--8pvr4u.jp":true,"xn--uist22h.jp":true,"xn--djrs72d6uy.jp":true,"xn--mkru45i.jp":true,"xn--0trq7p7nn.jp":true,"xn--8ltr62k.jp":true,"xn--2m4a15e.jp":true,"xn--efvn9s.jp":true,"xn--32vp30h.jp":true,"xn--4it797k.jp":true,"xn--1lqs71d.jp":true,"xn--5rtp49c.jp":true,"xn--5js045d.jp":true,"xn--ehqz56n.jp":true,"xn--1lqs03n.jp":true,"xn--qqqt11m.jp":true,"xn--kbrq7o.jp":true,"xn--pssu33l.jp":true,"xn--ntsq17g.jp":true,"xn--uisz3g.jp":true,"xn--6btw5a.jp":true,"xn--1ctwo.jp":true,"xn--6orx2r.jp":true,"xn--rht61e.jp":true,"xn--rht27z.jp":true,"xn--djty4k.jp":true,"xn--nit225k.jp":true,"xn--rht3d.jp":true,"xn--klty5x.jp":true,"xn--kltx9a.jp":true,"xn--kltp7d.jp":true,"xn--uuwu58a.jp":true,"xn--zbx025d.jp":true,"xn--ntso0iqx3a.jp":true,"xn--elqq16h.jp":true,"xn--4it168d.jp":true,"xn--klt787d.jp":true,"xn--rny31h.jp":true,"xn--7t0a264c.jp":true,"xn--5rtq34k.jp":true,"xn--k7yn95e.jp":true,"xn--tor131o.jp":true,"xn--d5qv7z876c.jp":true,"*.kawasaki.jp":true,"*.kitakyushu.jp":true,"*.kobe.jp":true,"*.nagoya.jp":true,"*.sapporo.jp":true,"*.sendai.jp":true,"*.yokohama.jp":true,"city.kawasaki.jp":false,"city.kitakyushu.jp":false,"city.kobe.jp":false,"city.nagoya.jp":false,"city.sapporo.jp":false,"city.sendai.jp":false,"city.yokohama.jp":false,"aisai.aichi.jp":true,"ama.aichi.jp":true,"anjo.aichi.jp":true,"asuke.aichi.jp":true,"chiryu.aichi.jp":true,"chita.aichi.jp":true,"fuso.aichi.jp":true,"gamagori.aichi.jp":true,"handa.aichi.jp":true,"hazu.aichi.jp":true,"hekinan.aichi.jp":true,"higashiura.aichi.jp":true,"ichinomiya.aichi.jp":true,"inazawa.aichi.jp":true,"inuyama.aichi.jp":true,"isshiki.aichi.jp":true,"iwakura.aichi.jp":true,"kanie.aichi.jp":true,"kariya.aichi.jp":true,"kasugai.aichi.jp":true,"kira.aichi.jp":true,"kiyosu.aichi.jp":true,"komaki.aichi.jp":true,"konan.aichi.jp":true,"kota.aichi.jp":true,"mihama.aichi.jp":true,"miyoshi.aichi.jp":true,"nishio.aichi.jp":true,"nisshin.aichi.jp":true,"obu.aichi.jp":true,"oguchi.aichi.jp":true,"oharu.aichi.jp":true,"okazaki.aichi.jp":true,"owariasahi.aichi.jp":true,"seto.aichi.jp":true,"shikatsu.aichi.jp":true,"shinshiro.aichi.jp":true,"shitara.aichi.jp":true,"tahara.aichi.jp":true,"takahama.aichi.jp":true,"tobishima.aichi.jp":true,"toei.aichi.jp":true,"togo.aichi.jp":true,"tokai.aichi.jp":true,"tokoname.aichi.jp":true,"toyoake.aichi.jp":true,"toyohashi.aichi.jp":true,"toyokawa.aichi.jp":true,"toyone.aichi.jp":true,"toyota.aichi.jp":true,"tsushima.aichi.jp":true,"yatomi.aichi.jp":true,"akita.akita.jp":true,"daisen.akita.jp":true,"fujisato.akita.jp":true,"gojome.akita.jp":true,"hachirogata.akita.jp":true,"happou.akita.jp":true,"higashinaruse.akita.jp":true,"honjo.akita.jp":true,"honjyo.akita.jp":true,"ikawa.akita.jp":true,"kamikoani.akita.jp":true,"kamioka.akita.jp":true,"katagami.akita.jp":true,"kazuno.akita.jp":true,"kitaakita.akita.jp":true,"kosaka.akita.jp":true,"kyowa.akita.jp":true,"misato.akita.jp":true,"mitane.akita.jp":true,"moriyoshi.akita.jp":true,"nikaho.akita.jp":true,"noshiro.akita.jp":true,"odate.akita.jp":true,"oga.akita.jp":true,"ogata.akita.jp":true,"semboku.akita.jp":true,"yokote.akita.jp":true,"yurihonjo.akita.jp":true,"aomori.aomori.jp":true,"gonohe.aomori.jp":true,"hachinohe.aomori.jp":true,"hashikami.aomori.jp":true,"hiranai.aomori.jp":true,"hirosaki.aomori.jp":true,"itayanagi.aomori.jp":true,"kuroishi.aomori.jp":true,"misawa.aomori.jp":true,"mutsu.aomori.jp":true,"nakadomari.aomori.jp":true,"noheji.aomori.jp":true,"oirase.aomori.jp":true,"owani.aomori.jp":true,"rokunohe.aomori.jp":true,"sannohe.aomori.jp":true,"shichinohe.aomori.jp":true,"shingo.aomori.jp":true,"takko.aomori.jp":true,"towada.aomori.jp":true,"tsugaru.aomori.jp":true,"tsuruta.aomori.jp":true,"abiko.chiba.jp":true,"asahi.chiba.jp":true,"chonan.chiba.jp":true,"chosei.chiba.jp":true,"choshi.chiba.jp":true,"chuo.chiba.jp":true,"funabashi.chiba.jp":true,"futtsu.chiba.jp":true,"hanamigawa.chiba.jp":true,"ichihara.chiba.jp":true,"ichikawa.chiba.jp":true,"ichinomiya.chiba.jp":true,"inzai.chiba.jp":true,"isumi.chiba.jp":true,"kamagaya.chiba.jp":true,"kamogawa.chiba.jp":true,"kashiwa.chiba.jp":true,"katori.chiba.jp":true,"katsuura.chiba.jp":true,"kimitsu.chiba.jp":true,"kisarazu.chiba.jp":true,"kozaki.chiba.jp":true,"kujukuri.chiba.jp":true,"kyonan.chiba.jp":true,"matsudo.chiba.jp":true,"midori.chiba.jp":true,"mihama.chiba.jp":true,"minamiboso.chiba.jp":true,"mobara.chiba.jp":true,"mutsuzawa.chiba.jp":true,"nagara.chiba.jp":true,"nagareyama.chiba.jp":true,"narashino.chiba.jp":true,"narita.chiba.jp":true,"noda.chiba.jp":true,"oamishirasato.chiba.jp":true,"omigawa.chiba.jp":true,"onjuku.chiba.jp":true,"otaki.chiba.jp":true,"sakae.chiba.jp":true,"sakura.chiba.jp":true,"shimofusa.chiba.jp":true,"shirako.chiba.jp":true,"shiroi.chiba.jp":true,"shisui.chiba.jp":true,"sodegaura.chiba.jp":true,"sosa.chiba.jp":true,"tako.chiba.jp":true,"tateyama.chiba.jp":true,"togane.chiba.jp":true,"tohnosho.chiba.jp":true,"tomisato.chiba.jp":true,"urayasu.chiba.jp":true,"yachimata.chiba.jp":true,"yachiyo.chiba.jp":true,"yokaichiba.chiba.jp":true,"yokoshibahikari.chiba.jp":true,"yotsukaido.chiba.jp":true,"ainan.ehime.jp":true,"honai.ehime.jp":true,"ikata.ehime.jp":true,"imabari.ehime.jp":true,"iyo.ehime.jp":true,"kamijima.ehime.jp":true,"kihoku.ehime.jp":true,"kumakogen.ehime.jp":true,"masaki.ehime.jp":true,"matsuno.ehime.jp":true,"matsuyama.ehime.jp":true,"namikata.ehime.jp":true,"niihama.ehime.jp":true,"ozu.ehime.jp":true,"saijo.ehime.jp":true,"seiyo.ehime.jp":true,"shikokuchuo.ehime.jp":true,"tobe.ehime.jp":true,"toon.ehime.jp":true,"uchiko.ehime.jp":true,"uwajima.ehime.jp":true,"yawatahama.ehime.jp":true,"echizen.fukui.jp":true,"eiheiji.fukui.jp":true,"fukui.fukui.jp":true,"ikeda.fukui.jp":true,"katsuyama.fukui.jp":true,"mihama.fukui.jp":true,"minamiechizen.fukui.jp":true,"obama.fukui.jp":true,"ohi.fukui.jp":true,"ono.fukui.jp":true,"sabae.fukui.jp":true,"sakai.fukui.jp":true,"takahama.fukui.jp":true,"tsuruga.fukui.jp":true,"wakasa.fukui.jp":true,"ashiya.fukuoka.jp":true,"buzen.fukuoka.jp":true,"chikugo.fukuoka.jp":true,"chikuho.fukuoka.jp":true,"chikujo.fukuoka.jp":true,"chikushino.fukuoka.jp":true,"chikuzen.fukuoka.jp":true,"chuo.fukuoka.jp":true,"dazaifu.fukuoka.jp":true,"fukuchi.fukuoka.jp":true,"hakata.fukuoka.jp":true,"higashi.fukuoka.jp":true,"hirokawa.fukuoka.jp":true,"hisayama.fukuoka.jp":true,"iizuka.fukuoka.jp":true,"inatsuki.fukuoka.jp":true,"kaho.fukuoka.jp":true,"kasuga.fukuoka.jp":true,"kasuya.fukuoka.jp":true,"kawara.fukuoka.jp":true,"keisen.fukuoka.jp":true,"koga.fukuoka.jp":true,"kurate.fukuoka.jp":true,"kurogi.fukuoka.jp":true,"kurume.fukuoka.jp":true,"minami.fukuoka.jp":true,"miyako.fukuoka.jp":true,"miyama.fukuoka.jp":true,"miyawaka.fukuoka.jp":true,"mizumaki.fukuoka.jp":true,"munakata.fukuoka.jp":true,"nakagawa.fukuoka.jp":true,"nakama.fukuoka.jp":true,"nishi.fukuoka.jp":true,"nogata.fukuoka.jp":true,"ogori.fukuoka.jp":true,"okagaki.fukuoka.jp":true,"okawa.fukuoka.jp":true,"oki.fukuoka.jp":true,"omuta.fukuoka.jp":true,"onga.fukuoka.jp":true,"onojo.fukuoka.jp":true,"oto.fukuoka.jp":true,"saigawa.fukuoka.jp":true,"sasaguri.fukuoka.jp":true,"shingu.fukuoka.jp":true,"shinyoshitomi.fukuoka.jp":true,"shonai.fukuoka.jp":true,"soeda.fukuoka.jp":true,"sue.fukuoka.jp":true,"tachiarai.fukuoka.jp":true,"tagawa.fukuoka.jp":true,"takata.fukuoka.jp":true,"toho.fukuoka.jp":true,"toyotsu.fukuoka.jp":true,"tsuiki.fukuoka.jp":true,"ukiha.fukuoka.jp":true,"umi.fukuoka.jp":true,"usui.fukuoka.jp":true,"yamada.fukuoka.jp":true,"yame.fukuoka.jp":true,"yanagawa.fukuoka.jp":true,"yukuhashi.fukuoka.jp":true,"aizubange.fukushima.jp":true,"aizumisato.fukushima.jp":true,"aizuwakamatsu.fukushima.jp":true,"asakawa.fukushima.jp":true,"bandai.fukushima.jp":true,"date.fukushima.jp":true,"fukushima.fukushima.jp":true,"furudono.fukushima.jp":true,"futaba.fukushima.jp":true,"hanawa.fukushima.jp":true,"higashi.fukushima.jp":true,"hirata.fukushima.jp":true,"hirono.fukushima.jp":true,"iitate.fukushima.jp":true,"inawashiro.fukushima.jp":true,"ishikawa.fukushima.jp":true,"iwaki.fukushima.jp":true,"izumizaki.fukushima.jp":true,"kagamiishi.fukushima.jp":true,"kaneyama.fukushima.jp":true,"kawamata.fukushima.jp":true,"kitakata.fukushima.jp":true,"kitashiobara.fukushima.jp":true,"koori.fukushima.jp":true,"koriyama.fukushima.jp":true,"kunimi.fukushima.jp":true,"miharu.fukushima.jp":true,"mishima.fukushima.jp":true,"namie.fukushima.jp":true,"nango.fukushima.jp":true,"nishiaizu.fukushima.jp":true,"nishigo.fukushima.jp":true,"okuma.fukushima.jp":true,"omotego.fukushima.jp":true,"ono.fukushima.jp":true,"otama.fukushima.jp":true,"samegawa.fukushima.jp":true,"shimogo.fukushima.jp":true,"shirakawa.fukushima.jp":true,"showa.fukushima.jp":true,"soma.fukushima.jp":true,"sukagawa.fukushima.jp":true,"taishin.fukushima.jp":true,"tamakawa.fukushima.jp":true,"tanagura.fukushima.jp":true,"tenei.fukushima.jp":true,"yabuki.fukushima.jp":true,"yamato.fukushima.jp":true,"yamatsuri.fukushima.jp":true,"yanaizu.fukushima.jp":true,"yugawa.fukushima.jp":true,"anpachi.gifu.jp":true,"ena.gifu.jp":true,"gifu.gifu.jp":true,"ginan.gifu.jp":true,"godo.gifu.jp":true,"gujo.gifu.jp":true,"hashima.gifu.jp":true,"hichiso.gifu.jp":true,"hida.gifu.jp":true,"higashishirakawa.gifu.jp":true,"ibigawa.gifu.jp":true,"ikeda.gifu.jp":true,"kakamigahara.gifu.jp":true,"kani.gifu.jp":true,"kasahara.gifu.jp":true,"kasamatsu.gifu.jp":true,"kawaue.gifu.jp":true,"kitagata.gifu.jp":true,"mino.gifu.jp":true,"minokamo.gifu.jp":true,"mitake.gifu.jp":true,"mizunami.gifu.jp":true,"motosu.gifu.jp":true,"nakatsugawa.gifu.jp":true,"ogaki.gifu.jp":true,"sakahogi.gifu.jp":true,"seki.gifu.jp":true,"sekigahara.gifu.jp":true,"shirakawa.gifu.jp":true,"tajimi.gifu.jp":true,"takayama.gifu.jp":true,"tarui.gifu.jp":true,"toki.gifu.jp":true,"tomika.gifu.jp":true,"wanouchi.gifu.jp":true,"yamagata.gifu.jp":true,"yaotsu.gifu.jp":true,"yoro.gifu.jp":true,"annaka.gunma.jp":true,"chiyoda.gunma.jp":true,"fujioka.gunma.jp":true,"higashiagatsuma.gunma.jp":true,"isesaki.gunma.jp":true,"itakura.gunma.jp":true,"kanna.gunma.jp":true,"kanra.gunma.jp":true,"katashina.gunma.jp":true,"kawaba.gunma.jp":true,"kiryu.gunma.jp":true,"kusatsu.gunma.jp":true,"maebashi.gunma.jp":true,"meiwa.gunma.jp":true,"midori.gunma.jp":true,"minakami.gunma.jp":true,"naganohara.gunma.jp":true,"nakanojo.gunma.jp":true,"nanmoku.gunma.jp":true,"numata.gunma.jp":true,"oizumi.gunma.jp":true,"ora.gunma.jp":true,"ota.gunma.jp":true,"shibukawa.gunma.jp":true,"shimonita.gunma.jp":true,"shinto.gunma.jp":true,"showa.gunma.jp":true,"takasaki.gunma.jp":true,"takayama.gunma.jp":true,"tamamura.gunma.jp":true,"tatebayashi.gunma.jp":true,"tomioka.gunma.jp":true,"tsukiyono.gunma.jp":true,"tsumagoi.gunma.jp":true,"ueno.gunma.jp":true,"yoshioka.gunma.jp":true,"asaminami.hiroshima.jp":true,"daiwa.hiroshima.jp":true,"etajima.hiroshima.jp":true,"fuchu.hiroshima.jp":true,"fukuyama.hiroshima.jp":true,"hatsukaichi.hiroshima.jp":true,"higashihiroshima.hiroshima.jp":true,"hongo.hiroshima.jp":true,"jinsekikogen.hiroshima.jp":true,"kaita.hiroshima.jp":true,"kui.hiroshima.jp":true,"kumano.hiroshima.jp":true,"kure.hiroshima.jp":true,"mihara.hiroshima.jp":true,"miyoshi.hiroshima.jp":true,"naka.hiroshima.jp":true,"onomichi.hiroshima.jp":true,"osakikamijima.hiroshima.jp":true,"otake.hiroshima.jp":true,"saka.hiroshima.jp":true,"sera.hiroshima.jp":true,"seranishi.hiroshima.jp":true,"shinichi.hiroshima.jp":true,"shobara.hiroshima.jp":true,"takehara.hiroshima.jp":true,"abashiri.hokkaido.jp":true,"abira.hokkaido.jp":true,"aibetsu.hokkaido.jp":true,"akabira.hokkaido.jp":true,"akkeshi.hokkaido.jp":true,"asahikawa.hokkaido.jp":true,"ashibetsu.hokkaido.jp":true,"ashoro.hokkaido.jp":true,"assabu.hokkaido.jp":true,"atsuma.hokkaido.jp":true,"bibai.hokkaido.jp":true,"biei.hokkaido.jp":true,"bifuka.hokkaido.jp":true,"bihoro.hokkaido.jp":true,"biratori.hokkaido.jp":true,"chippubetsu.hokkaido.jp":true,"chitose.hokkaido.jp":true,"date.hokkaido.jp":true,"ebetsu.hokkaido.jp":true,"embetsu.hokkaido.jp":true,"eniwa.hokkaido.jp":true,"erimo.hokkaido.jp":true,"esan.hokkaido.jp":true,"esashi.hokkaido.jp":true,"fukagawa.hokkaido.jp":true,"fukushima.hokkaido.jp":true,"furano.hokkaido.jp":true,"furubira.hokkaido.jp":true,"haboro.hokkaido.jp":true,"hakodate.hokkaido.jp":true,"hamatonbetsu.hokkaido.jp":true,"hidaka.hokkaido.jp":true,"higashikagura.hokkaido.jp":true,"higashikawa.hokkaido.jp":true,"hiroo.hokkaido.jp":true,"hokuryu.hokkaido.jp":true,"hokuto.hokkaido.jp":true,"honbetsu.hokkaido.jp":true,"horokanai.hokkaido.jp":true,"horonobe.hokkaido.jp":true,"ikeda.hokkaido.jp":true,"imakane.hokkaido.jp":true,"ishikari.hokkaido.jp":true,"iwamizawa.hokkaido.jp":true,"iwanai.hokkaido.jp":true,"kamifurano.hokkaido.jp":true,"kamikawa.hokkaido.jp":true,"kamishihoro.hokkaido.jp":true,"kamisunagawa.hokkaido.jp":true,"kamoenai.hokkaido.jp":true,"kayabe.hokkaido.jp":true,"kembuchi.hokkaido.jp":true,"kikonai.hokkaido.jp":true,"kimobetsu.hokkaido.jp":true,"kitahiroshima.hokkaido.jp":true,"kitami.hokkaido.jp":true,"kiyosato.hokkaido.jp":true,"koshimizu.hokkaido.jp":true,"kunneppu.hokkaido.jp":true,"kuriyama.hokkaido.jp":true,"kuromatsunai.hokkaido.jp":true,"kushiro.hokkaido.jp":true,"kutchan.hokkaido.jp":true,"kyowa.hokkaido.jp":true,"mashike.hokkaido.jp":true,"matsumae.hokkaido.jp":true,"mikasa.hokkaido.jp":true,"minamifurano.hokkaido.jp":true,"mombetsu.hokkaido.jp":true,"moseushi.hokkaido.jp":true,"mukawa.hokkaido.jp":true,"muroran.hokkaido.jp":true,"naie.hokkaido.jp":true,"nakagawa.hokkaido.jp":true,"nakasatsunai.hokkaido.jp":true,"nakatombetsu.hokkaido.jp":true,"nanae.hokkaido.jp":true,"nanporo.hokkaido.jp":true,"nayoro.hokkaido.jp":true,"nemuro.hokkaido.jp":true,"niikappu.hokkaido.jp":true,"niki.hokkaido.jp":true,"nishiokoppe.hokkaido.jp":true,"noboribetsu.hokkaido.jp":true,"numata.hokkaido.jp":true,"obihiro.hokkaido.jp":true,"obira.hokkaido.jp":true,"oketo.hokkaido.jp":true,"okoppe.hokkaido.jp":true,"otaru.hokkaido.jp":true,"otobe.hokkaido.jp":true,"otofuke.hokkaido.jp":true,"otoineppu.hokkaido.jp":true,"oumu.hokkaido.jp":true,"ozora.hokkaido.jp":true,"pippu.hokkaido.jp":true,"rankoshi.hokkaido.jp":true,"rebun.hokkaido.jp":true,"rikubetsu.hokkaido.jp":true,"rishiri.hokkaido.jp":true,"rishirifuji.hokkaido.jp":true,"saroma.hokkaido.jp":true,"sarufutsu.hokkaido.jp":true,"shakotan.hokkaido.jp":true,"shari.hokkaido.jp":true,"shibecha.hokkaido.jp":true,"shibetsu.hokkaido.jp":true,"shikabe.hokkaido.jp":true,"shikaoi.hokkaido.jp":true,"shimamaki.hokkaido.jp":true,"shimizu.hokkaido.jp":true,"shimokawa.hokkaido.jp":true,"shinshinotsu.hokkaido.jp":true,"shintoku.hokkaido.jp":true,"shiranuka.hokkaido.jp":true,"shiraoi.hokkaido.jp":true,"shiriuchi.hokkaido.jp":true,"sobetsu.hokkaido.jp":true,"sunagawa.hokkaido.jp":true,"taiki.hokkaido.jp":true,"takasu.hokkaido.jp":true,"takikawa.hokkaido.jp":true,"takinoue.hokkaido.jp":true,"teshikaga.hokkaido.jp":true,"tobetsu.hokkaido.jp":true,"tohma.hokkaido.jp":true,"tomakomai.hokkaido.jp":true,"tomari.hokkaido.jp":true,"toya.hokkaido.jp":true,"toyako.hokkaido.jp":true,"toyotomi.hokkaido.jp":true,"toyoura.hokkaido.jp":true,"tsubetsu.hokkaido.jp":true,"tsukigata.hokkaido.jp":true,"urakawa.hokkaido.jp":true,"urausu.hokkaido.jp":true,"uryu.hokkaido.jp":true,"utashinai.hokkaido.jp":true,"wakkanai.hokkaido.jp":true,"wassamu.hokkaido.jp":true,"yakumo.hokkaido.jp":true,"yoichi.hokkaido.jp":true,"aioi.hyogo.jp":true,"akashi.hyogo.jp":true,"ako.hyogo.jp":true,"amagasaki.hyogo.jp":true,"aogaki.hyogo.jp":true,"asago.hyogo.jp":true,"ashiya.hyogo.jp":true,"awaji.hyogo.jp":true,"fukusaki.hyogo.jp":true,"goshiki.hyogo.jp":true,"harima.hyogo.jp":true,"himeji.hyogo.jp":true,"ichikawa.hyogo.jp":true,"inagawa.hyogo.jp":true,"itami.hyogo.jp":true,"kakogawa.hyogo.jp":true,"kamigori.hyogo.jp":true,"kamikawa.hyogo.jp":true,"kasai.hyogo.jp":true,"kasuga.hyogo.jp":true,"kawanishi.hyogo.jp":true,"miki.hyogo.jp":true,"minamiawaji.hyogo.jp":true,"nishinomiya.hyogo.jp":true,"nishiwaki.hyogo.jp":true,"ono.hyogo.jp":true,"sanda.hyogo.jp":true,"sannan.hyogo.jp":true,"sasayama.hyogo.jp":true,"sayo.hyogo.jp":true,"shingu.hyogo.jp":true,"shinonsen.hyogo.jp":true,"shiso.hyogo.jp":true,"sumoto.hyogo.jp":true,"taishi.hyogo.jp":true,"taka.hyogo.jp":true,"takarazuka.hyogo.jp":true,"takasago.hyogo.jp":true,"takino.hyogo.jp":true,"tamba.hyogo.jp":true,"tatsuno.hyogo.jp":true,"toyooka.hyogo.jp":true,"yabu.hyogo.jp":true,"yashiro.hyogo.jp":true,"yoka.hyogo.jp":true,"yokawa.hyogo.jp":true,"ami.ibaraki.jp":true,"asahi.ibaraki.jp":true,"bando.ibaraki.jp":true,"chikusei.ibaraki.jp":true,"daigo.ibaraki.jp":true,"fujishiro.ibaraki.jp":true,"hitachi.ibaraki.jp":true,"hitachinaka.ibaraki.jp":true,"hitachiomiya.ibaraki.jp":true,"hitachiota.ibaraki.jp":true,"ibaraki.ibaraki.jp":true,"ina.ibaraki.jp":true,"inashiki.ibaraki.jp":true,"itako.ibaraki.jp":true,"iwama.ibaraki.jp":true,"joso.ibaraki.jp":true,"kamisu.ibaraki.jp":true,"kasama.ibaraki.jp":true,"kashima.ibaraki.jp":true,"kasumigaura.ibaraki.jp":true,"koga.ibaraki.jp":true,"miho.ibaraki.jp":true,"mito.ibaraki.jp":true,"moriya.ibaraki.jp":true,"naka.ibaraki.jp":true,"namegata.ibaraki.jp":true,"oarai.ibaraki.jp":true,"ogawa.ibaraki.jp":true,"omitama.ibaraki.jp":true,"ryugasaki.ibaraki.jp":true,"sakai.ibaraki.jp":true,"sakuragawa.ibaraki.jp":true,"shimodate.ibaraki.jp":true,"shimotsuma.ibaraki.jp":true,"shirosato.ibaraki.jp":true,"sowa.ibaraki.jp":true,"suifu.ibaraki.jp":true,"takahagi.ibaraki.jp":true,"tamatsukuri.ibaraki.jp":true,"tokai.ibaraki.jp":true,"tomobe.ibaraki.jp":true,"tone.ibaraki.jp":true,"toride.ibaraki.jp":true,"tsuchiura.ibaraki.jp":true,"tsukuba.ibaraki.jp":true,"uchihara.ibaraki.jp":true,"ushiku.ibaraki.jp":true,"yachiyo.ibaraki.jp":true,"yamagata.ibaraki.jp":true,"yawara.ibaraki.jp":true,"yuki.ibaraki.jp":true,"anamizu.ishikawa.jp":true,"hakui.ishikawa.jp":true,"hakusan.ishikawa.jp":true,"kaga.ishikawa.jp":true,"kahoku.ishikawa.jp":true,"kanazawa.ishikawa.jp":true,"kawakita.ishikawa.jp":true,"komatsu.ishikawa.jp":true,"nakanoto.ishikawa.jp":true,"nanao.ishikawa.jp":true,"nomi.ishikawa.jp":true,"nonoichi.ishikawa.jp":true,"noto.ishikawa.jp":true,"shika.ishikawa.jp":true,"suzu.ishikawa.jp":true,"tsubata.ishikawa.jp":true,"tsurugi.ishikawa.jp":true,"uchinada.ishikawa.jp":true,"wajima.ishikawa.jp":true,"fudai.iwate.jp":true,"fujisawa.iwate.jp":true,"hanamaki.iwate.jp":true,"hiraizumi.iwate.jp":true,"hirono.iwate.jp":true,"ichinohe.iwate.jp":true,"ichinoseki.iwate.jp":true,"iwaizumi.iwate.jp":true,"iwate.iwate.jp":true,"joboji.iwate.jp":true,"kamaishi.iwate.jp":true,"kanegasaki.iwate.jp":true,"karumai.iwate.jp":true,"kawai.iwate.jp":true,"kitakami.iwate.jp":true,"kuji.iwate.jp":true,"kunohe.iwate.jp":true,"kuzumaki.iwate.jp":true,"miyako.iwate.jp":true,"mizusawa.iwate.jp":true,"morioka.iwate.jp":true,"ninohe.iwate.jp":true,"noda.iwate.jp":true,"ofunato.iwate.jp":true,"oshu.iwate.jp":true,"otsuchi.iwate.jp":true,"rikuzentakata.iwate.jp":true,"shiwa.iwate.jp":true,"shizukuishi.iwate.jp":true,"sumita.iwate.jp":true,"tanohata.iwate.jp":true,"tono.iwate.jp":true,"yahaba.iwate.jp":true,"yamada.iwate.jp":true,"ayagawa.kagawa.jp":true,"higashikagawa.kagawa.jp":true,"kanonji.kagawa.jp":true,"kotohira.kagawa.jp":true,"manno.kagawa.jp":true,"marugame.kagawa.jp":true,"mitoyo.kagawa.jp":true,"naoshima.kagawa.jp":true,"sanuki.kagawa.jp":true,"tadotsu.kagawa.jp":true,"takamatsu.kagawa.jp":true,"tonosho.kagawa.jp":true,"uchinomi.kagawa.jp":true,"utazu.kagawa.jp":true,"zentsuji.kagawa.jp":true,"akune.kagoshima.jp":true,"amami.kagoshima.jp":true,"hioki.kagoshima.jp":true,"isa.kagoshima.jp":true,"isen.kagoshima.jp":true,"izumi.kagoshima.jp":true,"kagoshima.kagoshima.jp":true,"kanoya.kagoshima.jp":true,"kawanabe.kagoshima.jp":true,"kinko.kagoshima.jp":true,"kouyama.kagoshima.jp":true,"makurazaki.kagoshima.jp":true,"matsumoto.kagoshima.jp":true,"minamitane.kagoshima.jp":true,"nakatane.kagoshima.jp":true,"nishinoomote.kagoshima.jp":true,"satsumasendai.kagoshima.jp":true,"soo.kagoshima.jp":true,"tarumizu.kagoshima.jp":true,"yusui.kagoshima.jp":true,"aikawa.kanagawa.jp":true,"atsugi.kanagawa.jp":true,"ayase.kanagawa.jp":true,"chigasaki.kanagawa.jp":true,"ebina.kanagawa.jp":true,"fujisawa.kanagawa.jp":true,"hadano.kanagawa.jp":true,"hakone.kanagawa.jp":true,"hiratsuka.kanagawa.jp":true,"isehara.kanagawa.jp":true,"kaisei.kanagawa.jp":true,"kamakura.kanagawa.jp":true,"kiyokawa.kanagawa.jp":true,"matsuda.kanagawa.jp":true,"minamiashigara.kanagawa.jp":true,"miura.kanagawa.jp":true,"nakai.kanagawa.jp":true,"ninomiya.kanagawa.jp":true,"odawara.kanagawa.jp":true,"oi.kanagawa.jp":true,"oiso.kanagawa.jp":true,"sagamihara.kanagawa.jp":true,"samukawa.kanagawa.jp":true,"tsukui.kanagawa.jp":true,"yamakita.kanagawa.jp":true,"yamato.kanagawa.jp":true,"yokosuka.kanagawa.jp":true,"yugawara.kanagawa.jp":true,"zama.kanagawa.jp":true,"zushi.kanagawa.jp":true,"aki.kochi.jp":true,"geisei.kochi.jp":true,"hidaka.kochi.jp":true,"higashitsuno.kochi.jp":true,"ino.kochi.jp":true,"kagami.kochi.jp":true,"kami.kochi.jp":true,"kitagawa.kochi.jp":true,"kochi.kochi.jp":true,"mihara.kochi.jp":true,"motoyama.kochi.jp":true,"muroto.kochi.jp":true,"nahari.kochi.jp":true,"nakamura.kochi.jp":true,"nankoku.kochi.jp":true,"nishitosa.kochi.jp":true,"niyodogawa.kochi.jp":true,"ochi.kochi.jp":true,"okawa.kochi.jp":true,"otoyo.kochi.jp":true,"otsuki.kochi.jp":true,"sakawa.kochi.jp":true,"sukumo.kochi.jp":true,"susaki.kochi.jp":true,"tosa.kochi.jp":true,"tosashimizu.kochi.jp":true,"toyo.kochi.jp":true,"tsuno.kochi.jp":true,"umaji.kochi.jp":true,"yasuda.kochi.jp":true,"yusuhara.kochi.jp":true,"amakusa.kumamoto.jp":true,"arao.kumamoto.jp":true,"aso.kumamoto.jp":true,"choyo.kumamoto.jp":true,"gyokuto.kumamoto.jp":true,"hitoyoshi.kumamoto.jp":true,"kamiamakusa.kumamoto.jp":true,"kashima.kumamoto.jp":true,"kikuchi.kumamoto.jp":true,"kosa.kumamoto.jp":true,"kumamoto.kumamoto.jp":true,"mashiki.kumamoto.jp":true,"mifune.kumamoto.jp":true,"minamata.kumamoto.jp":true,"minamioguni.kumamoto.jp":true,"nagasu.kumamoto.jp":true,"nishihara.kumamoto.jp":true,"oguni.kumamoto.jp":true,"ozu.kumamoto.jp":true,"sumoto.kumamoto.jp":true,"takamori.kumamoto.jp":true,"uki.kumamoto.jp":true,"uto.kumamoto.jp":true,"yamaga.kumamoto.jp":true,"yamato.kumamoto.jp":true,"yatsushiro.kumamoto.jp":true,"ayabe.kyoto.jp":true,"fukuchiyama.kyoto.jp":true,"higashiyama.kyoto.jp":true,"ide.kyoto.jp":true,"ine.kyoto.jp":true,"joyo.kyoto.jp":true,"kameoka.kyoto.jp":true,"kamo.kyoto.jp":true,"kita.kyoto.jp":true,"kizu.kyoto.jp":true,"kumiyama.kyoto.jp":true,"kyotamba.kyoto.jp":true,"kyotanabe.kyoto.jp":true,"kyotango.kyoto.jp":true,"maizuru.kyoto.jp":true,"minami.kyoto.jp":true,"minamiyamashiro.kyoto.jp":true,"miyazu.kyoto.jp":true,"muko.kyoto.jp":true,"nagaokakyo.kyoto.jp":true,"nakagyo.kyoto.jp":true,"nantan.kyoto.jp":true,"oyamazaki.kyoto.jp":true,"sakyo.kyoto.jp":true,"seika.kyoto.jp":true,"tanabe.kyoto.jp":true,"uji.kyoto.jp":true,"ujitawara.kyoto.jp":true,"wazuka.kyoto.jp":true,"yamashina.kyoto.jp":true,"yawata.kyoto.jp":true,"asahi.mie.jp":true,"inabe.mie.jp":true,"ise.mie.jp":true,"kameyama.mie.jp":true,"kawagoe.mie.jp":true,"kiho.mie.jp":true,"kisosaki.mie.jp":true,"kiwa.mie.jp":true,"komono.mie.jp":true,"kumano.mie.jp":true,"kuwana.mie.jp":true,"matsusaka.mie.jp":true,"meiwa.mie.jp":true,"mihama.mie.jp":true,"minamiise.mie.jp":true,"misugi.mie.jp":true,"miyama.mie.jp":true,"nabari.mie.jp":true,"shima.mie.jp":true,"suzuka.mie.jp":true,"tado.mie.jp":true,"taiki.mie.jp":true,"taki.mie.jp":true,"tamaki.mie.jp":true,"toba.mie.jp":true,"tsu.mie.jp":true,"udono.mie.jp":true,"ureshino.mie.jp":true,"watarai.mie.jp":true,"yokkaichi.mie.jp":true,"furukawa.miyagi.jp":true,"higashimatsushima.miyagi.jp":true,"ishinomaki.miyagi.jp":true,"iwanuma.miyagi.jp":true,"kakuda.miyagi.jp":true,"kami.miyagi.jp":true,"kawasaki.miyagi.jp":true,"kesennuma.miyagi.jp":true,"marumori.miyagi.jp":true,"matsushima.miyagi.jp":true,"minamisanriku.miyagi.jp":true,"misato.miyagi.jp":true,"murata.miyagi.jp":true,"natori.miyagi.jp":true,"ogawara.miyagi.jp":true,"ohira.miyagi.jp":true,"onagawa.miyagi.jp":true,"osaki.miyagi.jp":true,"rifu.miyagi.jp":true,"semine.miyagi.jp":true,"shibata.miyagi.jp":true,"shichikashuku.miyagi.jp":true,"shikama.miyagi.jp":true,"shiogama.miyagi.jp":true,"shiroishi.miyagi.jp":true,"tagajo.miyagi.jp":true,"taiwa.miyagi.jp":true,"tome.miyagi.jp":true,"tomiya.miyagi.jp":true,"wakuya.miyagi.jp":true,"watari.miyagi.jp":true,"yamamoto.miyagi.jp":true,"zao.miyagi.jp":true,"aya.miyazaki.jp":true,"ebino.miyazaki.jp":true,"gokase.miyazaki.jp":true,"hyuga.miyazaki.jp":true,"kadogawa.miyazaki.jp":true,"kawaminami.miyazaki.jp":true,"kijo.miyazaki.jp":true,"kitagawa.miyazaki.jp":true,"kitakata.miyazaki.jp":true,"kitaura.miyazaki.jp":true,"kobayashi.miyazaki.jp":true,"kunitomi.miyazaki.jp":true,"kushima.miyazaki.jp":true,"mimata.miyazaki.jp":true,"miyakonojo.miyazaki.jp":true,"miyazaki.miyazaki.jp":true,"morotsuka.miyazaki.jp":true,"nichinan.miyazaki.jp":true,"nishimera.miyazaki.jp":true,"nobeoka.miyazaki.jp":true,"saito.miyazaki.jp":true,"shiiba.miyazaki.jp":true,"shintomi.miyazaki.jp":true,"takaharu.miyazaki.jp":true,"takanabe.miyazaki.jp":true,"takazaki.miyazaki.jp":true,"tsuno.miyazaki.jp":true,"achi.nagano.jp":true,"agematsu.nagano.jp":true,"anan.nagano.jp":true,"aoki.nagano.jp":true,"asahi.nagano.jp":true,"azumino.nagano.jp":true,"chikuhoku.nagano.jp":true,"chikuma.nagano.jp":true,"chino.nagano.jp":true,"fujimi.nagano.jp":true,"hakuba.nagano.jp":true,"hara.nagano.jp":true,"hiraya.nagano.jp":true,"iida.nagano.jp":true,"iijima.nagano.jp":true,"iiyama.nagano.jp":true,"iizuna.nagano.jp":true,"ikeda.nagano.jp":true,"ikusaka.nagano.jp":true,"ina.nagano.jp":true,"karuizawa.nagano.jp":true,"kawakami.nagano.jp":true,"kiso.nagano.jp":true,"kisofukushima.nagano.jp":true,"kitaaiki.nagano.jp":true,"komagane.nagano.jp":true,"komoro.nagano.jp":true,"matsukawa.nagano.jp":true,"matsumoto.nagano.jp":true,"miasa.nagano.jp":true,"minamiaiki.nagano.jp":true,"minamimaki.nagano.jp":true,"minamiminowa.nagano.jp":true,"minowa.nagano.jp":true,"miyada.nagano.jp":true,"miyota.nagano.jp":true,"mochizuki.nagano.jp":true,"nagano.nagano.jp":true,"nagawa.nagano.jp":true,"nagiso.nagano.jp":true,"nakagawa.nagano.jp":true,"nakano.nagano.jp":true,"nozawaonsen.nagano.jp":true,"obuse.nagano.jp":true,"ogawa.nagano.jp":true,"okaya.nagano.jp":true,"omachi.nagano.jp":true,"omi.nagano.jp":true,"ookuwa.nagano.jp":true,"ooshika.nagano.jp":true,"otaki.nagano.jp":true,"otari.nagano.jp":true,"sakae.nagano.jp":true,"sakaki.nagano.jp":true,"saku.nagano.jp":true,"sakuho.nagano.jp":true,"shimosuwa.nagano.jp":true,"shinanomachi.nagano.jp":true,"shiojiri.nagano.jp":true,"suwa.nagano.jp":true,"suzaka.nagano.jp":true,"takagi.nagano.jp":true,"takamori.nagano.jp":true,"takayama.nagano.jp":true,"tateshina.nagano.jp":true,"tatsuno.nagano.jp":true,"togakushi.nagano.jp":true,"togura.nagano.jp":true,"tomi.nagano.jp":true,"ueda.nagano.jp":true,"wada.nagano.jp":true,"yamagata.nagano.jp":true,"yamanouchi.nagano.jp":true,"yasaka.nagano.jp":true,"yasuoka.nagano.jp":true,"chijiwa.nagasaki.jp":true,"futsu.nagasaki.jp":true,"goto.nagasaki.jp":true,"hasami.nagasaki.jp":true,"hirado.nagasaki.jp":true,"iki.nagasaki.jp":true,"isahaya.nagasaki.jp":true,"kawatana.nagasaki.jp":true,"kuchinotsu.nagasaki.jp":true,"matsuura.nagasaki.jp":true,"nagasaki.nagasaki.jp":true,"obama.nagasaki.jp":true,"omura.nagasaki.jp":true,"oseto.nagasaki.jp":true,"saikai.nagasaki.jp":true,"sasebo.nagasaki.jp":true,"seihi.nagasaki.jp":true,"shimabara.nagasaki.jp":true,"shinkamigoto.nagasaki.jp":true,"togitsu.nagasaki.jp":true,"tsushima.nagasaki.jp":true,"unzen.nagasaki.jp":true,"ando.nara.jp":true,"gose.nara.jp":true,"heguri.nara.jp":true,"higashiyoshino.nara.jp":true,"ikaruga.nara.jp":true,"ikoma.nara.jp":true,"kamikitayama.nara.jp":true,"kanmaki.nara.jp":true,"kashiba.nara.jp":true,"kashihara.nara.jp":true,"katsuragi.nara.jp":true,"kawai.nara.jp":true,"kawakami.nara.jp":true,"kawanishi.nara.jp":true,"koryo.nara.jp":true,"kurotaki.nara.jp":true,"mitsue.nara.jp":true,"miyake.nara.jp":true,"nara.nara.jp":true,"nosegawa.nara.jp":true,"oji.nara.jp":true,"ouda.nara.jp":true,"oyodo.nara.jp":true,"sakurai.nara.jp":true,"sango.nara.jp":true,"shimoichi.nara.jp":true,"shimokitayama.nara.jp":true,"shinjo.nara.jp":true,"soni.nara.jp":true,"takatori.nara.jp":true,"tawaramoto.nara.jp":true,"tenkawa.nara.jp":true,"tenri.nara.jp":true,"uda.nara.jp":true,"yamatokoriyama.nara.jp":true,"yamatotakada.nara.jp":true,"yamazoe.nara.jp":true,"yoshino.nara.jp":true,"aga.niigata.jp":true,"agano.niigata.jp":true,"gosen.niigata.jp":true,"itoigawa.niigata.jp":true,"izumozaki.niigata.jp":true,"joetsu.niigata.jp":true,"kamo.niigata.jp":true,"kariwa.niigata.jp":true,"kashiwazaki.niigata.jp":true,"minamiuonuma.niigata.jp":true,"mitsuke.niigata.jp":true,"muika.niigata.jp":true,"murakami.niigata.jp":true,"myoko.niigata.jp":true,"nagaoka.niigata.jp":true,"niigata.niigata.jp":true,"ojiya.niigata.jp":true,"omi.niigata.jp":true,"sado.niigata.jp":true,"sanjo.niigata.jp":true,"seiro.niigata.jp":true,"seirou.niigata.jp":true,"sekikawa.niigata.jp":true,"shibata.niigata.jp":true,"tagami.niigata.jp":true,"tainai.niigata.jp":true,"tochio.niigata.jp":true,"tokamachi.niigata.jp":true,"tsubame.niigata.jp":true,"tsunan.niigata.jp":true,"uonuma.niigata.jp":true,"yahiko.niigata.jp":true,"yoita.niigata.jp":true,"yuzawa.niigata.jp":true,"beppu.oita.jp":true,"bungoono.oita.jp":true,"bungotakada.oita.jp":true,"hasama.oita.jp":true,"hiji.oita.jp":true,"himeshima.oita.jp":true,"hita.oita.jp":true,"kamitsue.oita.jp":true,"kokonoe.oita.jp":true,"kuju.oita.jp":true,"kunisaki.oita.jp":true,"kusu.oita.jp":true,"oita.oita.jp":true,"saiki.oita.jp":true,"taketa.oita.jp":true,"tsukumi.oita.jp":true,"usa.oita.jp":true,"usuki.oita.jp":true,"yufu.oita.jp":true,"akaiwa.okayama.jp":true,"asakuchi.okayama.jp":true,"bizen.okayama.jp":true,"hayashima.okayama.jp":true,"ibara.okayama.jp":true,"kagamino.okayama.jp":true,"kasaoka.okayama.jp":true,"kibichuo.okayama.jp":true,"kumenan.okayama.jp":true,"kurashiki.okayama.jp":true,"maniwa.okayama.jp":true,"misaki.okayama.jp":true,"nagi.okayama.jp":true,"niimi.okayama.jp":true,"nishiawakura.okayama.jp":true,"okayama.okayama.jp":true,"satosho.okayama.jp":true,"setouchi.okayama.jp":true,"shinjo.okayama.jp":true,"shoo.okayama.jp":true,"soja.okayama.jp":true,"takahashi.okayama.jp":true,"tamano.okayama.jp":true,"tsuyama.okayama.jp":true,"wake.okayama.jp":true,"yakage.okayama.jp":true,"aguni.okinawa.jp":true,"ginowan.okinawa.jp":true,"ginoza.okinawa.jp":true,"gushikami.okinawa.jp":true,"haebaru.okinawa.jp":true,"higashi.okinawa.jp":true,"hirara.okinawa.jp":true,"iheya.okinawa.jp":true,"ishigaki.okinawa.jp":true,"ishikawa.okinawa.jp":true,"itoman.okinawa.jp":true,"izena.okinawa.jp":true,"kadena.okinawa.jp":true,"kin.okinawa.jp":true,"kitadaito.okinawa.jp":true,"kitanakagusuku.okinawa.jp":true,"kumejima.okinawa.jp":true,"kunigami.okinawa.jp":true,"minamidaito.okinawa.jp":true,"motobu.okinawa.jp":true,"nago.okinawa.jp":true,"naha.okinawa.jp":true,"nakagusuku.okinawa.jp":true,"nakijin.okinawa.jp":true,"nanjo.okinawa.jp":true,"nishihara.okinawa.jp":true,"ogimi.okinawa.jp":true,"okinawa.okinawa.jp":true,"onna.okinawa.jp":true,"shimoji.okinawa.jp":true,"taketomi.okinawa.jp":true,"tarama.okinawa.jp":true,"tokashiki.okinawa.jp":true,"tomigusuku.okinawa.jp":true,"tonaki.okinawa.jp":true,"urasoe.okinawa.jp":true,"uruma.okinawa.jp":true,"yaese.okinawa.jp":true,"yomitan.okinawa.jp":true,"yonabaru.okinawa.jp":true,"yonaguni.okinawa.jp":true,"zamami.okinawa.jp":true,"abeno.osaka.jp":true,"chihayaakasaka.osaka.jp":true,"chuo.osaka.jp":true,"daito.osaka.jp":true,"fujiidera.osaka.jp":true,"habikino.osaka.jp":true,"hannan.osaka.jp":true,"higashiosaka.osaka.jp":true,"higashisumiyoshi.osaka.jp":true,"higashiyodogawa.osaka.jp":true,"hirakata.osaka.jp":true,"ibaraki.osaka.jp":true,"ikeda.osaka.jp":true,"izumi.osaka.jp":true,"izumiotsu.osaka.jp":true,"izumisano.osaka.jp":true,"kadoma.osaka.jp":true,"kaizuka.osaka.jp":true,"kanan.osaka.jp":true,"kashiwara.osaka.jp":true,"katano.osaka.jp":true,"kawachinagano.osaka.jp":true,"kishiwada.osaka.jp":true,"kita.osaka.jp":true,"kumatori.osaka.jp":true,"matsubara.osaka.jp":true,"minato.osaka.jp":true,"minoh.osaka.jp":true,"misaki.osaka.jp":true,"moriguchi.osaka.jp":true,"neyagawa.osaka.jp":true,"nishi.osaka.jp":true,"nose.osaka.jp":true,"osakasayama.osaka.jp":true,"sakai.osaka.jp":true,"sayama.osaka.jp":true,"sennan.osaka.jp":true,"settsu.osaka.jp":true,"shijonawate.osaka.jp":true,"shimamoto.osaka.jp":true,"suita.osaka.jp":true,"tadaoka.osaka.jp":true,"taishi.osaka.jp":true,"tajiri.osaka.jp":true,"takaishi.osaka.jp":true,"takatsuki.osaka.jp":true,"tondabayashi.osaka.jp":true,"toyonaka.osaka.jp":true,"toyono.osaka.jp":true,"yao.osaka.jp":true,"ariake.saga.jp":true,"arita.saga.jp":true,"fukudomi.saga.jp":true,"genkai.saga.jp":true,"hamatama.saga.jp":true,"hizen.saga.jp":true,"imari.saga.jp":true,"kamimine.saga.jp":true,"kanzaki.saga.jp":true,"karatsu.saga.jp":true,"kashima.saga.jp":true,"kitagata.saga.jp":true,"kitahata.saga.jp":true,"kiyama.saga.jp":true,"kouhoku.saga.jp":true,"kyuragi.saga.jp":true,"nishiarita.saga.jp":true,"ogi.saga.jp":true,"omachi.saga.jp":true,"ouchi.saga.jp":true,"saga.saga.jp":true,"shiroishi.saga.jp":true,"taku.saga.jp":true,"tara.saga.jp":true,"tosu.saga.jp":true,"yoshinogari.saga.jp":true,"arakawa.saitama.jp":true,"asaka.saitama.jp":true,"chichibu.saitama.jp":true,"fujimi.saitama.jp":true,"fujimino.saitama.jp":true,"fukaya.saitama.jp":true,"hanno.saitama.jp":true,"hanyu.saitama.jp":true,"hasuda.saitama.jp":true,"hatogaya.saitama.jp":true,"hatoyama.saitama.jp":true,"hidaka.saitama.jp":true,"higashichichibu.saitama.jp":true,"higashimatsuyama.saitama.jp":true,"honjo.saitama.jp":true,"ina.saitama.jp":true,"iruma.saitama.jp":true,"iwatsuki.saitama.jp":true,"kamiizumi.saitama.jp":true,"kamikawa.saitama.jp":true,"kamisato.saitama.jp":true,"kasukabe.saitama.jp":true,"kawagoe.saitama.jp":true,"kawaguchi.saitama.jp":true,"kawajima.saitama.jp":true,"kazo.saitama.jp":true,"kitamoto.saitama.jp":true,"koshigaya.saitama.jp":true,"kounosu.saitama.jp":true,"kuki.saitama.jp":true,"kumagaya.saitama.jp":true,"matsubushi.saitama.jp":true,"minano.saitama.jp":true,"misato.saitama.jp":true,"miyashiro.saitama.jp":true,"miyoshi.saitama.jp":true,"moroyama.saitama.jp":true,"nagatoro.saitama.jp":true,"namegawa.saitama.jp":true,"niiza.saitama.jp":true,"ogano.saitama.jp":true,"ogawa.saitama.jp":true,"ogose.saitama.jp":true,"okegawa.saitama.jp":true,"omiya.saitama.jp":true,"otaki.saitama.jp":true,"ranzan.saitama.jp":true,"ryokami.saitama.jp":true,"saitama.saitama.jp":true,"sakado.saitama.jp":true,"satte.saitama.jp":true,"sayama.saitama.jp":true,"shiki.saitama.jp":true,"shiraoka.saitama.jp":true,"soka.saitama.jp":true,"sugito.saitama.jp":true,"toda.saitama.jp":true,"tokigawa.saitama.jp":true,"tokorozawa.saitama.jp":true,"tsurugashima.saitama.jp":true,"urawa.saitama.jp":true,"warabi.saitama.jp":true,"yashio.saitama.jp":true,"yokoze.saitama.jp":true,"yono.saitama.jp":true,"yorii.saitama.jp":true,"yoshida.saitama.jp":true,"yoshikawa.saitama.jp":true,"yoshimi.saitama.jp":true,"aisho.shiga.jp":true,"gamo.shiga.jp":true,"higashiomi.shiga.jp":true,"hikone.shiga.jp":true,"koka.shiga.jp":true,"konan.shiga.jp":true,"kosei.shiga.jp":true,"koto.shiga.jp":true,"kusatsu.shiga.jp":true,"maibara.shiga.jp":true,"moriyama.shiga.jp":true,"nagahama.shiga.jp":true,"nishiazai.shiga.jp":true,"notogawa.shiga.jp":true,"omihachiman.shiga.jp":true,"otsu.shiga.jp":true,"ritto.shiga.jp":true,"ryuoh.shiga.jp":true,"takashima.shiga.jp":true,"takatsuki.shiga.jp":true,"torahime.shiga.jp":true,"toyosato.shiga.jp":true,"yasu.shiga.jp":true,"akagi.shimane.jp":true,"ama.shimane.jp":true,"gotsu.shimane.jp":true,"hamada.shimane.jp":true,"higashiizumo.shimane.jp":true,"hikawa.shimane.jp":true,"hikimi.shimane.jp":true,"izumo.shimane.jp":true,"kakinoki.shimane.jp":true,"masuda.shimane.jp":true,"matsue.shimane.jp":true,"misato.shimane.jp":true,"nishinoshima.shimane.jp":true,"ohda.shimane.jp":true,"okinoshima.shimane.jp":true,"okuizumo.shimane.jp":true,"shimane.shimane.jp":true,"tamayu.shimane.jp":true,"tsuwano.shimane.jp":true,"unnan.shimane.jp":true,"yakumo.shimane.jp":true,"yasugi.shimane.jp":true,"yatsuka.shimane.jp":true,"arai.shizuoka.jp":true,"atami.shizuoka.jp":true,"fuji.shizuoka.jp":true,"fujieda.shizuoka.jp":true,"fujikawa.shizuoka.jp":true,"fujinomiya.shizuoka.jp":true,"fukuroi.shizuoka.jp":true,"gotemba.shizuoka.jp":true,"haibara.shizuoka.jp":true,"hamamatsu.shizuoka.jp":true,"higashiizu.shizuoka.jp":true,"ito.shizuoka.jp":true,"iwata.shizuoka.jp":true,"izu.shizuoka.jp":true,"izunokuni.shizuoka.jp":true,"kakegawa.shizuoka.jp":true,"kannami.shizuoka.jp":true,"kawanehon.shizuoka.jp":true,"kawazu.shizuoka.jp":true,"kikugawa.shizuoka.jp":true,"kosai.shizuoka.jp":true,"makinohara.shizuoka.jp":true,"matsuzaki.shizuoka.jp":true,"minamiizu.shizuoka.jp":true,"mishima.shizuoka.jp":true,"morimachi.shizuoka.jp":true,"nishiizu.shizuoka.jp":true,"numazu.shizuoka.jp":true,"omaezaki.shizuoka.jp":true,"shimada.shizuoka.jp":true,"shimizu.shizuoka.jp":true,"shimoda.shizuoka.jp":true,"shizuoka.shizuoka.jp":true,"susono.shizuoka.jp":true,"yaizu.shizuoka.jp":true,"yoshida.shizuoka.jp":true,"ashikaga.tochigi.jp":true,"bato.tochigi.jp":true,"haga.tochigi.jp":true,"ichikai.tochigi.jp":true,"iwafune.tochigi.jp":true,"kaminokawa.tochigi.jp":true,"kanuma.tochigi.jp":true,"karasuyama.tochigi.jp":true,"kuroiso.tochigi.jp":true,"mashiko.tochigi.jp":true,"mibu.tochigi.jp":true,"moka.tochigi.jp":true,"motegi.tochigi.jp":true,"nasu.tochigi.jp":true,"nasushiobara.tochigi.jp":true,"nikko.tochigi.jp":true,"nishikata.tochigi.jp":true,"nogi.tochigi.jp":true,"ohira.tochigi.jp":true,"ohtawara.tochigi.jp":true,"oyama.tochigi.jp":true,"sakura.tochigi.jp":true,"sano.tochigi.jp":true,"shimotsuke.tochigi.jp":true,"shioya.tochigi.jp":true,"takanezawa.tochigi.jp":true,"tochigi.tochigi.jp":true,"tsuga.tochigi.jp":true,"ujiie.tochigi.jp":true,"utsunomiya.tochigi.jp":true,"yaita.tochigi.jp":true,"aizumi.tokushima.jp":true,"anan.tokushima.jp":true,"ichiba.tokushima.jp":true,"itano.tokushima.jp":true,"kainan.tokushima.jp":true,"komatsushima.tokushima.jp":true,"matsushige.tokushima.jp":true,"mima.tokushima.jp":true,"minami.tokushima.jp":true,"miyoshi.tokushima.jp":true,"mugi.tokushima.jp":true,"nakagawa.tokushima.jp":true,"naruto.tokushima.jp":true,"sanagochi.tokushima.jp":true,"shishikui.tokushima.jp":true,"tokushima.tokushima.jp":true,"wajiki.tokushima.jp":true,"adachi.tokyo.jp":true,"akiruno.tokyo.jp":true,"akishima.tokyo.jp":true,"aogashima.tokyo.jp":true,"arakawa.tokyo.jp":true,"bunkyo.tokyo.jp":true,"chiyoda.tokyo.jp":true,"chofu.tokyo.jp":true,"chuo.tokyo.jp":true,"edogawa.tokyo.jp":true,"fuchu.tokyo.jp":true,"fussa.tokyo.jp":true,"hachijo.tokyo.jp":true,"hachioji.tokyo.jp":true,"hamura.tokyo.jp":true,"higashikurume.tokyo.jp":true,"higashimurayama.tokyo.jp":true,"higashiyamato.tokyo.jp":true,"hino.tokyo.jp":true,"hinode.tokyo.jp":true,"hinohara.tokyo.jp":true,"inagi.tokyo.jp":true,"itabashi.tokyo.jp":true,"katsushika.tokyo.jp":true,"kita.tokyo.jp":true,"kiyose.tokyo.jp":true,"kodaira.tokyo.jp":true,"koganei.tokyo.jp":true,"kokubunji.tokyo.jp":true,"komae.tokyo.jp":true,"koto.tokyo.jp":true,"kouzushima.tokyo.jp":true,"kunitachi.tokyo.jp":true,"machida.tokyo.jp":true,"meguro.tokyo.jp":true,"minato.tokyo.jp":true,"mitaka.tokyo.jp":true,"mizuho.tokyo.jp":true,"musashimurayama.tokyo.jp":true,"musashino.tokyo.jp":true,"nakano.tokyo.jp":true,"nerima.tokyo.jp":true,"ogasawara.tokyo.jp":true,"okutama.tokyo.jp":true,"ome.tokyo.jp":true,"oshima.tokyo.jp":true,"ota.tokyo.jp":true,"setagaya.tokyo.jp":true,"shibuya.tokyo.jp":true,"shinagawa.tokyo.jp":true,"shinjuku.tokyo.jp":true,"suginami.tokyo.jp":true,"sumida.tokyo.jp":true,"tachikawa.tokyo.jp":true,"taito.tokyo.jp":true,"tama.tokyo.jp":true,"toshima.tokyo.jp":true,"chizu.tottori.jp":true,"hino.tottori.jp":true,"kawahara.tottori.jp":true,"koge.tottori.jp":true,"kotoura.tottori.jp":true,"misasa.tottori.jp":true,"nanbu.tottori.jp":true,"nichinan.tottori.jp":true,"sakaiminato.tottori.jp":true,"tottori.tottori.jp":true,"wakasa.tottori.jp":true,"yazu.tottori.jp":true,"yonago.tottori.jp":true,"asahi.toyama.jp":true,"fuchu.toyama.jp":true,"fukumitsu.toyama.jp":true,"funahashi.toyama.jp":true,"himi.toyama.jp":true,"imizu.toyama.jp":true,"inami.toyama.jp":true,"johana.toyama.jp":true,"kamiichi.toyama.jp":true,"kurobe.toyama.jp":true,"nakaniikawa.toyama.jp":true,"namerikawa.toyama.jp":true,"nanto.toyama.jp":true,"nyuzen.toyama.jp":true,"oyabe.toyama.jp":true,"taira.toyama.jp":true,"takaoka.toyama.jp":true,"tateyama.toyama.jp":true,"toga.toyama.jp":true,"tonami.toyama.jp":true,"toyama.toyama.jp":true,"unazuki.toyama.jp":true,"uozu.toyama.jp":true,"yamada.toyama.jp":true,"arida.wakayama.jp":true,"aridagawa.wakayama.jp":true,"gobo.wakayama.jp":true,"hashimoto.wakayama.jp":true,"hidaka.wakayama.jp":true,"hirogawa.wakayama.jp":true,"inami.wakayama.jp":true,"iwade.wakayama.jp":true,"kainan.wakayama.jp":true,"kamitonda.wakayama.jp":true,"katsuragi.wakayama.jp":true,"kimino.wakayama.jp":true,"kinokawa.wakayama.jp":true,"kitayama.wakayama.jp":true,"koya.wakayama.jp":true,"koza.wakayama.jp":true,"kozagawa.wakayama.jp":true,"kudoyama.wakayama.jp":true,"kushimoto.wakayama.jp":true,"mihama.wakayama.jp":true,"misato.wakayama.jp":true,"nachikatsuura.wakayama.jp":true,"shingu.wakayama.jp":true,"shirahama.wakayama.jp":true,"taiji.wakayama.jp":true,"tanabe.wakayama.jp":true,"wakayama.wakayama.jp":true,"yuasa.wakayama.jp":true,"yura.wakayama.jp":true,"asahi.yamagata.jp":true,"funagata.yamagata.jp":true,"higashine.yamagata.jp":true,"iide.yamagata.jp":true,"kahoku.yamagata.jp":true,"kaminoyama.yamagata.jp":true,"kaneyama.yamagata.jp":true,"kawanishi.yamagata.jp":true,"mamurogawa.yamagata.jp":true,"mikawa.yamagata.jp":true,"murayama.yamagata.jp":true,"nagai.yamagata.jp":true,"nakayama.yamagata.jp":true,"nanyo.yamagata.jp":true,"nishikawa.yamagata.jp":true,"obanazawa.yamagata.jp":true,"oe.yamagata.jp":true,"oguni.yamagata.jp":true,"ohkura.yamagata.jp":true,"oishida.yamagata.jp":true,"sagae.yamagata.jp":true,"sakata.yamagata.jp":true,"sakegawa.yamagata.jp":true,"shinjo.yamagata.jp":true,"shirataka.yamagata.jp":true,"shonai.yamagata.jp":true,"takahata.yamagata.jp":true,"tendo.yamagata.jp":true,"tozawa.yamagata.jp":true,"tsuruoka.yamagata.jp":true,"yamagata.yamagata.jp":true,"yamanobe.yamagata.jp":true,"yonezawa.yamagata.jp":true,"yuza.yamagata.jp":true,"abu.yamaguchi.jp":true,"hagi.yamaguchi.jp":true,"hikari.yamaguchi.jp":true,"hofu.yamaguchi.jp":true,"iwakuni.yamaguchi.jp":true,"kudamatsu.yamaguchi.jp":true,"mitou.yamaguchi.jp":true,"nagato.yamaguchi.jp":true,"oshima.yamaguchi.jp":true,"shimonoseki.yamaguchi.jp":true,"shunan.yamaguchi.jp":true,"tabuse.yamaguchi.jp":true,"tokuyama.yamaguchi.jp":true,"toyota.yamaguchi.jp":true,"ube.yamaguchi.jp":true,"yuu.yamaguchi.jp":true,"chuo.yamanashi.jp":true,"doshi.yamanashi.jp":true,"fuefuki.yamanashi.jp":true,"fujikawa.yamanashi.jp":true,"fujikawaguchiko.yamanashi.jp":true,"fujiyoshida.yamanashi.jp":true,"hayakawa.yamanashi.jp":true,"hokuto.yamanashi.jp":true,"ichikawamisato.yamanashi.jp":true,"kai.yamanashi.jp":true,"kofu.yamanashi.jp":true,"koshu.yamanashi.jp":true,"kosuge.yamanashi.jp":true,"minami-alps.yamanashi.jp":true,"minobu.yamanashi.jp":true,"nakamichi.yamanashi.jp":true,"nanbu.yamanashi.jp":true,"narusawa.yamanashi.jp":true,"nirasaki.yamanashi.jp":true,"nishikatsura.yamanashi.jp":true,"oshino.yamanashi.jp":true,"otsuki.yamanashi.jp":true,"showa.yamanashi.jp":true,"tabayama.yamanashi.jp":true,"tsuru.yamanashi.jp":true,"uenohara.yamanashi.jp":true,"yamanakako.yamanashi.jp":true,"yamanashi.yamanashi.jp":true,"*.ke":true,"kg":true,"org.kg":true,"net.kg":true,"com.kg":true,"edu.kg":true,"gov.kg":true,"mil.kg":true,"*.kh":true,"ki":true,"edu.ki":true,"biz.ki":true,"net.ki":true,"org.ki":true,"gov.ki":true,"info.ki":true,"com.ki":true,"km":true,"org.km":true,"nom.km":true,"gov.km":true,"prd.km":true,"tm.km":true,"edu.km":true,"mil.km":true,"ass.km":true,"com.km":true,"coop.km":true,"asso.km":true,"presse.km":true,"medecin.km":true,"notaires.km":true,"pharmaciens.km":true,"veterinaire.km":true,"gouv.km":true,"kn":true,"net.kn":true,"org.kn":true,"edu.kn":true,"gov.kn":true,"kp":true,"com.kp":true,"edu.kp":true,"gov.kp":true,"org.kp":true,"rep.kp":true,"tra.kp":true,"kr":true,"ac.kr":true,"co.kr":true,"es.kr":true,"go.kr":true,"hs.kr":true,"kg.kr":true,"mil.kr":true,"ms.kr":true,"ne.kr":true,"or.kr":true,"pe.kr":true,"re.kr":true,"sc.kr":true,"busan.kr":true,"chungbuk.kr":true,"chungnam.kr":true,"daegu.kr":true,"daejeon.kr":true,"gangwon.kr":true,"gwangju.kr":true,"gyeongbuk.kr":true,"gyeonggi.kr":true,"gyeongnam.kr":true,"incheon.kr":true,"jeju.kr":true,"jeonbuk.kr":true,"jeonnam.kr":true,"seoul.kr":true,"ulsan.kr":true,"*.kw":true,"ky":true,"edu.ky":true,"gov.ky":true,"com.ky":true,"org.ky":true,"net.ky":true,"kz":true,"org.kz":true,"edu.kz":true,"net.kz":true,"gov.kz":true,"mil.kz":true,"com.kz":true,"la":true,"int.la":true,"net.la":true,"info.la":true,"edu.la":true,"gov.la":true,"per.la":true,"com.la":true,"org.la":true,"lb":true,"com.lb":true,"edu.lb":true,"gov.lb":true,"net.lb":true,"org.lb":true,"lc":true,"com.lc":true,"net.lc":true,"co.lc":true,"org.lc":true,"edu.lc":true,"gov.lc":true,"li":true,"lk":true,"gov.lk":true,"sch.lk":true,"net.lk":true,"int.lk":true,"com.lk":true,"org.lk":true,"edu.lk":true,"ngo.lk":true,"soc.lk":true,"web.lk":true,"ltd.lk":true,"assn.lk":true,"grp.lk":true,"hotel.lk":true,"lr":true,"com.lr":true,"edu.lr":true,"gov.lr":true,"org.lr":true,"net.lr":true,"ls":true,"co.ls":true,"org.ls":true,"lt":true,"gov.lt":true,"lu":true,"lv":true,"com.lv":true,"edu.lv":true,"gov.lv":true,"org.lv":true,"mil.lv":true,"id.lv":true,"net.lv":true,"asn.lv":true,"conf.lv":true,"ly":true,"com.ly":true,"net.ly":true,"gov.ly":true,"plc.ly":true,"edu.ly":true,"sch.ly":true,"med.ly":true,"org.ly":true,"id.ly":true,"ma":true,"co.ma":true,"net.ma":true,"gov.ma":true,"org.ma":true,"ac.ma":true,"press.ma":true,"mc":true,"tm.mc":true,"asso.mc":true,"md":true,"me":true,"co.me":true,"net.me":true,"org.me":true,"edu.me":true,"ac.me":true,"gov.me":true,"its.me":true,"priv.me":true,"mg":true,"org.mg":true,"nom.mg":true,"gov.mg":true,"prd.mg":true,"tm.mg":true,"edu.mg":true,"mil.mg":true,"com.mg":true,"mh":true,"mil":true,"mk":true,"com.mk":true,"org.mk":true,"net.mk":true,"edu.mk":true,"gov.mk":true,"inf.mk":true,"name.mk":true,"ml":true,"com.ml":true,"edu.ml":true,"gouv.ml":true,"gov.ml":true,"net.ml":true,"org.ml":true,"presse.ml":true,"*.mm":true,"mn":true,"gov.mn":true,"edu.mn":true,"org.mn":true,"mo":true,"com.mo":true,"net.mo":true,"org.mo":true,"edu.mo":true,"gov.mo":true,"mobi":true,"mp":true,"mq":true,"mr":true,"gov.mr":true,"ms":true,"com.ms":true,"edu.ms":true,"gov.ms":true,"net.ms":true,"org.ms":true,"mt":true,"com.mt":true,"edu.mt":true,"net.mt":true,"org.mt":true,"mu":true,"com.mu":true,"net.mu":true,"org.mu":true,"gov.mu":true,"ac.mu":true,"co.mu":true,"or.mu":true,"museum":true,"academy.museum":true,"agriculture.museum":true,"air.museum":true,"airguard.museum":true,"alabama.museum":true,"alaska.museum":true,"amber.museum":true,"ambulance.museum":true,"american.museum":true,"americana.museum":true,"americanantiques.museum":true,"americanart.museum":true,"amsterdam.museum":true,"and.museum":true,"annefrank.museum":true,"anthro.museum":true,"anthropology.museum":true,"antiques.museum":true,"aquarium.museum":true,"arboretum.museum":true,"archaeological.museum":true,"archaeology.museum":true,"architecture.museum":true,"art.museum":true,"artanddesign.museum":true,"artcenter.museum":true,"artdeco.museum":true,"arteducation.museum":true,"artgallery.museum":true,"arts.museum":true,"artsandcrafts.museum":true,"asmatart.museum":true,"assassination.museum":true,"assisi.museum":true,"association.museum":true,"astronomy.museum":true,"atlanta.museum":true,"austin.museum":true,"australia.museum":true,"automotive.museum":true,"aviation.museum":true,"axis.museum":true,"badajoz.museum":true,"baghdad.museum":true,"bahn.museum":true,"bale.museum":true,"baltimore.museum":true,"barcelona.museum":true,"baseball.museum":true,"basel.museum":true,"baths.museum":true,"bauern.museum":true,"beauxarts.museum":true,"beeldengeluid.museum":true,"bellevue.museum":true,"bergbau.museum":true,"berkeley.museum":true,"berlin.museum":true,"bern.museum":true,"bible.museum":true,"bilbao.museum":true,"bill.museum":true,"birdart.museum":true,"birthplace.museum":true,"bonn.museum":true,"boston.museum":true,"botanical.museum":true,"botanicalgarden.museum":true,"botanicgarden.museum":true,"botany.museum":true,"brandywinevalley.museum":true,"brasil.museum":true,"bristol.museum":true,"british.museum":true,"britishcolumbia.museum":true,"broadcast.museum":true,"brunel.museum":true,"brussel.museum":true,"brussels.museum":true,"bruxelles.museum":true,"building.museum":true,"burghof.museum":true,"bus.museum":true,"bushey.museum":true,"cadaques.museum":true,"california.museum":true,"cambridge.museum":true,"can.museum":true,"canada.museum":true,"capebreton.museum":true,"carrier.museum":true,"cartoonart.museum":true,"casadelamoneda.museum":true,"castle.museum":true,"castres.museum":true,"celtic.museum":true,"center.museum":true,"chattanooga.museum":true,"cheltenham.museum":true,"chesapeakebay.museum":true,"chicago.museum":true,"children.museum":true,"childrens.museum":true,"childrensgarden.museum":true,"chiropractic.museum":true,"chocolate.museum":true,"christiansburg.museum":true,"cincinnati.museum":true,"cinema.museum":true,"circus.museum":true,"civilisation.museum":true,"civilization.museum":true,"civilwar.museum":true,"clinton.museum":true,"clock.museum":true,"coal.museum":true,"coastaldefence.museum":true,"cody.museum":true,"coldwar.museum":true,"collection.museum":true,"colonialwilliamsburg.museum":true,"coloradoplateau.museum":true,"columbia.museum":true,"columbus.museum":true,"communication.museum":true,"communications.museum":true,"community.museum":true,"computer.museum":true,"computerhistory.museum":true,"xn--comunicaes-v6a2o.museum":true,"contemporary.museum":true,"contemporaryart.museum":true,"convent.museum":true,"copenhagen.museum":true,"corporation.museum":true,"xn--correios-e-telecomunicaes-ghc29a.museum":true,"corvette.museum":true,"costume.museum":true,"countryestate.museum":true,"county.museum":true,"crafts.museum":true,"cranbrook.museum":true,"creation.museum":true,"cultural.museum":true,"culturalcenter.museum":true,"culture.museum":true,"cyber.museum":true,"cymru.museum":true,"dali.museum":true,"dallas.museum":true,"database.museum":true,"ddr.museum":true,"decorativearts.museum":true,"delaware.museum":true,"delmenhorst.museum":true,"denmark.museum":true,"depot.museum":true,"design.museum":true,"detroit.museum":true,"dinosaur.museum":true,"discovery.museum":true,"dolls.museum":true,"donostia.museum":true,"durham.museum":true,"eastafrica.museum":true,"eastcoast.museum":true,"education.museum":true,"educational.museum":true,"egyptian.museum":true,"eisenbahn.museum":true,"elburg.museum":true,"elvendrell.museum":true,"embroidery.museum":true,"encyclopedic.museum":true,"england.museum":true,"entomology.museum":true,"environment.museum":true,"environmentalconservation.museum":true,"epilepsy.museum":true,"essex.museum":true,"estate.museum":true,"ethnology.museum":true,"exeter.museum":true,"exhibition.museum":true,"family.museum":true,"farm.museum":true,"farmequipment.museum":true,"farmers.museum":true,"farmstead.museum":true,"field.museum":true,"figueres.museum":true,"filatelia.museum":true,"film.museum":true,"fineart.museum":true,"finearts.museum":true,"finland.museum":true,"flanders.museum":true,"florida.museum":true,"force.museum":true,"fortmissoula.museum":true,"fortworth.museum":true,"foundation.museum":true,"francaise.museum":true,"frankfurt.museum":true,"franziskaner.museum":true,"freemasonry.museum":true,"freiburg.museum":true,"fribourg.museum":true,"frog.museum":true,"fundacio.museum":true,"furniture.museum":true,"gallery.museum":true,"garden.museum":true,"gateway.museum":true,"geelvinck.museum":true,"gemological.museum":true,"geology.museum":true,"georgia.museum":true,"giessen.museum":true,"glas.museum":true,"glass.museum":true,"gorge.museum":true,"grandrapids.museum":true,"graz.museum":true,"guernsey.museum":true,"halloffame.museum":true,"hamburg.museum":true,"handson.museum":true,"harvestcelebration.museum":true,"hawaii.museum":true,"health.museum":true,"heimatunduhren.museum":true,"hellas.museum":true,"helsinki.museum":true,"hembygdsforbund.museum":true,"heritage.museum":true,"histoire.museum":true,"historical.museum":true,"historicalsociety.museum":true,"historichouses.museum":true,"historisch.museum":true,"historisches.museum":true,"history.museum":true,"historyofscience.museum":true,"horology.museum":true,"house.museum":true,"humanities.museum":true,"illustration.museum":true,"imageandsound.museum":true,"indian.museum":true,"indiana.museum":true,"indianapolis.museum":true,"indianmarket.museum":true,"intelligence.museum":true,"interactive.museum":true,"iraq.museum":true,"iron.museum":true,"isleofman.museum":true,"jamison.museum":true,"jefferson.museum":true,"jerusalem.museum":true,"jewelry.museum":true,"jewish.museum":true,"jewishart.museum":true,"jfk.museum":true,"journalism.museum":true,"judaica.museum":true,"judygarland.museum":true,"juedisches.museum":true,"juif.museum":true,"karate.museum":true,"karikatur.museum":true,"kids.museum":true,"koebenhavn.museum":true,"koeln.museum":true,"kunst.museum":true,"kunstsammlung.museum":true,"kunstunddesign.museum":true,"labor.museum":true,"labour.museum":true,"lajolla.museum":true,"lancashire.museum":true,"landes.museum":true,"lans.museum":true,"xn--lns-qla.museum":true,"larsson.museum":true,"lewismiller.museum":true,"lincoln.museum":true,"linz.museum":true,"living.museum":true,"livinghistory.museum":true,"localhistory.museum":true,"london.museum":true,"losangeles.museum":true,"louvre.museum":true,"loyalist.museum":true,"lucerne.museum":true,"luxembourg.museum":true,"luzern.museum":true,"mad.museum":true,"madrid.museum":true,"mallorca.museum":true,"manchester.museum":true,"mansion.museum":true,"mansions.museum":true,"manx.museum":true,"marburg.museum":true,"maritime.museum":true,"maritimo.museum":true,"maryland.museum":true,"marylhurst.museum":true,"media.museum":true,"medical.museum":true,"medizinhistorisches.museum":true,"meeres.museum":true,"memorial.museum":true,"mesaverde.museum":true,"michigan.museum":true,"midatlantic.museum":true,"military.museum":true,"mill.museum":true,"miners.museum":true,"mining.museum":true,"minnesota.museum":true,"missile.museum":true,"missoula.museum":true,"modern.museum":true,"moma.museum":true,"money.museum":true,"monmouth.museum":true,"monticello.museum":true,"montreal.museum":true,"moscow.museum":true,"motorcycle.museum":true,"muenchen.museum":true,"muenster.museum":true,"mulhouse.museum":true,"muncie.museum":true,"museet.museum":true,"museumcenter.museum":true,"museumvereniging.museum":true,"music.museum":true,"national.museum":true,"nationalfirearms.museum":true,"nationalheritage.museum":true,"nativeamerican.museum":true,"naturalhistory.museum":true,"naturalhistorymuseum.museum":true,"naturalsciences.museum":true,"nature.museum":true,"naturhistorisches.museum":true,"natuurwetenschappen.museum":true,"naumburg.museum":true,"naval.museum":true,"nebraska.museum":true,"neues.museum":true,"newhampshire.museum":true,"newjersey.museum":true,"newmexico.museum":true,"newport.museum":true,"newspaper.museum":true,"newyork.museum":true,"niepce.museum":true,"norfolk.museum":true,"north.museum":true,"nrw.museum":true,"nuernberg.museum":true,"nuremberg.museum":true,"nyc.museum":true,"nyny.museum":true,"oceanographic.museum":true,"oceanographique.museum":true,"omaha.museum":true,"online.museum":true,"ontario.museum":true,"openair.museum":true,"oregon.museum":true,"oregontrail.museum":true,"otago.museum":true,"oxford.museum":true,"pacific.museum":true,"paderborn.museum":true,"palace.museum":true,"paleo.museum":true,"palmsprings.museum":true,"panama.museum":true,"paris.museum":true,"pasadena.museum":true,"pharmacy.museum":true,"philadelphia.museum":true,"philadelphiaarea.museum":true,"philately.museum":true,"phoenix.museum":true,"photography.museum":true,"pilots.museum":true,"pittsburgh.museum":true,"planetarium.museum":true,"plantation.museum":true,"plants.museum":true,"plaza.museum":true,"portal.museum":true,"portland.museum":true,"portlligat.museum":true,"posts-and-telecommunications.museum":true,"preservation.museum":true,"presidio.museum":true,"press.museum":true,"project.museum":true,"public.museum":true,"pubol.museum":true,"quebec.museum":true,"railroad.museum":true,"railway.museum":true,"research.museum":true,"resistance.museum":true,"riodejaneiro.museum":true,"rochester.museum":true,"rockart.museum":true,"roma.museum":true,"russia.museum":true,"saintlouis.museum":true,"salem.museum":true,"salvadordali.museum":true,"salzburg.museum":true,"sandiego.museum":true,"sanfrancisco.museum":true,"santabarbara.museum":true,"santacruz.museum":true,"santafe.museum":true,"saskatchewan.museum":true,"satx.museum":true,"savannahga.museum":true,"schlesisches.museum":true,"schoenbrunn.museum":true,"schokoladen.museum":true,"school.museum":true,"schweiz.museum":true,"science.museum":true,"scienceandhistory.museum":true,"scienceandindustry.museum":true,"sciencecenter.museum":true,"sciencecenters.museum":true,"science-fiction.museum":true,"sciencehistory.museum":true,"sciences.museum":true,"sciencesnaturelles.museum":true,"scotland.museum":true,"seaport.museum":true,"settlement.museum":true,"settlers.museum":true,"shell.museum":true,"sherbrooke.museum":true,"sibenik.museum":true,"silk.museum":true,"ski.museum":true,"skole.museum":true,"society.museum":true,"sologne.museum":true,"soundandvision.museum":true,"southcarolina.museum":true,"southwest.museum":true,"space.museum":true,"spy.museum":true,"square.museum":true,"stadt.museum":true,"stalbans.museum":true,"starnberg.museum":true,"state.museum":true,"stateofdelaware.museum":true,"station.museum":true,"steam.museum":true,"steiermark.museum":true,"stjohn.museum":true,"stockholm.museum":true,"stpetersburg.museum":true,"stuttgart.museum":true,"suisse.museum":true,"surgeonshall.museum":true,"surrey.museum":true,"svizzera.museum":true,"sweden.museum":true,"sydney.museum":true,"tank.museum":true,"tcm.museum":true,"technology.museum":true,"telekommunikation.museum":true,"television.museum":true,"texas.museum":true,"textile.museum":true,"theater.museum":true,"time.museum":true,"timekeeping.museum":true,"topology.museum":true,"torino.museum":true,"touch.museum":true,"town.museum":true,"transport.museum":true,"tree.museum":true,"trolley.museum":true,"trust.museum":true,"trustee.museum":true,"uhren.museum":true,"ulm.museum":true,"undersea.museum":true,"university.museum":true,"usa.museum":true,"usantiques.museum":true,"usarts.museum":true,"uscountryestate.museum":true,"usculture.museum":true,"usdecorativearts.museum":true,"usgarden.museum":true,"ushistory.museum":true,"ushuaia.museum":true,"uslivinghistory.museum":true,"utah.museum":true,"uvic.museum":true,"valley.museum":true,"vantaa.museum":true,"versailles.museum":true,"viking.museum":true,"village.museum":true,"virginia.museum":true,"virtual.museum":true,"virtuel.museum":true,"vlaanderen.museum":true,"volkenkunde.museum":true,"wales.museum":true,"wallonie.museum":true,"war.museum":true,"washingtondc.museum":true,"watchandclock.museum":true,"watch-and-clock.museum":true,"western.museum":true,"westfalen.museum":true,"whaling.museum":true,"wildlife.museum":true,"williamsburg.museum":true,"windmill.museum":true,"workshop.museum":true,"york.museum":true,"yorkshire.museum":true,"yosemite.museum":true,"youth.museum":true,"zoological.museum":true,"zoology.museum":true,"xn--9dbhblg6di.museum":true,"xn--h1aegh.museum":true,"mv":true,"aero.mv":true,"biz.mv":true,"com.mv":true,"coop.mv":true,"edu.mv":true,"gov.mv":true,"info.mv":true,"int.mv":true,"mil.mv":true,"museum.mv":true,"name.mv":true,"net.mv":true,"org.mv":true,"pro.mv":true,"mw":true,"ac.mw":true,"biz.mw":true,"co.mw":true,"com.mw":true,"coop.mw":true,"edu.mw":true,"gov.mw":true,"int.mw":true,"museum.mw":true,"net.mw":true,"org.mw":true,"mx":true,"com.mx":true,"org.mx":true,"gob.mx":true,"edu.mx":true,"net.mx":true,"my":true,"com.my":true,"net.my":true,"org.my":true,"gov.my":true,"edu.my":true,"mil.my":true,"name.my":true,"*.mz":true,"teledata.mz":false,"na":true,"info.na":true,"pro.na":true,"name.na":true,"school.na":true,"or.na":true,"dr.na":true,"us.na":true,"mx.na":true,"ca.na":true,"in.na":true,"cc.na":true,"tv.na":true,"ws.na":true,"mobi.na":true,"co.na":true,"com.na":true,"org.na":true,"name":true,"nc":true,"asso.nc":true,"ne":true,"net":true,"nf":true,"com.nf":true,"net.nf":true,"per.nf":true,"rec.nf":true,"web.nf":true,"arts.nf":true,"firm.nf":true,"info.nf":true,"other.nf":true,"store.nf":true,"ng":true,"com.ng":true,"edu.ng":true,"name.ng":true,"net.ng":true,"org.ng":true,"sch.ng":true,"gov.ng":true,"mil.ng":true,"mobi.ng":true,"*.ni":true,"nl":true,"bv.nl":true,"no":true,"fhs.no":true,"vgs.no":true,"fylkesbibl.no":true,"folkebibl.no":true,"museum.no":true,"idrett.no":true,"priv.no":true,"mil.no":true,"stat.no":true,"dep.no":true,"kommune.no":true,"herad.no":true,"aa.no":true,"ah.no":true,"bu.no":true,"fm.no":true,"hl.no":true,"hm.no":true,"jan-mayen.no":true,"mr.no":true,"nl.no":true,"nt.no":true,"of.no":true,"ol.no":true,"oslo.no":true,"rl.no":true,"sf.no":true,"st.no":true,"svalbard.no":true,"tm.no":true,"tr.no":true,"va.no":true,"vf.no":true,"gs.aa.no":true,"gs.ah.no":true,"gs.bu.no":true,"gs.fm.no":true,"gs.hl.no":true,"gs.hm.no":true,"gs.jan-mayen.no":true,"gs.mr.no":true,"gs.nl.no":true,"gs.nt.no":true,"gs.of.no":true,"gs.ol.no":true,"gs.oslo.no":true,"gs.rl.no":true,"gs.sf.no":true,"gs.st.no":true,"gs.svalbard.no":true,"gs.tm.no":true,"gs.tr.no":true,"gs.va.no":true,"gs.vf.no":true,"akrehamn.no":true,"xn--krehamn-dxa.no":true,"algard.no":true,"xn--lgrd-poac.no":true,"arna.no":true,"brumunddal.no":true,"bryne.no":true,"bronnoysund.no":true,"xn--brnnysund-m8ac.no":true,"drobak.no":true,"xn--drbak-wua.no":true,"egersund.no":true,"fetsund.no":true,"floro.no":true,"xn--flor-jra.no":true,"fredrikstad.no":true,"hokksund.no":true,"honefoss.no":true,"xn--hnefoss-q1a.no":true,"jessheim.no":true,"jorpeland.no":true,"xn--jrpeland-54a.no":true,"kirkenes.no":true,"kopervik.no":true,"krokstadelva.no":true,"langevag.no":true,"xn--langevg-jxa.no":true,"leirvik.no":true,"mjondalen.no":true,"xn--mjndalen-64a.no":true,"mo-i-rana.no":true,"mosjoen.no":true,"xn--mosjen-eya.no":true,"nesoddtangen.no":true,"orkanger.no":true,"osoyro.no":true,"xn--osyro-wua.no":true,"raholt.no":true,"xn--rholt-mra.no":true,"sandnessjoen.no":true,"xn--sandnessjen-ogb.no":true,"skedsmokorset.no":true,"slattum.no":true,"spjelkavik.no":true,"stathelle.no":true,"stavern.no":true,"stjordalshalsen.no":true,"xn--stjrdalshalsen-sqb.no":true,"tananger.no":true,"tranby.no":true,"vossevangen.no":true,"afjord.no":true,"xn--fjord-lra.no":true,"agdenes.no":true,"al.no":true,"xn--l-1fa.no":true,"alesund.no":true,"xn--lesund-hua.no":true,"alstahaug.no":true,"alta.no":true,"xn--lt-liac.no":true,"alaheadju.no":true,"xn--laheadju-7ya.no":true,"alvdal.no":true,"amli.no":true,"xn--mli-tla.no":true,"amot.no":true,"xn--mot-tla.no":true,"andebu.no":true,"andoy.no":true,"xn--andy-ira.no":true,"andasuolo.no":true,"ardal.no":true,"xn--rdal-poa.no":true,"aremark.no":true,"arendal.no":true,"xn--s-1fa.no":true,"aseral.no":true,"xn--seral-lra.no":true,"asker.no":true,"askim.no":true,"askvoll.no":true,"askoy.no":true,"xn--asky-ira.no":true,"asnes.no":true,"xn--snes-poa.no":true,"audnedaln.no":true,"aukra.no":true,"aure.no":true,"aurland.no":true,"aurskog-holand.no":true,"xn--aurskog-hland-jnb.no":true,"austevoll.no":true,"austrheim.no":true,"averoy.no":true,"xn--avery-yua.no":true,"balestrand.no":true,"ballangen.no":true,"balat.no":true,"xn--blt-elab.no":true,"balsfjord.no":true,"bahccavuotna.no":true,"xn--bhccavuotna-k7a.no":true,"bamble.no":true,"bardu.no":true,"beardu.no":true,"beiarn.no":true,"bajddar.no":true,"xn--bjddar-pta.no":true,"baidar.no":true,"xn--bidr-5nac.no":true,"berg.no":true,"bergen.no":true,"berlevag.no":true,"xn--berlevg-jxa.no":true,"bearalvahki.no":true,"xn--bearalvhki-y4a.no":true,"bindal.no":true,"birkenes.no":true,"bjarkoy.no":true,"xn--bjarky-fya.no":true,"bjerkreim.no":true,"bjugn.no":true,"bodo.no":true,"xn--bod-2na.no":true,"badaddja.no":true,"xn--bdddj-mrabd.no":true,"budejju.no":true,"bokn.no":true,"bremanger.no":true,"bronnoy.no":true,"xn--brnny-wuac.no":true,"bygland.no":true,"bykle.no":true,"barum.no":true,"xn--brum-voa.no":true,"bo.telemark.no":true,"xn--b-5ga.telemark.no":true,"bo.nordland.no":true,"xn--b-5ga.nordland.no":true,"bievat.no":true,"xn--bievt-0qa.no":true,"bomlo.no":true,"xn--bmlo-gra.no":true,"batsfjord.no":true,"xn--btsfjord-9za.no":true,"bahcavuotna.no":true,"xn--bhcavuotna-s4a.no":true,"dovre.no":true,"drammen.no":true,"drangedal.no":true,"dyroy.no":true,"xn--dyry-ira.no":true,"donna.no":true,"xn--dnna-gra.no":true,"eid.no":true,"eidfjord.no":true,"eidsberg.no":true,"eidskog.no":true,"eidsvoll.no":true,"eigersund.no":true,"elverum.no":true,"enebakk.no":true,"engerdal.no":true,"etne.no":true,"etnedal.no":true,"evenes.no":true,"evenassi.no":true,"xn--eveni-0qa01ga.no":true,"evje-og-hornnes.no":true,"farsund.no":true,"fauske.no":true,"fuossko.no":true,"fuoisku.no":true,"fedje.no":true,"fet.no":true,"finnoy.no":true,"xn--finny-yua.no":true,"fitjar.no":true,"fjaler.no":true,"fjell.no":true,"flakstad.no":true,"flatanger.no":true,"flekkefjord.no":true,"flesberg.no":true,"flora.no":true,"fla.no":true,"xn--fl-zia.no":true,"folldal.no":true,"forsand.no":true,"fosnes.no":true,"frei.no":true,"frogn.no":true,"froland.no":true,"frosta.no":true,"frana.no":true,"xn--frna-woa.no":true,"froya.no":true,"xn--frya-hra.no":true,"fusa.no":true,"fyresdal.no":true,"forde.no":true,"xn--frde-gra.no":true,"gamvik.no":true,"gangaviika.no":true,"xn--ggaviika-8ya47h.no":true,"gaular.no":true,"gausdal.no":true,"gildeskal.no":true,"xn--gildeskl-g0a.no":true,"giske.no":true,"gjemnes.no":true,"gjerdrum.no":true,"gjerstad.no":true,"gjesdal.no":true,"gjovik.no":true,"xn--gjvik-wua.no":true,"gloppen.no":true,"gol.no":true,"gran.no":true,"grane.no":true,"granvin.no":true,"gratangen.no":true,"grimstad.no":true,"grong.no":true,"kraanghke.no":true,"xn--kranghke-b0a.no":true,"grue.no":true,"gulen.no":true,"hadsel.no":true,"halden.no":true,"halsa.no":true,"hamar.no":true,"hamaroy.no":true,"habmer.no":true,"xn--hbmer-xqa.no":true,"hapmir.no":true,"xn--hpmir-xqa.no":true,"hammerfest.no":true,"hammarfeasta.no":true,"xn--hmmrfeasta-s4ac.no":true,"haram.no":true,"hareid.no":true,"harstad.no":true,"hasvik.no":true,"aknoluokta.no":true,"xn--koluokta-7ya57h.no":true,"hattfjelldal.no":true,"aarborte.no":true,"haugesund.no":true,"hemne.no":true,"hemnes.no":true,"hemsedal.no":true,"heroy.more-og-romsdal.no":true,"xn--hery-ira.xn--mre-og-romsdal-qqb.no":true,"heroy.nordland.no":true,"xn--hery-ira.nordland.no":true,"hitra.no":true,"hjartdal.no":true,"hjelmeland.no":true,"hobol.no":true,"xn--hobl-ira.no":true,"hof.no":true,"hol.no":true,"hole.no":true,"holmestrand.no":true,"holtalen.no":true,"xn--holtlen-hxa.no":true,"hornindal.no":true,"horten.no":true,"hurdal.no":true,"hurum.no":true,"hvaler.no":true,"hyllestad.no":true,"hagebostad.no":true,"xn--hgebostad-g3a.no":true,"hoyanger.no":true,"xn--hyanger-q1a.no":true,"hoylandet.no":true,"xn--hylandet-54a.no":true,"ha.no":true,"xn--h-2fa.no":true,"ibestad.no":true,"inderoy.no":true,"xn--indery-fya.no":true,"iveland.no":true,"jevnaker.no":true,"jondal.no":true,"jolster.no":true,"xn--jlster-bya.no":true,"karasjok.no":true,"karasjohka.no":true,"xn--krjohka-hwab49j.no":true,"karlsoy.no":true,"galsa.no":true,"xn--gls-elac.no":true,"karmoy.no":true,"xn--karmy-yua.no":true,"kautokeino.no":true,"guovdageaidnu.no":true,"klepp.no":true,"klabu.no":true,"xn--klbu-woa.no":true,"kongsberg.no":true,"kongsvinger.no":true,"kragero.no":true,"xn--krager-gya.no":true,"kristiansand.no":true,"kristiansund.no":true,"krodsherad.no":true,"xn--krdsherad-m8a.no":true,"kvalsund.no":true,"rahkkeravju.no":true,"xn--rhkkervju-01af.no":true,"kvam.no":true,"kvinesdal.no":true,"kvinnherad.no":true,"kviteseid.no":true,"kvitsoy.no":true,"xn--kvitsy-fya.no":true,"kvafjord.no":true,"xn--kvfjord-nxa.no":true,"giehtavuoatna.no":true,"kvanangen.no":true,"xn--kvnangen-k0a.no":true,"navuotna.no":true,"xn--nvuotna-hwa.no":true,"kafjord.no":true,"xn--kfjord-iua.no":true,"gaivuotna.no":true,"xn--givuotna-8ya.no":true,"larvik.no":true,"lavangen.no":true,"lavagis.no":true,"loabat.no":true,"xn--loabt-0qa.no":true,"lebesby.no":true,"davvesiida.no":true,"leikanger.no":true,"leirfjord.no":true,"leka.no":true,"leksvik.no":true,"lenvik.no":true,"leangaviika.no":true,"xn--leagaviika-52b.no":true,"lesja.no":true,"levanger.no":true,"lier.no":true,"lierne.no":true,"lillehammer.no":true,"lillesand.no":true,"lindesnes.no":true,"lindas.no":true,"xn--linds-pra.no":true,"lom.no":true,"loppa.no":true,"lahppi.no":true,"xn--lhppi-xqa.no":true,"lund.no":true,"lunner.no":true,"luroy.no":true,"xn--lury-ira.no":true,"luster.no":true,"lyngdal.no":true,"lyngen.no":true,"ivgu.no":true,"lardal.no":true,"lerdal.no":true,"xn--lrdal-sra.no":true,"lodingen.no":true,"xn--ldingen-q1a.no":true,"lorenskog.no":true,"xn--lrenskog-54a.no":true,"loten.no":true,"xn--lten-gra.no":true,"malvik.no":true,"masoy.no":true,"xn--msy-ula0h.no":true,"muosat.no":true,"xn--muost-0qa.no":true,"mandal.no":true,"marker.no":true,"marnardal.no":true,"masfjorden.no":true,"meland.no":true,"meldal.no":true,"melhus.no":true,"meloy.no":true,"xn--mely-ira.no":true,"meraker.no":true,"xn--merker-kua.no":true,"moareke.no":true,"xn--moreke-jua.no":true,"midsund.no":true,"midtre-gauldal.no":true,"modalen.no":true,"modum.no":true,"molde.no":true,"moskenes.no":true,"moss.no":true,"mosvik.no":true,"malselv.no":true,"xn--mlselv-iua.no":true,"malatvuopmi.no":true,"xn--mlatvuopmi-s4a.no":true,"namdalseid.no":true,"aejrie.no":true,"namsos.no":true,"namsskogan.no":true,"naamesjevuemie.no":true,"xn--nmesjevuemie-tcba.no":true,"laakesvuemie.no":true,"nannestad.no":true,"narvik.no":true,"narviika.no":true,"naustdal.no":true,"nedre-eiker.no":true,"nes.akershus.no":true,"nes.buskerud.no":true,"nesna.no":true,"nesodden.no":true,"nesseby.no":true,"unjarga.no":true,"xn--unjrga-rta.no":true,"nesset.no":true,"nissedal.no":true,"nittedal.no":true,"nord-aurdal.no":true,"nord-fron.no":true,"nord-odal.no":true,"norddal.no":true,"nordkapp.no":true,"davvenjarga.no":true,"xn--davvenjrga-y4a.no":true,"nordre-land.no":true,"nordreisa.no":true,"raisa.no":true,"xn--risa-5na.no":true,"nore-og-uvdal.no":true,"notodden.no":true,"naroy.no":true,"xn--nry-yla5g.no":true,"notteroy.no":true,"xn--nttery-byae.no":true,"odda.no":true,"oksnes.no":true,"xn--ksnes-uua.no":true,"oppdal.no":true,"oppegard.no":true,"xn--oppegrd-ixa.no":true,"orkdal.no":true,"orland.no":true,"xn--rland-uua.no":true,"orskog.no":true,"xn--rskog-uua.no":true,"orsta.no":true,"xn--rsta-fra.no":true,"os.hedmark.no":true,"os.hordaland.no":true,"osen.no":true,"osteroy.no":true,"xn--ostery-fya.no":true,"ostre-toten.no":true,"xn--stre-toten-zcb.no":true,"overhalla.no":true,"ovre-eiker.no":true,"xn--vre-eiker-k8a.no":true,"oyer.no":true,"xn--yer-zna.no":true,"oygarden.no":true,"xn--ygarden-p1a.no":true,"oystre-slidre.no":true,"xn--ystre-slidre-ujb.no":true,"porsanger.no":true,"porsangu.no":true,"xn--porsgu-sta26f.no":true,"porsgrunn.no":true,"radoy.no":true,"xn--rady-ira.no":true,"rakkestad.no":true,"rana.no":true,"ruovat.no":true,"randaberg.no":true,"rauma.no":true,"rendalen.no":true,"rennebu.no":true,"rennesoy.no":true,"xn--rennesy-v1a.no":true,"rindal.no":true,"ringebu.no":true,"ringerike.no":true,"ringsaker.no":true,"rissa.no":true,"risor.no":true,"xn--risr-ira.no":true,"roan.no":true,"rollag.no":true,"rygge.no":true,"ralingen.no":true,"xn--rlingen-mxa.no":true,"rodoy.no":true,"xn--rdy-0nab.no":true,"romskog.no":true,"xn--rmskog-bya.no":true,"roros.no":true,"xn--rros-gra.no":true,"rost.no":true,"xn--rst-0na.no":true,"royken.no":true,"xn--ryken-vua.no":true,"royrvik.no":true,"xn--ryrvik-bya.no":true,"rade.no":true,"xn--rde-ula.no":true,"salangen.no":true,"siellak.no":true,"saltdal.no":true,"salat.no":true,"xn--slt-elab.no":true,"xn--slat-5na.no":true,"samnanger.no":true,"sande.more-og-romsdal.no":true,"sande.xn--mre-og-romsdal-qqb.no":true,"sande.vestfold.no":true,"sandefjord.no":true,"sandnes.no":true,"sandoy.no":true,"xn--sandy-yua.no":true,"sarpsborg.no":true,"sauda.no":true,"sauherad.no":true,"sel.no":true,"selbu.no":true,"selje.no":true,"seljord.no":true,"sigdal.no":true,"siljan.no":true,"sirdal.no":true,"skaun.no":true,"skedsmo.no":true,"ski.no":true,"skien.no":true,"skiptvet.no":true,"skjervoy.no":true,"xn--skjervy-v1a.no":true,"skierva.no":true,"xn--skierv-uta.no":true,"skjak.no":true,"xn--skjk-soa.no":true,"skodje.no":true,"skanland.no":true,"xn--sknland-fxa.no":true,"skanit.no":true,"xn--sknit-yqa.no":true,"smola.no":true,"xn--smla-hra.no":true,"snillfjord.no":true,"snasa.no":true,"xn--snsa-roa.no":true,"snoasa.no":true,"snaase.no":true,"xn--snase-nra.no":true,"sogndal.no":true,"sokndal.no":true,"sola.no":true,"solund.no":true,"songdalen.no":true,"sortland.no":true,"spydeberg.no":true,"stange.no":true,"stavanger.no":true,"steigen.no":true,"steinkjer.no":true,"stjordal.no":true,"xn--stjrdal-s1a.no":true,"stokke.no":true,"stor-elvdal.no":true,"stord.no":true,"stordal.no":true,"storfjord.no":true,"omasvuotna.no":true,"strand.no":true,"stranda.no":true,"stryn.no":true,"sula.no":true,"suldal.no":true,"sund.no":true,"sunndal.no":true,"surnadal.no":true,"sveio.no":true,"svelvik.no":true,"sykkylven.no":true,"sogne.no":true,"xn--sgne-gra.no":true,"somna.no":true,"xn--smna-gra.no":true,"sondre-land.no":true,"xn--sndre-land-0cb.no":true,"sor-aurdal.no":true,"xn--sr-aurdal-l8a.no":true,"sor-fron.no":true,"xn--sr-fron-q1a.no":true,"sor-odal.no":true,"xn--sr-odal-q1a.no":true,"sor-varanger.no":true,"xn--sr-varanger-ggb.no":true,"matta-varjjat.no":true,"xn--mtta-vrjjat-k7af.no":true,"sorfold.no":true,"xn--srfold-bya.no":true,"sorreisa.no":true,"xn--srreisa-q1a.no":true,"sorum.no":true,"xn--srum-gra.no":true,"tana.no":true,"deatnu.no":true,"time.no":true,"tingvoll.no":true,"tinn.no":true,"tjeldsund.no":true,"dielddanuorri.no":true,"tjome.no":true,"xn--tjme-hra.no":true,"tokke.no":true,"tolga.no":true,"torsken.no":true,"tranoy.no":true,"xn--trany-yua.no":true,"tromso.no":true,"xn--troms-zua.no":true,"tromsa.no":true,"romsa.no":true,"trondheim.no":true,"troandin.no":true,"trysil.no":true,"trana.no":true,"xn--trna-woa.no":true,"trogstad.no":true,"xn--trgstad-r1a.no":true,"tvedestrand.no":true,"tydal.no":true,"tynset.no":true,"tysfjord.no":true,"divtasvuodna.no":true,"divttasvuotna.no":true,"tysnes.no":true,"tysvar.no":true,"xn--tysvr-vra.no":true,"tonsberg.no":true,"xn--tnsberg-q1a.no":true,"ullensaker.no":true,"ullensvang.no":true,"ulvik.no":true,"utsira.no":true,"vadso.no":true,"xn--vads-jra.no":true,"cahcesuolo.no":true,"xn--hcesuolo-7ya35b.no":true,"vaksdal.no":true,"valle.no":true,"vang.no":true,"vanylven.no":true,"vardo.no":true,"xn--vard-jra.no":true,"varggat.no":true,"xn--vrggt-xqad.no":true,"vefsn.no":true,"vaapste.no":true,"vega.no":true,"vegarshei.no":true,"xn--vegrshei-c0a.no":true,"vennesla.no":true,"verdal.no":true,"verran.no":true,"vestby.no":true,"vestnes.no":true,"vestre-slidre.no":true,"vestre-toten.no":true,"vestvagoy.no":true,"xn--vestvgy-ixa6o.no":true,"vevelstad.no":true,"vik.no":true,"vikna.no":true,"vindafjord.no":true,"volda.no":true,"voss.no":true,"varoy.no":true,"xn--vry-yla5g.no":true,"vagan.no":true,"xn--vgan-qoa.no":true,"voagat.no":true,"vagsoy.no":true,"xn--vgsy-qoa0j.no":true,"vaga.no":true,"xn--vg-yiab.no":true,"valer.ostfold.no":true,"xn--vler-qoa.xn--stfold-9xa.no":true,"valer.hedmark.no":true,"xn--vler-qoa.hedmark.no":true,"*.np":true,"nr":true,"biz.nr":true,"info.nr":true,"gov.nr":true,"edu.nr":true,"org.nr":true,"net.nr":true,"com.nr":true,"nu":true,"nz":true,"ac.nz":true,"co.nz":true,"cri.nz":true,"geek.nz":true,"gen.nz":true,"govt.nz":true,"health.nz":true,"iwi.nz":true,"kiwi.nz":true,"maori.nz":true,"mil.nz":true,"xn--mori-qsa.nz":true,"net.nz":true,"org.nz":true,"parliament.nz":true,"school.nz":true,"om":true,"co.om":true,"com.om":true,"edu.om":true,"gov.om":true,"med.om":true,"museum.om":true,"net.om":true,"org.om":true,"pro.om":true,"org":true,"pa":true,"ac.pa":true,"gob.pa":true,"com.pa":true,"org.pa":true,"sld.pa":true,"edu.pa":true,"net.pa":true,"ing.pa":true,"abo.pa":true,"med.pa":true,"nom.pa":true,"pe":true,"edu.pe":true,"gob.pe":true,"nom.pe":true,"mil.pe":true,"org.pe":true,"com.pe":true,"net.pe":true,"pf":true,"com.pf":true,"org.pf":true,"edu.pf":true,"*.pg":true,"ph":true,"com.ph":true,"net.ph":true,"org.ph":true,"gov.ph":true,"edu.ph":true,"ngo.ph":true,"mil.ph":true,"i.ph":true,"pk":true,"com.pk":true,"net.pk":true,"edu.pk":true,"org.pk":true,"fam.pk":true,"biz.pk":true,"web.pk":true,"gov.pk":true,"gob.pk":true,"gok.pk":true,"gon.pk":true,"gop.pk":true,"gos.pk":true,"info.pk":true,"pl":true,"com.pl":true,"net.pl":true,"org.pl":true,"info.pl":true,"waw.pl":true,"gov.pl":true,"aid.pl":true,"agro.pl":true,"atm.pl":true,"auto.pl":true,"biz.pl":true,"edu.pl":true,"gmina.pl":true,"gsm.pl":true,"mail.pl":true,"miasta.pl":true,"media.pl":true,"mil.pl":true,"nieruchomosci.pl":true,"nom.pl":true,"pc.pl":true,"powiat.pl":true,"priv.pl":true,"realestate.pl":true,"rel.pl":true,"sex.pl":true,"shop.pl":true,"sklep.pl":true,"sos.pl":true,"szkola.pl":true,"targi.pl":true,"tm.pl":true,"tourism.pl":true,"travel.pl":true,"turystyka.pl":true,"uw.gov.pl":true,"um.gov.pl":true,"ug.gov.pl":true,"upow.gov.pl":true,"starostwo.gov.pl":true,"so.gov.pl":true,"sr.gov.pl":true,"po.gov.pl":true,"pa.gov.pl":true,"augustow.pl":true,"babia-gora.pl":true,"bedzin.pl":true,"beskidy.pl":true,"bialowieza.pl":true,"bialystok.pl":true,"bielawa.pl":true,"bieszczady.pl":true,"boleslawiec.pl":true,"bydgoszcz.pl":true,"bytom.pl":true,"cieszyn.pl":true,"czeladz.pl":true,"czest.pl":true,"dlugoleka.pl":true,"elblag.pl":true,"elk.pl":true,"glogow.pl":true,"gniezno.pl":true,"gorlice.pl":true,"grajewo.pl":true,"ilawa.pl":true,"jaworzno.pl":true,"jelenia-gora.pl":true,"jgora.pl":true,"kalisz.pl":true,"kazimierz-dolny.pl":true,"karpacz.pl":true,"kartuzy.pl":true,"kaszuby.pl":true,"katowice.pl":true,"kepno.pl":true,"ketrzyn.pl":true,"klodzko.pl":true,"kobierzyce.pl":true,"kolobrzeg.pl":true,"konin.pl":true,"konskowola.pl":true,"kutno.pl":true,"lapy.pl":true,"lebork.pl":true,"legnica.pl":true,"lezajsk.pl":true,"limanowa.pl":true,"lomza.pl":true,"lowicz.pl":true,"lubin.pl":true,"lukow.pl":true,"malbork.pl":true,"malopolska.pl":true,"mazowsze.pl":true,"mazury.pl":true,"mielec.pl":true,"mielno.pl":true,"mragowo.pl":true,"naklo.pl":true,"nowaruda.pl":true,"nysa.pl":true,"olawa.pl":true,"olecko.pl":true,"olkusz.pl":true,"olsztyn.pl":true,"opoczno.pl":true,"opole.pl":true,"ostroda.pl":true,"ostroleka.pl":true,"ostrowiec.pl":true,"ostrowwlkp.pl":true,"pila.pl":true,"pisz.pl":true,"podhale.pl":true,"podlasie.pl":true,"polkowice.pl":true,"pomorze.pl":true,"pomorskie.pl":true,"prochowice.pl":true,"pruszkow.pl":true,"przeworsk.pl":true,"pulawy.pl":true,"radom.pl":true,"rawa-maz.pl":true,"rybnik.pl":true,"rzeszow.pl":true,"sanok.pl":true,"sejny.pl":true,"slask.pl":true,"slupsk.pl":true,"sosnowiec.pl":true,"stalowa-wola.pl":true,"skoczow.pl":true,"starachowice.pl":true,"stargard.pl":true,"suwalki.pl":true,"swidnica.pl":true,"swiebodzin.pl":true,"swinoujscie.pl":true,"szczecin.pl":true,"szczytno.pl":true,"tarnobrzeg.pl":true,"tgory.pl":true,"turek.pl":true,"tychy.pl":true,"ustka.pl":true,"walbrzych.pl":true,"warmia.pl":true,"warszawa.pl":true,"wegrow.pl":true,"wielun.pl":true,"wlocl.pl":true,"wloclawek.pl":true,"wodzislaw.pl":true,"wolomin.pl":true,"wroclaw.pl":true,"zachpomor.pl":true,"zagan.pl":true,"zarow.pl":true,"zgora.pl":true,"zgorzelec.pl":true,"pm":true,"pn":true,"gov.pn":true,"co.pn":true,"org.pn":true,"edu.pn":true,"net.pn":true,"post":true,"pr":true,"com.pr":true,"net.pr":true,"org.pr":true,"gov.pr":true,"edu.pr":true,"isla.pr":true,"pro.pr":true,"biz.pr":true,"info.pr":true,"name.pr":true,"est.pr":true,"prof.pr":true,"ac.pr":true,"pro":true,"aca.pro":true,"bar.pro":true,"cpa.pro":true,"jur.pro":true,"law.pro":true,"med.pro":true,"eng.pro":true,"ps":true,"edu.ps":true,"gov.ps":true,"sec.ps":true,"plo.ps":true,"com.ps":true,"org.ps":true,"net.ps":true,"pt":true,"net.pt":true,"gov.pt":true,"org.pt":true,"edu.pt":true,"int.pt":true,"publ.pt":true,"com.pt":true,"nome.pt":true,"pw":true,"co.pw":true,"ne.pw":true,"or.pw":true,"ed.pw":true,"go.pw":true,"belau.pw":true,"py":true,"com.py":true,"coop.py":true,"edu.py":true,"gov.py":true,"mil.py":true,"net.py":true,"org.py":true,"qa":true,"com.qa":true,"edu.qa":true,"gov.qa":true,"mil.qa":true,"name.qa":true,"net.qa":true,"org.qa":true,"sch.qa":true,"re":true,"com.re":true,"asso.re":true,"nom.re":true,"ro":true,"com.ro":true,"org.ro":true,"tm.ro":true,"nt.ro":true,"nom.ro":true,"info.ro":true,"rec.ro":true,"arts.ro":true,"firm.ro":true,"store.ro":true,"www.ro":true,"rs":true,"co.rs":true,"org.rs":true,"edu.rs":true,"ac.rs":true,"gov.rs":true,"in.rs":true,"ru":true,"ac.ru":true,"com.ru":true,"edu.ru":true,"int.ru":true,"net.ru":true,"org.ru":true,"pp.ru":true,"adygeya.ru":true,"altai.ru":true,"amur.ru":true,"arkhangelsk.ru":true,"astrakhan.ru":true,"bashkiria.ru":true,"belgorod.ru":true,"bir.ru":true,"bryansk.ru":true,"buryatia.ru":true,"cbg.ru":true,"chel.ru":true,"chelyabinsk.ru":true,"chita.ru":true,"chukotka.ru":true,"chuvashia.ru":true,"dagestan.ru":true,"dudinka.ru":true,"e-burg.ru":true,"grozny.ru":true,"irkutsk.ru":true,"ivanovo.ru":true,"izhevsk.ru":true,"jar.ru":true,"joshkar-ola.ru":true,"kalmykia.ru":true,"kaluga.ru":true,"kamchatka.ru":true,"karelia.ru":true,"kazan.ru":true,"kchr.ru":true,"kemerovo.ru":true,"khabarovsk.ru":true,"khakassia.ru":true,"khv.ru":true,"kirov.ru":true,"koenig.ru":true,"komi.ru":true,"kostroma.ru":true,"krasnoyarsk.ru":true,"kuban.ru":true,"kurgan.ru":true,"kursk.ru":true,"lipetsk.ru":true,"magadan.ru":true,"mari.ru":true,"mari-el.ru":true,"marine.ru":true,"mordovia.ru":true,"msk.ru":true,"murmansk.ru":true,"nalchik.ru":true,"nnov.ru":true,"nov.ru":true,"novosibirsk.ru":true,"nsk.ru":true,"omsk.ru":true,"orenburg.ru":true,"oryol.ru":true,"palana.ru":true,"penza.ru":true,"perm.ru":true,"ptz.ru":true,"rnd.ru":true,"ryazan.ru":true,"sakhalin.ru":true,"samara.ru":true,"saratov.ru":true,"simbirsk.ru":true,"smolensk.ru":true,"spb.ru":true,"stavropol.ru":true,"stv.ru":true,"surgut.ru":true,"tambov.ru":true,"tatarstan.ru":true,"tom.ru":true,"tomsk.ru":true,"tsaritsyn.ru":true,"tsk.ru":true,"tula.ru":true,"tuva.ru":true,"tver.ru":true,"tyumen.ru":true,"udm.ru":true,"udmurtia.ru":true,"ulan-ude.ru":true,"vladikavkaz.ru":true,"vladimir.ru":true,"vladivostok.ru":true,"volgograd.ru":true,"vologda.ru":true,"voronezh.ru":true,"vrn.ru":true,"vyatka.ru":true,"yakutia.ru":true,"yamal.ru":true,"yaroslavl.ru":true,"yekaterinburg.ru":true,"yuzhno-sakhalinsk.ru":true,"amursk.ru":true,"baikal.ru":true,"cmw.ru":true,"fareast.ru":true,"jamal.ru":true,"kms.ru":true,"k-uralsk.ru":true,"kustanai.ru":true,"kuzbass.ru":true,"magnitka.ru":true,"mytis.ru":true,"nakhodka.ru":true,"nkz.ru":true,"norilsk.ru":true,"oskol.ru":true,"pyatigorsk.ru":true,"rubtsovsk.ru":true,"snz.ru":true,"syzran.ru":true,"vdonsk.ru":true,"zgrad.ru":true,"gov.ru":true,"mil.ru":true,"test.ru":true,"rw":true,"gov.rw":true,"net.rw":true,"edu.rw":true,"ac.rw":true,"com.rw":true,"co.rw":true,"int.rw":true,"mil.rw":true,"gouv.rw":true,"sa":true,"com.sa":true,"net.sa":true,"org.sa":true,"gov.sa":true,"med.sa":true,"pub.sa":true,"edu.sa":true,"sch.sa":true,"sb":true,"com.sb":true,"edu.sb":true,"gov.sb":true,"net.sb":true,"org.sb":true,"sc":true,"com.sc":true,"gov.sc":true,"net.sc":true,"org.sc":true,"edu.sc":true,"sd":true,"com.sd":true,"net.sd":true,"org.sd":true,"edu.sd":true,"med.sd":true,"tv.sd":true,"gov.sd":true,"info.sd":true,"se":true,"a.se":true,"ac.se":true,"b.se":true,"bd.se":true,"brand.se":true,"c.se":true,"d.se":true,"e.se":true,"f.se":true,"fh.se":true,"fhsk.se":true,"fhv.se":true,"g.se":true,"h.se":true,"i.se":true,"k.se":true,"komforb.se":true,"kommunalforbund.se":true,"komvux.se":true,"l.se":true,"lanbib.se":true,"m.se":true,"n.se":true,"naturbruksgymn.se":true,"o.se":true,"org.se":true,"p.se":true,"parti.se":true,"pp.se":true,"press.se":true,"r.se":true,"s.se":true,"t.se":true,"tm.se":true,"u.se":true,"w.se":true,"x.se":true,"y.se":true,"z.se":true,"sg":true,"com.sg":true,"net.sg":true,"org.sg":true,"gov.sg":true,"edu.sg":true,"per.sg":true,"sh":true,"com.sh":true,"net.sh":true,"gov.sh":true,"org.sh":true,"mil.sh":true,"si":true,"sj":true,"sk":true,"sl":true,"com.sl":true,"net.sl":true,"edu.sl":true,"gov.sl":true,"org.sl":true,"sm":true,"sn":true,"art.sn":true,"com.sn":true,"edu.sn":true,"gouv.sn":true,"org.sn":true,"perso.sn":true,"univ.sn":true,"so":true,"com.so":true,"net.so":true,"org.so":true,"sr":true,"st":true,"co.st":true,"com.st":true,"consulado.st":true,"edu.st":true,"embaixada.st":true,"gov.st":true,"mil.st":true,"net.st":true,"org.st":true,"principe.st":true,"saotome.st":true,"store.st":true,"su":true,"adygeya.su":true,"arkhangelsk.su":true,"balashov.su":true,"bashkiria.su":true,"bryansk.su":true,"dagestan.su":true,"grozny.su":true,"ivanovo.su":true,"kalmykia.su":true,"kaluga.su":true,"karelia.su":true,"khakassia.su":true,"krasnodar.su":true,"kurgan.su":true,"lenug.su":true,"mordovia.su":true,"msk.su":true,"murmansk.su":true,"nalchik.su":true,"nov.su":true,"obninsk.su":true,"penza.su":true,"pokrovsk.su":true,"sochi.su":true,"spb.su":true,"togliatti.su":true,"troitsk.su":true,"tula.su":true,"tuva.su":true,"vladikavkaz.su":true,"vladimir.su":true,"vologda.su":true,"sv":true,"com.sv":true,"edu.sv":true,"gob.sv":true,"org.sv":true,"red.sv":true,"sx":true,"gov.sx":true,"sy":true,"edu.sy":true,"gov.sy":true,"net.sy":true,"mil.sy":true,"com.sy":true,"org.sy":true,"sz":true,"co.sz":true,"ac.sz":true,"org.sz":true,"tc":true,"td":true,"tel":true,"tf":true,"tg":true,"th":true,"ac.th":true,"co.th":true,"go.th":true,"in.th":true,"mi.th":true,"net.th":true,"or.th":true,"tj":true,"ac.tj":true,"biz.tj":true,"co.tj":true,"com.tj":true,"edu.tj":true,"go.tj":true,"gov.tj":true,"int.tj":true,"mil.tj":true,"name.tj":true,"net.tj":true,"nic.tj":true,"org.tj":true,"test.tj":true,"web.tj":true,"tk":true,"tl":true,"gov.tl":true,"tm":true,"com.tm":true,"co.tm":true,"org.tm":true,"net.tm":true,"nom.tm":true,"gov.tm":true,"mil.tm":true,"edu.tm":true,"tn":true,"com.tn":true,"ens.tn":true,"fin.tn":true,"gov.tn":true,"ind.tn":true,"intl.tn":true,"nat.tn":true,"net.tn":true,"org.tn":true,"info.tn":true,"perso.tn":true,"tourism.tn":true,"edunet.tn":true,"rnrt.tn":true,"rns.tn":true,"rnu.tn":true,"mincom.tn":true,"agrinet.tn":true,"defense.tn":true,"turen.tn":true,"to":true,"com.to":true,"gov.to":true,"net.to":true,"org.to":true,"edu.to":true,"mil.to":true,"tp":true,"tr":true,"com.tr":true,"info.tr":true,"biz.tr":true,"net.tr":true,"org.tr":true,"web.tr":true,"gen.tr":true,"tv.tr":true,"av.tr":true,"dr.tr":true,"bbs.tr":true,"name.tr":true,"tel.tr":true,"gov.tr":true,"bel.tr":true,"pol.tr":true,"mil.tr":true,"k12.tr":true,"edu.tr":true,"kep.tr":true,"nc.tr":true,"gov.nc.tr":true,"travel":true,"tt":true,"co.tt":true,"com.tt":true,"org.tt":true,"net.tt":true,"biz.tt":true,"info.tt":true,"pro.tt":true,"int.tt":true,"coop.tt":true,"jobs.tt":true,"mobi.tt":true,"travel.tt":true,"museum.tt":true,"aero.tt":true,"name.tt":true,"gov.tt":true,"edu.tt":true,"tv":true,"tw":true,"edu.tw":true,"gov.tw":true,"mil.tw":true,"com.tw":true,"net.tw":true,"org.tw":true,"idv.tw":true,"game.tw":true,"ebiz.tw":true,"club.tw":true,"xn--zf0ao64a.tw":true,"xn--uc0atv.tw":true,"xn--czrw28b.tw":true,"tz":true,"ac.tz":true,"co.tz":true,"go.tz":true,"hotel.tz":true,"info.tz":true,"me.tz":true,"mil.tz":true,"mobi.tz":true,"ne.tz":true,"or.tz":true,"sc.tz":true,"tv.tz":true,"ua":true,"com.ua":true,"edu.ua":true,"gov.ua":true,"in.ua":true,"net.ua":true,"org.ua":true,"cherkassy.ua":true,"cherkasy.ua":true,"chernigov.ua":true,"chernihiv.ua":true,"chernivtsi.ua":true,"chernovtsy.ua":true,"ck.ua":true,"cn.ua":true,"cr.ua":true,"crimea.ua":true,"cv.ua":true,"dn.ua":true,"dnepropetrovsk.ua":true,"dnipropetrovsk.ua":true,"dominic.ua":true,"donetsk.ua":true,"dp.ua":true,"if.ua":true,"ivano-frankivsk.ua":true,"kh.ua":true,"kharkiv.ua":true,"kharkov.ua":true,"kherson.ua":true,"khmelnitskiy.ua":true,"khmelnytskyi.ua":true,"kiev.ua":true,"kirovograd.ua":true,"km.ua":true,"kr.ua":true,"krym.ua":true,"ks.ua":true,"kv.ua":true,"kyiv.ua":true,"lg.ua":true,"lt.ua":true,"lugansk.ua":true,"lutsk.ua":true,"lv.ua":true,"lviv.ua":true,"mk.ua":true,"mykolaiv.ua":true,"nikolaev.ua":true,"od.ua":true,"odesa.ua":true,"odessa.ua":true,"pl.ua":true,"poltava.ua":true,"rivne.ua":true,"rovno.ua":true,"rv.ua":true,"sb.ua":true,"sebastopol.ua":true,"sevastopol.ua":true,"sm.ua":true,"sumy.ua":true,"te.ua":true,"ternopil.ua":true,"uz.ua":true,"uzhgorod.ua":true,"vinnica.ua":true,"vinnytsia.ua":true,"vn.ua":true,"volyn.ua":true,"yalta.ua":true,"zaporizhzhe.ua":true,"zaporizhzhia.ua":true,"zhitomir.ua":true,"zhytomyr.ua":true,"zp.ua":true,"zt.ua":true,"co.ua":true,"pp.ua":true,"ug":true,"co.ug":true,"or.ug":true,"ac.ug":true,"sc.ug":true,"go.ug":true,"ne.ug":true,"com.ug":true,"org.ug":true,"uk":true,"ac.uk":true,"co.uk":true,"gov.uk":true,"ltd.uk":true,"me.uk":true,"net.uk":true,"nhs.uk":true,"org.uk":true,"plc.uk":true,"police.uk":true,"*.sch.uk":true,"us":true,"dni.us":true,"fed.us":true,"isa.us":true,"kids.us":true,"nsn.us":true,"ak.us":true,"al.us":true,"ar.us":true,"as.us":true,"az.us":true,"ca.us":true,"co.us":true,"ct.us":true,"dc.us":true,"de.us":true,"fl.us":true,"ga.us":true,"gu.us":true,"hi.us":true,"ia.us":true,"id.us":true,"il.us":true,"in.us":true,"ks.us":true,"ky.us":true,"la.us":true,"ma.us":true,"md.us":true,"me.us":true,"mi.us":true,"mn.us":true,"mo.us":true,"ms.us":true,"mt.us":true,"nc.us":true,"nd.us":true,"ne.us":true,"nh.us":true,"nj.us":true,"nm.us":true,"nv.us":true,"ny.us":true,"oh.us":true,"ok.us":true,"or.us":true,"pa.us":true,"pr.us":true,"ri.us":true,"sc.us":true,"sd.us":true,"tn.us":true,"tx.us":true,"ut.us":true,"vi.us":true,"vt.us":true,"va.us":true,"wa.us":true,"wi.us":true,"wv.us":true,"wy.us":true,"k12.ak.us":true,"k12.al.us":true,"k12.ar.us":true,"k12.as.us":true,"k12.az.us":true,"k12.ca.us":true,"k12.co.us":true,"k12.ct.us":true,"k12.dc.us":true,"k12.de.us":true,"k12.fl.us":true,"k12.ga.us":true,"k12.gu.us":true,"k12.ia.us":true,"k12.id.us":true,"k12.il.us":true,"k12.in.us":true,"k12.ks.us":true,"k12.ky.us":true,"k12.la.us":true,"k12.ma.us":true,"k12.md.us":true,"k12.me.us":true,"k12.mi.us":true,"k12.mn.us":true,"k12.mo.us":true,"k12.ms.us":true,"k12.mt.us":true,"k12.nc.us":true,"k12.ne.us":true,"k12.nh.us":true,"k12.nj.us":true,"k12.nm.us":true,"k12.nv.us":true,"k12.ny.us":true,"k12.oh.us":true,"k12.ok.us":true,"k12.or.us":true,"k12.pa.us":true,"k12.pr.us":true,"k12.ri.us":true,"k12.sc.us":true,"k12.tn.us":true,"k12.tx.us":true,"k12.ut.us":true,"k12.vi.us":true,"k12.vt.us":true,"k12.va.us":true,"k12.wa.us":true,"k12.wi.us":true,"k12.wy.us":true,"cc.ak.us":true,"cc.al.us":true,"cc.ar.us":true,"cc.as.us":true,"cc.az.us":true,"cc.ca.us":true,"cc.co.us":true,"cc.ct.us":true,"cc.dc.us":true,"cc.de.us":true,"cc.fl.us":true,"cc.ga.us":true,"cc.gu.us":true,"cc.hi.us":true,"cc.ia.us":true,"cc.id.us":true,"cc.il.us":true,"cc.in.us":true,"cc.ks.us":true,"cc.ky.us":true,"cc.la.us":true,"cc.ma.us":true,"cc.md.us":true,"cc.me.us":true,"cc.mi.us":true,"cc.mn.us":true,"cc.mo.us":true,"cc.ms.us":true,"cc.mt.us":true,"cc.nc.us":true,"cc.nd.us":true,"cc.ne.us":true,"cc.nh.us":true,"cc.nj.us":true,"cc.nm.us":true,"cc.nv.us":true,"cc.ny.us":true,"cc.oh.us":true,"cc.ok.us":true,"cc.or.us":true,"cc.pa.us":true,"cc.pr.us":true,"cc.ri.us":true,"cc.sc.us":true,"cc.sd.us":true,"cc.tn.us":true,"cc.tx.us":true,"cc.ut.us":true,"cc.vi.us":true,"cc.vt.us":true,"cc.va.us":true,"cc.wa.us":true,"cc.wi.us":true,"cc.wv.us":true,"cc.wy.us":true,"lib.ak.us":true,"lib.al.us":true,"lib.ar.us":true,"lib.as.us":true,"lib.az.us":true,"lib.ca.us":true,"lib.co.us":true,"lib.ct.us":true,"lib.dc.us":true,"lib.de.us":true,"lib.fl.us":true,"lib.ga.us":true,"lib.gu.us":true,"lib.hi.us":true,"lib.ia.us":true,"lib.id.us":true,"lib.il.us":true,"lib.in.us":true,"lib.ks.us":true,"lib.ky.us":true,"lib.la.us":true,"lib.ma.us":true,"lib.md.us":true,"lib.me.us":true,"lib.mi.us":true,"lib.mn.us":true,"lib.mo.us":true,"lib.ms.us":true,"lib.mt.us":true,"lib.nc.us":true,"lib.nd.us":true,"lib.ne.us":true,"lib.nh.us":true,"lib.nj.us":true,"lib.nm.us":true,"lib.nv.us":true,"lib.ny.us":true,"lib.oh.us":true,"lib.ok.us":true,"lib.or.us":true,"lib.pa.us":true,"lib.pr.us":true,"lib.ri.us":true,"lib.sc.us":true,"lib.sd.us":true,"lib.tn.us":true,"lib.tx.us":true,"lib.ut.us":true,"lib.vi.us":true,"lib.vt.us":true,"lib.va.us":true,"lib.wa.us":true,"lib.wi.us":true,"lib.wy.us":true,"pvt.k12.ma.us":true,"chtr.k12.ma.us":true,"paroch.k12.ma.us":true,"uy":true,"com.uy":true,"edu.uy":true,"gub.uy":true,"mil.uy":true,"net.uy":true,"org.uy":true,"uz":true,"co.uz":true,"com.uz":true,"net.uz":true,"org.uz":true,"va":true,"vc":true,"com.vc":true,"net.vc":true,"org.vc":true,"gov.vc":true,"mil.vc":true,"edu.vc":true,"ve":true,"arts.ve":true,"co.ve":true,"com.ve":true,"e12.ve":true,"edu.ve":true,"firm.ve":true,"gob.ve":true,"gov.ve":true,"info.ve":true,"int.ve":true,"mil.ve":true,"net.ve":true,"org.ve":true,"rec.ve":true,"store.ve":true,"tec.ve":true,"web.ve":true,"vg":true,"vi":true,"co.vi":true,"com.vi":true,"k12.vi":true,"net.vi":true,"org.vi":true,"vn":true,"com.vn":true,"net.vn":true,"org.vn":true,"edu.vn":true,"gov.vn":true,"int.vn":true,"ac.vn":true,"biz.vn":true,"info.vn":true,"name.vn":true,"pro.vn":true,"health.vn":true,"vu":true,"com.vu":true,"edu.vu":true,"net.vu":true,"org.vu":true,"wf":true,"ws":true,"com.ws":true,"net.ws":true,"org.ws":true,"gov.ws":true,"edu.ws":true,"yt":true,"xn--mgbaam7a8h":true,"xn--54b7fta0cc":true,"xn--fiqs8s":true,"xn--fiqz9s":true,"xn--lgbbat1ad8j":true,"xn--wgbh1c":true,"xn--node":true,"xn--j6w193g":true,"xn--h2brj9c":true,"xn--mgbbh1a71e":true,"xn--fpcrj9c3d":true,"xn--gecrj9c":true,"xn--s9brj9c":true,"xn--45brj9c":true,"xn--xkc2dl3a5ee0h":true,"xn--mgba3a4f16a":true,"xn--mgba3a4fra":true,"xn--mgbayh7gpa":true,"xn--3e0b707e":true,"xn--80ao21a":true,"xn--fzc2c9e2c":true,"xn--xkc2al3hye2a":true,"xn--mgbc0a9azcg":true,"xn--l1acc":true,"xn--mgbx4cd0ab":true,"xn--mgb9awbf":true,"xn--ygbi2ammx":true,"xn--90a3ac":true,"xn--o1ac.xn--90a3ac":true,"xn--c1avg.xn--90a3ac":true,"xn--90azh.xn--90a3ac":true,"xn--d1at.xn--90a3ac":true,"xn--o1ach.xn--90a3ac":true,"xn--80au.xn--90a3ac":true,"xn--p1ai":true,"xn--wgbl6a":true,"xn--mgberp4a5d4ar":true,"xn--mgberp4a5d4a87g":true,"xn--mgbqly7c0a67fbc":true,"xn--mgbqly7cvafr":true,"xn--ogbpf8fl":true,"xn--mgbtf8fl":true,"xn--yfro4i67o":true,"xn--clchc0ea0b2g2a9gcd":true,"xn--o3cw4h":true,"xn--pgbs0dh":true,"xn--kpry57d":true,"xn--kprw13d":true,"xn--nnx388a":true,"xn--j1amh":true,"xn--mgb2ddes":true,"xxx":true,"*.ye":true,"*.za":true,"*.zm":true,"*.zw":true,"aaa":true,"abb":true,"abbott":true,"abogado":true,"academy":true,"accenture":true,"accountant":true,"accountants":true,"aco":true,"active":true,"actor":true,"ads":true,"adult":true,"aeg":true,"afl":true,"africa":true,"africamagic":true,"agency":true,"aig":true,"airforce":true,"airtel":true,"alibaba":true,"alipay":true,"allfinanz":true,"alsace":true,"amsterdam":true,"analytics":true,"android":true,"anquan":true,"apartments":true,"aquarelle":true,"aramco":true,"archi":true,"army":true,"arte":true,"associates":true,"attorney":true,"auction":true,"audio":true,"author":true,"auto":true,"autos":true,"avianca":true,"axa":true,"azure":true,"baidu":true,"band":true,"bank":true,"bar":true,"barcelona":true,"barclaycard":true,"barclays":true,"bargains":true,"bauhaus":true,"bayern":true,"bbc":true,"bbva":true,"bcg":true,"bcn":true,"beer":true,"bentley":true,"berlin":true,"best":true,"bharti":true,"bible":true,"bid":true,"bike":true,"bing":true,"bingo":true,"bio":true,"black":true,"blackfriday":true,"bloomberg":true,"blue":true,"bms":true,"bmw":true,"bnl":true,"bnpparibas":true,"boats":true,"bom":true,"bond":true,"boo":true,"boots":true,"bot":true,"boutique":true,"bradesco":true,"bridgestone":true,"broadway":true,"broker":true,"brother":true,"brussels":true,"budapest":true,"build":true,"builders":true,"business":true,"buy":true,"buzz":true,"bzh":true,"cab":true,"cafe":true,"cal":true,"call":true,"camera":true,"camp":true,"cancerresearch":true,"canon":true,"capetown":true,"capital":true,"car":true,"caravan":true,"cards":true,"care":true,"career":true,"careers":true,"cars":true,"cartier":true,"casa":true,"cash":true,"casino":true,"catering":true,"cba":true,"cbn":true,"center":true,"ceo":true,"cern":true,"cfa":true,"cfd":true,"channel":true,"chat":true,"cheap":true,"chloe":true,"christmas":true,"chrome":true,"church":true,"cipriani":true,"circle":true,"cisco":true,"citic":true,"city":true,"cityeats":true,"claims":true,"cleaning":true,"click":true,"clinic":true,"clothing":true,"club":true,"coach":true,"codes":true,"coffee":true,"college":true,"cologne":true,"commbank":true,"community":true,"company":true,"computer":true,"comsec":true,"condos":true,"construction":true,"consulting":true,"contact":true,"contractors":true,"cooking":true,"cool":true,"corsica":true,"country":true,"coupon":true,"coupons":true,"courses":true,"credit":true,"creditcard":true,"creditunion":true,"cricket":true,"crown":true,"crs":true,"cruises":true,"csc":true,"cuisinella":true,"cymru":true,"cyou":true,"dabur":true,"dad":true,"dance":true,"date":true,"dating":true,"datsun":true,"day":true,"dclk":true,"dealer":true,"deals":true,"degree":true,"delivery":true,"dell":true,"delta":true,"democrat":true,"dental":true,"dentist":true,"desi":true,"design":true,"dev":true,"diamonds":true,"diet":true,"digital":true,"direct":true,"directory":true,"discount":true,"dnp":true,"docs":true,"dog":true,"doha":true,"domains":true,"doosan":true,"download":true,"drive":true,"dstv":true,"dubai":true,"durban":true,"dvag":true,"earth":true,"eat":true,"edeka":true,"education":true,"email":true,"emerck":true,"energy":true,"engineer":true,"engineering":true,"enterprises":true,"epson":true,"equipment":true,"erni":true,"esq":true,"estate":true,"eurovision":true,"eus":true,"events":true,"everbank":true,"exchange":true,"expert":true,"exposed":true,"express":true,"fage":true,"fail":true,"fairwinds":true,"faith":true,"family":true,"fan":true,"fans":true,"farm":true,"fashion":true,"fast":true,"feedback":true,"ferrero":true,"film":true,"final":true,"finance":true,"financial":true,"firestone":true,"firmdale":true,"fish":true,"fishing":true,"fit":true,"fitness":true,"flickr":true,"flights":true,"florist":true,"flowers":true,"flsmidth":true,"fly":true,"foo":true,"football":true,"ford":true,"forex":true,"forsale":true,"forum":true,"foundation":true,"frl":true,"frogans":true,"frontier":true,"fund":true,"furniture":true,"futbol":true,"fyi":true,"gal":true,"gallery":true,"gallup":true,"garden":true,"gbiz":true,"gdn":true,"gea":true,"gent":true,"genting":true,"ggee":true,"gift":true,"gifts":true,"gives":true,"giving":true,"glass":true,"gle":true,"global":true,"globo":true,"gmail":true,"gmo":true,"gmx":true,"gold":true,"goldpoint":true,"golf":true,"goo":true,"goog":true,"google":true,"gop":true,"got":true,"gotv":true,"graphics":true,"gratis":true,"green":true,"gripe":true,"group":true,"gucci":true,"guge":true,"guide":true,"guitars":true,"guru":true,"hamburg":true,"hangout":true,"haus":true,"hdfcbank":true,"health":true,"healthcare":true,"help":true,"helsinki":true,"here":true,"hermes":true,"hiphop":true,"hitachi":true,"hiv":true,"hockey":true,"holdings":true,"holiday":true,"homedepot":true,"homes":true,"honda":true,"horse":true,"host":true,"hosting":true,"hoteles":true,"hotmail":true,"house":true,"how":true,"hsbc":true,"htc":true,"ibm":true,"icbc":true,"ice":true,"icu":true,"ifm":true,"iinet":true,"immo":true,"immobilien":true,"industries":true,"infiniti":true,"ing":true,"ink":true,"institute":true,"insurance":true,"insure":true,"international":true,"investments":true,"ipiranga":true,"irish":true,"iselect":true,"ist":true,"istanbul":true,"itau":true,"iwc":true,"jaguar":true,"java":true,"jcb":true,"jetzt":true,"jewelry":true,"jio":true,"jlc":true,"jll":true,"jmp":true,"joburg":true,"jot":true,"joy":true,"jprs":true,"juegos":true,"kaufen":true,"kddi":true,"kfh":true,"kim":true,"kinder":true,"kitchen":true,"kiwi":true,"koeln":true,"komatsu":true,"kpn":true,"krd":true,"kred":true,"kyknet":true,"kyoto":true,"lacaixa":true,"lancaster":true,"land":true,"landrover":true,"lasalle":true,"lat":true,"latrobe":true,"law":true,"lawyer":true,"lds":true,"lease":true,"leclerc":true,"legal":true,"lgbt":true,"liaison":true,"lidl":true,"life":true,"lifeinsurance":true,"lifestyle":true,"lighting":true,"like":true,"limited":true,"limo":true,"lincoln":true,"linde":true,"link":true,"live":true,"lixil":true,"loan":true,"loans":true,"lol":true,"london":true,"lotte":true,"lotto":true,"love":true,"ltd":true,"ltda":true,"lupin":true,"luxe":true,"luxury":true,"madrid":true,"maif":true,"maison":true,"makeup":true,"man":true,"management":true,"mango":true,"market":true,"marketing":true,"markets":true,"marriott":true,"mba":true,"media":true,"meet":true,"melbourne":true,"meme":true,"memorial":true,"men":true,"menu":true,"meo":true,"miami":true,"microsoft":true,"mini":true,"mma":true,"mnet":true,"mobily":true,"moda":true,"moe":true,"moi":true,"monash":true,"money":true,"montblanc":true,"mormon":true,"mortgage":true,"moscow":true,"motorcycles":true,"mov":true,"movie":true,"movistar":true,"mtn":true,"mtpc":true,"mtr":true,"multichoice":true,"mutual":true,"mzansimagic":true,"nadex":true,"nagoya":true,"naspers":true,"natura":true,"navy":true,"nec":true,"netbank":true,"network":true,"neustar":true,"new":true,"news":true,"nexus":true,"ngo":true,"nhk":true,"nico":true,"ninja":true,"nissan":true,"nokia":true,"norton":true,"nowruz":true,"nra":true,"nrw":true,"ntt":true,"nyc":true,"obi":true,"office":true,"okinawa":true,"omega":true,"one":true,"ong":true,"onl":true,"online":true,"ooo":true,"oracle":true,"orange":true,"organic":true,"orientexpress":true,"osaka":true,"otsuka":true,"ovh":true,"page":true,"pamperedchef":true,"panerai":true,"paris":true,"pars":true,"partners":true,"parts":true,"party":true,"passagens":true,"payu":true,"pharmacy":true,"philips":true,"photo":true,"photography":true,"photos":true,"physio":true,"piaget":true,"pics":true,"pictet":true,"pictures":true,"pid":true,"pin":true,"pink":true,"pizza":true,"place":true,"play":true,"plumbing":true,"plus":true,"pohl":true,"poker":true,"porn":true,"praxi":true,"press":true,"prod":true,"productions":true,"prof":true,"promo":true,"properties":true,"property":true,"pub":true,"qpon":true,"quebec":true,"quest":true,"racing":true,"read":true,"realtor":true,"realty":true,"recipes":true,"red":true,"redstone":true,"redumbrella":true,"rehab":true,"reise":true,"reisen":true,"reit":true,"reliance":true,"ren":true,"rent":true,"rentals":true,"repair":true,"report":true,"republican":true,"rest":true,"restaurant":true,"review":true,"reviews":true,"rich":true,"ricoh":true,"ril":true,"rio":true,"rip":true,"rocher":true,"rocks":true,"rodeo":true,"room":true,"rsvp":true,"ruhr":true,"run":true,"rwe":true,"ryukyu":true,"saarland":true,"safe":true,"safety":true,"sakura":true,"sale":true,"salon":true,"samsung":true,"sandvik":true,"sandvikcoromant":true,"sanofi":true,"sap":true,"sapo":true,"sarl":true,"sas":true,"saxo":true,"sbi":true,"sbs":true,"sca":true,"scb":true,"schmidt":true,"scholarships":true,"school":true,"schule":true,"schwarz":true,"science":true,"scor":true,"scot":true,"seat":true,"seek":true,"sener":true,"services":true,"sew":true,"sex":true,"sexy":true,"sharp":true,"shia":true,"shiksha":true,"shoes":true,"shouji":true,"show":true,"shriram":true,"sina":true,"singles":true,"site":true,"skin":true,"sky":true,"skype":true,"smile":true,"sncf":true,"soccer":true,"social":true,"software":true,"sohu":true,"solar":true,"solutions":true,"song":true,"sony":true,"soy":true,"space":true,"spiegel":true,"spot":true,"spreadbetting":true,"stada":true,"star":true,"starhub":true,"statebank":true,"statoil":true,"stc":true,"stcgroup":true,"stockholm":true,"storage":true,"studio":true,"study":true,"style":true,"sucks":true,"supersport":true,"supplies":true,"supply":true,"support":true,"surf":true,"surgery":true,"suzuki":true,"swatch":true,"swiss":true,"sydney":true,"symantec":true,"systems":true,"tab":true,"taipei":true,"taobao":true,"tatamotors":true,"tatar":true,"tattoo":true,"tax":true,"taxi":true,"tci":true,"team":true,"tech":true,"technology":true,"telecity":true,"telefonica":true,"temasek":true,"tennis":true,"thd":true,"theater":true,"tickets":true,"tienda":true,"tiffany":true,"tips":true,"tires":true,"tirol":true,"tmall":true,"today":true,"tokyo":true,"tools":true,"top":true,"toray":true,"toshiba":true,"tours":true,"town":true,"toys":true,"trade":true,"trading":true,"training":true,"travelers":true,"travelersinsurance":true,"trust":true,"trv":true,"tui":true,"tunes":true,"tushu":true,"tvs":true,"ubs":true,"university":true,"uno":true,"uol":true,"vacations":true,"vana":true,"vegas":true,"ventures":true,"versicherung":true,"vet":true,"viajes":true,"video":true,"viking":true,"villas":true,"vip":true,"virgin":true,"vision":true,"vista":true,"vistaprint":true,"viva":true,"vlaanderen":true,"vodka":true,"vote":true,"voting":true,"voto":true,"voyage":true,"vuelos":true,"wales":true,"walter":true,"wang":true,"wanggou":true,"watch":true,"watches":true,"weather":true,"weatherchannel":true,"webcam":true,"website":true,"wed":true,"wedding":true,"weibo":true,"weir":true,"whoswho":true,"wien":true,"wiki":true,"williamhill":true,"win":true,"windows":true,"wme":true,"work":true,"works":true,"world":true,"wtc":true,"wtf":true,"xbox":true,"xerox":true,"xihuan":true,"xin":true,"xn--11b4c3d":true,"xn--1ck2e1b":true,"xn--1qqw23a":true,"xn--30rr7y":true,"xn--3bst00m":true,"xn--3ds443g":true,"xn--3pxu8k":true,"xn--42c2d9a":true,"xn--45q11c":true,"xn--4gbrim":true,"xn--55qw42g":true,"xn--55qx5d":true,"xn--5tzm5g":true,"xn--6frz82g":true,"xn--6qq986b3xl":true,"xn--80adxhks":true,"xn--80asehdb":true,"xn--80aswg":true,"xn--8y0a063a":true,"xn--9dbq2a":true,"xn--9et52u":true,"xn--9krt00a":true,"xn--b4w605ferd":true,"xn--bck1b9a5dre4c":true,"xn--c1avg":true,"xn--c2br7g":true,"xn--cck2b3b":true,"xn--cg4bki":true,"xn--czr694b":true,"xn--czrs0t":true,"xn--czru2d":true,"xn--d1acj3b":true,"xn--eckvdtc9d":true,"xn--efvy88h":true,"xn--estv75g":true,"xn--fhbei":true,"xn--fiq228c5hs":true,"xn--fiq64b":true,"xn--fjq720a":true,"xn--flw351e":true,"xn--g2xx48c":true,"xn--gckr3f0f":true,"xn--hxt814e":true,"xn--i1b6b1a6a2e":true,"xn--imr513n":true,"xn--io0a7i":true,"xn--j1aef":true,"xn--jlq61u9w7b":true,"xn--jvr189m":true,"xn--kcrx77d1x4a":true,"xn--kpu716f":true,"xn--kput3i":true,"xn--mgba3a3ejt":true,"xn--mgbab2bd":true,"xn--mgbb9fbpob":true,"xn--mgbt3dhd":true,"xn--mk1bu44c":true,"xn--mxtq1m":true,"xn--ngbc5azd":true,"xn--ngbe9e0a":true,"xn--nqv7f":true,"xn--nqv7fs00ema":true,"xn--nyqy26a":true,"xn--p1acf":true,"xn--pbt977c":true,"xn--pssy2u":true,"xn--q9jyb4c":true,"xn--qcka1pmc":true,"xn--rhqv96g":true,"xn--rovu88b":true,"xn--ses554g":true,"xn--t60b56a":true,"xn--tckwe":true,"xn--unup4y":true,"xn--vermgensberater-ctb":true,"xn--vermgensberatung-pwb":true,"xn--vhquv":true,"xn--vuq861b":true,"xn--xhq521b":true,"xn--zfr164b":true,"xyz":true,"yachts":true,"yahoo":true,"yamaxun":true,"yandex":true,"yodobashi":true,"yoga":true,"yokohama":true,"youtube":true,"yun":true,"zara":true,"zero":true,"zip":true,"zone":true,"zuerich":true,"cloudfront.net":true,"ap-northeast-1.compute.amazonaws.com":true,"ap-southeast-1.compute.amazonaws.com":true,"ap-southeast-2.compute.amazonaws.com":true,"cn-north-1.compute.amazonaws.cn":true,"compute.amazonaws.cn":true,"compute.amazonaws.com":true,"compute-1.amazonaws.com":true,"eu-west-1.compute.amazonaws.com":true,"eu-central-1.compute.amazonaws.com":true,"sa-east-1.compute.amazonaws.com":true,"us-east-1.amazonaws.com":true,"us-gov-west-1.compute.amazonaws.com":true,"us-west-1.compute.amazonaws.com":true,"us-west-2.compute.amazonaws.com":true,"z-1.compute-1.amazonaws.com":true,"z-2.compute-1.amazonaws.com":true,"elasticbeanstalk.com":true,"elb.amazonaws.com":true,"s3.amazonaws.com":true,"s3-us-west-2.amazonaws.com":true,"s3-us-west-1.amazonaws.com":true,"s3-eu-west-1.amazonaws.com":true,"s3-ap-southeast-1.amazonaws.com":true,"s3-ap-southeast-2.amazonaws.com":true,"s3-ap-northeast-1.amazonaws.com":true,"s3-sa-east-1.amazonaws.com":true,"s3-us-gov-west-1.amazonaws.com":true,"s3-fips-us-gov-west-1.amazonaws.com":true,"s3-website-us-east-1.amazonaws.com":true,"s3-website-us-west-2.amazonaws.com":true,"s3-website-us-west-1.amazonaws.com":true,"s3-website-eu-west-1.amazonaws.com":true,"s3-website-ap-southeast-1.amazonaws.com":true,"s3-website-ap-southeast-2.amazonaws.com":true,"s3-website-ap-northeast-1.amazonaws.com":true,"s3-website-sa-east-1.amazonaws.com":true,"s3-website-us-gov-west-1.amazonaws.com":true,"betainabox.com":true,"ae.org":true,"ar.com":true,"br.com":true,"cn.com":true,"com.de":true,"com.se":true,"de.com":true,"eu.com":true,"gb.com":true,"gb.net":true,"hu.com":true,"hu.net":true,"jp.net":true,"jpn.com":true,"kr.com":true,"mex.com":true,"no.com":true,"qc.com":true,"ru.com":true,"sa.com":true,"se.com":true,"se.net":true,"uk.com":true,"uk.net":true,"us.com":true,"uy.com":true,"za.bz":true,"za.com":true,"africa.com":true,"gr.com":true,"in.net":true,"us.org":true,"co.com":true,"c.la":true,"cloudcontrolled.com":true,"cloudcontrolapp.com":true,"co.ca":true,"co.nl":true,"co.no":true,"*.platform.sh":true,"cupcake.is":true,"dreamhosters.com":true,"dyndns-at-home.com":true,"dyndns-at-work.com":true,"dyndns-blog.com":true,"dyndns-free.com":true,"dyndns-home.com":true,"dyndns-ip.com":true,"dyndns-mail.com":true,"dyndns-office.com":true,"dyndns-pics.com":true,"dyndns-remote.com":true,"dyndns-server.com":true,"dyndns-web.com":true,"dyndns-wiki.com":true,"dyndns-work.com":true,"dyndns.biz":true,"dyndns.info":true,"dyndns.org":true,"dyndns.tv":true,"at-band-camp.net":true,"ath.cx":true,"barrel-of-knowledge.info":true,"barrell-of-knowledge.info":true,"better-than.tv":true,"blogdns.com":true,"blogdns.net":true,"blogdns.org":true,"blogsite.org":true,"boldlygoingnowhere.org":true,"broke-it.net":true,"buyshouses.net":true,"cechire.com":true,"dnsalias.com":true,"dnsalias.net":true,"dnsalias.org":true,"dnsdojo.com":true,"dnsdojo.net":true,"dnsdojo.org":true,"does-it.net":true,"doesntexist.com":true,"doesntexist.org":true,"dontexist.com":true,"dontexist.net":true,"dontexist.org":true,"doomdns.com":true,"doomdns.org":true,"dvrdns.org":true,"dyn-o-saur.com":true,"dynalias.com":true,"dynalias.net":true,"dynalias.org":true,"dynathome.net":true,"dyndns.ws":true,"endofinternet.net":true,"endofinternet.org":true,"endoftheinternet.org":true,"est-a-la-maison.com":true,"est-a-la-masion.com":true,"est-le-patron.com":true,"est-mon-blogueur.com":true,"for-better.biz":true,"for-more.biz":true,"for-our.info":true,"for-some.biz":true,"for-the.biz":true,"forgot.her.name":true,"forgot.his.name":true,"from-ak.com":true,"from-al.com":true,"from-ar.com":true,"from-az.net":true,"from-ca.com":true,"from-co.net":true,"from-ct.com":true,"from-dc.com":true,"from-de.com":true,"from-fl.com":true,"from-ga.com":true,"from-hi.com":true,"from-ia.com":true,"from-id.com":true,"from-il.com":true,"from-in.com":true,"from-ks.com":true,"from-ky.com":true,"from-la.net":true,"from-ma.com":true,"from-md.com":true,"from-me.org":true,"from-mi.com":true,"from-mn.com":true,"from-mo.com":true,"from-ms.com":true,"from-mt.com":true,"from-nc.com":true,"from-nd.com":true,"from-ne.com":true,"from-nh.com":true,"from-nj.com":true,"from-nm.com":true,"from-nv.com":true,"from-ny.net":true,"from-oh.com":true,"from-ok.com":true,"from-or.com":true,"from-pa.com":true,"from-pr.com":true,"from-ri.com":true,"from-sc.com":true,"from-sd.com":true,"from-tn.com":true,"from-tx.com":true,"from-ut.com":true,"from-va.com":true,"from-vt.com":true,"from-wa.com":true,"from-wi.com":true,"from-wv.com":true,"from-wy.com":true,"ftpaccess.cc":true,"fuettertdasnetz.de":true,"game-host.org":true,"game-server.cc":true,"getmyip.com":true,"gets-it.net":true,"go.dyndns.org":true,"gotdns.com":true,"gotdns.org":true,"groks-the.info":true,"groks-this.info":true,"ham-radio-op.net":true,"here-for-more.info":true,"hobby-site.com":true,"hobby-site.org":true,"home.dyndns.org":true,"homedns.org":true,"homeftp.net":true,"homeftp.org":true,"homeip.net":true,"homelinux.com":true,"homelinux.net":true,"homelinux.org":true,"homeunix.com":true,"homeunix.net":true,"homeunix.org":true,"iamallama.com":true,"in-the-band.net":true,"is-a-anarchist.com":true,"is-a-blogger.com":true,"is-a-bookkeeper.com":true,"is-a-bruinsfan.org":true,"is-a-bulls-fan.com":true,"is-a-candidate.org":true,"is-a-caterer.com":true,"is-a-celticsfan.org":true,"is-a-chef.com":true,"is-a-chef.net":true,"is-a-chef.org":true,"is-a-conservative.com":true,"is-a-cpa.com":true,"is-a-cubicle-slave.com":true,"is-a-democrat.com":true,"is-a-designer.com":true,"is-a-doctor.com":true,"is-a-financialadvisor.com":true,"is-a-geek.com":true,"is-a-geek.net":true,"is-a-geek.org":true,"is-a-green.com":true,"is-a-guru.com":true,"is-a-hard-worker.com":true,"is-a-hunter.com":true,"is-a-knight.org":true,"is-a-landscaper.com":true,"is-a-lawyer.com":true,"is-a-liberal.com":true,"is-a-libertarian.com":true,"is-a-linux-user.org":true,"is-a-llama.com":true,"is-a-musician.com":true,"is-a-nascarfan.com":true,"is-a-nurse.com":true,"is-a-painter.com":true,"is-a-patsfan.org":true,"is-a-personaltrainer.com":true,"is-a-photographer.com":true,"is-a-player.com":true,"is-a-republican.com":true,"is-a-rockstar.com":true,"is-a-socialist.com":true,"is-a-soxfan.org":true,"is-a-student.com":true,"is-a-teacher.com":true,"is-a-techie.com":true,"is-a-therapist.com":true,"is-an-accountant.com":true,"is-an-actor.com":true,"is-an-actress.com":true,"is-an-anarchist.com":true,"is-an-artist.com":true,"is-an-engineer.com":true,"is-an-entertainer.com":true,"is-by.us":true,"is-certified.com":true,"is-found.org":true,"is-gone.com":true,"is-into-anime.com":true,"is-into-cars.com":true,"is-into-cartoons.com":true,"is-into-games.com":true,"is-leet.com":true,"is-lost.org":true,"is-not-certified.com":true,"is-saved.org":true,"is-slick.com":true,"is-uberleet.com":true,"is-very-bad.org":true,"is-very-evil.org":true,"is-very-good.org":true,"is-very-nice.org":true,"is-very-sweet.org":true,"is-with-theband.com":true,"isa-geek.com":true,"isa-geek.net":true,"isa-geek.org":true,"isa-hockeynut.com":true,"issmarterthanyou.com":true,"isteingeek.de":true,"istmein.de":true,"kicks-ass.net":true,"kicks-ass.org":true,"knowsitall.info":true,"land-4-sale.us":true,"lebtimnetz.de":true,"leitungsen.de":true,"likes-pie.com":true,"likescandy.com":true,"merseine.nu":true,"mine.nu":true,"misconfused.org":true,"mypets.ws":true,"myphotos.cc":true,"neat-url.com":true,"office-on-the.net":true,"on-the-web.tv":true,"podzone.net":true,"podzone.org":true,"readmyblog.org":true,"saves-the-whales.com":true,"scrapper-site.net":true,"scrapping.cc":true,"selfip.biz":true,"selfip.com":true,"selfip.info":true,"selfip.net":true,"selfip.org":true,"sells-for-less.com":true,"sells-for-u.com":true,"sells-it.net":true,"sellsyourhome.org":true,"servebbs.com":true,"servebbs.net":true,"servebbs.org":true,"serveftp.net":true,"serveftp.org":true,"servegame.org":true,"shacknet.nu":true,"simple-url.com":true,"space-to-rent.com":true,"stuff-4-sale.org":true,"stuff-4-sale.us":true,"teaches-yoga.com":true,"thruhere.net":true,"traeumtgerade.de":true,"webhop.biz":true,"webhop.info":true,"webhop.net":true,"webhop.org":true,"worse-than.tv":true,"writesthisblog.com":true,"a.ssl.fastly.net":true,"b.ssl.fastly.net":true,"global.ssl.fastly.net":true,"a.prod.fastly.net":true,"global.prod.fastly.net":true,"firebaseapp.com":true,"flynnhub.com":true,"service.gov.uk":true,"github.io":true,"githubusercontent.com":true,"ro.com":true,"appspot.com":true,"blogspot.ae":true,"blogspot.be":true,"blogspot.bj":true,"blogspot.ca":true,"blogspot.cf":true,"blogspot.ch":true,"blogspot.co.at":true,"blogspot.co.il":true,"blogspot.co.nz":true,"blogspot.co.uk":true,"blogspot.com":true,"blogspot.com.ar":true,"blogspot.com.au":true,"blogspot.com.br":true,"blogspot.com.es":true,"blogspot.com.tr":true,"blogspot.cv":true,"blogspot.cz":true,"blogspot.de":true,"blogspot.dk":true,"blogspot.fi":true,"blogspot.fr":true,"blogspot.gr":true,"blogspot.hk":true,"blogspot.hu":true,"blogspot.ie":true,"blogspot.in":true,"blogspot.it":true,"blogspot.jp":true,"blogspot.kr":true,"blogspot.mr":true,"blogspot.mx":true,"blogspot.nl":true,"blogspot.no":true,"blogspot.pt":true,"blogspot.re":true,"blogspot.ro":true,"blogspot.ru":true,"blogspot.se":true,"blogspot.sg":true,"blogspot.sk":true,"blogspot.td":true,"blogspot.tw":true,"codespot.com":true,"googleapis.com":true,"googlecode.com":true,"pagespeedmobilizer.com":true,"withgoogle.com":true,"herokuapp.com":true,"herokussl.com":true,"iki.fi":true,"biz.at":true,"info.at":true,"co.pl":true,"azurewebsites.net":true,"azure-mobile.net":true,"cloudapp.net":true,"nfshost.com":true,"nyc.mn":true,"nid.io":true,"operaunite.com":true,"outsystemscloud.com":true,"art.pl":true,"gliwice.pl":true,"krakow.pl":true,"poznan.pl":true,"wroc.pl":true,"zakopane.pl":true,"priv.at":true,"rhcloud.com":true,"sinaapp.com":true,"vipsinaapp.com":true,"1kapp.com":true,"gda.pl":true,"gdansk.pl":true,"gdynia.pl":true,"med.pl":true,"sopot.pl":true,"hk.com":true,"hk.org":true,"ltd.hk":true,"inc.hk":true,"yolasite.com":true,"za.net":true,"za.org":true});
    
    // END of automatically generated file
    
  provide("tough-cookie/lib/pubsuffix", module.exports);
}(global));

// pakmanager:tough-cookie/lib/store
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*!
     * Copyright (c) 2015, Salesforce.com, Inc.
     * All rights reserved.
     *
     * Redistribution and use in source and binary forms, with or without
     * modification, are permitted provided that the following conditions are met:
     *
     * 1. Redistributions of source code must retain the above copyright notice,
     * this list of conditions and the following disclaimer.
     *
     * 2. Redistributions in binary form must reproduce the above copyright notice,
     * this list of conditions and the following disclaimer in the documentation
     * and/or other materials provided with the distribution.
     *
     * 3. Neither the name of Salesforce.com nor the names of its contributors may
     * be used to endorse or promote products derived from this software without
     * specific prior written permission.
     *
     * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
     * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
     * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
     * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
     * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
     * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
     * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
     * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
     * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
     * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
     * POSSIBILITY OF SUCH DAMAGE.
     */
    'use strict';
    /*jshint unused:false */
    
    function Store() {
    }
    exports.Store = Store;
    
    // Stores may be synchronous, but are still required to use a
    // Continuation-Passing Style API.  The CookieJar itself will expose a "*Sync"
    // API that converts from synchronous-callbacks to imperative style.
    Store.prototype.synchronous = false;
    
    Store.prototype.findCookie = function(domain, path, key, cb) {
      throw new Error('findCookie is not implemented');
    };
    
    Store.prototype.findCookies = function(domain, path, cb) {
      throw new Error('findCookies is not implemented');
    };
    
    Store.prototype.putCookie = function(cookie, cb) {
      throw new Error('putCookie is not implemented');
    };
    
    Store.prototype.updateCookie = function(oldCookie, newCookie, cb) {
      // recommended default implementation:
      // return this.putCookie(newCookie, cb);
      throw new Error('updateCookie is not implemented');
    };
    
    Store.prototype.removeCookie = function(domain, path, key, cb) {
      throw new Error('removeCookie is not implemented');
    };
    
    Store.prototype.removeCookies = function(domain, path, cb) {
      throw new Error('removeCookies is not implemented');
    };
    
    Store.prototype.getAllCookies = function(cb) {
      throw new Error('getAllCookies is not implemented (therefore jar cannot be serialized)');
    };
    
  provide("tough-cookie/lib/store", module.exports);
}(global));

// pakmanager:tough-cookie/lib/permuteDomain
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*!
     * Copyright (c) 2015, Salesforce.com, Inc.
     * All rights reserved.
     *
     * Redistribution and use in source and binary forms, with or without
     * modification, are permitted provided that the following conditions are met:
     *
     * 1. Redistributions of source code must retain the above copyright notice,
     * this list of conditions and the following disclaimer.
     *
     * 2. Redistributions in binary form must reproduce the above copyright notice,
     * this list of conditions and the following disclaimer in the documentation
     * and/or other materials provided with the distribution.
     *
     * 3. Neither the name of Salesforce.com nor the names of its contributors may
     * be used to endorse or promote products derived from this software without
     * specific prior written permission.
     *
     * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
     * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
     * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
     * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
     * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
     * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
     * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
     * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
     * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
     * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
     * POSSIBILITY OF SUCH DAMAGE.
     */
    "use strict";
    var pubsuffix =  require('tough-cookie/lib/pubsuffix');
    
    // Gives the permutation of all possible domainMatch()es of a given domain. The
    // array is in shortest-to-longest order.  Handy for indexing.
    function permuteDomain (domain) {
      var pubSuf = pubsuffix.getPublicSuffix(domain);
      if (!pubSuf) {
        return null;
      }
      if (pubSuf == domain) {
        return [domain];
      }
    
      var prefix = domain.slice(0, -(pubSuf.length + 1)); // ".example.com"
      var parts = prefix.split('.').reverse();
      var cur = pubSuf;
      var permutations = [cur];
      while (parts.length) {
        cur = parts.shift() + '.' + cur;
        permutations.push(cur);
      }
      return permutations;
    }
    
    exports.permuteDomain = permuteDomain;
    
  provide("tough-cookie/lib/permuteDomain", module.exports);
}(global));

// pakmanager:tough-cookie/lib/pathMatch
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*!
     * Copyright (c) 2015, Salesforce.com, Inc.
     * All rights reserved.
     *
     * Redistribution and use in source and binary forms, with or without
     * modification, are permitted provided that the following conditions are met:
     *
     * 1. Redistributions of source code must retain the above copyright notice,
     * this list of conditions and the following disclaimer.
     *
     * 2. Redistributions in binary form must reproduce the above copyright notice,
     * this list of conditions and the following disclaimer in the documentation
     * and/or other materials provided with the distribution.
     *
     * 3. Neither the name of Salesforce.com nor the names of its contributors may
     * be used to endorse or promote products derived from this software without
     * specific prior written permission.
     *
     * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
     * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
     * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
     * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
     * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
     * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
     * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
     * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
     * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
     * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
     * POSSIBILITY OF SUCH DAMAGE.
     */
    "use strict";
    /*
     * "A request-path path-matches a given cookie-path if at least one of the
     * following conditions holds:"
     */
    function pathMatch (reqPath, cookiePath) {
      // "o  The cookie-path and the request-path are identical."
      if (cookiePath === reqPath) {
        return true;
      }
    
      var idx = reqPath.indexOf(cookiePath);
      if (idx === 0) {
        // "o  The cookie-path is a prefix of the request-path, and the last
        // character of the cookie-path is %x2F ("/")."
        if (cookiePath.substr(-1) === "/") {
          return true;
        }
    
        // " o  The cookie-path is a prefix of the request-path, and the first
        // character of the request-path that is not included in the cookie- path
        // is a %x2F ("/") character."
        if (reqPath.substr(cookiePath.length, 1) === "/") {
          return true;
        }
      }
    
      return false;
    }
    
    exports.pathMatch = pathMatch;
    
  provide("tough-cookie/lib/pathMatch", module.exports);
}(global));

// pakmanager:tough-cookie/lib/memstore
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*!
     * Copyright (c) 2015, Salesforce.com, Inc.
     * All rights reserved.
     *
     * Redistribution and use in source and binary forms, with or without
     * modification, are permitted provided that the following conditions are met:
     *
     * 1. Redistributions of source code must retain the above copyright notice,
     * this list of conditions and the following disclaimer.
     *
     * 2. Redistributions in binary form must reproduce the above copyright notice,
     * this list of conditions and the following disclaimer in the documentation
     * and/or other materials provided with the distribution.
     *
     * 3. Neither the name of Salesforce.com nor the names of its contributors may
     * be used to endorse or promote products derived from this software without
     * specific prior written permission.
     *
     * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
     * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
     * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
     * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
     * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
     * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
     * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
     * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
     * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
     * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
     * POSSIBILITY OF SUCH DAMAGE.
     */
    'use strict';
    var Store =  require('tough-cookie/lib/store').Store;
    var permuteDomain =  require('tough-cookie/lib/permuteDomain').permuteDomain;
    var pathMatch =  require('tough-cookie/lib/pathMatch').pathMatch;
    var util = require('util');
    
    function MemoryCookieStore() {
      Store.call(this);
      this.idx = {};
    }
    util.inherits(MemoryCookieStore, Store);
    exports.MemoryCookieStore = MemoryCookieStore;
    MemoryCookieStore.prototype.idx = null;
    
    // Since it's just a struct in RAM, this Store is synchronous
    MemoryCookieStore.prototype.synchronous = true;
    
    // force a default depth:
    MemoryCookieStore.prototype.inspect = function() {
      return "{ idx: "+util.inspect(this.idx, false, 2)+' }';
    };
    
    MemoryCookieStore.prototype.findCookie = function(domain, path, key, cb) {
      if (!this.idx[domain]) {
        return cb(null,undefined);
      }
      if (!this.idx[domain][path]) {
        return cb(null,undefined);
      }
      return cb(null,this.idx[domain][path][key]||null);
    };
    
    MemoryCookieStore.prototype.findCookies = function(domain, path, cb) {
      var results = [];
      if (!domain) {
        return cb(null,[]);
      }
    
      var pathMatcher;
      if (!path) {
        // null means "all paths"
        pathMatcher = function matchAll(domainIndex) {
          for (var curPath in domainIndex) {
            var pathIndex = domainIndex[curPath];
            for (var key in pathIndex) {
              results.push(pathIndex[key]);
            }
          }
        };
    
      } else {
        pathMatcher = function matchRFC(domainIndex) {
           //NOTE: we should use path-match algorithm from S5.1.4 here
           //(see : https://github.com/ChromiumWebApps/chromium/blob/b3d3b4da8bb94c1b2e061600df106d590fda3620/net/cookies/canonical_cookie.cc#L299)
           Object.keys(domainIndex).forEach(function (cookiePath) {
             if (pathMatch(path, cookiePath)) {
               var pathIndex = domainIndex[cookiePath];
    
               for (var key in pathIndex) {
                 results.push(pathIndex[key]);
               }
             }
           });
         };
      }
    
      var domains = permuteDomain(domain) || [domain];
      var idx = this.idx;
      domains.forEach(function(curDomain) {
        var domainIndex = idx[curDomain];
        if (!domainIndex) {
          return;
        }
        pathMatcher(domainIndex);
      });
    
      cb(null,results);
    };
    
    MemoryCookieStore.prototype.putCookie = function(cookie, cb) {
      if (!this.idx[cookie.domain]) {
        this.idx[cookie.domain] = {};
      }
      if (!this.idx[cookie.domain][cookie.path]) {
        this.idx[cookie.domain][cookie.path] = {};
      }
      this.idx[cookie.domain][cookie.path][cookie.key] = cookie;
      cb(null);
    };
    
    MemoryCookieStore.prototype.updateCookie = function(oldCookie, newCookie, cb) {
      // updateCookie() may avoid updating cookies that are identical.  For example,
      // lastAccessed may not be important to some stores and an equality
      // comparison could exclude that field.
      this.putCookie(newCookie,cb);
    };
    
    MemoryCookieStore.prototype.removeCookie = function(domain, path, key, cb) {
      if (this.idx[domain] && this.idx[domain][path] && this.idx[domain][path][key]) {
        delete this.idx[domain][path][key];
      }
      cb(null);
    };
    
    MemoryCookieStore.prototype.removeCookies = function(domain, path, cb) {
      if (this.idx[domain]) {
        if (path) {
          delete this.idx[domain][path];
        } else {
          delete this.idx[domain];
        }
      }
      return cb(null);
    };
    
    MemoryCookieStore.prototype.getAllCookies = function(cb) {
      var cookies = [];
      var idx = this.idx;
    
      var domains = Object.keys(idx);
      domains.forEach(function(domain) {
        var paths = Object.keys(idx[domain]);
        paths.forEach(function(path) {
          var keys = Object.keys(idx[domain][path]);
          keys.forEach(function(key) {
            if (key !== null) {
              cookies.push(idx[domain][path][key]);
            }
          });
        });
      });
    
      // Sort by creationIndex so deserializing retains the creation order.
      // When implementing your own store, this SHOULD retain the order too
      cookies.sort(function(a,b) {
        return (a.creationIndex||0) - (b.creationIndex||0);
      });
    
      cb(null, cookies);
    };
    
  provide("tough-cookie/lib/memstore", module.exports);
}(global));

// pakmanager:tough-cookie
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*!
     * Copyright (c) 2015, Salesforce.com, Inc.
     * All rights reserved.
     *
     * Redistribution and use in source and binary forms, with or without
     * modification, are permitted provided that the following conditions are met:
     *
     * 1. Redistributions of source code must retain the above copyright notice,
     * this list of conditions and the following disclaimer.
     *
     * 2. Redistributions in binary form must reproduce the above copyright notice,
     * this list of conditions and the following disclaimer in the documentation
     * and/or other materials provided with the distribution.
     *
     * 3. Neither the name of Salesforce.com nor the names of its contributors may
     * be used to endorse or promote products derived from this software without
     * specific prior written permission.
     *
     * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
     * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
     * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
     * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
     * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
     * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
     * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
     * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
     * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
     * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
     * POSSIBILITY OF SUCH DAMAGE.
     */
    'use strict';
    var net = require('net');
    var urlParse = require('url').parse;
    var pubsuffix =  require('tough-cookie/lib/pubsuffix');
    var Store =  require('tough-cookie/lib/store').Store;
    var MemoryCookieStore =  require('tough-cookie/lib/memstore').MemoryCookieStore;
    var pathMatch =  require('tough-cookie/lib/pathMatch').pathMatch;
    var VERSION = require('../package.json').version;
    
    var punycode;
    try {
      punycode = require('punycode');
    } catch(e) {
      console.warn("cookie: can't load punycode; won't use punycode for domain normalization");
    }
    
    var DATE_DELIM = /[\x09\x20-\x2F\x3B-\x40\x5B-\x60\x7B-\x7E]/;
    
    // From RFC6265 S4.1.1
    // note that it excludes \x3B ";"
    var COOKIE_OCTET  = /[\x21\x23-\x2B\x2D-\x3A\x3C-\x5B\x5D-\x7E]/;
    var COOKIE_OCTETS = new RegExp('^'+COOKIE_OCTET.source+'$');
    
    // Double quotes are part of the value (see: S4.1.1).
    // '\r', '\n' and '\0' should be treated as a terminator in the "relaxed" mode
    // (see: https://github.com/ChromiumWebApps/chromium/blob/b3d3b4da8bb94c1b2e061600df106d590fda3620/net/cookies/parsed_cookie.cc#L60)
    // '=' and ';' are attribute/values separators
    // (see: https://github.com/ChromiumWebApps/chromium/blob/b3d3b4da8bb94c1b2e061600df106d590fda3620/net/cookies/parsed_cookie.cc#L64)
    var COOKIE_PAIR = /^([^=;]+)\s*=\s*(("?)[^\n\r\0]*\3)/;
    
    // RFC6265 S4.1.1 defines path value as 'any CHAR except CTLs or ";"'
    // Note ';' is \x3B
    var PATH_VALUE = /[\x20-\x3A\x3C-\x7E]+/;
    
    // Used for checking whether or not there is a trailing semi-colon
    var TRAILING_SEMICOLON = /;+$/;
    
    var DAY_OF_MONTH = /^(\d{1,2})[^\d]*$/;
    var TIME = /^(\d{1,2})[^\d]*:(\d{1,2})[^\d]*:(\d{1,2})[^\d]*$/;
    var MONTH = /^(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)/i;
    
    var MONTH_TO_NUM = {
      jan:0, feb:1, mar:2, apr:3, may:4, jun:5,
      jul:6, aug:7, sep:8, oct:9, nov:10, dec:11
    };
    var NUM_TO_MONTH = [
      'Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'
    ];
    var NUM_TO_DAY = [
      'Sun','Mon','Tue','Wed','Thu','Fri','Sat'
    ];
    
    var YEAR = /^(\d{2}|\d{4})$/; // 2 to 4 digits
    
    var MAX_TIME = 2147483647000; // 31-bit max
    var MIN_TIME = 0; // 31-bit min
    
    
    // RFC6265 S5.1.1 date parser:
    function parseDate(str) {
      if (!str) {
        return;
      }
    
      /* RFC6265 S5.1.1:
       * 2. Process each date-token sequentially in the order the date-tokens
       * appear in the cookie-date
       */
      var tokens = str.split(DATE_DELIM);
      if (!tokens) {
        return;
      }
    
      var hour = null;
      var minutes = null;
      var seconds = null;
      var day = null;
      var month = null;
      var year = null;
    
      for (var i=0; i<tokens.length; i++) {
        var token = tokens[i].trim();
        if (!token.length) {
          continue;
        }
    
        var result;
    
        /* 2.1. If the found-time flag is not set and the token matches the time
         * production, set the found-time flag and set the hour- value,
         * minute-value, and second-value to the numbers denoted by the digits in
         * the date-token, respectively.  Skip the remaining sub-steps and continue
         * to the next date-token.
         */
        if (seconds === null) {
          result = TIME.exec(token);
          if (result) {
            hour = parseInt(result[1], 10);
            minutes = parseInt(result[2], 10);
            seconds = parseInt(result[3], 10);
            /* RFC6265 S5.1.1.5:
             * [fail if]
             * *  the hour-value is greater than 23,
             * *  the minute-value is greater than 59, or
             * *  the second-value is greater than 59.
             */
            if(hour > 23 || minutes > 59 || seconds > 59) {
              return;
            }
    
            continue;
          }
        }
    
        /* 2.2. If the found-day-of-month flag is not set and the date-token matches
         * the day-of-month production, set the found-day-of- month flag and set
         * the day-of-month-value to the number denoted by the date-token.  Skip
         * the remaining sub-steps and continue to the next date-token.
         */
        if (day === null) {
          result = DAY_OF_MONTH.exec(token);
          if (result) {
            day = parseInt(result, 10);
            /* RFC6265 S5.1.1.5:
             * [fail if] the day-of-month-value is less than 1 or greater than 31
             */
            if(day < 1 || day > 31) {
              return;
            }
            continue;
          }
        }
    
        /* 2.3. If the found-month flag is not set and the date-token matches the
         * month production, set the found-month flag and set the month-value to
         * the month denoted by the date-token.  Skip the remaining sub-steps and
         * continue to the next date-token.
         */
        if (month === null) {
          result = MONTH.exec(token);
          if (result) {
            month = MONTH_TO_NUM[result[1].toLowerCase()];
            continue;
          }
        }
    
        /* 2.4. If the found-year flag is not set and the date-token matches the year
         * production, set the found-year flag and set the year-value to the number
         * denoted by the date-token.  Skip the remaining sub-steps and continue to
         * the next date-token.
         */
        if (year === null) {
          result = YEAR.exec(token);
          if (result) {
            year = parseInt(result[0], 10);
            /* From S5.1.1:
             * 3.  If the year-value is greater than or equal to 70 and less
             * than or equal to 99, increment the year-value by 1900.
             * 4.  If the year-value is greater than or equal to 0 and less
             * than or equal to 69, increment the year-value by 2000.
             */
            if (70 <= year && year <= 99) {
              year += 1900;
            } else if (0 <= year && year <= 69) {
              year += 2000;
            }
    
            if (year < 1601) {
              return; // 5. ... the year-value is less than 1601
            }
          }
        }
      }
    
      if (seconds === null || day === null || month === null || year === null) {
        return; // 5. ... at least one of the found-day-of-month, found-month, found-
                // year, or found-time flags is not set,
      }
    
      return new Date(Date.UTC(year, month, day, hour, minutes, seconds));
    }
    
    function formatDate(date) {
      var d = date.getUTCDate(); d = d >= 10 ? d : '0'+d;
      var h = date.getUTCHours(); h = h >= 10 ? h : '0'+h;
      var m = date.getUTCMinutes(); m = m >= 10 ? m : '0'+m;
      var s = date.getUTCSeconds(); s = s >= 10 ? s : '0'+s;
      return NUM_TO_DAY[date.getUTCDay()] + ', ' +
        d+' '+ NUM_TO_MONTH[date.getUTCMonth()] +' '+ date.getUTCFullYear() +' '+
        h+':'+m+':'+s+' GMT';
    }
    
    // S5.1.2 Canonicalized Host Names
    function canonicalDomain(str) {
      if (str == null) {
        return null;
      }
      str = str.trim().replace(/^\./,''); // S4.1.2.3 & S5.2.3: ignore leading .
    
      // convert to IDN if any non-ASCII characters
      if (punycode && /[^\u0001-\u007f]/.test(str)) {
        str = punycode.toASCII(str);
      }
    
      return str.toLowerCase();
    }
    
    // S5.1.3 Domain Matching
    function domainMatch(str, domStr, canonicalize) {
      if (str == null || domStr == null) {
        return null;
      }
      if (canonicalize !== false) {
        str = canonicalDomain(str);
        domStr = canonicalDomain(domStr);
      }
    
      /*
       * "The domain string and the string are identical. (Note that both the
       * domain string and the string will have been canonicalized to lower case at
       * this point)"
       */
      if (str == domStr) {
        return true;
      }
    
      /* "All of the following [three] conditions hold:" (order adjusted from the RFC) */
    
      /* "* The string is a host name (i.e., not an IP address)." */
      if (net.isIP(str)) {
        return false;
      }
    
      /* "* The domain string is a suffix of the string" */
      var idx = str.indexOf(domStr);
      if (idx <= 0) {
        return false; // it's a non-match (-1) or prefix (0)
      }
    
      // e.g "a.b.c".indexOf("b.c") === 2
      // 5 === 3+2
      if (str.length !== domStr.length + idx) { // it's not a suffix
        return false;
      }
    
      /* "* The last character of the string that is not included in the domain
      * string is a %x2E (".") character." */
      if (str.substr(idx-1,1) !== '.') {
        return false;
      }
    
      return true;
    }
    
    
    // RFC6265 S5.1.4 Paths and Path-Match
    
    /*
     * "The user agent MUST use an algorithm equivalent to the following algorithm
     * to compute the default-path of a cookie:"
     *
     * Assumption: the path (and not query part or absolute uri) is passed in.
     */
    function defaultPath(path) {
      // "2. If the uri-path is empty or if the first character of the uri-path is not
      // a %x2F ("/") character, output %x2F ("/") and skip the remaining steps.
      if (!path || path.substr(0,1) !== "/") {
        return "/";
      }
    
      // "3. If the uri-path contains no more than one %x2F ("/") character, output
      // %x2F ("/") and skip the remaining step."
      if (path === "/") {
        return path;
      }
    
      var rightSlash = path.lastIndexOf("/");
      if (rightSlash === 0) {
        return "/";
      }
    
      // "4. Output the characters of the uri-path from the first character up to,
      // but not including, the right-most %x2F ("/")."
      return path.slice(0, rightSlash);
    }
    
    
    function parse(str) {
      str = str.trim();
    
      // S4.1.1 Trailing semi-colons are not part of the specification.
      var semiColonCheck = TRAILING_SEMICOLON.exec(str);
      if (semiColonCheck) {
        str = str.slice(0, semiColonCheck.index);
      }
    
      // We use a regex to parse the "name-value-pair" part of S5.2
      var firstSemi = str.indexOf(';'); // S5.2 step 1
      var result = COOKIE_PAIR.exec(firstSemi === -1 ? str : str.substr(0,firstSemi));
    
      // Rx satisfies the "the name string is empty" and "lacks a %x3D ("=")"
      // constraints as well as trimming any whitespace.
      if (!result) {
        return;
      }
    
      var c = new Cookie();
      c.key = result[1].trim();
      c.value = result[2].trim();
    
      if (firstSemi === -1) {
        return c;
      }
    
      // S5.2.3 "unparsed-attributes consist of the remainder of the set-cookie-string
      // (including the %x3B (";") in question)." plus later on in the same section
      // "discard the first ";" and trim".
      var unparsed = str.slice(firstSemi).replace(/^\s*;\s*/,'').trim();
    
      // "If the unparsed-attributes string is empty, skip the rest of these
      // steps."
      if (unparsed.length === 0) {
        return c;
      }
    
      /*
       * S5.2 says that when looping over the items "[p]rocess the attribute-name
       * and attribute-value according to the requirements in the following
       * subsections" for every item.  Plus, for many of the individual attributes
       * in S5.3 it says to use the "attribute-value of the last attribute in the
       * cookie-attribute-list".  Therefore, in this implementation, we overwrite
       * the previous value.
       */
      var cookie_avs = unparsed.split(/\s*;\s*/);
      while (cookie_avs.length) {
        var av = cookie_avs.shift();
        var av_sep = av.indexOf('=');
        var av_key, av_value;
    
        if (av_sep === -1) {
          av_key = av;
          av_value = null;
        } else {
          av_key = av.substr(0,av_sep);
          av_value = av.substr(av_sep+1);
        }
    
        av_key = av_key.trim().toLowerCase();
    
        if (av_value) {
          av_value = av_value.trim();
        }
    
        switch(av_key) {
        case 'expires': // S5.2.1
          if (av_value) {
            var exp = parseDate(av_value);
            // "If the attribute-value failed to parse as a cookie date, ignore the
            // cookie-av."
            if (exp) {
              // over and underflow not realistically a concern: V8's getTime() seems to
              // store something larger than a 32-bit time_t (even with 32-bit node)
              c.expires = exp;
            }
          }
          break;
    
        case 'max-age': // S5.2.2
          if (av_value) {
            // "If the first character of the attribute-value is not a DIGIT or a "-"
            // character ...[or]... If the remainder of attribute-value contains a
            // non-DIGIT character, ignore the cookie-av."
            if (/^-?[0-9]+$/.test(av_value)) {
              var delta = parseInt(av_value, 10);
              // "If delta-seconds is less than or equal to zero (0), let expiry-time
              // be the earliest representable date and time."
              c.setMaxAge(delta);
            }
          }
          break;
    
        case 'domain': // S5.2.3
          // "If the attribute-value is empty, the behavior is undefined.  However,
          // the user agent SHOULD ignore the cookie-av entirely."
          if (av_value) {
            // S5.2.3 "Let cookie-domain be the attribute-value without the leading %x2E
            // (".") character."
            var domain = av_value.trim().replace(/^\./, '');
            if (domain) {
              // "Convert the cookie-domain to lower case."
              c.domain = domain.toLowerCase();
            }
          }
          break;
    
        case 'path': // S5.2.4
          /*
           * "If the attribute-value is empty or if the first character of the
           * attribute-value is not %x2F ("/"):
           *   Let cookie-path be the default-path.
           * Otherwise:
           *   Let cookie-path be the attribute-value."
           *
           * We'll represent the default-path as null since it depends on the
           * context of the parsing.
           */
          c.path = av_value && av_value[0] === "/" ? av_value : null;
          break;
    
        case 'secure': // S5.2.5
          /*
           * "If the attribute-name case-insensitively matches the string "Secure",
           * the user agent MUST append an attribute to the cookie-attribute-list
           * with an attribute-name of Secure and an empty attribute-value."
           */
          c.secure = true;
          break;
    
        case 'httponly': // S5.2.6 -- effectively the same as 'secure'
          c.httpOnly = true;
          break;
    
        default:
          c.extensions = c.extensions || [];
          c.extensions.push(av);
          break;
        }
      }
    
      return c;
    }
    
    // avoid the V8 deoptimization monster!
    function jsonParse(str) {
      var obj;
      try {
        obj = JSON.parse(str);
      } catch (e) {
        return e;
      }
      return obj;
    }
    
    function fromJSON(str) {
      if (!str) {
        return null;
      }
    
      var obj;
      if (typeof str === 'string') {
        obj = jsonParse(str);
        if (obj instanceof Error) {
          return null;
        }
      } else {
        // assume it's an Object
        obj = str;
      }
    
      var c = new Cookie();
      for (var i=0; i<Cookie.serializableProperties.length; i++) {
        var prop = Cookie.serializableProperties[i];
        if (obj[prop] === undefined ||
            obj[prop] === Cookie.prototype[prop])
        {
          continue; // leave as prototype default
        }
    
        if (prop === 'expires' ||
            prop === 'creation' ||
            prop === 'lastAccessed')
        {
          if (obj[prop] === null) {
            c[prop] = null;
          } else {
            c[prop] = obj[prop] == "Infinity" ?
              "Infinity" : new Date(obj[prop]);
          }
        } else {
          c[prop] = obj[prop];
        }
      }
    
      return c;
    }
    
    /* Section 5.4 part 2:
     * "*  Cookies with longer paths are listed before cookies with
     *     shorter paths.
     *
     *  *  Among cookies that have equal-length path fields, cookies with
     *     earlier creation-times are listed before cookies with later
     *     creation-times."
     */
    
    function cookieCompare(a,b) {
      var cmp = 0;
    
      // descending for length: b CMP a
      var aPathLen = a.path ? a.path.length : 0;
      var bPathLen = b.path ? b.path.length : 0;
      cmp = bPathLen - aPathLen;
      if (cmp !== 0) {
        return cmp;
      }
    
      // ascending for time: a CMP b
      var aTime = a.creation ? a.creation.getTime() : MAX_TIME;
      var bTime = b.creation ? b.creation.getTime() : MAX_TIME;
      cmp = aTime - bTime;
      if (cmp !== 0) {
        return cmp;
      }
    
      // break ties for the same millisecond (precision of JavaScript's clock)
      cmp = a.creationIndex - b.creationIndex;
    
      return cmp;
    }
    
    // Gives the permutation of all possible pathMatch()es of a given path. The
    // array is in longest-to-shortest order.  Handy for indexing.
    function permutePath(path) {
      if (path === '/') {
        return ['/'];
      }
      if (path.lastIndexOf('/') === path.length-1) {
        path = path.substr(0,path.length-1);
      }
      var permutations = [path];
      while (path.length > 1) {
        var lindex = path.lastIndexOf('/');
        if (lindex === 0) {
          break;
        }
        path = path.substr(0,lindex);
        permutations.push(path);
      }
      permutations.push('/');
      return permutations;
    }
    
    function getCookieContext(url) {
      if (url instanceof Object) {
        return url;
      }
      // NOTE: decodeURI will throw on malformed URIs (see GH-32).
      // Therefore, we will just skip decoding for such URIs.
      try {
        url = decodeURI(url);
      }
      catch(err) {
        // Silently swallow error
      }
    
      return urlParse(url);
    }
    
    function Cookie(opts) {
      opts = opts || {};
    
      Object.keys(opts).forEach(function(prop) {
        if (Cookie.prototype.hasOwnProperty(prop) &&
            Cookie.prototype[prop] !== opts[prop] &&
            prop.substr(0,1) !== '_')
        {
          this[prop] = opts[prop];
        }
      }, this);
    
      this.creation = this.creation || new Date();
    
      // used to break creation ties in cookieCompare():
      Object.defineProperty(this, 'creationIndex', {
        configurable: false,
        enumerable: false, // important for assert.deepEqual checks
        writable: true,
        value: ++Cookie.cookiesCreated
      });
    }
    
    Cookie.cookiesCreated = 0; // incremented each time a cookie is created
    
    Cookie.parse = parse;
    Cookie.fromJSON = fromJSON;
    
    Cookie.prototype.key = "";
    Cookie.prototype.value = "";
    
    // the order in which the RFC has them:
    Cookie.prototype.expires = "Infinity"; // coerces to literal Infinity
    Cookie.prototype.maxAge = null; // takes precedence over expires for TTL
    Cookie.prototype.domain = null;
    Cookie.prototype.path = null;
    Cookie.prototype.secure = false;
    Cookie.prototype.httpOnly = false;
    Cookie.prototype.extensions = null;
    
    // set by the CookieJar:
    Cookie.prototype.hostOnly = null; // boolean when set
    Cookie.prototype.pathIsDefault = null; // boolean when set
    Cookie.prototype.creation = null; // Date when set; defaulted by Cookie.parse
    Cookie.prototype.lastAccessed = null; // Date when set
    Object.defineProperty(Cookie.prototype, 'creationIndex', {
      configurable: true,
      enumerable: false,
      writable: true,
      value: 0
    });
    
    Cookie.serializableProperties = Object.keys(Cookie.prototype)
      .filter(function(prop) {
        return !(
          Cookie.prototype[prop] instanceof Function ||
          prop === 'creationIndex' ||
          prop.substr(0,1) === '_'
        );
      });
    
    Cookie.prototype.inspect = function inspect() {
      var now = Date.now();
      return 'Cookie="'+this.toString() +
        '; hostOnly='+(this.hostOnly != null ? this.hostOnly : '?') +
        '; aAge='+(this.lastAccessed ? (now-this.lastAccessed.getTime())+'ms' : '?') +
        '; cAge='+(this.creation ? (now-this.creation.getTime())+'ms' : '?') +
        '"';
    };
    
    Cookie.prototype.toJSON = function() {
      var obj = {};
    
      var props = Cookie.serializableProperties;
      for (var i=0; i<props.length; i++) {
        var prop = props[i];
        if (this[prop] === Cookie.prototype[prop]) {
          continue; // leave as prototype default
        }
    
        if (prop === 'expires' ||
            prop === 'creation' ||
            prop === 'lastAccessed')
        {
          if (this[prop] === null) {
            obj[prop] = null;
          } else {
            obj[prop] = this[prop] == "Infinity" ? // intentionally not ===
              "Infinity" : this[prop].toISOString();
          }
        } else if (prop === 'maxAge') {
          if (this[prop] !== null) {
            // again, intentionally not ===
            obj[prop] = (this[prop] == Infinity || this[prop] == -Infinity) ?
              this[prop].toString() : this[prop];
          }
        } else {
          if (this[prop] !== Cookie.prototype[prop]) {
            obj[prop] = this[prop];
          }
        }
      }
    
      return obj;
    };
    
    Cookie.prototype.clone = function() {
      return fromJSON(this.toJSON());
    };
    
    Cookie.prototype.validate = function validate() {
      if (!COOKIE_OCTETS.test(this.value)) {
        return false;
      }
      if (this.expires != Infinity && !(this.expires instanceof Date) && !parseDate(this.expires)) {
        return false;
      }
      if (this.maxAge != null && this.maxAge <= 0) {
        return false; // "Max-Age=" non-zero-digit *DIGIT
      }
      if (this.path != null && !PATH_VALUE.test(this.path)) {
        return false;
      }
    
      var cdomain = this.cdomain();
      if (cdomain) {
        if (cdomain.match(/\.$/)) {
          return false; // S4.1.2.3 suggests that this is bad. domainMatch() tests confirm this
        }
        var suffix = pubsuffix.getPublicSuffix(cdomain);
        if (suffix == null) { // it's a public suffix
          return false;
        }
      }
      return true;
    };
    
    Cookie.prototype.setExpires = function setExpires(exp) {
      if (exp instanceof Date) {
        this.expires = exp;
      } else {
        this.expires = parseDate(exp) || "Infinity";
      }
    };
    
    Cookie.prototype.setMaxAge = function setMaxAge(age) {
      if (age === Infinity || age === -Infinity) {
        this.maxAge = age.toString(); // so JSON.stringify() works
      } else {
        this.maxAge = age;
      }
    };
    
    // gives Cookie header format
    Cookie.prototype.cookieString = function cookieString() {
      var val = this.value;
      if (val == null) {
        val = '';
      }
      return this.key+'='+val;
    };
    
    // gives Set-Cookie header format
    Cookie.prototype.toString = function toString() {
      var str = this.cookieString();
    
      if (this.expires != Infinity) {
        if (this.expires instanceof Date) {
          str += '; Expires='+formatDate(this.expires);
        } else {
          str += '; Expires='+this.expires;
        }
      }
    
      if (this.maxAge != null && this.maxAge != Infinity) {
        str += '; Max-Age='+this.maxAge;
      }
    
      if (this.domain && !this.hostOnly) {
        str += '; Domain='+this.domain;
      }
      if (this.path) {
        str += '; Path='+this.path;
      }
    
      if (this.secure) {
        str += '; Secure';
      }
      if (this.httpOnly) {
        str += '; HttpOnly';
      }
      if (this.extensions) {
        this.extensions.forEach(function(ext) {
          str += '; '+ext;
        });
      }
    
      return str;
    };
    
    // TTL() partially replaces the "expiry-time" parts of S5.3 step 3 (setCookie()
    // elsewhere)
    // S5.3 says to give the "latest representable date" for which we use Infinity
    // For "expired" we use 0
    Cookie.prototype.TTL = function TTL(now) {
      /* RFC6265 S4.1.2.2 If a cookie has both the Max-Age and the Expires
       * attribute, the Max-Age attribute has precedence and controls the
       * expiration date of the cookie.
       * (Concurs with S5.3 step 3)
       */
      if (this.maxAge != null) {
        return this.maxAge<=0 ? 0 : this.maxAge*1000;
      }
    
      var expires = this.expires;
      if (expires != Infinity) {
        if (!(expires instanceof Date)) {
          expires = parseDate(expires) || Infinity;
        }
    
        if (expires == Infinity) {
          return Infinity;
        }
    
        return expires.getTime() - (now || Date.now());
      }
    
      return Infinity;
    };
    
    // expiryTime() replaces the "expiry-time" parts of S5.3 step 3 (setCookie()
    // elsewhere)
    Cookie.prototype.expiryTime = function expiryTime(now) {
      if (this.maxAge != null) {
        var relativeTo = now || this.creation || new Date();
        var age = (this.maxAge <= 0) ? -Infinity : this.maxAge*1000;
        return relativeTo.getTime() + age;
      }
    
      if (this.expires == Infinity) {
        return Infinity;
      }
      return this.expires.getTime();
    };
    
    // expiryDate() replaces the "expiry-time" parts of S5.3 step 3 (setCookie()
    // elsewhere), except it returns a Date
    Cookie.prototype.expiryDate = function expiryDate(now) {
      var millisec = this.expiryTime(now);
      if (millisec == Infinity) {
        return new Date(MAX_TIME);
      } else if (millisec == -Infinity) {
        return new Date(MIN_TIME);
      } else {
        return new Date(millisec);
      }
    };
    
    // This replaces the "persistent-flag" parts of S5.3 step 3
    Cookie.prototype.isPersistent = function isPersistent() {
      return (this.maxAge != null || this.expires != Infinity);
    };
    
    // Mostly S5.1.2 and S5.2.3:
    Cookie.prototype.cdomain =
    Cookie.prototype.canonicalizedDomain = function canonicalizedDomain() {
      if (this.domain == null) {
        return null;
      }
      return canonicalDomain(this.domain);
    };
    
    function CookieJar(store, rejectPublicSuffixes) {
      if (rejectPublicSuffixes != null) {
        this.rejectPublicSuffixes = rejectPublicSuffixes;
      }
    
      if (!store) {
        store = new MemoryCookieStore();
      }
      this.store = store;
    }
    CookieJar.prototype.store = null;
    CookieJar.prototype.rejectPublicSuffixes = true;
    var CAN_BE_SYNC = [];
    
    CAN_BE_SYNC.push('setCookie');
    CookieJar.prototype.setCookie = function(cookie, url, options, cb) {
      var err;
      var context = getCookieContext(url);
      if (options instanceof Function) {
        cb = options;
        options = {};
      }
    
      var host = canonicalDomain(context.hostname);
    
      // S5.3 step 1
      if (!(cookie instanceof Cookie)) {
        cookie = Cookie.parse(cookie);
      }
      if (!cookie) {
        err = new Error("Cookie failed to parse");
        return cb(options.ignoreError ? null : err);
      }
    
      // S5.3 step 2
      var now = options.now || new Date(); // will assign later to save effort in the face of errors
    
      // S5.3 step 3: NOOP; persistent-flag and expiry-time is handled by getCookie()
    
      // S5.3 step 4: NOOP; domain is null by default
    
      // S5.3 step 5: public suffixes
      if (this.rejectPublicSuffixes && cookie.domain) {
        var suffix = pubsuffix.getPublicSuffix(cookie.cdomain());
        if (suffix == null) { // e.g. "com"
          err = new Error("Cookie has domain set to a public suffix");
          return cb(options.ignoreError ? null : err);
        }
      }
    
      // S5.3 step 6:
      if (cookie.domain) {
        if (!domainMatch(host, cookie.cdomain(), false)) {
          err = new Error("Cookie not in this host's domain. Cookie:"+cookie.cdomain()+" Request:"+host);
          return cb(options.ignoreError ? null : err);
        }
    
        if (cookie.hostOnly == null) { // don't reset if already set
          cookie.hostOnly = false;
        }
    
      } else {
        cookie.hostOnly = true;
        cookie.domain = host;
      }
    
      //S5.2.4 If the attribute-value is empty or if the first character of the
      //attribute-value is not %x2F ("/"):
      //Let cookie-path be the default-path.
      if (!cookie.path || cookie.path[0] !== '/') {
        cookie.path = defaultPath(context.pathname);
        cookie.pathIsDefault = true;
      }
    
      // S5.3 step 8: NOOP; secure attribute
      // S5.3 step 9: NOOP; httpOnly attribute
    
      // S5.3 step 10
      if (options.http === false && cookie.httpOnly) {
        err = new Error("Cookie is HttpOnly and this isn't an HTTP API");
        return cb(options.ignoreError ? null : err);
      }
    
      var store = this.store;
    
      if (!store.updateCookie) {
        store.updateCookie = function(oldCookie, newCookie, cb) {
          this.putCookie(newCookie, cb);
        };
      }
    
      function withCookie(err, oldCookie) {
        if (err) {
          return cb(err);
        }
    
        var next = function(err) {
          if (err) {
            return cb(err);
          } else {
            cb(null, cookie);
          }
        };
    
        if (oldCookie) {
          // S5.3 step 11 - "If the cookie store contains a cookie with the same name,
          // domain, and path as the newly created cookie:"
          if (options.http === false && oldCookie.httpOnly) { // step 11.2
            err = new Error("old Cookie is HttpOnly and this isn't an HTTP API");
            return cb(options.ignoreError ? null : err);
          }
          cookie.creation = oldCookie.creation; // step 11.3
          cookie.creationIndex = oldCookie.creationIndex; // preserve tie-breaker
          cookie.lastAccessed = now;
          // Step 11.4 (delete cookie) is implied by just setting the new one:
          store.updateCookie(oldCookie, cookie, next); // step 12
    
        } else {
          cookie.creation = cookie.lastAccessed = now;
          store.putCookie(cookie, next); // step 12
        }
      }
    
      store.findCookie(cookie.domain, cookie.path, cookie.key, withCookie);
    };
    
    // RFC6365 S5.4
    CAN_BE_SYNC.push('getCookies');
    CookieJar.prototype.getCookies = function(url, options, cb) {
      var context = getCookieContext(url);
      if (options instanceof Function) {
        cb = options;
        options = {};
      }
    
      var host = canonicalDomain(context.hostname);
      var path = context.pathname || '/';
    
      var secure = options.secure;
      if (secure == null && context.protocol &&
          (context.protocol == 'https:' || context.protocol == 'wss:'))
      {
        secure = true;
      }
    
      var http = options.http;
      if (http == null) {
        http = true;
      }
    
      var now = options.now || Date.now();
      var expireCheck = options.expire !== false;
      var allPaths = !!options.allPaths;
      var store = this.store;
    
      function matchingCookie(c) {
        // "Either:
        //   The cookie's host-only-flag is true and the canonicalized
        //   request-host is identical to the cookie's domain.
        // Or:
        //   The cookie's host-only-flag is false and the canonicalized
        //   request-host domain-matches the cookie's domain."
        if (c.hostOnly) {
          if (c.domain != host) {
            return false;
          }
        } else {
          if (!domainMatch(host, c.domain, false)) {
            return false;
          }
        }
    
        // "The request-uri's path path-matches the cookie's path."
        if (!allPaths && !pathMatch(path, c.path)) {
          return false;
        }
    
        // "If the cookie's secure-only-flag is true, then the request-uri's
        // scheme must denote a "secure" protocol"
        if (c.secure && !secure) {
          return false;
        }
    
        // "If the cookie's http-only-flag is true, then exclude the cookie if the
        // cookie-string is being generated for a "non-HTTP" API"
        if (c.httpOnly && !http) {
          return false;
        }
    
        // deferred from S5.3
        // non-RFC: allow retention of expired cookies by choice
        if (expireCheck && c.expiryTime() <= now) {
          store.removeCookie(c.domain, c.path, c.key, function(){}); // result ignored
          return false;
        }
    
        return true;
      }
    
      store.findCookies(host, allPaths ? null : path, function(err,cookies) {
        if (err) {
          return cb(err);
        }
    
        cookies = cookies.filter(matchingCookie);
    
        // sorting of S5.4 part 2
        if (options.sort !== false) {
          cookies = cookies.sort(cookieCompare);
        }
    
        // S5.4 part 3
        var now = new Date();
        cookies.forEach(function(c) {
          c.lastAccessed = now;
        });
        // TODO persist lastAccessed
    
        cb(null,cookies);
      });
    };
    
    CAN_BE_SYNC.push('getCookieString');
    CookieJar.prototype.getCookieString = function(/*..., cb*/) {
      var args = Array.prototype.slice.call(arguments,0);
      var cb = args.pop();
      var next = function(err,cookies) {
        if (err) {
          cb(err);
        } else {
          cb(null, cookies
            .sort(cookieCompare)
            .map(function(c){
              return c.cookieString();
            })
            .join('; '));
        }
      };
      args.push(next);
      this.getCookies.apply(this,args);
    };
    
    CAN_BE_SYNC.push('getSetCookieStrings');
    CookieJar.prototype.getSetCookieStrings = function(/*..., cb*/) {
      var args = Array.prototype.slice.call(arguments,0);
      var cb = args.pop();
      var next = function(err,cookies) {
        if (err) {
          cb(err);
        } else {
          cb(null, cookies.map(function(c){
            return c.toString();
          }));
        }
      };
      args.push(next);
      this.getCookies.apply(this,args);
    };
    
    CAN_BE_SYNC.push('serialize');
    CookieJar.prototype.serialize = function(cb) {
      var type = this.store.constructor.name;
      if (type === 'Object') {
        type = null;
      }
    
      // update README.md "Serialization Format" if you change this, please!
      var serialized = {
        // The version of tough-cookie that serialized this jar. Generally a good
        // practice since future versions can make data import decisions based on
        // known past behavior. When/if this matters, use `semver`.
        version: 'tough-cookie@'+VERSION,
    
        // add the store type, to make humans happy:
        storeType: type,
    
        // CookieJar configuration:
        rejectPublicSuffixes: !!this.rejectPublicSuffixes,
    
        // this gets filled from getAllCookies:
        cookies: []
      };
    
      if (!(this.store.getAllCookies &&
            typeof this.store.getAllCookies === 'function'))
      {
        return cb(new Error('store does not support getAllCookies and cannot be serialized'));
      }
    
      this.store.getAllCookies(function(err,cookies) {
        if (err) {
          return cb(err);
        }
    
        serialized.cookies = cookies.map(function(cookie) {
          // convert to serialized 'raw' cookies
          cookie = (cookie instanceof Cookie) ? cookie.toJSON() : cookie;
    
          // Remove the index so new ones get assigned during deserialization
          delete cookie.creationIndex;
    
          return cookie;
        });
    
        return cb(null, serialized);
      });
    };
    
    // well-known name that JSON.stringify calls
    CookieJar.prototype.toJSON = function() {
      return this.serializeSync();
    };
    
    // use the class method CookieJar.deserialize instead of calling this directly
    CAN_BE_SYNC.push('_importCookies');
    CookieJar.prototype._importCookies = function(serialized, cb) {
      var jar = this;
      var cookies = serialized.cookies;
      if (!cookies || !Array.isArray(cookies)) {
        return cb(new Error('serialized jar has no cookies array'));
      }
    
      function putNext(err) {
        if (err) {
          return cb(err);
        }
    
        if (!cookies.length) {
          return cb(err, jar);
        }
    
        var cookie;
        try {
          cookie = fromJSON(cookies.shift());
        } catch (e) {
          return cb(e);
        }
    
        if (cookie === null) {
          return putNext(null); // skip this cookie
        }
    
        jar.store.putCookie(cookie, putNext);
      }
    
      putNext();
    };
    
    CookieJar.deserialize = function(strOrObj, store, cb) {
      if (arguments.length !== 3) {
        // store is optional
        cb = store;
        store = null;
      }
    
      var serialized;
      if (typeof strOrObj === 'string') {
        serialized = jsonParse(strOrObj);
        if (serialized instanceof Error) {
          return cb(serialized);
        }
      } else {
        serialized = strOrObj;
      }
    
      var jar = new CookieJar(store, serialized.rejectPublicSuffixes);
      jar._importCookies(serialized, function(err) {
        if (err) {
          return cb(err);
        }
        cb(null, jar);
      });
    };
    
    CookieJar.fromJSON = CookieJar.deserializeSync;
    CookieJar.deserializeSync = function(strOrObj, store) {
      var serialized = typeof strOrObj === 'string' ?
        JSON.parse(strOrObj) : strOrObj;
      var jar = new CookieJar(store, serialized.rejectPublicSuffixes);
    
      // catch this mistake early:
      if (!jar.store.synchronous) {
        throw new Error('CookieJar store is not synchronous; use async API instead.');
      }
    
      jar._importCookiesSync(serialized);
      return jar;
    };
    
    CAN_BE_SYNC.push('clone');
    CookieJar.prototype.clone = function(newStore, cb) {
      if (arguments.length === 1) {
        cb = newStore;
        newStore = null;
      }
    
      this.serialize(function(err,serialized) {
        if (err) {
          return cb(err);
        }
        CookieJar.deserialize(newStore, serialized, cb);
      });
    };
    
    // Use a closure to provide a true imperative API for synchronous stores.
    function syncWrap(method) {
      return function() {
        if (!this.store.synchronous) {
          throw new Error('CookieJar store is not synchronous; use async API instead.');
        }
    
        var args = Array.prototype.slice.call(arguments);
        var syncErr, syncResult;
        args.push(function syncCb(err, result) {
          syncErr = err;
          syncResult = result;
        });
        this[method].apply(this, args);
    
        if (syncErr) {
          throw syncErr;
        }
        return syncResult;
      };
    }
    
    // wrap all declared CAN_BE_SYNC methods in the sync wrapper
    CAN_BE_SYNC.forEach(function(method) {
      CookieJar.prototype[method+'Sync'] = syncWrap(method);
    });
    
    module.exports = {
      CookieJar: CookieJar,
      Cookie: Cookie,
      Store: Store,
      MemoryCookieStore: MemoryCookieStore,
      parseDate: parseDate,
      formatDate: formatDate,
      parse: parse,
      fromJSON: fromJSON,
      domainMatch: domainMatch,
      defaultPath: defaultPath,
      pathMatch: pathMatch,
      getPublicSuffix: pubsuffix.getPublicSuffix,
      cookieCompare: cookieCompare,
      permuteDomain:  require('tough-cookie/lib/permuteDomain').permuteDomain,
      permutePath: permutePath,
      canonicalDomain: canonicalDomain
    };
    
  provide("tough-cookie", module.exports);
}(global));

// pakmanager:http-signature/lib/parser
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Copyright 2012 Joyent, Inc.  All rights reserved.
    
    var assert = require('assert-plus');
    var util = require('util');
    
    
    
    ///--- Globals
    
    var Algorithms = {
      'rsa-sha1': true,
      'rsa-sha256': true,
      'rsa-sha512': true,
      'dsa-sha1': true,
      'hmac-sha1': true,
      'hmac-sha256': true,
      'hmac-sha512': true
    };
    
    var State = {
      New: 0,
      Params: 1
    };
    
    var ParamsState = {
      Name: 0,
      Quote: 1,
      Value: 2,
      Comma: 3
    };
    
    
    
    ///--- Specific Errors
    
    function HttpSignatureError(message, caller) {
      if (Error.captureStackTrace)
        Error.captureStackTrace(this, caller || HttpSignatureError);
    
      this.message = message;
      this.name = caller.name;
    }
    util.inherits(HttpSignatureError, Error);
    
    function ExpiredRequestError(message) {
      HttpSignatureError.call(this, message, ExpiredRequestError);
    }
    util.inherits(ExpiredRequestError, HttpSignatureError);
    
    
    function InvalidHeaderError(message) {
      HttpSignatureError.call(this, message, InvalidHeaderError);
    }
    util.inherits(InvalidHeaderError, HttpSignatureError);
    
    
    function InvalidParamsError(message) {
      HttpSignatureError.call(this, message, InvalidParamsError);
    }
    util.inherits(InvalidParamsError, HttpSignatureError);
    
    
    function MissingHeaderError(message) {
      HttpSignatureError.call(this, message, MissingHeaderError);
    }
    util.inherits(MissingHeaderError, HttpSignatureError);
    
    
    
    ///--- Exported API
    
    module.exports = {
    
      /**
       * Parses the 'Authorization' header out of an http.ServerRequest object.
       *
       * Note that this API will fully validate the Authorization header, and throw
       * on any error.  It will not however check the signature, or the keyId format
       * as those are specific to your environment.  You can use the options object
       * to pass in extra constraints.
       *
       * As a response object you can expect this:
       *
       *     {
       *       "scheme": "Signature",
       *       "params": {
       *         "keyId": "foo",
       *         "algorithm": "rsa-sha256",
       *         "headers": [
       *           "date" or "x-date",
       *           "content-md5"
       *         ],
       *         "signature": "base64"
       *       },
       *       "signingString": "ready to be passed to crypto.verify()"
       *     }
       *
       * @param {Object} request an http.ServerRequest.
       * @param {Object} options an optional options object with:
       *                   - clockSkew: allowed clock skew in seconds (default 300).
       *                   - headers: required header names (def: date or x-date)
       *                   - algorithms: algorithms to support (default: all).
       * @return {Object} parsed out object (see above).
       * @throws {TypeError} on invalid input.
       * @throws {InvalidHeaderError} on an invalid Authorization header error.
       * @throws {InvalidParamsError} if the params in the scheme are invalid.
       * @throws {MissingHeaderError} if the params indicate a header not present,
       *                              either in the request headers from the params,
       *                              or not in the params from a required header
       *                              in options.
       * @throws {ExpiredRequestError} if the value of date or x-date exceeds skew.
       */
      parseRequest: function parseRequest(request, options) {
        assert.object(request, 'request');
        assert.object(request.headers, 'request.headers');
        if (options === undefined) {
          options = {};
        }
        if (options.headers === undefined) {
          options.headers = [request.headers['x-date'] ? 'x-date' : 'date'];
        }
        assert.object(options, 'options');
        assert.arrayOfString(options.headers, 'options.headers');
        assert.optionalNumber(options.clockSkew, 'options.clockSkew');
    
        if (!request.headers.authorization)
          throw new MissingHeaderError('no authorization header present in ' +
                                       'the request');
    
        options.clockSkew = options.clockSkew || 300;
    
    
        var i = 0;
        var state = State.New;
        var substate = ParamsState.Name;
        var tmpName = '';
        var tmpValue = '';
    
        var parsed = {
          scheme: '',
          params: {},
          signingString: '',
    
          get algorithm() {
            return this.params.algorithm.toUpperCase();
          },
    
          get keyId() {
            return this.params.keyId;
          }
    
        };
    
        var authz = request.headers.authorization;
        for (i = 0; i < authz.length; i++) {
          var c = authz.charAt(i);
    
          switch (Number(state)) {
    
          case State.New:
            if (c !== ' ') parsed.scheme += c;
            else state = State.Params;
            break;
    
          case State.Params:
            switch (Number(substate)) {
    
            case ParamsState.Name:
              var code = c.charCodeAt(0);
              // restricted name of A-Z / a-z
              if ((code >= 0x41 && code <= 0x5a) || // A-Z
                  (code >= 0x61 && code <= 0x7a)) { // a-z
                tmpName += c;
              } else if (c === '=') {
                if (tmpName.length === 0)
                  throw new InvalidHeaderError('bad param format');
                substate = ParamsState.Quote;
              } else {
                throw new InvalidHeaderError('bad param format');
              }
              break;
    
            case ParamsState.Quote:
              if (c === '"') {
                tmpValue = '';
                substate = ParamsState.Value;
              } else {
                throw new InvalidHeaderError('bad param format');
              }
              break;
    
            case ParamsState.Value:
              if (c === '"') {
                parsed.params[tmpName] = tmpValue;
                substate = ParamsState.Comma;
              } else {
                tmpValue += c;
              }
              break;
    
            case ParamsState.Comma:
              if (c === ',') {
                tmpName = '';
                substate = ParamsState.Name;
              } else {
                throw new InvalidHeaderError('bad param format');
              }
              break;
    
            default:
              throw new Error('Invalid substate');
            }
            break;
    
          default:
            throw new Error('Invalid substate');
          }
    
        }
    
        if (!parsed.params.headers || parsed.params.headers === '') {
          if (request.headers['x-date']) {
            parsed.params.headers = ['x-date'];
          } else {
            parsed.params.headers = ['date'];
          }
        } else {
          parsed.params.headers = parsed.params.headers.split(' ');
        }
    
        // Minimally validate the parsed object
        if (!parsed.scheme || parsed.scheme !== 'Signature')
          throw new InvalidHeaderError('scheme was not "Signature"');
    
        if (!parsed.params.keyId)
          throw new InvalidHeaderError('keyId was not specified');
    
        if (!parsed.params.algorithm)
          throw new InvalidHeaderError('algorithm was not specified');
    
        if (!parsed.params.signature)
          throw new InvalidHeaderError('signature was not specified');
    
        // Check the algorithm against the official list
        parsed.params.algorithm = parsed.params.algorithm.toLowerCase();
        if (!Algorithms[parsed.params.algorithm])
          throw new InvalidParamsError(parsed.params.algorithm +
                                       ' is not supported');
    
        // Build the signingString
        for (i = 0; i < parsed.params.headers.length; i++) {
          var h = parsed.params.headers[i].toLowerCase();
          parsed.params.headers[i] = h;
    
          if (h !== 'request-line') {
            var value = request.headers[h];
            if (!value)
              throw new MissingHeaderError(h + ' was not in the request');
            parsed.signingString += h + ': ' + value;
          } else {
            parsed.signingString +=
              request.method + ' ' + request.url + ' HTTP/' + request.httpVersion;
          }
    
          if ((i + 1) < parsed.params.headers.length)
            parsed.signingString += '\n';
        }
    
        // Check against the constraints
        var date;
        if (request.headers.date || request.headers['x-date']) {
            if (request.headers['x-date']) {
              date = new Date(request.headers['x-date']);
            } else {
              date = new Date(request.headers.date);
            }
          var now = new Date();
          var skew = Math.abs(now.getTime() - date.getTime());
    
          if (skew > options.clockSkew * 1000) {
            throw new ExpiredRequestError('clock skew of ' +
                                          (skew / 1000) +
                                          's was greater than ' +
                                          options.clockSkew + 's');
          }
        }
    
        options.headers.forEach(function (hdr) {
          // Remember that we already checked any headers in the params
          // were in the request, so if this passes we're good.
          if (parsed.params.headers.indexOf(hdr) < 0)
            throw new MissingHeaderError(hdr + ' was not a signed header');
        });
    
        if (options.algorithms) {
          if (options.algorithms.indexOf(parsed.params.algorithm) === -1)
            throw new InvalidParamsError(parsed.params.algorithm +
                                         ' is not a supported algorithm');
        }
    
        return parsed;
      }
    
    };
    
  provide("http-signature/lib/parser", module.exports);
}(global));

// pakmanager:http-signature/lib/signer
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Copyright 2012 Joyent, Inc.  All rights reserved.
    
    var assert = require('assert-plus');
    var crypto = require('crypto');
    var http = require('http');
    
    var sprintf = require('util').format;
    
    
    
    ///--- Globals
    
    var Algorithms = {
      'rsa-sha1': true,
      'rsa-sha256': true,
      'rsa-sha512': true,
      'dsa-sha1': true,
      'hmac-sha1': true,
      'hmac-sha256': true,
      'hmac-sha512': true
    };
    
    var Authorization =
      'Signature keyId="%s",algorithm="%s",headers="%s",signature="%s"';
    
    
    
    ///--- Specific Errors
    
    function MissingHeaderError(message) {
        this.name = 'MissingHeaderError';
        this.message = message;
        this.stack = (new Error()).stack;
    }
    MissingHeaderError.prototype = new Error();
    
    
    function InvalidAlgorithmError(message) {
        this.name = 'InvalidAlgorithmError';
        this.message = message;
        this.stack = (new Error()).stack;
    }
    InvalidAlgorithmError.prototype = new Error();
    
    
    
    ///--- Internal Functions
    
    function _pad(val) {
      if (parseInt(val, 10) < 10) {
        val = '0' + val;
      }
      return val;
    }
    
    
    function _rfc1123() {
      var date = new Date();
    
      var months = ['Jan',
                    'Feb',
                    'Mar',
                    'Apr',
                    'May',
                    'Jun',
                    'Jul',
                    'Aug',
                    'Sep',
                    'Oct',
                    'Nov',
                    'Dec'];
      var days = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
      return days[date.getUTCDay()] + ', ' +
        _pad(date.getUTCDate()) + ' ' +
        months[date.getUTCMonth()] + ' ' +
        date.getUTCFullYear() + ' ' +
        _pad(date.getUTCHours()) + ':' +
        _pad(date.getUTCMinutes()) + ':' +
        _pad(date.getUTCSeconds()) +
        ' GMT';
    }
    
    
    
    ///--- Exported API
    
    module.exports = {
    
      /**
       * Adds an 'Authorization' header to an http.ClientRequest object.
       *
       * Note that this API will add a Date header if it's not already set. Any
       * other headers in the options.headers array MUST be present, or this
       * will throw.
       *
       * You shouldn't need to check the return type; it's just there if you want
       * to be pedantic.
       *
       * @param {Object} request an instance of http.ClientRequest.
       * @param {Object} options signing parameters object:
       *                   - {String} keyId required.
       *                   - {String} key required (either a PEM or HMAC key).
       *                   - {Array} headers optional; defaults to ['date'].
       *                   - {String} algorithm optional; defaults to 'rsa-sha256'.
       *                   - {String} httpVersion optional; defaults to '1.1'.
       * @return {Boolean} true if Authorization (and optionally Date) were added.
       * @throws {TypeError} on bad parameter types (input).
       * @throws {InvalidAlgorithmError} if algorithm was bad.
       * @throws {MissingHeaderError} if a header to be signed was specified but
       *                              was not present.
       */
      signRequest: function signRequest(request, options) {
        assert.object(request, 'request');
        assert.object(options, 'options');
        assert.optionalString(options.algorithm, 'options.algorithm');
        assert.string(options.keyId, 'options.keyId');
        assert.optionalArrayOfString(options.headers, 'options.headers');
        assert.optionalString(options.httpVersion, 'options.httpVersion');
    
        if (!request.getHeader('Date'))
          request.setHeader('Date', _rfc1123());
        if (!options.headers)
          options.headers = ['date'];
        if (!options.algorithm)
          options.algorithm = 'rsa-sha256';
        if (!options.httpVersion)
          options.httpVersion = '1.1';
    
        options.algorithm = options.algorithm.toLowerCase();
    
        if (!Algorithms[options.algorithm])
          throw new InvalidAlgorithmError(options.algorithm + ' is not supported');
    
        var i;
        var stringToSign = '';
        for (i = 0; i < options.headers.length; i++) {
          if (typeof (options.headers[i]) !== 'string')
            throw new TypeError('options.headers must be an array of Strings');
    
          var h = options.headers[i].toLowerCase();
    
          if (h !== 'request-line') {
            var value = request.getHeader(h);
            if (!value) {
              throw new MissingHeaderError(h + ' was not in the request');
            }
            stringToSign += h + ': ' + value;
          } else {
            stringToSign +=
              request.method + ' ' + request.path + ' HTTP/' + options.httpVersion;
          }
    
          if ((i + 1) < options.headers.length)
            stringToSign += '\n';
        }
    
        var alg = options.algorithm.match(/(hmac|rsa)-(\w+)/);
        var signature;
        if (alg[1] === 'hmac') {
          var hmac = crypto.createHmac(alg[2].toUpperCase(), options.key);
          hmac.update(stringToSign);
          signature = hmac.digest('base64');
        } else {
          var signer = crypto.createSign(options.algorithm.toUpperCase());
          signer.update(stringToSign);
          signature = signer.sign(options.key, 'base64');
        }
    
        request.setHeader('Authorization', sprintf(Authorization,
                                                   options.keyId,
                                                   options.algorithm,
                                                   options.headers.join(' '),
                                                   signature));
    
        return true;
      }
    
    };
    
  provide("http-signature/lib/signer", module.exports);
}(global));

// pakmanager:http-signature/lib/verify
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Copyright 2015 Joyent, Inc.
    
    var assert = require('assert-plus');
    var crypto = require('crypto');
    
    
    
    ///--- Exported API
    
    module.exports = {
      /**
       * Verify RSA/DSA signature against public key.  You are expected to pass in
       * an object that was returned from `parse()`.
       *
       * @param {Object} parsedSignature the object you got from `parse`.
       * @param {String} pubkey RSA/DSA private key PEM.
       * @return {Boolean} true if valid, false otherwise.
       * @throws {TypeError} if you pass in bad arguments.
       */
      verifySignature: function verifySignature(parsedSignature, pubkey) {
        assert.object(parsedSignature, 'parsedSignature');
        assert.string(pubkey, 'pubkey');
    
        var alg = parsedSignature.algorithm.match(/^(RSA|DSA)-(\w+)/);
        if (!alg || alg.length !== 3)
          throw new TypeError('parsedSignature: unsupported algorithm ' +
                              parsedSignature.algorithm);
    
        var verify = crypto.createVerify(alg[0]);
        verify.update(parsedSignature.signingString);
        return verify.verify(pubkey, parsedSignature.params.signature, 'base64');
      },
    
      /**
       * Verify HMAC against shared secret.  You are expected to pass in an object
       * that was returned from `parse()`.
       *
       * @param {Object} parsedSignature the object you got from `parse`.
       * @param {String} secret HMAC shared secret.
       * @return {Boolean} true if valid, false otherwise.
       * @throws {TypeError} if you pass in bad arguments.
       */
      verifyHMAC: function verifyHMAC(parsedSignature, secret) {
        assert.object(parsedSignature, 'parsedHMAC');
        assert.string(secret, 'secret');
    
        var alg = parsedSignature.algorithm.match(/^HMAC-(\w+)/);
        if (!alg || alg.length !== 2)
          throw new TypeError('parsedSignature: unsupported algorithm ' +
                              parsedSignature.algorithm);
    
        var hmac = crypto.createHmac(alg[1].toUpperCase(), secret);
        hmac.update(parsedSignature.signingString);
        return (hmac.digest('base64') === parsedSignature.params.signature);
      }
    };
    
  provide("http-signature/lib/verify", module.exports);
}(global));

// pakmanager:http-signature/lib/util
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Copyright 2012 Joyent, Inc.  All rights reserved.
    
    var assert = require('assert-plus');
    var crypto = require('crypto');
    
    var asn1 = require('asn1');
    var ctype = require('ctype');
    
    
    
    ///--- Helpers
    
    function readNext(buffer, offset) {
      var len = ctype.ruint32(buffer, 'big', offset);
      offset += 4;
    
      var newOffset = offset + len;
    
      return {
        data: buffer.slice(offset, newOffset),
        offset: newOffset
      };
    }
    
    
    function writeInt(writer, buffer) {
      writer.writeByte(0x02); // ASN1.Integer
      writer.writeLength(buffer.length);
    
      for (var i = 0; i < buffer.length; i++)
        writer.writeByte(buffer[i]);
    
      return writer;
    }
    
    
    function rsaToPEM(key) {
      var buffer;
      var der;
      var exponent;
      var i;
      var modulus;
      var newKey = '';
      var offset = 0;
      var type;
      var tmp;
    
      try {
        buffer = new Buffer(key.split(' ')[1], 'base64');
    
        tmp = readNext(buffer, offset);
        type = tmp.data.toString();
        offset = tmp.offset;
    
        if (type !== 'ssh-rsa')
          throw new Error('Invalid ssh key type: ' + type);
    
        tmp = readNext(buffer, offset);
        exponent = tmp.data;
        offset = tmp.offset;
    
        tmp = readNext(buffer, offset);
        modulus = tmp.data;
      } catch (e) {
        throw new Error('Invalid ssh key: ' + key);
      }
    
      // DER is a subset of BER
      der = new asn1.BerWriter();
    
      der.startSequence();
    
      der.startSequence();
      der.writeOID('1.2.840.113549.1.1.1');
      der.writeNull();
      der.endSequence();
    
      der.startSequence(0x03); // bit string
      der.writeByte(0x00);
    
      // Actual key
      der.startSequence();
      writeInt(der, modulus);
      writeInt(der, exponent);
      der.endSequence();
    
      // bit string
      der.endSequence();
    
      der.endSequence();
    
      tmp = der.buffer.toString('base64');
      for (i = 0; i < tmp.length; i++) {
        if ((i % 64) === 0)
          newKey += '\n';
        newKey += tmp.charAt(i);
      }
    
      if (!/\\n$/.test(newKey))
        newKey += '\n';
    
      return '-----BEGIN PUBLIC KEY-----' + newKey + '-----END PUBLIC KEY-----\n';
    }
    
    
    function dsaToPEM(key) {
      var buffer;
      var offset = 0;
      var tmp;
      var der;
      var newKey = '';
    
      var type;
      var p;
      var q;
      var g;
      var y;
    
      try {
        buffer = new Buffer(key.split(' ')[1], 'base64');
    
        tmp = readNext(buffer, offset);
        type = tmp.data.toString();
        offset = tmp.offset;
    
        /* JSSTYLED */
        if (!/^ssh-ds[as].*/.test(type))
          throw new Error('Invalid ssh key type: ' + type);
    
        tmp = readNext(buffer, offset);
        p = tmp.data;
        offset = tmp.offset;
    
        tmp = readNext(buffer, offset);
        q = tmp.data;
        offset = tmp.offset;
    
        tmp = readNext(buffer, offset);
        g = tmp.data;
        offset = tmp.offset;
    
        tmp = readNext(buffer, offset);
        y = tmp.data;
      } catch (e) {
        console.log(e.stack);
        throw new Error('Invalid ssh key: ' + key);
      }
    
      // DER is a subset of BER
      der = new asn1.BerWriter();
    
      der.startSequence();
    
      der.startSequence();
      der.writeOID('1.2.840.10040.4.1');
    
      der.startSequence();
      writeInt(der, p);
      writeInt(der, q);
      writeInt(der, g);
      der.endSequence();
    
      der.endSequence();
    
      der.startSequence(0x03); // bit string
      der.writeByte(0x00);
      writeInt(der, y);
      der.endSequence();
    
      der.endSequence();
    
      tmp = der.buffer.toString('base64');
      for (var i = 0; i < tmp.length; i++) {
        if ((i % 64) === 0)
          newKey += '\n';
        newKey += tmp.charAt(i);
      }
    
      if (!/\\n$/.test(newKey))
        newKey += '\n';
    
      return '-----BEGIN PUBLIC KEY-----' + newKey + '-----END PUBLIC KEY-----\n';
    }
    
    
    ///--- API
    
    module.exports = {
    
      /**
       * Converts an OpenSSH public key (rsa only) to a PKCS#8 PEM file.
       *
       * The intent of this module is to interoperate with OpenSSL only,
       * specifically the node crypto module's `verify` method.
       *
       * @param {String} key an OpenSSH public key.
       * @return {String} PEM encoded form of the RSA public key.
       * @throws {TypeError} on bad input.
       * @throws {Error} on invalid ssh key formatted data.
       */
      sshKeyToPEM: function sshKeyToPEM(key) {
        assert.string(key, 'ssh_key');
    
        /* JSSTYLED */
        if (/^ssh-rsa.*/.test(key))
          return rsaToPEM(key);
    
        /* JSSTYLED */
        if (/^ssh-ds[as].*/.test(key))
          return dsaToPEM(key);
    
        throw new Error('Only RSA and DSA public keys are allowed');
      },
    
    
      /**
       * Generates an OpenSSH fingerprint from an ssh public key.
       *
       * @param {String} key an OpenSSH public key.
       * @return {String} key fingerprint.
       * @throws {TypeError} on bad input.
       * @throws {Error} if what you passed doesn't look like an ssh public key.
       */
      fingerprint: function fingerprint(key) {
        assert.string(key, 'ssh_key');
    
        var pieces = key.split(' ');
        if (!pieces || !pieces.length || pieces.length < 2)
          throw new Error('invalid ssh key');
    
        var data = new Buffer(pieces[1], 'base64');
    
        var hash = crypto.createHash('md5');
        hash.update(data);
        var digest = hash.digest('hex');
    
        var fp = '';
        for (var i = 0; i < digest.length; i++) {
          if (i && i % 2 === 0)
            fp += ':';
    
          fp += digest[i];
        }
    
        return fp;
      },
    
      /**
       * Converts a PKGCS#8 PEM file to an OpenSSH public key (rsa)
       *
       * The reverse of the above function.
       */
      pemToRsaSSHKey: function pemToRsaSSHKey(pem, comment) {
        assert.equal('string', typeof (pem), 'typeof pem');
    
        // chop off the BEGIN PUBLIC KEY and END PUBLIC KEY portion
        var cleaned = pem.split('\n').slice(1, -2).join('');
    
        var buf = new Buffer(cleaned, 'base64');
    
        var der = new asn1.BerReader(buf);
    
        der.readSequence();
        der.readSequence();
    
        var oid = der.readOID();
        assert.equal(oid, '1.2.840.113549.1.1.1', 'pem not in RSA format');
    
        // Null -- XXX this probably isn't good practice
        der.readByte();
        der.readByte();
    
        // bit string sequence
        der.readSequence(0x03);
        der.readByte();
        der.readSequence();
    
        // modulus
        assert.equal(der.peek(), asn1.Ber.Integer, 'modulus not an integer');
        der._offset = der.readLength(der.offset + 1);
        var modulus = der._buf.slice(der.offset, der.offset + der.length);
        der._offset += der.length;
    
        // exponent
        assert.equal(der.peek(), asn1.Ber.Integer, 'exponent not an integer');
        der._offset = der.readLength(der.offset + 1);
        var exponent = der._buf.slice(der.offset, der.offset + der.length);
        der._offset += der.length;
    
        // now, make the key
        var type = new Buffer('ssh-rsa');
        var buffer = new Buffer(4 + type.length + 4 + modulus.length +
          4 + exponent.length);
        var i = 0;
        buffer.writeUInt32BE(type.length, i);     i += 4;
        type.copy(buffer, i);                     i += type.length;
        buffer.writeUInt32BE(exponent.length, i); i += 4;
        exponent.copy(buffer, i);                 i += exponent.length;
        buffer.writeUInt32BE(modulus.length, i);  i += 4;
        modulus.copy(buffer, i);                  i += modulus.length;
    
        var s = (type.toString() + ' ' + buffer.toString('base64') + ' ' +
          (comment || ''));
        return s;
      }
    };
    
  provide("http-signature/lib/util", module.exports);
}(global));

// pakmanager:http-signature
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Copyright 2015 Joyent, Inc.
    
    var parser =  require('http-signature/lib/parser');
    var signer =  require('http-signature/lib/signer');
    var verify =  require('http-signature/lib/verify');
    var util =  require('http-signature/lib/util');
    
    
    
    ///--- API
    
    module.exports = {
    
      parse: parser.parseRequest,
      parseRequest: parser.parseRequest,
    
      sign: signer.signRequest,
      signRequest: signer.signRequest,
    
      sshKeyToPEM: util.sshKeyToPEM,
      sshKeyFingerprint: util.fingerprint,
      pemToRsaSSHKey: util.pemToRsaSSHKey,
    
      verify: verify.verifySignature,
      verifySignature: verify.verifySignature,
      verifyHMAC: verify.verifyHMAC
    };
    
  provide("http-signature", module.exports);
}(global));

// pakmanager:oauth-sign
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var crypto = require('crypto')
      , qs = require('querystring')
      ;
    
    function sha1 (key, body) {
      return crypto.createHmac('sha1', key).update(body).digest('base64')
    }
    
    function rsa (key, body) {
      return crypto.createSign("RSA-SHA1").update(body).sign(key, 'base64');
    }
    
    function rfc3986 (str) {
      return encodeURIComponent(str)
        .replace(/!/g,'%21')
        .replace(/\*/g,'%2A')
        .replace(/\(/g,'%28')
        .replace(/\)/g,'%29')
        .replace(/'/g,'%27')
        ;
    }
    
    // Maps object to bi-dimensional array
    // Converts { foo: 'A', bar: [ 'b', 'B' ]} to
    // [ ['foo', 'A'], ['bar', 'b'], ['bar', 'B'] ]
    function map (obj) {
      var key, val, arr = []
      for (key in obj) {
        val = obj[key]
        if (Array.isArray(val))
          for (var i = 0; i < val.length; i++)
            arr.push([key, val[i]])
        else if (typeof val === "object")
          for (var prop in val)
            arr.push([key + '[' + prop + ']', val[prop]]);
        else
          arr.push([key, val])
      }
      return arr
    }
    
    // Compare function for sort
    function compare (a, b) {
      return a > b ? 1 : a < b ? -1 : 0
    }
    
    function generateBase (httpMethod, base_uri, params) {
      // adapted from https://dev.twitter.com/docs/auth/oauth and 
      // https://dev.twitter.com/docs/auth/creating-signature
    
      // Parameter normalization
      // http://tools.ietf.org/html/rfc5849#section-3.4.1.3.2
      var normalized = map(params)
      // 1.  First, the name and value of each parameter are encoded
      .map(function (p) {
        return [ rfc3986(p[0]), rfc3986(p[1] || '') ]
      })
      // 2.  The parameters are sorted by name, using ascending byte value
      //     ordering.  If two or more parameters share the same name, they
      //     are sorted by their value.
      .sort(function (a, b) {
        return compare(a[0], b[0]) || compare(a[1], b[1])
      })
      // 3.  The name of each parameter is concatenated to its corresponding
      //     value using an "=" character (ASCII code 61) as a separator, even
      //     if the value is empty.
      .map(function (p) { return p.join('=') })
       // 4.  The sorted name/value pairs are concatenated together into a
       //     single string by using an "&" character (ASCII code 38) as
       //     separator.
      .join('&')
    
      var base = [
        rfc3986(httpMethod ? httpMethod.toUpperCase() : 'GET'),
        rfc3986(base_uri),
        rfc3986(normalized)
      ].join('&')
    
      return base
    }
    
    function hmacsign (httpMethod, base_uri, params, consumer_secret, token_secret) {
      var base = generateBase(httpMethod, base_uri, params)
      var key = [
        consumer_secret || '',
        token_secret || ''
      ].map(rfc3986).join('&')
    
      return sha1(key, base)
    }
    
    function rsasign (httpMethod, base_uri, params, private_key, token_secret) {
      var base = generateBase(httpMethod, base_uri, params)
      var key = private_key || ''
    
      return rsa(key, base)
    }
    
    function plaintext (consumer_secret, token_secret) {
      var key = [
        consumer_secret || '',
        token_secret || ''
      ].map(rfc3986).join('&')
    
      return key
    }
    
    function sign (signMethod, httpMethod, base_uri, params, consumer_secret, token_secret) {
      var method
      var skipArgs = 1
    
      switch (signMethod) {
        case 'RSA-SHA1':
          method = rsasign
          break
        case 'HMAC-SHA1':
          method = hmacsign
          break
        case 'PLAINTEXT':
          method = plaintext
          skipArgs = 4
          break
        default:
         throw new Error("Signature method not supported: " + signMethod)
      }
    
      return method.apply(null, [].slice.call(arguments, skipArgs))
    }
    
    exports.hmacsign = hmacsign
    exports.rsasign = rsasign
    exports.plaintext = plaintext
    exports.sign = sign
    exports.rfc3986 = rfc3986
    
  provide("oauth-sign", module.exports);
}(global));

// pakmanager:hawk/lib/utils
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Load modules
    
    var Sntp = require('sntp');
    var Boom = require('boom');
    
    
    // Declare internals
    
    var internals = {};
    
    
    exports.version = function () {
    
        return require('../package.json').version;
    };
    
    
    // Extract host and port from request
    
    //                                            $1                            $2
    internals.hostHeaderRegex = /^(?:(?:\r\n)?\s)*((?:[^:]+)|(?:\[[^\]]+\]))(?::(\d+))?(?:(?:\r\n)?\s)*$/;              // (IPv4, hostname)|(IPv6)
    
    
    exports.parseHost = function (req, hostHeaderName) {
    
        hostHeaderName = (hostHeaderName ? hostHeaderName.toLowerCase() : 'host');
        var hostHeader = req.headers[hostHeaderName];
        if (!hostHeader) {
            return null;
        }
    
        var hostParts = hostHeader.match(internals.hostHeaderRegex);
        if (!hostParts) {
            return null;
        }
    
        return {
            name: hostParts[1],
            port: (hostParts[2] ? hostParts[2] : (req.connection && req.connection.encrypted ? 443 : 80))
        };
    };
    
    
    // Parse Content-Type header content
    
    exports.parseContentType = function (header) {
    
        if (!header) {
            return '';
        }
    
        return header.split(';')[0].trim().toLowerCase();
    };
    
    
    // Convert node's  to request configuration object
    
    exports.parseRequest = function (req, options) {
    
        if (!req.headers) {
            return req;
        }
    
        // Obtain host and port information
    
        if (!options.host || !options.port) {
            var host = exports.parseHost(req, options.hostHeaderName);
            if (!host) {
                return new Error('Invalid Host header');
            }
        }
    
        var request = {
            method: req.method,
            url: req.url,
            host: options.host || host.name,
            port: options.port || host.port,
            authorization: req.headers.authorization,
            contentType: req.headers['content-type'] || ''
        };
    
        return request;
    };
    
    
    exports.now = function (localtimeOffsetMsec) {
    
        return Sntp.now() + (localtimeOffsetMsec || 0);
    };
    
    
    exports.nowSecs = function (localtimeOffsetMsec) {
    
        return Math.floor(exports.now(localtimeOffsetMsec) / 1000);
    };
    
    
    // Parse Hawk HTTP Authorization header
    
    exports.parseAuthorizationHeader = function (header, keys) {
    
        keys = keys || ['id', 'ts', 'nonce', 'hash', 'ext', 'mac', 'app', 'dlg'];
    
        if (!header) {
            return Boom.unauthorized(null, 'Hawk');
        }
    
        var headerParts = header.match(/^(\w+)(?:\s+(.*))?$/);       // Header: scheme[ something]
        if (!headerParts) {
            return Boom.badRequest('Invalid header syntax');
        }
    
        var scheme = headerParts[1];
        if (scheme.toLowerCase() !== 'hawk') {
            return Boom.unauthorized(null, 'Hawk');
        }
    
        var attributesString = headerParts[2];
        if (!attributesString) {
            return Boom.badRequest('Invalid header syntax');
        }
    
        var attributes = {};
        var errorMessage = '';
        var verify = attributesString.replace(/(\w+)="([^"\\]*)"\s*(?:,\s*|$)/g, function ($0, $1, $2) {
    
            // Check valid attribute names
    
            if (keys.indexOf($1) === -1) {
                errorMessage = 'Unknown attribute: ' + $1;
                return;
            }
    
            // Allowed attribute value characters: !#$%&'()*+,-./:;<=>?@[]^_`{|}~ and space, a-z, A-Z, 0-9
    
            if ($2.match(/^[ \w\!#\$%&'\(\)\*\+,\-\.\/\:;<\=>\?@\[\]\^`\{\|\}~]+$/) === null) {
                errorMessage = 'Bad attribute value: ' + $1;
                return;
            }
    
            // Check for duplicates
    
            if (attributes.hasOwnProperty($1)) {
                errorMessage = 'Duplicate attribute: ' + $1;
                return;
            }
    
            attributes[$1] = $2;
            return '';
        });
    
        if (verify !== '') {
            return Boom.badRequest(errorMessage || 'Bad header format');
        }
    
        return attributes;
    };
    
    
    exports.unauthorized = function (message, attributes) {
    
        return Boom.unauthorized(message, 'Hawk', attributes);
    };
    
    
  provide("hawk/lib/utils", module.exports);
}(global));

// pakmanager:hawk/lib/crypto
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Load modules
    
    var Crypto = require('crypto');
    var Url = require('url');
    var Utils =  require('hawk/lib/utils');
    
    
    // Declare internals
    
    var internals = {};
    
    
    // MAC normalization format version
    
    exports.headerVersion = '1';                        // Prevent comparison of mac values generated with different normalized string formats
    
    
    // Supported HMAC algorithms
    
    exports.algorithms = ['sha1', 'sha256'];
    
    
    // Calculate the request MAC
    
    /*
        type: 'header',                                 // 'header', 'bewit', 'response'
        credentials: {
            key: 'aoijedoaijsdlaksjdl',
            algorithm: 'sha256'                         // 'sha1', 'sha256'
        },
        options: {
            method: 'GET',
            resource: '/resource?a=1&b=2',
            host: 'example.com',
            port: 8080,
            ts: 1357718381034,
            nonce: 'd3d345f',
            hash: 'U4MKKSmiVxk37JCCrAVIjV/OhB3y+NdwoCr6RShbVkE=',
            ext: 'app-specific-data',
            app: 'hf48hd83qwkj',                        // Application id (Oz)
            dlg: 'd8djwekds9cj'                         // Delegated by application id (Oz), requires options.app
        }
    */
    
    exports.calculateMac = function (type, credentials, options) {
    
        var normalized = exports.generateNormalizedString(type, options);
    
        var hmac = Crypto.createHmac(credentials.algorithm, credentials.key).update(normalized);
        var digest = hmac.digest('base64');
        return digest;
    };
    
    
    exports.generateNormalizedString = function (type, options) {
    
        var resource = options.resource || '';
        if (resource &&
            resource[0] !== '/') {
    
            var url = Url.parse(resource, false);
            resource = url.path;                        // Includes query
        }
    
        var normalized = 'hawk.' + exports.headerVersion + '.' + type + '\n' +
                         options.ts + '\n' +
                         options.nonce + '\n' +
                         (options.method || '').toUpperCase() + '\n' +
                         resource + '\n' +
                         options.host.toLowerCase() + '\n' +
                         options.port + '\n' +
                         (options.hash || '') + '\n';
    
        if (options.ext) {
            normalized += options.ext.replace('\\', '\\\\').replace('\n', '\\n');
        }
    
        normalized += '\n';
    
        if (options.app) {
            normalized += options.app + '\n' +
                          (options.dlg || '') + '\n';
        }
    
        return normalized;
    };
    
    
    exports.calculatePayloadHash = function (payload, algorithm, contentType) {
    
        var hash = exports.initializePayloadHash(algorithm, contentType);
        hash.update(payload || '');
        return exports.finalizePayloadHash(hash);
    };
    
    
    exports.initializePayloadHash = function (algorithm, contentType) {
    
        var hash = Crypto.createHash(algorithm);
        hash.update('hawk.' + exports.headerVersion + '.payload\n');
        hash.update(Utils.parseContentType(contentType) + '\n');
        return hash;
    };
    
    
    exports.finalizePayloadHash = function (hash) {
    
        hash.update('\n');
        return hash.digest('base64');
    };
    
    
    exports.calculateTsMac = function (ts, credentials) {
    
        var hmac = Crypto.createHmac(credentials.algorithm, credentials.key);
        hmac.update('hawk.' + exports.headerVersion + '.ts\n' + ts + '\n');
        return hmac.digest('base64');
    };
    
    
    exports.timestampMessage = function (credentials, localtimeOffsetMsec) {
    
        var now = Utils.nowSecs(localtimeOffsetMsec);
        var tsm = exports.calculateTsMac(now, credentials);
        return { ts: now, tsm: tsm };
    };
    
  provide("hawk/lib/crypto", module.exports);
}(global));

// pakmanager:hawk/lib/server
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Load modules
    
    var Boom = require('boom');
    var Hoek = require('hoek');
    var Cryptiles = require('cryptiles');
    var Crypto =  require('hawk/lib/crypto');
    var Utils =  require('hawk/lib/utils');
    
    
    // Declare internals
    
    var internals = {};
    
    
    // Hawk authentication
    
    /*
       req:                 node's HTTP request object or an object as follows:
    
                            var request = {
                                method: 'GET',
                                url: '/resource/4?a=1&b=2',
                                host: 'example.com',
                                port: 8080,
                                authorization: 'Hawk id="dh37fgj492je", ts="1353832234", nonce="j4h3g2", ext="some-app-ext-data", mac="6R4rV5iE+NPoym+WwjeHzjAGXUtLNIxmo1vpMofpLAE="'
                            };
    
       credentialsFunc:     required function to lookup the set of Hawk credentials based on the provided credentials id.
                            The credentials include the MAC key, MAC algorithm, and other attributes (such as username)
                            needed by the application. This function is the equivalent of verifying the username and
                            password in Basic authentication.
    
                            var credentialsFunc = function (id, callback) {
    
                                // Lookup credentials in database
                                db.lookup(id, function (err, item) {
    
                                    if (err || !item) {
                                        return callback(err);
                                    }
    
                                    var credentials = {
                                        // Required
                                        key: item.key,
                                        algorithm: item.algorithm,
                                        // Application specific
                                        user: item.user
                                    };
    
                                    return callback(null, credentials);
                                });
                            };
    
       options: {
    
            hostHeaderName:        optional header field name, used to override the default 'Host' header when used
                                   behind a cache of a proxy. Apache2 changes the value of the 'Host' header while preserving
                                   the original (which is what the module must verify) in the 'x-forwarded-host' header field.
                                   Only used when passed a node Http.ServerRequest object.
    
            nonceFunc:             optional nonce validation function. The function signature is function(key, nonce, ts, callback)
                                   where 'callback' must be called using the signature function(err).
    
            timestampSkewSec:      optional number of seconds of permitted clock skew for incoming timestamps. Defaults to 60 seconds.
                                   Provides a +/- skew which means actual allowed window is double the number of seconds.
    
            localtimeOffsetMsec:   optional local clock time offset express in a number of milliseconds (positive or negative).
                                   Defaults to 0.
    
            payload:               optional payload for validation. The client calculates the hash value and includes it via the 'hash'
                                   header attribute. The server always ensures the value provided has been included in the request
                                   MAC. When this option is provided, it validates the hash value itself. Validation is done by calculating
                                   a hash value over the entire payload (assuming it has already be normalized to the same format and
                                   encoding used by the client to calculate the hash on request). If the payload is not available at the time
                                   of authentication, the authenticatePayload() method can be used by passing it the credentials and
                                   attributes.hash returned in the authenticate callback.
    
            host:                  optional host name override. Only used when passed a node request object.
            port:                  optional port override. Only used when passed a node request object.
        }
    
        callback: function (err, credentials, artifacts) { }
     */
    
    exports.authenticate = function (req, credentialsFunc, options, callback) {
    
        callback = Hoek.nextTick(callback);
    
        // Default options
    
        options.nonceFunc = options.nonceFunc || internals.nonceFunc;
        options.timestampSkewSec = options.timestampSkewSec || 60;                                                  // 60 seconds
    
        // Application time
    
        var now = Utils.now(options.localtimeOffsetMsec);                           // Measure now before any other processing
    
        // Convert node Http request object to a request configuration object
    
        var request = Utils.parseRequest(req, options);
        if (request instanceof Error) {
            return callback(Boom.badRequest(request.message));
        }
    
        // Parse HTTP Authorization header
    
        var attributes = Utils.parseAuthorizationHeader(request.authorization);
        if (attributes instanceof Error) {
            return callback(attributes);
        }
    
        // Construct artifacts container
    
        var artifacts = {
            method: request.method,
            host: request.host,
            port: request.port,
            resource: request.url,
            ts: attributes.ts,
            nonce: attributes.nonce,
            hash: attributes.hash,
            ext: attributes.ext,
            app: attributes.app,
            dlg: attributes.dlg,
            mac: attributes.mac,
            id: attributes.id
        };
    
        // Verify required header attributes
    
        if (!attributes.id ||
            !attributes.ts ||
            !attributes.nonce ||
            !attributes.mac) {
    
            return callback(Boom.badRequest('Missing attributes'), null, artifacts);
        }
    
        // Fetch Hawk credentials
    
        credentialsFunc(attributes.id, function (err, credentials) {
    
            if (err) {
                return callback(err, credentials || null, artifacts);
            }
    
            if (!credentials) {
                return callback(Boom.unauthorized('Unknown credentials', 'Hawk'), null, artifacts);
            }
    
            if (!credentials.key ||
                !credentials.algorithm) {
    
                return callback(Boom.internal('Invalid credentials'), credentials, artifacts);
            }
    
            if (Crypto.algorithms.indexOf(credentials.algorithm) === -1) {
                return callback(Boom.internal('Unknown algorithm'), credentials, artifacts);
            }
    
            // Calculate MAC
    
            var mac = Crypto.calculateMac('header', credentials, artifacts);
            if (!Cryptiles.fixedTimeComparison(mac, attributes.mac)) {
                return callback(Boom.unauthorized('Bad mac', 'Hawk'), credentials, artifacts);
            }
    
            // Check payload hash
    
            if (options.payload ||
                options.payload === '') {
    
                if (!attributes.hash) {
                    return callback(Boom.unauthorized('Missing required payload hash', 'Hawk'), credentials, artifacts);
                }
    
                var hash = Crypto.calculatePayloadHash(options.payload, credentials.algorithm, request.contentType);
                if (!Cryptiles.fixedTimeComparison(hash, attributes.hash)) {
                    return callback(Boom.unauthorized('Bad payload hash', 'Hawk'), credentials, artifacts);
                }
            }
    
            // Check nonce
    
            options.nonceFunc(credentials.key, attributes.nonce, attributes.ts, function (err) {
    
                if (err) {
                    return callback(Boom.unauthorized('Invalid nonce', 'Hawk'), credentials, artifacts);
                }
    
                // Check timestamp staleness
    
                if (Math.abs((attributes.ts * 1000) - now) > (options.timestampSkewSec * 1000)) {
                    var tsm = Crypto.timestampMessage(credentials, options.localtimeOffsetMsec);
                    return callback(Boom.unauthorized('Stale timestamp', 'Hawk', tsm), credentials, artifacts);
                }
    
                // Successful authentication
    
                return callback(null, credentials, artifacts);
            });
        });
    };
    
    
    // Authenticate payload hash - used when payload cannot be provided during authenticate()
    
    /*
        payload:        raw request payload
        credentials:    from authenticate callback
        artifacts:      from authenticate callback
        contentType:    req.headers['content-type']
    */
    
    exports.authenticatePayload = function (payload, credentials, artifacts, contentType) {
    
        var calculatedHash = Crypto.calculatePayloadHash(payload, credentials.algorithm, contentType);
        return Cryptiles.fixedTimeComparison(calculatedHash, artifacts.hash);
    };
    
    
    // Authenticate payload hash - used when payload cannot be provided during authenticate()
    
    /*
        calculatedHash: the payload hash calculated using Crypto.calculatePayloadHash()
        artifacts:      from authenticate callback
    */
    
    exports.authenticatePayloadHash = function (calculatedHash, artifacts) {
    
        return Cryptiles.fixedTimeComparison(calculatedHash, artifacts.hash);
    };
    
    
    // Generate a Server-Authorization header for a given response
    
    /*
        credentials: {},                                        // Object received from authenticate()
        artifacts: {}                                           // Object received from authenticate(); 'mac', 'hash', and 'ext' - ignored
        options: {
            ext: 'application-specific',                        // Application specific data sent via the ext attribute
            payload: '{"some":"payload"}',                      // UTF-8 encoded string for body hash generation (ignored if hash provided)
            contentType: 'application/json',                    // Payload content-type (ignored if hash provided)
            hash: 'U4MKKSmiVxk37JCCrAVIjV='                     // Pre-calculated payload hash
        }
    */
    
    exports.header = function (credentials, artifacts, options) {
    
        // Prepare inputs
    
        options = options || {};
    
        if (!artifacts ||
            typeof artifacts !== 'object' ||
            typeof options !== 'object') {
    
            return '';
        }
    
        artifacts = Hoek.clone(artifacts);
        delete artifacts.mac;
        artifacts.hash = options.hash;
        artifacts.ext = options.ext;
    
        // Validate credentials
    
        if (!credentials ||
            !credentials.key ||
            !credentials.algorithm) {
    
            // Invalid credential object
            return '';
        }
    
        if (Crypto.algorithms.indexOf(credentials.algorithm) === -1) {
            return '';
        }
    
        // Calculate payload hash
    
        if (!artifacts.hash &&
            (options.payload || options.payload === '')) {
    
            artifacts.hash = Crypto.calculatePayloadHash(options.payload, credentials.algorithm, options.contentType);
        }
    
        var mac = Crypto.calculateMac('response', credentials, artifacts);
    
        // Construct header
    
        var header = 'Hawk mac="' + mac + '"' +
                     (artifacts.hash ? ', hash="' + artifacts.hash + '"' : '');
    
        if (artifacts.ext !== null &&
            artifacts.ext !== undefined &&
            artifacts.ext !== '') {                       // Other falsey values allowed
    
            header += ', ext="' + Hoek.escapeHeaderAttribute(artifacts.ext) + '"';
        }
    
        return header;
    };
    
    
    /*
     * Arguments and options are the same as authenticate() with the exception that the only supported options are:
     * 'hostHeaderName', 'localtimeOffsetMsec', 'host', 'port'
     */
    
    exports.authenticateBewit = function (req, credentialsFunc, options, callback) {
    
        callback = Hoek.nextTick(callback);
    
        // Application time
    
        var now = Utils.now(options.localtimeOffsetMsec);
    
        // Convert node Http request object to a request configuration object
    
        var request = Utils.parseRequest(req, options);
        if (request instanceof Error) {
            return callback(Boom.badRequest(request.message));
        }
    
        // Extract bewit
    
        //                                 1     2             3           4
        var resource = request.url.match(/^(\/.*)([\?&])bewit\=([^&$]*)(?:&(.+))?$/);
        if (!resource) {
            return callback(Boom.unauthorized(null, 'Hawk'));
        }
    
        // Bewit not empty
    
        if (!resource[3]) {
            return callback(Boom.unauthorized('Empty bewit', 'Hawk'));
        }
    
        // Verify method is GET
    
        if (request.method !== 'GET' &&
            request.method !== 'HEAD') {
    
            return callback(Boom.unauthorized('Invalid method', 'Hawk'));
        }
    
        // No other authentication
    
        if (request.authorization) {
            return callback(Boom.badRequest('Multiple authentications'));
        }
    
        // Parse bewit
    
        var bewitString = Hoek.base64urlDecode(resource[3]);
        if (bewitString instanceof Error) {
            return callback(Boom.badRequest('Invalid bewit encoding'));
        }
    
        // Bewit format: id\exp\mac\ext ('\' is used because it is a reserved header attribute character)
    
        var bewitParts = bewitString.split('\\');
        if (bewitParts.length !== 4) {
            return callback(Boom.badRequest('Invalid bewit structure'));
        }
    
        var bewit = {
            id: bewitParts[0],
            exp: parseInt(bewitParts[1], 10),
            mac: bewitParts[2],
            ext: bewitParts[3] || ''
        };
    
        if (!bewit.id ||
            !bewit.exp ||
            !bewit.mac) {
    
            return callback(Boom.badRequest('Missing bewit attributes'));
        }
    
        // Construct URL without bewit
    
        var url = resource[1];
        if (resource[4]) {
            url += resource[2] + resource[4];
        }
    
        // Check expiration
    
        if (bewit.exp * 1000 <= now) {
            return callback(Boom.unauthorized('Access expired', 'Hawk'), null, bewit);
        }
    
        // Fetch Hawk credentials
    
        credentialsFunc(bewit.id, function (err, credentials) {
    
            if (err) {
                return callback(err, credentials || null, bewit.ext);
            }
    
            if (!credentials) {
                return callback(Boom.unauthorized('Unknown credentials', 'Hawk'), null, bewit);
            }
    
            if (!credentials.key ||
                !credentials.algorithm) {
    
                return callback(Boom.internal('Invalid credentials'), credentials, bewit);
            }
    
            if (Crypto.algorithms.indexOf(credentials.algorithm) === -1) {
                return callback(Boom.internal('Unknown algorithm'), credentials, bewit);
            }
    
            // Calculate MAC
    
            var mac = Crypto.calculateMac('bewit', credentials, {
                ts: bewit.exp,
                nonce: '',
                method: 'GET',
                resource: url,
                host: request.host,
                port: request.port,
                ext: bewit.ext
            });
    
            if (!Cryptiles.fixedTimeComparison(mac, bewit.mac)) {
                return callback(Boom.unauthorized('Bad mac', 'Hawk'), credentials, bewit);
            }
    
            // Successful authentication
    
            return callback(null, credentials, bewit);
        });
    };
    
    
    /*
     *  options are the same as authenticate() with the exception that the only supported options are:
     * 'nonceFunc', 'timestampSkewSec', 'localtimeOffsetMsec'
     */
    
    exports.authenticateMessage = function (host, port, message, authorization, credentialsFunc, options, callback) {
    
        callback = Hoek.nextTick(callback);
    
        // Default options
    
        options.nonceFunc = options.nonceFunc || internals.nonceFunc;
        options.timestampSkewSec = options.timestampSkewSec || 60;                                                  // 60 seconds
    
        // Application time
    
        var now = Utils.now(options.localtimeOffsetMsec);                       // Measure now before any other processing
    
        // Validate authorization
    
        if (!authorization.id ||
            !authorization.ts ||
            !authorization.nonce ||
            !authorization.hash ||
            !authorization.mac) {
    
            return callback(Boom.badRequest('Invalid authorization'));
        }
    
        // Fetch Hawk credentials
    
        credentialsFunc(authorization.id, function (err, credentials) {
    
            if (err) {
                return callback(err, credentials || null);
            }
    
            if (!credentials) {
                return callback(Boom.unauthorized('Unknown credentials', 'Hawk'));
            }
    
            if (!credentials.key ||
                !credentials.algorithm) {
    
                return callback(Boom.internal('Invalid credentials'), credentials);
            }
    
            if (Crypto.algorithms.indexOf(credentials.algorithm) === -1) {
                return callback(Boom.internal('Unknown algorithm'), credentials);
            }
    
            // Construct artifacts container
    
            var artifacts = {
                ts: authorization.ts,
                nonce: authorization.nonce,
                host: host,
                port: port,
                hash: authorization.hash
            };
    
            // Calculate MAC
    
            var mac = Crypto.calculateMac('message', credentials, artifacts);
            if (!Cryptiles.fixedTimeComparison(mac, authorization.mac)) {
                return callback(Boom.unauthorized('Bad mac', 'Hawk'), credentials);
            }
    
            // Check payload hash
    
            var hash = Crypto.calculatePayloadHash(message, credentials.algorithm);
            if (!Cryptiles.fixedTimeComparison(hash, authorization.hash)) {
                return callback(Boom.unauthorized('Bad message hash', 'Hawk'), credentials);
            }
    
            // Check nonce
    
            options.nonceFunc(credentials.key, authorization.nonce, authorization.ts, function (err) {
    
                if (err) {
                    return callback(Boom.unauthorized('Invalid nonce', 'Hawk'), credentials);
                }
    
                // Check timestamp staleness
    
                if (Math.abs((authorization.ts * 1000) - now) > (options.timestampSkewSec * 1000)) {
                    return callback(Boom.unauthorized('Stale timestamp'), credentials);
                }
    
                // Successful authentication
    
                return callback(null, credentials);
            });
        });
    };
    
    
    internals.nonceFunc = function (key, nonce, ts, nonceCallback) {
    
        return nonceCallback();         // No validation
    };
    
  provide("hawk/lib/server", module.exports);
}(global));

// pakmanager:hawk/lib/client
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Load modules
    
    var Url = require('url');
    var Hoek = require('hoek');
    var Cryptiles = require('cryptiles');
    var Crypto =  require('hawk/lib/crypto');
    var Utils =  require('hawk/lib/utils');
    
    
    // Declare internals
    
    var internals = {};
    
    
    // Generate an Authorization header for a given request
    
    /*
        uri: 'http://example.com/resource?a=b' or object from Url.parse()
        method: HTTP verb (e.g. 'GET', 'POST')
        options: {
    
            // Required
    
            credentials: {
                id: 'dh37fgj492je',
                key: 'aoijedoaijsdlaksjdl',
                algorithm: 'sha256'                                 // 'sha1', 'sha256'
            },
    
            // Optional
    
            ext: 'application-specific',                        // Application specific data sent via the ext attribute
            timestamp: Date.now(),                              // A pre-calculated timestamp
            nonce: '2334f34f',                                  // A pre-generated nonce
            localtimeOffsetMsec: 400,                           // Time offset to sync with server time (ignored if timestamp provided)
            payload: '{"some":"payload"}',                      // UTF-8 encoded string for body hash generation (ignored if hash provided)
            contentType: 'application/json',                    // Payload content-type (ignored if hash provided)
            hash: 'U4MKKSmiVxk37JCCrAVIjV=',                    // Pre-calculated payload hash
            app: '24s23423f34dx',                               // Oz application id
            dlg: '234sz34tww3sd'                                // Oz delegated-by application id
        }
    */
    
    exports.header = function (uri, method, options) {
    
        var result = {
            field: '',
            artifacts: {}
        };
    
        // Validate inputs
    
        if (!uri || (typeof uri !== 'string' && typeof uri !== 'object') ||
            !method || typeof method !== 'string' ||
            !options || typeof options !== 'object') {
    
            result.err = 'Invalid argument type';
            return result;
        }
    
        // Application time
    
        var timestamp = options.timestamp || Utils.nowSecs(options.localtimeOffsetMsec);
    
        // Validate credentials
    
        var credentials = options.credentials;
        if (!credentials ||
            !credentials.id ||
            !credentials.key ||
            !credentials.algorithm) {
    
            result.err = 'Invalid credential object';
            return result;
        }
    
        if (Crypto.algorithms.indexOf(credentials.algorithm) === -1) {
            result.err = 'Unknown algorithm';
            return result;
        }
    
        // Parse URI
    
        if (typeof uri === 'string') {
            uri = Url.parse(uri);
        }
    
        // Calculate signature
    
        var artifacts = {
            ts: timestamp,
            nonce: options.nonce || Cryptiles.randomString(6),
            method: method,
            resource: uri.pathname + (uri.search || ''),                            // Maintain trailing '?'
            host: uri.hostname,
            port: uri.port || (uri.protocol === 'http:' ? 80 : 443),
            hash: options.hash,
            ext: options.ext,
            app: options.app,
            dlg: options.dlg
        };
    
        result.artifacts = artifacts;
    
        // Calculate payload hash
    
        if (!artifacts.hash &&
            (options.payload || options.payload === '')) {
    
            artifacts.hash = Crypto.calculatePayloadHash(options.payload, credentials.algorithm, options.contentType);
        }
    
        var mac = Crypto.calculateMac('header', credentials, artifacts);
    
        // Construct header
    
        var hasExt = artifacts.ext !== null && artifacts.ext !== undefined && artifacts.ext !== '';       // Other falsey values allowed
        var header = 'Hawk id="' + credentials.id +
                     '", ts="' + artifacts.ts +
                     '", nonce="' + artifacts.nonce +
                     (artifacts.hash ? '", hash="' + artifacts.hash : '') +
                     (hasExt ? '", ext="' + Hoek.escapeHeaderAttribute(artifacts.ext) : '') +
                     '", mac="' + mac + '"';
    
        if (artifacts.app) {
            header += ', app="' + artifacts.app +
                      (artifacts.dlg ? '", dlg="' + artifacts.dlg : '') + '"';
        }
    
        result.field = header;
    
        return result;
    };
    
    
    // Validate server response
    
    /*
        res:        node's response object
        artifacts:  object received from header().artifacts
        options: {
            payload:    optional payload received
            required:   specifies if a Server-Authorization header is required. Defaults to 'false'
        }
    */
    
    exports.authenticate = function (res, credentials, artifacts, options) {
    
        artifacts = Hoek.clone(artifacts);
        options = options || {};
    
        if (res.headers['www-authenticate']) {
    
            // Parse HTTP WWW-Authenticate header
    
            var wwwAttributes = Utils.parseAuthorizationHeader(res.headers['www-authenticate'], ['ts', 'tsm', 'error']);
            if (wwwAttributes instanceof Error) {
                return false;
            }
    
            // Validate server timestamp (not used to update clock since it is done via the SNPT client)
    
            if (wwwAttributes.ts) {
                var tsm = Crypto.calculateTsMac(wwwAttributes.ts, credentials);
                if (tsm !== wwwAttributes.tsm) {
                    return false;
                }
            }
        }
    
        // Parse HTTP Server-Authorization header
    
        if (!res.headers['server-authorization'] &&
            !options.required) {
    
            return true;
        }
    
        var attributes = Utils.parseAuthorizationHeader(res.headers['server-authorization'], ['mac', 'ext', 'hash']);
        if (attributes instanceof Error) {
            return false;
        }
    
        artifacts.ext = attributes.ext;
        artifacts.hash = attributes.hash;
    
        var mac = Crypto.calculateMac('response', credentials, artifacts);
        if (mac !== attributes.mac) {
            return false;
        }
    
        if (!options.payload &&
            options.payload !== '') {
    
            return true;
        }
    
        if (!attributes.hash) {
            return false;
        }
    
        var calculatedHash = Crypto.calculatePayloadHash(options.payload, credentials.algorithm, res.headers['content-type']);
        return (calculatedHash === attributes.hash);
    };
    
    
    // Generate a bewit value for a given URI
    
    /*
        uri: 'http://example.com/resource?a=b' or object from Url.parse()
        options: {
    
            // Required
    
            credentials: {
                id: 'dh37fgj492je',
                key: 'aoijedoaijsdlaksjdl',
                algorithm: 'sha256'                             // 'sha1', 'sha256'
            },
            ttlSec: 60 * 60,                                    // TTL in seconds
    
            // Optional
    
            ext: 'application-specific',                        // Application specific data sent via the ext attribute
            localtimeOffsetMsec: 400                            // Time offset to sync with server time
        };
    */
    
    exports.getBewit = function (uri, options) {
    
        // Validate inputs
    
        if (!uri ||
            (typeof uri !== 'string' && typeof uri !== 'object') ||
            !options ||
            typeof options !== 'object' ||
            !options.ttlSec) {
    
            return '';
        }
    
        options.ext = (options.ext === null || options.ext === undefined ? '' : options.ext);       // Zero is valid value
    
        // Application time
    
        var now = Utils.now(options.localtimeOffsetMsec);
    
        // Validate credentials
    
        var credentials = options.credentials;
        if (!credentials ||
            !credentials.id ||
            !credentials.key ||
            !credentials.algorithm) {
    
            return '';
        }
    
        if (Crypto.algorithms.indexOf(credentials.algorithm) === -1) {
            return '';
        }
    
        // Parse URI
    
        if (typeof uri === 'string') {
            uri = Url.parse(uri);
        }
    
        // Calculate signature
    
        var exp = Math.floor(now / 1000) + options.ttlSec;
        var mac = Crypto.calculateMac('bewit', credentials, {
            ts: exp,
            nonce: '',
            method: 'GET',
            resource: uri.pathname + (uri.search || ''),                            // Maintain trailing '?'
            host: uri.hostname,
            port: uri.port || (uri.protocol === 'http:' ? 80 : 443),
            ext: options.ext
        });
    
        // Construct bewit: id\exp\mac\ext
    
        var bewit = credentials.id + '\\' + exp + '\\' + mac + '\\' + options.ext;
        return Hoek.base64urlEncode(bewit);
    };
    
    
    // Generate an authorization string for a message
    
    /*
        host: 'example.com',
        port: 8000,
        message: '{"some":"payload"}',                          // UTF-8 encoded string for body hash generation
        options: {
    
            // Required
    
            credentials: {
                id: 'dh37fgj492je',
                key: 'aoijedoaijsdlaksjdl',
                algorithm: 'sha256'                             // 'sha1', 'sha256'
            },
    
            // Optional
    
            timestamp: Date.now(),                              // A pre-calculated timestamp
            nonce: '2334f34f',                                  // A pre-generated nonce
            localtimeOffsetMsec: 400,                           // Time offset to sync with server time (ignored if timestamp provided)
        }
    */
    
    exports.message = function (host, port, message, options) {
    
        // Validate inputs
    
        if (!host || typeof host !== 'string' ||
            !port || typeof port !== 'number' ||
            message === null || message === undefined || typeof message !== 'string' ||
            !options || typeof options !== 'object') {
    
            return null;
        }
    
        // Application time
    
        var timestamp = options.timestamp || Utils.nowSecs(options.localtimeOffsetMsec);
    
        // Validate credentials
    
        var credentials = options.credentials;
        if (!credentials ||
            !credentials.id ||
            !credentials.key ||
            !credentials.algorithm) {
    
            // Invalid credential object
            return null;
        }
    
        if (Crypto.algorithms.indexOf(credentials.algorithm) === -1) {
            return null;
        }
    
        // Calculate signature
    
        var artifacts = {
            ts: timestamp,
            nonce: options.nonce || Cryptiles.randomString(6),
            host: host,
            port: port,
            hash: Crypto.calculatePayloadHash(message, credentials.algorithm)
        };
    
        // Construct authorization
    
        var result = {
            id: credentials.id,
            ts: artifacts.ts,
            nonce: artifacts.nonce,
            hash: artifacts.hash,
            mac: Crypto.calculateMac('message', credentials, artifacts)
        };
    
        return result;
    };
    
    
    
    
  provide("hawk/lib/client", module.exports);
}(global));

// pakmanager:hawk
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Export sub-modules
    
    exports.error = exports.Error = require('boom');
    exports.sntp = require('sntp');
    
    exports.server =  require('hawk/lib/server');
    exports.client =  require('hawk/lib/client');
    exports.crypto =  require('hawk/lib/crypto');
    exports.utils =  require('hawk/lib/utils');
    
    exports.uri = {
        authenticate: exports.server.authenticateBewit,
        getBewit: exports.client.getBewit
    };
    
    
  provide("hawk", module.exports);
}(global));

// pakmanager:aws-sign2
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  
    /*!
     * knox - auth
     * Copyright(c) 2010 LearnBoost <dev@learnboost.com>
     * MIT Licensed
     */
    
    /**
     * Module dependencies.
     */
    
    var crypto = require('crypto')
      , parse = require('url').parse
      ;
    
    /**
     * Valid keys.
     */
    
    var keys = 
      [ 'acl'
      , 'location'
      , 'logging'
      , 'notification'
      , 'partNumber'
      , 'policy'
      , 'requestPayment'
      , 'torrent'
      , 'uploadId'
      , 'uploads'
      , 'versionId'
      , 'versioning'
      , 'versions'
      , 'website'
      ]
    
    /**
     * Return an "Authorization" header value with the given `options`
     * in the form of "AWS <key>:<signature>"
     *
     * @param {Object} options
     * @return {String}
     * @api private
     */
    
    function authorization (options) {
      return 'AWS ' + options.key + ':' + sign(options)
    }
    
    module.exports = authorization
    module.exports.authorization = authorization
    
    /**
     * Simple HMAC-SHA1 Wrapper
     *
     * @param {Object} options
     * @return {String}
     * @api private
     */ 
    
    function hmacSha1 (options) {
      return crypto.createHmac('sha1', options.secret).update(options.message).digest('base64')
    }
    
    module.exports.hmacSha1 = hmacSha1
    
    /**
     * Create a base64 sha1 HMAC for `options`. 
     * 
     * @param {Object} options
     * @return {String}
     * @api private
     */
    
    function sign (options) {
      options.message = stringToSign(options)
      return hmacSha1(options)
    }
    module.exports.sign = sign
    
    /**
     * Create a base64 sha1 HMAC for `options`. 
     *
     * Specifically to be used with S3 presigned URLs
     * 
     * @param {Object} options
     * @return {String}
     * @api private
     */
    
    function signQuery (options) {
      options.message = queryStringToSign(options)
      return hmacSha1(options)
    }
    module.exports.signQuery= signQuery
    
    /**
     * Return a string for sign() with the given `options`.
     *
     * Spec:
     * 
     *    <verb>\n
     *    <md5>\n
     *    <content-type>\n
     *    <date>\n
     *    [headers\n]
     *    <resource>
     *
     * @param {Object} options
     * @return {String}
     * @api private
     */
    
    function stringToSign (options) {
      var headers = options.amazonHeaders || ''
      if (headers) headers += '\n'
      var r = 
        [ options.verb
        , options.md5
        , options.contentType
        , options.date ? options.date.toUTCString() : ''
        , headers + options.resource
        ]
      return r.join('\n')
    }
    module.exports.queryStringToSign = stringToSign
    
    /**
     * Return a string for sign() with the given `options`, but is meant exclusively
     * for S3 presigned URLs
     *
     * Spec:
     * 
     *    <date>\n
     *    <resource>
     *
     * @param {Object} options
     * @return {String}
     * @api private
     */
    
    function queryStringToSign (options){
      return 'GET\n\n\n' + options.date + '\n' + options.resource
    }
    module.exports.queryStringToSign = queryStringToSign
    
    /**
     * Perform the following:
     *
     *  - ignore non-amazon headers
     *  - lowercase fields
     *  - sort lexicographically
     *  - trim whitespace between ":"
     *  - join with newline
     *
     * @param {Object} headers
     * @return {String}
     * @api private
     */
    
    function canonicalizeHeaders (headers) {
      var buf = []
        , fields = Object.keys(headers)
        ;
      for (var i = 0, len = fields.length; i < len; ++i) {
        var field = fields[i]
          , val = headers[field]
          , field = field.toLowerCase()
          ;
        if (0 !== field.indexOf('x-amz')) continue
        buf.push(field + ':' + val)
      }
      return buf.sort().join('\n')
    }
    module.exports.canonicalizeHeaders = canonicalizeHeaders
    
    /**
     * Perform the following:
     *
     *  - ignore non sub-resources
     *  - sort lexicographically
     *
     * @param {String} resource
     * @return {String}
     * @api private
     */
    
    function canonicalizeResource (resource) {
      var url = parse(resource, true)
        , path = url.pathname
        , buf = []
        ;
    
      Object.keys(url.query).forEach(function(key){
        if (!~keys.indexOf(key)) return
        var val = '' == url.query[key] ? '' : '=' + encodeURIComponent(url.query[key])
        buf.push(key + val)
      })
    
      return path + (buf.length ? '?' + buf.sort().join('&') : '')
    }
    module.exports.canonicalizeResource = canonicalizeResource
    
  provide("aws-sign2", module.exports);
}(global));

// pakmanager:stringstream
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var util = require('util')
    var Stream = require('stream')
    var StringDecoder = require('string_decoder').StringDecoder
    
    module.exports = StringStream
    module.exports.AlignedStringDecoder = AlignedStringDecoder
    
    function StringStream(from, to) {
      if (!(this instanceof StringStream)) return new StringStream(from, to)
    
      Stream.call(this)
    
      if (from == null) from = 'utf8'
    
      this.readable = this.writable = true
      this.paused = false
      this.toEncoding = (to == null ? from : to)
      this.fromEncoding = (to == null ? '' : from)
      this.decoder = new AlignedStringDecoder(this.toEncoding)
    }
    util.inherits(StringStream, Stream)
    
    StringStream.prototype.write = function(data) {
      if (!this.writable) {
        var err = new Error('stream not writable')
        err.code = 'EPIPE'
        this.emit('error', err)
        return false
      }
      if (this.fromEncoding) {
        if (Buffer.isBuffer(data)) data = data.toString()
        data = new Buffer(data, this.fromEncoding)
      }
      var string = this.decoder.write(data)
      if (string.length) this.emit('data', string)
      return !this.paused
    }
    
    StringStream.prototype.flush = function() {
      if (this.decoder.flush) {
        var string = this.decoder.flush()
        if (string.length) this.emit('data', string)
      }
    }
    
    StringStream.prototype.end = function() {
      if (!this.writable && !this.readable) return
      this.flush()
      this.emit('end')
      this.writable = this.readable = false
      this.destroy()
    }
    
    StringStream.prototype.destroy = function() {
      this.decoder = null
      this.writable = this.readable = false
      this.emit('close')
    }
    
    StringStream.prototype.pause = function() {
      this.paused = true
    }
    
    StringStream.prototype.resume = function () {
      if (this.paused) this.emit('drain')
      this.paused = false
    }
    
    function AlignedStringDecoder(encoding) {
      StringDecoder.call(this, encoding)
    
      switch (this.encoding) {
        case 'base64':
          this.write = alignedWrite
          this.alignedBuffer = new Buffer(3)
          this.alignedBytes = 0
          break
      }
    }
    util.inherits(AlignedStringDecoder, StringDecoder)
    
    AlignedStringDecoder.prototype.flush = function() {
      if (!this.alignedBuffer || !this.alignedBytes) return ''
      var leftover = this.alignedBuffer.toString(this.encoding, 0, this.alignedBytes)
      this.alignedBytes = 0
      return leftover
    }
    
    function alignedWrite(buffer) {
      var rem = (this.alignedBytes + buffer.length) % this.alignedBuffer.length
      if (!rem && !this.alignedBytes) return buffer.toString(this.encoding)
    
      var returnBuffer = new Buffer(this.alignedBytes + buffer.length - rem)
    
      this.alignedBuffer.copy(returnBuffer, 0, 0, this.alignedBytes)
      buffer.copy(returnBuffer, this.alignedBytes, 0, buffer.length - rem)
    
      buffer.copy(this.alignedBuffer, 0, buffer.length - rem, buffer.length)
      this.alignedBytes = rem
    
      return returnBuffer.toString(this.encoding)
    }
    
  provide("stringstream", module.exports);
}(global));

// pakmanager:isstream
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var stream = require('stream')
    
    
    function isStream (obj) {
      return obj instanceof stream.Stream
    }
    
    
    function isReadable (obj) {
      return isStream(obj) && typeof obj._read == 'function' && typeof obj._readableState == 'object'
    }
    
    
    function isWritable (obj) {
      return isStream(obj) && typeof obj._write == 'function' && typeof obj._writableState == 'object'
    }
    
    
    function isDuplex (obj) {
      return isReadable(obj) && isWritable(obj)
    }
    
    
    module.exports            = isStream
    module.exports.isReadable = isReadable
    module.exports.isWritable = isWritable
    module.exports.isDuplex   = isDuplex
    
  provide("isstream", module.exports);
}(global));

// pakmanager:har-validator/lib/schemas
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict'
    
    var schemas = {
      cache: require('./cache.json'),
      cacheEntry: require('./cacheEntry.json'),
      content: require('./content.json'),
      cookie: require('./cookie.json'),
      creator: require('./creator.json'),
      entry: require('./entry.json'),
      har: require('./har.json'),
      log: require('./log.json'),
      page: require('./page.json'),
      pageTimings: require('./pageTimings.json'),
      postData: require('./postData.json'),
      record: require('./record.json'),
      request: require('./request.json'),
      response: require('./response.json'),
      timings: require('./timings.json')
    }
    
    // is-my-json-valid does not provide meaningful error messages for external schemas
    // this is a workaround
    schemas.cache.properties.beforeRequest = schemas.cacheEntry
    schemas.cache.properties.afterRequest = schemas.cacheEntry
    
    schemas.page.properties.pageTimings = schemas.pageTimings
    
    schemas.request.properties.cookies.items = schemas.cookie
    schemas.request.properties.headers.items = schemas.record
    schemas.request.properties.queryString.items = schemas.record
    schemas.request.properties.postData = schemas.postData
    
    schemas.response.properties.cookies.items = schemas.cookie
    schemas.response.properties.headers.items = schemas.record
    schemas.response.properties.content = schemas.content
    
    schemas.entry.properties.request = schemas.request
    schemas.entry.properties.response = schemas.response
    schemas.entry.properties.cache = schemas.cache
    schemas.entry.properties.timings = schemas.timings
    
    schemas.log.properties.creator = schemas.creator
    schemas.log.properties.browser = schemas.creator
    schemas.log.properties.pages.items = schemas.page
    schemas.log.properties.entries.items = schemas.entry
    
    schemas.har.properties.log = schemas.log
    
    module.exports = schemas
    
  provide("har-validator/lib/schemas", module.exports);
}(global));

// pakmanager:har-validator/lib/error
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict'
    
    function ValidationError (errors) {
      this.name = 'ValidationError'
      this.errors = errors
    }
    
    ValidationError.prototype = Error.prototype
    
    module.exports = ValidationError
    
  provide("har-validator/lib/error", module.exports);
}(global));

// pakmanager:har-validator
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict'
    
    var schemas =  require('har-validator/lib/schemas')
    var ValidationError =  require('har-validator/lib/error')
    var validator = require('is-my-json-valid')
    
    var runner = function (schema, data, cb) {
      var validate = validator(schema, {
        greedy: true,
        verbose: true,
        schemas: schemas
      })
    
      var valid = false
    
      if (data !== undefined) {
        // execute is-my-json-valid
        valid = validate(data)
      }
    
      // callback?
      if (!cb) {
        return valid
      } else {
        return cb(validate.errors ? new ValidationError(validate.errors) : null, valid)
      }
    
      return valid
    }
    
    module.exports = function (data, cb) {
      return runner(schemas.har, data, cb)
    }
    
    Object.keys(schemas).map(function (name) {
      module.exports[name] = function (data, cb) {
        return runner(schemas[name], data, cb)
      }
    })
    
  provide("har-validator", module.exports);
}(global));

// pakmanager:duplexify
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var stream = require('readable-stream')
    var eos = require('end-of-stream')
    var util = require('util')
    
    var SIGNAL_FLUSH = new Buffer([0])
    
    var onuncork = function(self, fn) {
      if (self._corked) self.once('uncork', fn)
      else fn()
    }
    
    var destroyer = function(self, end) {
      return function(err) {
        if (err) self.destroy(err.message === 'premature close' ? null : err)
        else if (end && !self._ended) self.end()
      }
    }
    
    var end = function(ws, fn) {
      if (!ws) return fn()
      if (ws._writableState && ws._writableState.finished) return fn()
      if (ws._writableState) return ws.end(fn)
      ws.end()
      fn()
    }
    
    var toStreams2 = function(rs) {
      return new (stream.Readable)({objectMode:true, highWaterMark:16}).wrap(rs)
    }
    
    var Duplexify = function(writable, readable, opts) {
      if (!(this instanceof Duplexify)) return new Duplexify(writable, readable, opts)
      stream.Duplex.call(this, opts)
    
      this._writable = null
      this._readable = null
      this._readable2 = null
    
      this._forwardDestroy = !opts || opts.destroy !== false
      this._forwardEnd = !opts || opts.end !== false
      this._corked = 1 // start corked
      this._ondrain = null
      this._drained = false
      this._forwarding = false
      this._unwrite = null
      this._unread = null
      this._ended = false
    
      this.destroyed = false
    
      if (writable) this.setWritable(writable)
      if (readable) this.setReadable(readable)
    }
    
    util.inherits(Duplexify, stream.Duplex)
    
    Duplexify.obj = function(writable, readable, opts) {
      if (!opts) opts = {}
      opts.objectMode = true
      opts.highWaterMark = 16
      return new Duplexify(writable, readable, opts)
    }
    
    Duplexify.prototype.cork = function() {
      if (++this._corked === 1) this.emit('cork')
    }
    
    Duplexify.prototype.uncork = function() {
      if (this._corked && --this._corked === 0) this.emit('uncork')
    }
    
    Duplexify.prototype.setWritable = function(writable) {
      if (this._unwrite) this._unwrite()
    
      if (this.destroyed) {
        if (writable && writable.destroy) writable.destroy()
        return
      }
    
      if (writable === null || writable === false) {
        this.end()
        return
      }
    
      var self = this
      var unend = eos(writable, {writable:true, readable:false}, destroyer(this, this._forwardEnd))
    
      var ondrain = function() {
        var ondrain = self._ondrain
        self._ondrain = null
        if (ondrain) ondrain()
      }
    
      var clear = function() {
        self._writable.removeListener('drain', ondrain)
        unend()
      }
    
      if (this._unwrite) process.nextTick(ondrain) // force a drain on stream reset to avoid livelocks
    
      this._writable = writable
      this._writable.on('drain', ondrain)
      this._unwrite = clear
    
      this.uncork() // always uncork setWritable
    }
    
    Duplexify.prototype.setReadable = function(readable) {
      if (this._unread) this._unread()
    
      if (this.destroyed) {
        if (readable && readable.destroy) readable.destroy()
        return
      }
    
      if (readable === null || readable === false) {
        this.push(null)
        this.resume()
        return
      }
    
      var self = this
      var unend = eos(readable, {writable:false, readable:true}, destroyer(this))
    
      var onreadable = function() {
        self._forward()
      }
    
      var onend = function() {
        self.push(null)
      }
    
      var clear = function() {
        self._readable2.removeListener('readable', onreadable)
        self._readable2.removeListener('end', onend)
        unend()
      }
    
      this._drained = true
      this._readable = readable
      this._readable2 = readable._readableState ? readable : toStreams2(readable)
      this._readable2.on('readable', onreadable)
      this._readable2.on('end', onend)
      this._unread = clear
    
      this._forward()
    }
    
    Duplexify.prototype._read = function() {
      this._drained = true
      this._forward()
    }
    
    Duplexify.prototype._forward = function() {
      if (this._forwarding || !this._readable2 || !this._drained) return
      this._forwarding = true
    
      var data
      var state = this._readable2._readableState
    
      while ((data = this._readable2.read(state.buffer.length ? state.buffer[0].length : state.length)) !== null) {
        this._drained = this.push(data)
      }
    
      this._forwarding = false
    }
    
    Duplexify.prototype.destroy = function(err) {
      if (this.destroyed) return
      this.destroyed = true
    
      var self = this
      process.nextTick(function() {
        self._destroy(err)
      })
    }
    
    Duplexify.prototype._destroy = function(err) {
      if (err) {
        var ondrain = this._ondrain
        this._ondrain = null
        if (ondrain) ondrain(err)
        else this.emit('error', err)
      }
    
      if (this._forwardDestroy) {
        if (this._readable && this._readable.destroy) this._readable.destroy()
        if (this._writable && this._writable.destroy) this._writable.destroy()
      }
    
      this.emit('close')
    }
    
    Duplexify.prototype._write = function(data, enc, cb) {
      if (this.destroyed) return cb()
      if (this._corked) return onuncork(this, this._write.bind(this, data, enc, cb))
      if (data === SIGNAL_FLUSH) return this._finish(cb)
      if (!this._writable) return cb()
    
      if (this._writable.write(data) === false) this._ondrain = cb
      else cb()
    }
    
    
    Duplexify.prototype._finish = function(cb) {
      var self = this
      this.emit('preend')
      onuncork(this, function() {
        end(self._forwardEnd && self._writable, function() {
          // haxx to not emit prefinish twice
          if (self._writableState.prefinished === false) self._writableState.prefinished = true
          self.emit('prefinish')
          onuncork(self, cb)
        })
      })
    }
    
    Duplexify.prototype.end = function(data, enc, cb) {
      if (typeof data === 'function') return this.end(null, null, data)
      if (typeof enc === 'function') return this.end(data, null, enc)
      this._ended = true
      if (data) this.write(data)
      if (!this._writableState.ending) this.write(SIGNAL_FLUSH)
      return stream.Writable.prototype.end.call(this, cb)
    }
    
    module.exports = Duplexify
  provide("duplexify", module.exports);
}(global));

// pakmanager:infinity-agent/http.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    var net = require('net');
    var util = require('util');
    var EventEmitter = require('events').EventEmitter;
    
    var debug;
    
    if (util.debuglog) {
      debug = util.debuglog('http');
    } else {
      debug = function (x) {
        if (process.env.NODE_DEBUG && /http/.test(process.env.NODE_DEBUG)) {
          console.error('HTTP: %s', x);
        }
      };
    }
    
    // New Agent code.
    
    // The largest departure from the previous implementation is that
    // an Agent instance holds connections for a variable number of host:ports.
    // Surprisingly, this is still API compatible as far as third parties are
    // concerned. The only code that really notices the difference is the
    // request object.
    
    // Another departure is that all code related to HTTP parsing is in
    // ClientRequest.onSocket(). The Agent is now *strictly*
    // concerned with managing a connection pool.
    
    function Agent(options) {
      if (!(this instanceof Agent))
        return new Agent(options);
    
      EventEmitter.call(this);
    
      var self = this;
    
      self.defaultPort = 80;
      self.protocol = 'http:';
    
      self.options = util._extend({}, options);
    
      // don't confuse net and make it think that we're connecting to a pipe
      self.options.path = null;
      self.requests = {};
      self.sockets = {};
      self.freeSockets = {};
      self.keepAliveMsecs = self.options.keepAliveMsecs || 1000;
      self.keepAlive = self.options.keepAlive || false;
      self.maxSockets = self.options.maxSockets || Agent.defaultMaxSockets;
      self.maxFreeSockets = self.options.maxFreeSockets || 256;
    
      self.on('free', function(socket, options) {
        var name = self.getName(options);
        debug('agent.on(free)', name);
    
        if (!socket.destroyed &&
            self.requests[name] && self.requests[name].length) {
          self.requests[name].shift().onSocket(socket);
          if (self.requests[name].length === 0) {
            // don't leak
            delete self.requests[name];
          }
        } else {
          // If there are no pending requests, then put it in
          // the freeSockets pool, but only if we're allowed to do so.
          var req = socket._httpMessage;
          if (req &&
              req.shouldKeepAlive &&
              !socket.destroyed &&
              self.options.keepAlive) {
            var freeSockets = self.freeSockets[name];
            var freeLen = freeSockets ? freeSockets.length : 0;
            var count = freeLen;
            if (self.sockets[name])
              count += self.sockets[name].length;
    
            if (count >= self.maxSockets || freeLen >= self.maxFreeSockets) {
              self.removeSocket(socket, options);
              socket.destroy();
            } else {
              freeSockets = freeSockets || [];
              self.freeSockets[name] = freeSockets;
              socket.setKeepAlive(true, self.keepAliveMsecs);
              socket.unref();
              socket._httpMessage = null;
              self.removeSocket(socket, options);
              freeSockets.push(socket);
            }
          } else {
            self.removeSocket(socket, options);
            socket.destroy();
          }
        }
      });
    }
    
    util.inherits(Agent, EventEmitter);
    exports.Agent = Agent;
    
    Agent.defaultMaxSockets = Infinity;
    
    Agent.prototype.createConnection = net.createConnection;
    
    // Get the key for a given set of request options
    Agent.prototype.getName = function(options) {
      var name = '';
    
      if (options.host)
        name += options.host;
      else
        name += 'localhost';
    
      name += ':';
      if (options.port)
        name += options.port;
      name += ':';
      if (options.localAddress)
        name += options.localAddress;
      name += ':';
      return name;
    };
    
    Agent.prototype.addRequest = function(req, options) {
      // Legacy API: addRequest(req, host, port, path)
      if (typeof options === 'string') {
        options = {
          host: options,
          port: arguments[2],
          path: arguments[3]
        };
      }
    
      // If we are not keepAlive agent and maxSockets is Infinity
      // then disable shouldKeepAlive
      if (!this.keepAlive && !Number.isFinite(this.maxSockets)) {
        req._last = true;
        req.shouldKeepAlive = false;
      }
    
      var name = this.getName(options);
      if (!this.sockets[name]) {
        this.sockets[name] = [];
      }
    
      var freeLen = this.freeSockets[name] ? this.freeSockets[name].length : 0;
      var sockLen = freeLen + this.sockets[name].length;
    
      if (freeLen) {
        // we have a free socket, so use that.
        var socket = this.freeSockets[name].shift();
        debug('have free socket');
    
        // don't leak
        if (!this.freeSockets[name].length)
          delete this.freeSockets[name];
    
        socket.ref();
        req.onSocket(socket);
        this.sockets[name].push(socket);
      } else if (sockLen < this.maxSockets) {
        debug('call onSocket', sockLen, freeLen);
        // If we are under maxSockets create a new one.
        req.onSocket(this.createSocket(req, options));
      } else {
        debug('wait for socket');
        // We are over limit so we'll add it to the queue.
        if (!this.requests[name]) {
          this.requests[name] = [];
        }
        this.requests[name].push(req);
      }
    };
    
    Agent.prototype.createSocket = function(req, options) {
      var self = this;
      options = util._extend({}, options);
      options = util._extend(options, self.options);
    
      if (!options.servername) {
        options.servername = options.host;
        if (req) {
          var hostHeader = req.getHeader('host');
          if (hostHeader) {
            options.servername = hostHeader.replace(/:.*$/, '');
          }
        }
      }
    
      var name = self.getName(options);
    
      debug('createConnection', name, options);
      options.encoding = null;
      var s = self.createConnection(options);
      if (!self.sockets[name]) {
        self.sockets[name] = [];
      }
      this.sockets[name].push(s);
      debug('sockets', name, this.sockets[name].length);
    
      function onFree() {
        self.emit('free', s, options);
      }
      s.on('free', onFree);
    
      function onClose(err) {
        debug('CLIENT socket onClose');
        // This is the only place where sockets get removed from the Agent.
        // If you want to remove a socket from the pool, just close it.
        // All socket errors end in a close event anyway.
        self.removeSocket(s, options);
      }
      s.on('close', onClose);
    
      function onRemove() {
        // We need this function for cases like HTTP 'upgrade'
        // (defined by WebSockets) where we need to remove a socket from the
        // pool because it'll be locked up indefinitely
        debug('CLIENT socket onRemove');
        self.removeSocket(s, options);
        s.removeListener('close', onClose);
        s.removeListener('free', onFree);
        s.removeListener('agentRemove', onRemove);
      }
      s.on('agentRemove', onRemove);
      return s;
    };
    
    Agent.prototype.removeSocket = function(s, options) {
      var name = this.getName(options);
      debug('removeSocket', name, 'destroyed:', s.destroyed);
      var sets = [this.sockets];
    
      // If the socket was destroyed, remove it from the free buffers too.
      if (s.destroyed)
        sets.push(this.freeSockets);
    
      for (var sk = 0; sk < sets.length; sk++) {
        var sockets = sets[sk];
    
        if (sockets[name]) {
          var index = sockets[name].indexOf(s);
          if (index !== -1) {
            sockets[name].splice(index, 1);
            // Don't leak
            if (sockets[name].length === 0)
              delete sockets[name];
          }
        }
      }
    
      if (this.requests[name] && this.requests[name].length) {
        debug('removeSocket, have a request, make a socket');
        var req = this.requests[name][0];
        // If we have pending requests and a socket gets closed make a new one
        this.createSocket(req, options).emit('free');
      }
    };
    
    Agent.prototype.destroy = function() {
      var sets = [this.freeSockets, this.sockets];
      for (var s = 0; s < sets.length; s++) {
        var set = sets[s];
        var keys = Object.keys(set);
        for (var v = 0; v < keys.length; v++) {
          var setName = set[keys[v]];
          for (var n = 0; n < setName.length; n++) {
            setName[n].destroy();
          }
        }
      }
    };
    
    exports.globalAgent = new Agent();
    
  provide("infinity-agent/http.js", module.exports);
}(global));

// pakmanager:infinity-agent/https.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    var tls = require('tls');
    var http =  require('infinity-agent/http.js');
    var util = require('util');
    var inherits = util.inherits;
    
    var debug;
    
    if (util.debuglog) {
      debug = util.debuglog('https');
    } else {
      debug = function (x) {
        if (process.env.NODE_DEBUG && /http/.test(process.env.NODE_DEBUG)) {
          console.error('HTTPS: %s', x);
        }
      };
    }
    function createConnection(port, host, options) {
      if (port !== null && typeof port === 'object') {
        options = port;
      } else if (host !== null && typeof host === 'object') {
        options = host;
      } else if (options === null || typeof options !== 'object') {
        options = {};
      }
    
      if (typeof port === 'number') {
        options.port = port;
      }
    
      if (typeof host === 'string') {
        options.host = host;
      }
    
      debug('createConnection', options);
      return tls.connect(options);
    }
    
    
    function Agent(options) {
      http.Agent.call(this, options);
      this.defaultPort = 443;
      this.protocol = 'https:';
    }
    inherits(Agent, http.Agent);
    Agent.prototype.createConnection = createConnection;
    
    Agent.prototype.getName = function(options) {
      var name = http.Agent.prototype.getName.call(this, options);
    
      name += ':';
      if (options.ca)
        name += options.ca;
    
      name += ':';
      if (options.cert)
        name += options.cert;
    
      name += ':';
      if (options.ciphers)
        name += options.ciphers;
    
      name += ':';
      if (options.key)
        name += options.key;
    
      name += ':';
      if (options.pfx)
        name += options.pfx;
    
      name += ':';
      if (options.rejectUnauthorized !== undefined)
        name += options.rejectUnauthorized;
    
      return name;
    };
    
    var globalAgent = new Agent();
    
    exports.globalAgent = globalAgent;
    exports.Agent = Agent;
    
  provide("infinity-agent/https.js", module.exports);
}(global));

// pakmanager:infinity-agent
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    exports.http =  require('infinity-agent/http.js');
    exports.https =  require('infinity-agent/https.js');
    
  provide("infinity-agent", module.exports);
}(global));

// pakmanager:is-redirect
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    module.exports = function (x) {
    	if (typeof x !== 'number') {
    		throw new TypeError('Expected a number');
    	}
    
    	return x === 300 ||
    		x === 301 ||
    		x === 302 ||
    		x === 303 ||
    		x === 305 ||
    		x === 307 ||
    		x === 308;
    };
    
  provide("is-redirect", module.exports);
}(global));

// pakmanager:is-stream
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    var isStream = module.exports = function (stream) {
    	return stream !== null && typeof stream === 'object' && typeof stream.pipe === 'function';
    };
    
    isStream.writable = function (stream) {
    	return isStream(stream) && stream.writable !== false && typeof stream._write == 'function' && typeof stream._writableState == 'object';
    };
    
    isStream.readable = function (stream) {
    	return isStream(stream) && stream.readable !== false && typeof stream._read == 'function' && typeof stream._readableState == 'object';
    };
    
    isStream.duplex = function (stream) {
    	return isStream.writable(stream) && isStream.readable(stream);
    };
    
  provide("is-stream", module.exports);
}(global));

// pakmanager:lowercase-keys
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    module.exports = function (obj) {
    	var ret = {};
    	var keys = Object.keys(Object(obj));
    
    	for (var i = 0; i < keys.length; i++) {
    		ret[keys[i].toLowerCase()] = obj[keys[i]];
    	}
    
    	return ret;
    };
    
  provide("lowercase-keys", module.exports);
}(global));

// pakmanager:nested-error-stacks
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var util = require('util');
    
    var NestedError = function (message, nested) {
        Error.call(this);
        this.nested = nested;
    
        Error.captureStackTrace(this, this.constructor);
    
        var oldStackDescriptor = Object.getOwnPropertyDescriptor(this, 'stack');
    
        if (typeof message !== 'undefined') {
            Object.defineProperty(this, 'message', {
                value: message,
                writable: true,
                enumerable: false,
                configurable: true
            });
        }
    
        Object.defineProperties(this, {
            stack: {
                get: function () {
                    var stack = oldStackDescriptor.get.call(this);
                    if (this.nested) {
                        stack += '\nCaused By: ' + this.nested.stack;
                    }
                    return stack;
                }
            }
    
        });
    };
    
    util.inherits(NestedError, Error);
    NestedError.prototype.name = 'NestedError';
    
    
    module.exports = NestedError;
    
  provide("nested-error-stacks", module.exports);
}(global));

// pakmanager:prepend-http
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    module.exports = function (url) {
    	if (typeof url !== 'string') {
    		throw new TypeError('Expected a string');
    	}
    
    	return url.trim().replace(/^(?!(?:\w+:)?\/\/)/, 'http://');
    };
    
  provide("prepend-http", module.exports);
}(global));

// pakmanager:read-all-stream
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    var Writable = require('readable-stream').Writable;
    var inherits = require('util').inherits;
    var Promise = require('pinkie-promise');
    
    function BufferStream() {
    	Writable.call(this, { objectMode: true });
    	this.buffer = [];
    	this.length = 0;
    }
    
    inherits(BufferStream, Writable);
    BufferStream.prototype._write = function(chunk, enc, next) {
    	if (!Buffer.isBuffer(chunk)) {
    		chunk = new Buffer(chunk);
    	}
    
    	this.buffer.push(chunk);
    	this.length += chunk.length;
    	next();
    };
    
    module.exports = function read(stream, options, cb) {
    	if (!stream) {
    		throw new Error('stream argument is required');
    	}
    
    	if (typeof options === 'function') {
    		cb = options;
    		options = {};
    	}
    
    	if (typeof options === 'string' || options === undefined || options === null) {
    		options = { encoding: options };
    	}
    
    	if (options.encoding === undefined) { options.encoding = 'utf8'; }
    
    	var promise = new Promise(function (resolve, reject) {
    		var sink = new BufferStream();
    
    		sink.on('finish', function () {
    			var data = Buffer.concat(this.buffer, this.length);
    
    			if (options.encoding) {
    				data = data.toString(options.encoding);
    			}
    
    			resolve(data);
    		});
    
    		stream.once('error', reject);
    
    		stream.pipe(sink);
    	});
    
    	if (!cb) {
    		return promise;
    	}
    
    	promise.then(function (data) {
    		cb(null, data);
    	}, cb);
    };
    
  provide("read-all-stream", module.exports);
}(global));

// pakmanager:statuses
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  
    var codes = require('./codes.json');
    
    module.exports = status;
    
    // [Integer...]
    status.codes = Object.keys(codes).map(function (code) {
      code = ~~code;
      var msg = codes[code];
      status[code] = msg;
      status[msg] = status[msg.toLowerCase()] = code;
      return code;
    });
    
    // status codes for redirects
    status.redirect = {
      300: true,
      301: true,
      302: true,
      303: true,
      305: true,
      307: true,
      308: true,
    };
    
    // status codes for empty bodies
    status.empty = {
      204: true,
      205: true,
      304: true,
    };
    
    // status codes for when you should retry the request
    status.retry = {
      502: true,
      503: true,
      504: true,
    };
    
    function status(code) {
      if (typeof code === 'number') {
        if (!status[code]) throw new Error('invalid status code: ' + code);
        return code;
      }
    
      if (typeof code !== 'string') {
        throw new TypeError('code must be a number or string');
      }
    
      // '403'
      var n = parseInt(code, 10)
      if (!isNaN(n)) {
        if (!status[n]) throw new Error('invalid status code: ' + n);
        return n;
      }
    
      n = status[code.toLowerCase()];
      if (!n) throw new Error('invalid status message: "' + code + '"');
      return n;
    }
    
  provide("statuses", module.exports);
}(global));

// pakmanager:timed-out
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    module.exports = function (req, time) {
    	if (req.timeoutTimer) { return req; }
    
    	var host = req._headers ? (' to ' + req._headers.host) : '';
    
    	req.timeoutTimer = setTimeout(function timeoutHandler() {
    		req.abort();
    		var e = new Error('Connection timed out on request' + host);
    		e.code = 'ETIMEDOUT';
    		req.emit('error', e);
    	}, time);
    
    	// Set additional timeout on socket - in case if remote
    	// server freeze after sending headers
    	req.setTimeout(time, function socketTimeoutHandler() {
    		req.abort();
    		var e = new Error('Socket timed out on request' + host);
    		e.code = 'ESOCKETTIMEDOUT';
    		req.emit('error', e);
    	});
    
    	function clear() {
    		if (req.timeoutTimer) {
    			clearTimeout(req.timeoutTimer);
    			req.timeoutTimer = null;
    		}
    	}
    
    	return req
    		.on('response', clear)
    		.on('error', clear);
    };
    
  provide("timed-out", module.exports);
}(global));

// pakmanager:rc/lib/utils
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var fs   = require('fs')
    var ini  = require('ini')
    var path = require('path')
    var stripJsonComments = require('strip-json-comments')
    
    var parse = exports.parse = function (content, file) {
    
      //if it ends in .json or starts with { then it must be json.
      //must be done this way, because ini accepts everything.
      //can't just try and parse it and let it throw if it's not ini.
      //everything is ini. even json with a systax error.
    
      if((file && /\.json$/.test(file)) || /^\s*{/.test(content)) 
        return JSON.parse(stripJsonComments(content))
      return ini.parse(content)
    
    }
    
    var file = exports.file = function () {
      var args = [].slice.call(arguments).filter(function (arg) { return arg != null })
    
      //path.join breaks if it's a not a string, so just skip this.
      for(var i in args)
        if('string' !== typeof args[i])
          return
    
      var file = path.join.apply(null, args)
      var content
      try {
        return fs.readFileSync(file,'utf-8')
      } catch (err) {
        return
      }
    }
    
    var json = exports.json = function () {
      var content = file.apply(null, arguments)
      return content ? parse(content) : null
    }
    
    var env = exports.env = function (prefix, env) {
      env = env || process.env
      var obj = {}
      var l = prefix.length
      for(var k in env) {
        if((k.indexOf(prefix)) === 0) {
    
          var keypath = k.substring(l).split('__')
    
          // Trim empty strings from keypath array
          var _emptyStringIndex
          while ((_emptyStringIndex=keypath.indexOf('')) > -1) {
            keypath.splice(_emptyStringIndex, 1)
          }
          
          var cursor = obj
          keypath.forEach(function _buildSubObj(_subkey,i){
    
            // (check for _subkey first so we ignore empty strings)
            if (!_subkey)
              return
    
            // If this is the last key, just stuff the value in there
            // Assigns actual value from env variable to final key
            // (unless it's just an empty string- in that case use the last valid key)
            if (i === keypath.length-1)
              cursor[_subkey] = env[k]
              
    
            // Build sub-object if nothing already exists at the keypath
            if (cursor[_subkey] === undefined)
              cursor[_subkey] = {}
    
            // Increment cursor used to track the object at the current depth
            cursor = cursor[_subkey]
    
          })
    
        }
    
      }
    
      return obj
    }
    
    var find = exports.find = function () {
      var rel = path.join.apply(null, [].slice.call(arguments))
    
      function find(start, rel) {
        var file = path.join(start, rel)
        try {
          fs.statSync(file)
          return file
        } catch (err) {
          if(path.dirname(start) !== start) // root
            return find(path.dirname(start), rel)
        }
      }
      return find(process.cwd(), rel)
    }
    
    
  provide("rc/lib/utils", module.exports);
}(global));

// pakmanager:rc
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  #! /usr/bin/env node
    var cc   =  require('rc/lib/utils')
    var join = require('path').join
    var deepExtend = require('deep-extend')
    var etc = '/etc'
    var win = process.platform === "win32"
    var home = win
               ? process.env.USERPROFILE
               : process.env.HOME
    
    module.exports = function (name, defaults, argv, parse) {
      if('string' !== typeof name)
        throw new Error('rc(name): name *must* be string')
      if(!argv)
        argv = require('minimist')(process.argv.slice(2))
      defaults = (
          'string' === typeof defaults
        ? cc.json(defaults) : defaults
        ) || {}
    
      parse = parse || cc.parse
    
      var env = cc.env(name + '_')
    
      var configs = [defaults]
      var configFiles = []
      function addConfigFile (file) {
        if (configFiles.indexOf(file) >= 0) return
        var fileConfig = cc.file(file)
        if (fileConfig) {
          configs.push(parse(fileConfig))
          configFiles.push(file)
        }
      }
    
      // which files do we look at?
      if (!win)
       [join(etc, name, 'config'),
        join(etc, name + 'rc')].forEach(addConfigFile)
      if (home)
       [join(home, '.config', name, 'config'),
        join(home, '.config', name),
        join(home, '.' + name, 'config'),
        join(home, '.' + name + 'rc')].forEach(addConfigFile)
      addConfigFile(cc.find('.'+name+'rc'))
      if (env.config) addConfigFile(env.config)
      if (argv.config) addConfigFile(argv.config)
    
      return deepExtend.apply(null, configs.concat([
        env,
        argv,
        configFiles.length ? {configs: configFiles, config: configFiles[configFiles.length - 1]} : null,
      ]))
    }
    
    if(!module.parent) {
      console.log(
        JSON.stringify(module.exports(process.argv[2]), false, 2)
      )
    }
    
  provide("rc", module.exports);
}(global));

// pakmanager:traverse
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var traverse = module.exports = function (obj) {
        return new Traverse(obj);
    };
    
    function Traverse (obj) {
        this.value = obj;
    }
    
    Traverse.prototype.get = function (ps) {
        var node = this.value;
        for (var i = 0; i < ps.length; i ++) {
            var key = ps[i];
            if (!node || !hasOwnProperty.call(node, key)) {
                node = undefined;
                break;
            }
            node = node[key];
        }
        return node;
    };
    
    Traverse.prototype.has = function (ps) {
        var node = this.value;
        for (var i = 0; i < ps.length; i ++) {
            var key = ps[i];
            if (!node || !hasOwnProperty.call(node, key)) {
                return false;
            }
            node = node[key];
        }
        return true;
    };
    
    Traverse.prototype.set = function (ps, value) {
        var node = this.value;
        for (var i = 0; i < ps.length - 1; i ++) {
            var key = ps[i];
            if (!hasOwnProperty.call(node, key)) node[key] = {};
            node = node[key];
        }
        node[ps[i]] = value;
        return value;
    };
    
    Traverse.prototype.map = function (cb) {
        return walk(this.value, cb, true);
    };
    
    Traverse.prototype.forEach = function (cb) {
        this.value = walk(this.value, cb, false);
        return this.value;
    };
    
    Traverse.prototype.reduce = function (cb, init) {
        var skip = arguments.length === 1;
        var acc = skip ? this.value : init;
        this.forEach(function (x) {
            if (!this.isRoot || !skip) {
                acc = cb.call(this, acc, x);
            }
        });
        return acc;
    };
    
    Traverse.prototype.paths = function () {
        var acc = [];
        this.forEach(function (x) {
            acc.push(this.path); 
        });
        return acc;
    };
    
    Traverse.prototype.nodes = function () {
        var acc = [];
        this.forEach(function (x) {
            acc.push(this.node);
        });
        return acc;
    };
    
    Traverse.prototype.clone = function () {
        var parents = [], nodes = [];
        
        return (function clone (src) {
            for (var i = 0; i < parents.length; i++) {
                if (parents[i] === src) {
                    return nodes[i];
                }
            }
            
            if (typeof src === 'object' && src !== null) {
                var dst = copy(src);
                
                parents.push(src);
                nodes.push(dst);
                
                forEach(objectKeys(src), function (key) {
                    dst[key] = clone(src[key]);
                });
                
                parents.pop();
                nodes.pop();
                return dst;
            }
            else {
                return src;
            }
        })(this.value);
    };
    
    function walk (root, cb, immutable) {
        var path = [];
        var parents = [];
        var alive = true;
        
        return (function walker (node_) {
            var node = immutable ? copy(node_) : node_;
            var modifiers = {};
            
            var keepGoing = true;
            
            var state = {
                node : node,
                node_ : node_,
                path : [].concat(path),
                parent : parents[parents.length - 1],
                parents : parents,
                key : path.slice(-1)[0],
                isRoot : path.length === 0,
                level : path.length,
                circular : null,
                update : function (x, stopHere) {
                    if (!state.isRoot) {
                        state.parent.node[state.key] = x;
                    }
                    state.node = x;
                    if (stopHere) keepGoing = false;
                },
                'delete' : function (stopHere) {
                    delete state.parent.node[state.key];
                    if (stopHere) keepGoing = false;
                },
                remove : function (stopHere) {
                    if (isArray(state.parent.node)) {
                        state.parent.node.splice(state.key, 1);
                    }
                    else {
                        delete state.parent.node[state.key];
                    }
                    if (stopHere) keepGoing = false;
                },
                keys : null,
                before : function (f) { modifiers.before = f },
                after : function (f) { modifiers.after = f },
                pre : function (f) { modifiers.pre = f },
                post : function (f) { modifiers.post = f },
                stop : function () { alive = false },
                block : function () { keepGoing = false }
            };
            
            if (!alive) return state;
            
            function updateState() {
                if (typeof state.node === 'object' && state.node !== null) {
                    if (!state.keys || state.node_ !== state.node) {
                        state.keys = objectKeys(state.node)
                    }
                    
                    state.isLeaf = state.keys.length == 0;
                    
                    for (var i = 0; i < parents.length; i++) {
                        if (parents[i].node_ === node_) {
                            state.circular = parents[i];
                            break;
                        }
                    }
                }
                else {
                    state.isLeaf = true;
                    state.keys = null;
                }
                
                state.notLeaf = !state.isLeaf;
                state.notRoot = !state.isRoot;
            }
            
            updateState();
            
            // use return values to update if defined
            var ret = cb.call(state, state.node);
            if (ret !== undefined && state.update) state.update(ret);
            
            if (modifiers.before) modifiers.before.call(state, state.node);
            
            if (!keepGoing) return state;
            
            if (typeof state.node == 'object'
            && state.node !== null && !state.circular) {
                parents.push(state);
                
                updateState();
                
                forEach(state.keys, function (key, i) {
                    path.push(key);
                    
                    if (modifiers.pre) modifiers.pre.call(state, state.node[key], key);
                    
                    var child = walker(state.node[key]);
                    if (immutable && hasOwnProperty.call(state.node, key)) {
                        state.node[key] = child.node;
                    }
                    
                    child.isLast = i == state.keys.length - 1;
                    child.isFirst = i == 0;
                    
                    if (modifiers.post) modifiers.post.call(state, child);
                    
                    path.pop();
                });
                parents.pop();
            }
            
            if (modifiers.after) modifiers.after.call(state, state.node);
            
            return state;
        })(root).node;
    }
    
    function copy (src) {
        if (typeof src === 'object' && src !== null) {
            var dst;
            
            if (isArray(src)) {
                dst = [];
            }
            else if (isDate(src)) {
                dst = new Date(src.getTime ? src.getTime() : src);
            }
            else if (isRegExp(src)) {
                dst = new RegExp(src);
            }
            else if (isError(src)) {
                dst = { message: src.message };
            }
            else if (isBoolean(src)) {
                dst = new Boolean(src);
            }
            else if (isNumber(src)) {
                dst = new Number(src);
            }
            else if (isString(src)) {
                dst = new String(src);
            }
            else if (Object.create && Object.getPrototypeOf) {
                dst = Object.create(Object.getPrototypeOf(src));
            }
            else if (src.constructor === Object) {
                dst = {};
            }
            else {
                var proto =
                    (src.constructor && src.constructor.prototype)
                    || src.__proto__
                    || {}
                ;
                var T = function () {};
                T.prototype = proto;
                dst = new T;
            }
            
            forEach(objectKeys(src), function (key) {
                dst[key] = src[key];
            });
            return dst;
        }
        else return src;
    }
    
    var objectKeys = Object.keys || function keys (obj) {
        var res = [];
        for (var key in obj) res.push(key)
        return res;
    };
    
    function toS (obj) { return Object.prototype.toString.call(obj) }
    function isDate (obj) { return toS(obj) === '[object Date]' }
    function isRegExp (obj) { return toS(obj) === '[object RegExp]' }
    function isError (obj) { return toS(obj) === '[object Error]' }
    function isBoolean (obj) { return toS(obj) === '[object Boolean]' }
    function isNumber (obj) { return toS(obj) === '[object Number]' }
    function isString (obj) { return toS(obj) === '[object String]' }
    
    var isArray = Array.isArray || function isArray (xs) {
        return Object.prototype.toString.call(xs) === '[object Array]';
    };
    
    var forEach = function (xs, fn) {
        if (xs.forEach) return xs.forEach(fn)
        else for (var i = 0; i < xs.length; i++) {
            fn(xs[i], i, xs);
        }
    };
    
    forEach(objectKeys(Traverse.prototype), function (key) {
        traverse[key] = function (obj) {
            var args = [].slice.call(arguments, 1);
            var t = new Traverse(obj);
            return t[key].apply(t, args);
        };
    });
    
    var hasOwnProperty = Object.hasOwnProperty || function (obj, key) {
        return key in obj;
    };
    
  provide("traverse", module.exports);
}(global));

// pakmanager:abbrev
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  
    module.exports = exports = abbrev.abbrev = abbrev
    
    abbrev.monkeyPatch = monkeyPatch
    
    function monkeyPatch () {
      Object.defineProperty(Array.prototype, 'abbrev', {
        value: function () { return abbrev(this) },
        enumerable: false, configurable: true, writable: true
      })
    
      Object.defineProperty(Object.prototype, 'abbrev', {
        value: function () { return abbrev(Object.keys(this)) },
        enumerable: false, configurable: true, writable: true
      })
    }
    
    function abbrev (list) {
      if (arguments.length !== 1 || !Array.isArray(list)) {
        list = Array.prototype.slice.call(arguments, 0)
      }
      for (var i = 0, l = list.length, args = [] ; i < l ; i ++) {
        args[i] = typeof list[i] === "string" ? list[i] : String(list[i])
      }
    
      // sort them lexicographically, so that they're next to their nearest kin
      args = args.sort(lexSort)
    
      // walk through each, seeing how much it has in common with the next and previous
      var abbrevs = {}
        , prev = ""
      for (var i = 0, l = args.length ; i < l ; i ++) {
        var current = args[i]
          , next = args[i + 1] || ""
          , nextMatches = true
          , prevMatches = true
        if (current === next) continue
        for (var j = 0, cl = current.length ; j < cl ; j ++) {
          var curChar = current.charAt(j)
          nextMatches = nextMatches && curChar === next.charAt(j)
          prevMatches = prevMatches && curChar === prev.charAt(j)
          if (!nextMatches && !prevMatches) {
            j ++
            break
          }
        }
        prev = current
        if (j === cl) {
          abbrevs[current] = current
          continue
        }
        for (var a = current.substr(0, j) ; j <= cl ; j ++) {
          abbrevs[a] = current
          a += current.charAt(j)
        }
      }
      return abbrevs
    }
    
    function lexSort (a, b) {
      return a === b ? 0 : a > b ? 1 : -1
    }
    
  provide("abbrev", module.exports);
}(global));

// pakmanager:google-p12-pem
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var forge = require('node-forge');
    var fs = require('fs');
    
    /**
     * Convert a .p12 file to .pem string.
     * This is the constructor so it can also be used to
     * create an object that can be reused to get different keys.
     *
     * @param  {string}    filename The .p12 key filename.
     * @param  {Function=} callback The callback function.
     */
    function GoogleP12toPem(filename, callback) {
      if (!(this instanceof GoogleP12toPem)) {
        var gp12 = new GoogleP12toPem();
        return gp12.getPem(filename, callback);
      }
    
      this.pem = null;
    }
    
    /**
     * Convert a .p12 file to .pem string
     * @param  {string}    filename The .p12 key filename.
     * @param  {Function=} callback The callback function.
     * @return {string=}            The .pem private key if no callback provided.
     */
    GoogleP12toPem.prototype.getPem = function(filename, callback) {
      var self = this;
    
      if (typeof callback === 'function') {
        fs.readFile(filename, { encoding: 'base64' }, function(err, keyp12) {
          if (err) {
            callback(err, null);
            return;
          }
          try {
            this.pem = _convertToPem(keyp12);
          } catch (e) {
            callback(e, null);
            return;
          }
          callback(null, this.pem);
        });
      } else {
        var keyp12 = fs.readFileSync(filename, { encoding: 'base64' });
        this.pem = _convertToPem(keyp12);
        return this.pem;
      }
    
      function _convertToPem(p12base64) {
        var p12Der = forge.util.decode64(p12base64);
        var p12Asn1 = forge.asn1.fromDer(p12Der);
        var p12 = forge.pkcs12.pkcs12FromAsn1(p12Asn1, 'notasecret');
        var privateKey = p12.getBagsByFriendlyName('privatekey')[0].key;
        var pem = forge.pki.privateKeyToPem(privateKey);
        return pem.replace(/\r\n/g, '\n');
      }
    };
    
    module.exports = GoogleP12toPem;
    
  provide("google-p12-pem", module.exports);
}(global));

// pakmanager:jws/lib/data-stream
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*global module, process*/
    const Buffer = require('buffer').Buffer;
    const Stream = require('stream');
    const util = require('util');
    
    function DataStream(data) {
      this.buffer = Buffer(data||0);
      this.writable = true;
      this.readable = true;
      if (!data)
        return this;
      if (typeof data.pipe === 'function')
        data.pipe(this);
      else if (data.length) {
        this.writable = false;
        process.nextTick(function () {
          this.buffer = data;
          this.emit('end', data);
          this.readable = false;
          this.emit('close');
        }.bind(this));
      }
    }
    util.inherits(DataStream, Stream);
    
    DataStream.prototype.write = function write(data) {
      this.buffer = Buffer.concat([this.buffer, Buffer(data)]);
      this.emit('data', data);
    };
    
    DataStream.prototype.end = function end(data) {
      if (data)
        this.write(data);
      this.emit('end', data);
      this.emit('close');
      this.writable = false;
      this.readable = false;
    };
    
    module.exports = DataStream;
    
  provide("jws/lib/data-stream", module.exports);
}(global));

// pakmanager:jws/lib/tostring
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*global module*/
    const Buffer = require('buffer').Buffer;
    
    module.exports = function toString(obj) {
      if (typeof obj === 'string')
        return obj;
      if (typeof obj === 'number' || Buffer.isBuffer(obj))
        return obj.toString();
      return JSON.stringify(obj);
    };
    
  provide("jws/lib/tostring", module.exports);
}(global));

// pakmanager:jws/lib/sign-stream
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*global module*/
    const base64url = require('base64url');
    const DataStream =  require('jws/lib/data-stream');
    const jwa = require('jwa');
    const Stream = require('stream');
    const toString =  require('jws/lib/tostring');
    const util = require('util');
    
    function jwsSecuredInput(header, payload, encoding) {
      encoding = encoding || 'utf8';
      const encodedHeader = base64url(toString(header), 'binary');
      const encodedPayload = base64url(toString(payload), encoding);
      return util.format('%s.%s', encodedHeader, encodedPayload);
    }
    
    function jwsSign(opts) {
      const header = opts.header;
      const payload = opts.payload;
      const secretOrKey = opts.secret || opts.privateKey;
      const encoding = opts.encoding;
      const algo = jwa(header.alg);
      const securedInput = jwsSecuredInput(header, payload, encoding);
      const signature = algo.sign(securedInput, secretOrKey);
      return util.format('%s.%s', securedInput, signature);
    }
    
    function SignStream(opts) {
      const secret = opts.secret||opts.privateKey||opts.key;
      const secretStream = new DataStream(secret);
      this.readable = true;
      this.header = opts.header;
      this.encoding = opts.encoding;
      this.secret = this.privateKey = this.key = secretStream;
      this.payload = new DataStream(opts.payload);
      this.secret.once('close', function () {
        if (!this.payload.writable && this.readable)
          this.sign();
      }.bind(this));
    
      this.payload.once('close', function () {
        if (!this.secret.writable && this.readable)
          this.sign();
      }.bind(this));
    }
    util.inherits(SignStream, Stream);
    
    SignStream.prototype.sign = function sign() {
      const signature = jwsSign({
        header: this.header,
        payload: this.payload.buffer,
        secret: this.secret.buffer,
        encoding: this.encoding
      });
      this.emit('done', signature);
      this.emit('data', signature);
      this.emit('end');
      this.readable = false;
      return signature;
    };
    
    SignStream.sign = jwsSign;
    
    module.exports = SignStream;
    
  provide("jws/lib/sign-stream", module.exports);
}(global));

// pakmanager:jws/lib/verify-stream
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*global module*/
    const base64url = require('base64url');
    const DataStream =  require('jws/lib/data-stream');
    const jwa = require('jwa');
    const Stream = require('stream');
    const toString =  require('jws/lib/tostring');
    const util = require('util');
    const JWS_REGEX = /^[a-zA-Z0-9\-_]+?\.[a-zA-Z0-9\-_]+?\.([a-zA-Z0-9\-_]+)?$/;
    
    function isObject(thing) {
      return Object.prototype.toString.call(thing) === '[object Object]';
    }
    
    function safeJsonParse(thing) {
      if (isObject(thing))
        return thing;
      try { return JSON.parse(thing); }
      catch (e) { return undefined; }
    }
    
    function headerFromJWS(jwsSig) {
      const encodedHeader = jwsSig.split('.', 1)[0];
      return safeJsonParse(base64url.decode(encodedHeader, 'binary'));
    }
    
    function securedInputFromJWS(jwsSig) {
      return jwsSig.split('.', 2).join('.');
    }
    
    function signatureFromJWS(jwsSig) {
      return jwsSig.split('.')[2];
    }
    
    function payloadFromJWS(jwsSig, encoding) {
      encoding = encoding || 'utf8';
      const payload = jwsSig.split('.')[1];
      return base64url.decode(payload, encoding);
    }
    
    function isValidJws(string) {
      return JWS_REGEX.test(string) && !!headerFromJWS(string);
    }
    
    function jwsVerify(jwsSig, algorithm, secretOrKey) {
      if (!algorithm) {
        var err = new Error("Missing algorithm parameter for jws.verify");
        err.code = "MISSING_ALGORITHM";
        throw err;
      }
      jwsSig = toString(jwsSig);
      const signature = signatureFromJWS(jwsSig);
      const securedInput = securedInputFromJWS(jwsSig);
      const algo = jwa(algorithm);
      return algo.verify(securedInput, signature, secretOrKey);
    }
    
    function jwsDecode(jwsSig, opts) {
      opts = opts || {};
      jwsSig = toString(jwsSig);
    
      if (!isValidJws(jwsSig))
        return null;
    
      const header = headerFromJWS(jwsSig);
    
      if (!header)
        return null;
    
      var payload = payloadFromJWS(jwsSig);
      if (header.typ === 'JWT' || opts.json)
        payload = JSON.parse(payload, opts.encoding);
    
      return {
        header: header,
        payload: payload,
        signature: signatureFromJWS(jwsSig)
      };
    }
    
    function VerifyStream(opts) {
      opts = opts || {};
      const secretOrKey = opts.secret||opts.publicKey||opts.key;
      const secretStream = new DataStream(secretOrKey);
      this.readable = true;
      this.algorithm = opts.algorithm;
      this.encoding = opts.encoding;
      this.secret = this.publicKey = this.key = secretStream;
      this.signature = new DataStream(opts.signature);
      this.secret.once('close', function () {
        if (!this.signature.writable && this.readable)
          this.verify();
      }.bind(this));
    
      this.signature.once('close', function () {
        if (!this.secret.writable && this.readable)
          this.verify();
      }.bind(this));
    }
    util.inherits(VerifyStream, Stream);
    VerifyStream.prototype.verify = function verify() {
      const valid = jwsVerify(this.signature.buffer, this.algorithm, this.key.buffer);
      const obj = jwsDecode(this.signature.buffer, this.encoding);
      this.emit('done', valid, obj);
      this.emit('data', valid);
      this.emit('end');
      this.readable = false;
      return valid;
    };
    
    VerifyStream.decode = jwsDecode;
    VerifyStream.isValid = isValidJws;
    VerifyStream.verify = jwsVerify;
    
    module.exports = VerifyStream;
    
  provide("jws/lib/verify-stream", module.exports);
}(global));

// pakmanager:jws
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*global exports*/
    const SignStream =  require('jws/lib/sign-stream');
    const VerifyStream =  require('jws/lib/verify-stream');
    
    const ALGORITHMS = [
      'HS256', 'HS384', 'HS512',
      'RS256', 'RS384', 'RS512',
      'ES256', 'ES384', 'ES512'
    ];
    
    exports.ALGORITHMS = ALGORITHMS;
    exports.sign = SignStream.sign;
    exports.verify = VerifyStream.verify;
    exports.decode = VerifyStream.decode;
    exports.isValid = VerifyStream.isValid;
    exports.createSign = function createSign(opts) {
      return new SignStream(opts);
    };
    exports.createVerify = function createVerify(opts) {
      return new VerifyStream(opts);
    };
    
  provide("jws", module.exports);
}(global));

// pakmanager:mime
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var path = require('path');
    var fs = require('fs');
    
    function Mime() {
      // Map of extension -> mime type
      this.types = Object.create(null);
    
      // Map of mime type -> extension
      this.extensions = Object.create(null);
    }
    
    /**
     * Define mimetype -> extension mappings.  Each key is a mime-type that maps
     * to an array of extensions associated with the type.  The first extension is
     * used as the default extension for the type.
     *
     * e.g. mime.define({'audio/ogg', ['oga', 'ogg', 'spx']});
     *
     * @param map (Object) type definitions
     */
    Mime.prototype.define = function (map) {
      for (var type in map) {
        var exts = map[type];
        for (var i = 0; i < exts.length; i++) {
          if (process.env.DEBUG_MIME && this.types[exts]) {
            console.warn(this._loading.replace(/.*\//, ''), 'changes "' + exts[i] + '" extension type from ' +
              this.types[exts] + ' to ' + type);
          }
    
          this.types[exts[i]] = type;
        }
    
        // Default extension is the first one we encounter
        if (!this.extensions[type]) {
          this.extensions[type] = exts[0];
        }
      }
    };
    
    /**
     * Load an Apache2-style ".types" file
     *
     * This may be called multiple times (it's expected).  Where files declare
     * overlapping types/extensions, the last file wins.
     *
     * @param file (String) path of file to load.
     */
    Mime.prototype.load = function(file) {
      this._loading = file;
      // Read file and split into lines
      var map = {},
          content = fs.readFileSync(file, 'ascii'),
          lines = content.split(/[\r\n]+/);
    
      lines.forEach(function(line) {
        // Clean up whitespace/comments, and split into fields
        var fields = line.replace(/\s*#.*|^\s*|\s*$/g, '').split(/\s+/);
        map[fields.shift()] = fields;
      });
    
      this.define(map);
    
      this._loading = null;
    };
    
    /**
     * Lookup a mime type based on extension
     */
    Mime.prototype.lookup = function(path, fallback) {
      var ext = path.replace(/.*[\.\/\\]/, '').toLowerCase();
    
      return this.types[ext] || fallback || this.default_type;
    };
    
    /**
     * Return file extension associated with a mime type
     */
    Mime.prototype.extension = function(mimeType) {
      var type = mimeType.match(/^\s*([^;\s]*)(?:;|\s|$)/)[1].toLowerCase();
      return this.extensions[type];
    };
    
    // Default instance
    var mime = new Mime();
    
    // Define built-in types
    mime.define(require('./types.json'));
    
    // Default type
    mime.default_type = mime.lookup('bin');
    
    //
    // Additional API specific to the default instance
    //
    
    mime.Mime = Mime;
    
    /**
     * Lookup a charset based on mime type.
     */
    mime.charsets = {
      lookup: function(mimeType, fallback) {
        // Assume text types are utf8
        return (/^text\//).test(mimeType) ? 'UTF-8' : fallback;
      }
    };
    
    module.exports = mime;
    
  provide("mime", module.exports);
}(global));

// pakmanager:request/lib/cookies
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict'
    
    var tough = require('tough-cookie')
    
    var Cookie = tough.Cookie
      , CookieJar = tough.CookieJar
    
    
    exports.parse = function(str) {
      if (str && str.uri) {
        str = str.uri
      }
      if (typeof str !== 'string') {
        throw new Error('The cookie function only accepts STRING as param')
      }
      return Cookie.parse(str)
    }
    
    // Adapt the sometimes-Async api of tough.CookieJar to our requirements
    function RequestJar(store) {
      var self = this
      self._jar = new CookieJar(store)
    }
    RequestJar.prototype.setCookie = function(cookieOrStr, uri, options) {
      var self = this
      return self._jar.setCookieSync(cookieOrStr, uri, options || {})
    }
    RequestJar.prototype.getCookieString = function(uri) {
      var self = this
      return self._jar.getCookieStringSync(uri)
    }
    RequestJar.prototype.getCookies = function(uri) {
      var self = this
      return self._jar.getCookiesSync(uri)
    }
    
    exports.jar = function(store) {
      return new RequestJar(store)
    }
    
  provide("request/lib/cookies", module.exports);
}(global));

// pakmanager:request/lib/helpers
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict'
    
    var jsonSafeStringify = require('json-stringify-safe')
      , crypto = require('crypto')
    
    function deferMethod() {
      if (typeof setImmediate === 'undefined') {
        return process.nextTick
      }
    
      return setImmediate
    }
    
    function isFunction(value) {
      return typeof value === 'function'
    }
    
    function paramsHaveRequestBody(params) {
      return (
        params.body ||
        params.requestBodyStream ||
        (params.json && typeof params.json !== 'boolean') ||
        params.multipart
      )
    }
    
    function safeStringify (obj) {
      var ret
      try {
        ret = JSON.stringify(obj)
      } catch (e) {
        ret = jsonSafeStringify(obj)
      }
      return ret
    }
    
    function md5 (str) {
      return crypto.createHash('md5').update(str).digest('hex')
    }
    
    function isReadStream (rs) {
      return rs.readable && rs.path && rs.mode
    }
    
    function toBase64 (str) {
      return (new Buffer(str || '', 'utf8')).toString('base64')
    }
    
    function copy (obj) {
      var o = {}
      Object.keys(obj).forEach(function (i) {
        o[i] = obj[i]
      })
      return o
    }
    
    exports.isFunction            = isFunction
    exports.paramsHaveRequestBody = paramsHaveRequestBody
    exports.safeStringify         = safeStringify
    exports.md5                   = md5
    exports.isReadStream          = isReadStream
    exports.toBase64              = toBase64
    exports.copy                  = copy
    exports.defer                 = deferMethod()
    
  provide("request/lib/helpers", module.exports);
}(global));

// pakmanager:request
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Copyright 2010-2012 Mikeal Rogers
    //
    //    Licensed under the Apache License, Version 2.0 (the "License");
    //    you may not use this file except in compliance with the License.
    //    You may obtain a copy of the License at
    //
    //        http://www.apache.org/licenses/LICENSE-2.0
    //
    //    Unless required by applicable law or agreed to in writing, software
    //    distributed under the License is distributed on an "AS IS" BASIS,
    //    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    //    See the License for the specific language governing permissions and
    //    limitations under the License.
    
    'use strict'
    
    var extend                = require('extend')
      , cookies               =  require('request/lib/cookies')
      , helpers               =  require('request/lib/helpers')
    
    var isFunction            = helpers.isFunction
      , paramsHaveRequestBody = helpers.paramsHaveRequestBody
    
    
    // organize params for patch, post, put, head, del
    function initParams(uri, options, callback) {
      if (typeof options === 'function') {
        callback = options
      }
    
      var params = {}
      if (typeof options === 'object') {
        extend(params, options, {uri: uri})
      } else if (typeof uri === 'string') {
        extend(params, {uri: uri})
      } else {
        extend(params, uri)
      }
    
      params.callback = callback
      return params
    }
    
    function request (uri, options, callback) {
      if (typeof uri === 'undefined') {
        throw new Error('undefined is not a valid uri or options object.')
      }
    
      var params = initParams(uri, options, callback)
    
      if (params.method === 'HEAD' && paramsHaveRequestBody(params)) {
        throw new Error('HTTP HEAD requests MUST NOT include a request body.')
      }
    
      return new request.Request(params)
    }
    
    function verbFunc (verb) {
      var method = verb === 'del' ? 'DELETE' : verb.toUpperCase()
      return function (uri, options, callback) {
        var params = initParams(uri, options, callback)
        params.method = method
        return request(params, params.callback)
      }
    }
    
    // define like this to please codeintel/intellisense IDEs
    request.get = verbFunc('get')
    request.head = verbFunc('head')
    request.post = verbFunc('post')
    request.put = verbFunc('put')
    request.patch = verbFunc('patch')
    request.del = verbFunc('del')
    
    request.jar = function (store) {
      return cookies.jar(store)
    }
    
    request.cookie = function (str) {
      return cookies.parse(str)
    }
    
    function wrapRequestMethod (method, options, requester, verb) {
    
      return function (uri, opts, callback) {
        var params = initParams(uri, opts, callback)
    
        var target = {}
        extend(true, target, options, params)
    
        if (verb) {
          target.method = (verb === 'del' ? 'DELETE' : verb.toUpperCase())
        }
    
        if (isFunction(requester)) {
          method = requester
        }
    
        return method(target, target.callback)
      }
    }
    
    request.defaults = function (options, requester) {
      var self = this
    
      if (typeof options === 'function') {
        requester = options
        options = {}
      }
    
      var defaults      = wrapRequestMethod(self, options, requester)
    
      var verbs = ['get', 'head', 'post', 'put', 'patch', 'del']
      verbs.forEach(function(verb) {
        defaults[verb]  = wrapRequestMethod(self[verb], options, requester, verb)
      })
    
      defaults.cookie   = wrapRequestMethod(self.cookie, options, requester)
      defaults.jar      = self.jar
      defaults.defaults = self.defaults
      return defaults
    }
    
    request.forever = function (agentOptions, optionsArg) {
      var options = {}
      if (optionsArg) {
        extend(options, optionsArg)
      }
      if (agentOptions) {
        options.agentOptions = agentOptions
      }
    
      options.forever = true
      return request.defaults(options)
    }
    
    // Exports
    
    module.exports = request
    request.Request =   require('request')
    request.initParams = initParams
    
    // Backwards compatibility for request.debug
    Object.defineProperty(request, 'debug', {
      enumerable : true,
      get : function() {
        return request.Request.debug
      },
      set : function(debug) {
        request.Request.debug = debug
      }
    })
    
  provide("request", module.exports);
}(global));

// pakmanager:os-homedir
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    var os = require('os');
    
    function homedir() {
    	var env = process.env;
    	var home = env.HOME;
    	var user = env.LOGNAME || env.USER || env.LNAME || env.USERNAME;
    
    	if (process.platform === 'win32') {
    		return env.USERPROFILE || env.HOMEDRIVE + env.HOMEPATH || home || null;
    	}
    
    	if (process.platform === 'darwin') {
    		return home || (user ? '/Users/' + user : null);
    	}
    
    	if (process.platform === 'linux') {
    		return home || (user ? (process.getuid() === 0 ? '/root' : '/home/' + user) : null);
    	}
    
    	return home || null;
    }
    
    module.exports = typeof os.homedir === 'function' ? os.homedir : homedir;
    
  provide("os-homedir", module.exports);
}(global));

// pakmanager:os-tmpdir
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    var isWindows = process.platform === 'win32';
    var trailingSlashRe = isWindows ? /[^:]\\$/ : /.\/$/;
    
    // https://github.com/nodejs/io.js/blob/3e7a14381497a3b73dda68d05b5130563cdab420/lib/os.js#L25-L43
    module.exports = function () {
    	var path;
    
    	if (isWindows) {
    		path = process.env.TEMP ||
    			process.env.TMP ||
    			(process.env.SystemRoot || process.env.windir) + '\\temp';
    	} else {
    		path = process.env.TMPDIR ||
    			process.env.TMP ||
    			process.env.TEMP ||
    			'/tmp';
    	}
    
    	if (trailingSlashRe.test(path)) {
    		path = path.slice(0, -1);
    	}
    
    	return path;
    };
    
  provide("os-tmpdir", module.exports);
}(global));

// pakmanager:got
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    var http = require('http');
    var https = require('https');
    var urlLib = require('url');
    var util = require('util');
    var zlib = require('zlib');
    var querystring = require('querystring');
    var objectAssign = require('object-assign');
    var infinityAgent = require('infinity-agent');
    var duplexify = require('duplexify');
    var isStream = require('is-stream');
    var readAllStream = require('read-all-stream');
    var timedOut = require('timed-out');
    var prependHttp = require('prepend-http');
    var lowercaseKeys = require('lowercase-keys');
    var statuses = require('statuses');
    var isRedirect = require('is-redirect');
    var NestedErrorStacks = require('nested-error-stacks');
    
    function GotError(message, nested) {
    	NestedErrorStacks.call(this, message, nested);
    	objectAssign(this, nested, {nested: this.nested});
    }
    
    util.inherits(GotError, NestedErrorStacks);
    GotError.prototype.name = 'GotError';
    
    function got(url, opts, cb) {
    	if (typeof url !== 'string' && typeof url !== 'object') {
    		throw new GotError('Parameter `url` must be a string or object, not ' + typeof url);
    	}
    
    	if (typeof opts === 'function') {
    		cb = opts;
    		opts = {};
    	}
    
    	opts = objectAssign(
    		{
    			protocol: 'http:'
    		},
    		typeof url === 'string' ? urlLib.parse(prependHttp(url)) : url,
    		opts
    	);
    
    	opts.headers = objectAssign({
    		'user-agent': 'https://github.com/sindresorhus/got',
    		'accept-encoding': 'gzip,deflate'
    	}, lowercaseKeys(opts.headers));
    
    	if (opts.pathname) {
    		opts.path = opts.pathname;
    	}
    
    	if (opts.query) {
    		if (typeof opts.query !== 'string') {
    			opts.query = querystring.stringify(opts.query);
    		}
    
    		opts.path = opts.pathname + '?' + opts.query;
    		delete opts.query;
    	}
    
    	var encoding = opts.encoding;
    	var body = opts.body;
    	var json = opts.json;
    	var timeout = opts.timeout;
    	var proxy;
    	var redirectCount = 0;
    
    	delete opts.encoding;
    	delete opts.body;
    	delete opts.json;
    	delete opts.timeout;
    
    	if (json) {
    		opts.headers.accept = opts.headers.accept || 'application/json';
    	}
    
    	if (body) {
    		if (typeof body !== 'string' && !Buffer.isBuffer(body) && !isStream.readable(body)) {
    			throw new GotError('options.body must be a ReadableStream, string or Buffer');
    		}
    
    		opts.method = opts.method || 'POST';
    
    		if (!opts.headers['content-length'] && !opts.headers['transfer-encoding'] && !isStream.readable(body)) {
    			var length = typeof body === 'string' ? Buffer.byteLength(body) : body.length;
    			opts.headers['content-length'] = length;
    		}
    	}
    
    	opts.method = opts.method || 'GET';
    
    	// returns a proxy stream to the response
    	// if no callback has been provided
    	if (!cb) {
    		proxy = duplexify();
    
    		// forward errors on the stream
    		cb = function (err, data, response) {
    			proxy.emit('error', err, data, response);
    		};
    	}
    
    	if (proxy && json) {
    		throw new GotError('got can not be used as stream when options.json is used');
    	}
    
    	function get(opts, cb) {
    		var fn = opts.protocol === 'https:' ? https : http;
    		var url = urlLib.format(opts);
    
    		if (opts.agent === undefined) {
    			opts.agent = infinityAgent[fn === https ? 'https' : 'http'].globalAgent;
    
    			if (process.version.indexOf('v0.10') === 0 && fn === https && (
    				typeof opts.ca !== 'undefined' ||
    				typeof opts.cert !== 'undefined' ||
    				typeof opts.ciphers !== 'undefined' ||
    				typeof opts.key !== 'undefined' ||
    				typeof opts.passphrase !== 'undefined' ||
    				typeof opts.pfx !== 'undefined' ||
    				typeof opts.rejectUnauthorized !== 'undefined')) {
    				opts.agent = new infinityAgent.https.Agent({
    					ca: opts.ca,
    					cert: opts.cert,
    					ciphers: opts.ciphers,
    					key: opts.key,
    					passphrase: opts.passphrase,
    					pfx: opts.pfx,
    					rejectUnauthorized: opts.rejectUnauthorized
    				});
    			}
    		}
    
    		var req = fn.request(opts, function (response) {
    			var statusCode = response.statusCode;
    			var res = response;
    
    			if (proxy) {
    				proxy.emit('response', res);
    			}
    
    			// auto-redirect only for GET and HEAD methods
    			if (isRedirect(statusCode) && 'location' in res.headers && (opts.method === 'GET' || opts.method === 'HEAD')) {
    				// discard response
    				res.resume();
    
    				if (++redirectCount > 10) {
    					cb(new GotError('Redirected 10 times. Aborting.'), undefined, res);
    					return;
    				}
    
    				var redirectUrl = urlLib.resolve(url, res.headers.location);
    				var redirectOpts = objectAssign(opts, urlLib.parse(redirectUrl));
    
    				if (proxy) {
    					proxy.emit('redirect', res, redirectOpts);
    				}
    
    				get(redirectOpts, cb);
    				return;
    			}
    
    			if (['gzip', 'deflate'].indexOf(res.headers['content-encoding']) !== -1) {
    				res = res.pipe(zlib.createUnzip());
    			}
    
    			if (statusCode < 200 || statusCode > 299) {
    				readAllStream(res, encoding, function (err, data) {
    					err = new GotError(opts.method + ' ' + url + ' response code is ' + statusCode + ' (' + statuses[statusCode] + ')', err);
    					err.code = statusCode;
    
    					if (data && json) {
    						try {
    							data = JSON.parse(data);
    						} catch (e) {
    							err = new GotError('Parsing ' + url + ' response failed', new GotError(e.message, err));
    						}
    					}
    
    					cb(err, data, response);
    				});
    
    				return;
    			}
    
    			// pipe the response to the proxy if in proxy mode
    			if (proxy) {
    				proxy.setReadable(res);
    				return;
    			}
    
    			readAllStream(res, encoding, function (err, data) {
    				if (err) {
    					err = new GotError('Reading ' + url + ' response failed', err);
    				} else if (json) {
    					try {
    						data = JSON.parse(data);
    					} catch (e) {
    						err = new GotError('Parsing ' + url + ' response failed', e);
    					}
    				}
    
    				cb(err, data, response);
    			});
    		}).once('error', function (err) {
    			cb(new GotError('Request to ' + url + ' failed', err));
    		});
    
    		if (timeout) {
    			timedOut(req, timeout);
    		}
    
    		if (!proxy) {
    			if (isStream.readable(body)) {
    				body.pipe(req);
    			} else {
    				req.end(body);
    			}
    
    			return;
    		}
    
    		if (body) {
    			proxy.write = function () {
    				throw new Error('got\'s stream is not writable when options.body is used');
    			};
    
    			if (isStream.readable(body)) {
    				body.pipe(req);
    			} else {
    				req.end(body);
    			}
    
    			return;
    		}
    
    		if (opts.method === 'POST' || opts.method === 'PUT' || opts.method === 'PATCH') {
    			proxy.setWritable(req);
    			return;
    		}
    
    		req.end();
    	}
    
    	get(opts, cb);
    
    	return proxy;
    }
    
    [
    	'get',
    	'post',
    	'put',
    	'patch',
    	'head',
    	'delete'
    ].forEach(function (el) {
    	got[el] = function (url, opts, cb) {
    		if (typeof opts === 'function') {
    			cb = opts;
    			opts = {};
    		}
    
    		return got(url, objectAssign({}, opts, {method: el.toUpperCase()}), cb);
    	};
    });
    
    module.exports = got;
    
  provide("got", module.exports);
}(global));

// pakmanager:registry-url
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    module.exports = function (scope) {
    	var rc = require('rc')('npm', {registry: 'https://registry.npmjs.org/'});
    	return rc[scope + ':registry'] || (rc.registry.slice(-1) !== '/' ? rc.registry + '/' : rc.registry);
    };
    
  provide("registry-url", module.exports);
}(global));

// pakmanager:chainsaw
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var Traverse = require('traverse');
    var EventEmitter = require('events').EventEmitter;
    
    module.exports = Chainsaw;
    function Chainsaw (builder) {
        var saw = Chainsaw.saw(builder, {});
        var r = builder.call(saw.handlers, saw);
        if (r !== undefined) saw.handlers = r;
        saw.record();
        return saw.chain();
    };
    
    Chainsaw.light = function ChainsawLight (builder) {
        var saw = Chainsaw.saw(builder, {});
        var r = builder.call(saw.handlers, saw);
        if (r !== undefined) saw.handlers = r;
        return saw.chain();
    };
    
    Chainsaw.saw = function (builder, handlers) {
        var saw = new EventEmitter;
        saw.handlers = handlers;
        saw.actions = [];
    
        saw.chain = function () {
            var ch = Traverse(saw.handlers).map(function (node) {
                if (this.isRoot) return node;
                var ps = this.path;
    
                if (typeof node === 'function') {
                    this.update(function () {
                        saw.actions.push({
                            path : ps,
                            args : [].slice.call(arguments)
                        });
                        return ch;
                    });
                }
            });
    
            process.nextTick(function () {
                saw.emit('begin');
                saw.next();
            });
    
            return ch;
        };
    
        saw.pop = function () {
            return saw.actions.shift();
        };
    
        saw.next = function () {
            var action = saw.pop();
    
            if (!action) {
                saw.emit('end');
            }
            else if (!action.trap) {
                var node = saw.handlers;
                action.path.forEach(function (key) { node = node[key] });
                node.apply(saw.handlers, action.args);
            }
        };
    
        saw.nest = function (cb) {
            var args = [].slice.call(arguments, 1);
            var autonext = true;
    
            if (typeof cb === 'boolean') {
                var autonext = cb;
                cb = args.shift();
            }
    
            var s = Chainsaw.saw(builder, {});
            var r = builder.call(s.handlers, s);
    
            if (r !== undefined) s.handlers = r;
    
            // If we are recording...
            if ("undefined" !== typeof saw.step) {
                // ... our children should, too
                s.record();
            }
    
            cb.apply(s.chain(), args);
            if (autonext !== false) s.on('end', saw.next);
        };
    
        saw.record = function () {
            upgradeChainsaw(saw);
        };
    
        ['trap', 'down', 'jump'].forEach(function (method) {
            saw[method] = function () {
                throw new Error("To use the trap, down and jump features, please "+
                                "call record() first to start recording actions.");
            };
        });
    
        return saw;
    };
    
    function upgradeChainsaw(saw) {
        saw.step = 0;
    
        // override pop
        saw.pop = function () {
            return saw.actions[saw.step++];
        };
    
        saw.trap = function (name, cb) {
            var ps = Array.isArray(name) ? name : [name];
            saw.actions.push({
                path : ps,
                step : saw.step,
                cb : cb,
                trap : true
            });
        };
    
        saw.down = function (name) {
            var ps = (Array.isArray(name) ? name : [name]).join('/');
            var i = saw.actions.slice(saw.step).map(function (x) {
                if (x.trap && x.step <= saw.step) return false;
                return x.path.join('/') == ps;
            }).indexOf(true);
    
            if (i >= 0) saw.step += i;
            else saw.step = saw.actions.length;
    
            var act = saw.actions[saw.step - 1];
            if (act && act.trap) {
                // It's a trap!
                saw.step = act.step;
                act.cb();
            }
            else saw.next();
        };
    
        saw.jump = function (step) {
            saw.step = step;
            saw.next();
        };
    };
    
  provide("chainsaw", module.exports);
}(global));

// pakmanager:buffers
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  module.exports = Buffers;
    
    function Buffers (bufs) {
        if (!(this instanceof Buffers)) return new Buffers(bufs);
        this.buffers = bufs || [];
        this.length = this.buffers.reduce(function (size, buf) {
            return size + buf.length
        }, 0);
    }
    
    Buffers.prototype.push = function () {
        for (var i = 0; i < arguments.length; i++) {
            if (!Buffer.isBuffer(arguments[i])) {
                throw new TypeError('Tried to push a non-buffer');
            }
        }
        
        for (var i = 0; i < arguments.length; i++) {
            var buf = arguments[i];
            this.buffers.push(buf);
            this.length += buf.length;
        }
        return this.length;
    };
    
    Buffers.prototype.unshift = function () {
        for (var i = 0; i < arguments.length; i++) {
            if (!Buffer.isBuffer(arguments[i])) {
                throw new TypeError('Tried to unshift a non-buffer');
            }
        }
        
        for (var i = 0; i < arguments.length; i++) {
            var buf = arguments[i];
            this.buffers.unshift(buf);
            this.length += buf.length;
        }
        return this.length;
    };
    
    Buffers.prototype.copy = function (dst, dStart, start, end) {
        return this.slice(start, end).copy(dst, dStart, 0, end - start);
    };
    
    Buffers.prototype.splice = function (i, howMany) {
        var buffers = this.buffers;
        var index = i >= 0 ? i : this.length - i;
        var reps = [].slice.call(arguments, 2);
        
        if (howMany === undefined) {
            howMany = this.length - index;
        }
        else if (howMany > this.length - index) {
            howMany = this.length - index;
        }
        
        for (var i = 0; i < reps.length; i++) {
            this.length += reps[i].length;
        }
        
        var removed = new Buffers();
        var bytes = 0;
        
        var startBytes = 0;
        for (
            var ii = 0;
            ii < buffers.length && startBytes + buffers[ii].length < index;
            ii ++
        ) { startBytes += buffers[ii].length }
        
        if (index - startBytes > 0) {
            var start = index - startBytes;
            
            if (start + howMany < buffers[ii].length) {
                removed.push(buffers[ii].slice(start, start + howMany));
                
                var orig = buffers[ii];
                //var buf = new Buffer(orig.length - howMany);
                var buf0 = new Buffer(start);
                for (var i = 0; i < start; i++) {
                    buf0[i] = orig[i];
                }
                
                var buf1 = new Buffer(orig.length - start - howMany);
                for (var i = start + howMany; i < orig.length; i++) {
                    buf1[ i - howMany - start ] = orig[i]
                }
                
                if (reps.length > 0) {
                    var reps_ = reps.slice();
                    reps_.unshift(buf0);
                    reps_.push(buf1);
                    buffers.splice.apply(buffers, [ ii, 1 ].concat(reps_));
                    ii += reps_.length;
                    reps = [];
                }
                else {
                    buffers.splice(ii, 1, buf0, buf1);
                    //buffers[ii] = buf;
                    ii += 2;
                }
            }
            else {
                removed.push(buffers[ii].slice(start));
                buffers[ii] = buffers[ii].slice(0, start);
                ii ++;
            }
        }
        
        if (reps.length > 0) {
            buffers.splice.apply(buffers, [ ii, 0 ].concat(reps));
            ii += reps.length;
        }
        
        while (removed.length < howMany) {
            var buf = buffers[ii];
            var len = buf.length;
            var take = Math.min(len, howMany - removed.length);
            
            if (take === len) {
                removed.push(buf);
                buffers.splice(ii, 1);
            }
            else {
                removed.push(buf.slice(0, take));
                buffers[ii] = buffers[ii].slice(take);
            }
        }
        
        this.length -= removed.length;
        
        return removed;
    };
     
    Buffers.prototype.slice = function (i, j) {
        var buffers = this.buffers;
        if (j === undefined) j = this.length;
        if (i === undefined) i = 0;
        
        if (j > this.length) j = this.length;
        
        var startBytes = 0;
        for (
            var si = 0;
            si < buffers.length && startBytes + buffers[si].length <= i;
            si ++
        ) { startBytes += buffers[si].length }
        
        var target = new Buffer(j - i);
        
        var ti = 0;
        for (var ii = si; ti < j - i && ii < buffers.length; ii++) {
            var len = buffers[ii].length;
            
            var start = ti === 0 ? i - startBytes : 0;
            var end = ti + len >= j - i
                ? Math.min(start + (j - i) - ti, len)
                : len
            ;
            
            buffers[ii].copy(target, ti, start, end);
            ti += end - start;
        }
        
        return target;
    };
    
    Buffers.prototype.pos = function (i) {
        if (i < 0 || i >= this.length) throw new Error('oob');
        var l = i, bi = 0, bu = null;
        for (;;) {
            bu = this.buffers[bi];
            if (l < bu.length) {
                return {buf: bi, offset: l};
            } else {
                l -= bu.length;
            }
            bi++;
        }
    };
    
    Buffers.prototype.get = function get (i) {
        var pos = this.pos(i);
    
        return this.buffers[pos.buf].get(pos.offset);
    };
    
    Buffers.prototype.set = function set (i, b) {
        var pos = this.pos(i);
    
        return this.buffers[pos.buf].set(pos.offset, b);
    };
    
    Buffers.prototype.indexOf = function (needle, offset) {
        if ("string" === typeof needle) {
            needle = new Buffer(needle);
        } else if (needle instanceof Buffer) {
            // already a buffer
        } else {
            throw new Error('Invalid type for a search string');
        }
    
        if (!needle.length) {
            return 0;
        }
    
        if (!this.length) {
            return -1;
        }
    
        var i = 0, j = 0, match = 0, mstart, pos = 0;
    
        // start search from a particular point in the virtual buffer
        if (offset) {
            var p = this.pos(offset);
            i = p.buf;
            j = p.offset;
            pos = offset;
        }
    
        // for each character in virtual buffer
        for (;;) {
            while (j >= this.buffers[i].length) {
                j = 0;
                i++;
    
                if (i >= this.buffers.length) {
                    // search string not found
                    return -1;
                }
            }
    
            var char = this.buffers[i][j];
    
            if (char == needle[match]) {
                // keep track where match started
                if (match == 0) {
                    mstart = {
                        i: i,
                        j: j,
                        pos: pos
                    };
                }
                match++;
                if (match == needle.length) {
                    // full match
                    return mstart.pos;
                }
            } else if (match != 0) {
                // a partial match ended, go back to match starting position
                // this will continue the search at the next character
                i = mstart.i;
                j = mstart.j;
                pos = mstart.pos;
                match = 0;
            }
    
            j++;
            pos++;
        }
    };
    
    Buffers.prototype.toBuffer = function() {
        return this.slice();
    }
    
    Buffers.prototype.toString = function(encoding, start, end) {
        return this.slice(start, end).toString(encoding);
    }
    
  provide("buffers", module.exports);
}(global));

// pakmanager:nopt
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // info about each config option.
    
    var debug = process.env.DEBUG_NOPT || process.env.NOPT_DEBUG
      ? function () { console.error.apply(console, arguments) }
      : function () {}
    
    var url = require("url")
      , path = require("path")
      , Stream = require("stream").Stream
      , abbrev = require("abbrev")
    
    module.exports = exports = nopt
    exports.clean = clean
    
    exports.typeDefs =
      { String  : { type: String,  validate: validateString  }
      , Boolean : { type: Boolean, validate: validateBoolean }
      , url     : { type: url,     validate: validateUrl     }
      , Number  : { type: Number,  validate: validateNumber  }
      , path    : { type: path,    validate: validatePath    }
      , Stream  : { type: Stream,  validate: validateStream  }
      , Date    : { type: Date,    validate: validateDate    }
      }
    
    function nopt (types, shorthands, args, slice) {
      args = args || process.argv
      types = types || {}
      shorthands = shorthands || {}
      if (typeof slice !== "number") slice = 2
    
      debug(types, shorthands, args, slice)
    
      args = args.slice(slice)
      var data = {}
        , key
        , remain = []
        , cooked = args
        , original = args.slice(0)
    
      parse(args, data, remain, types, shorthands)
      // now data is full
      clean(data, types, exports.typeDefs)
      data.argv = {remain:remain,cooked:cooked,original:original}
      Object.defineProperty(data.argv, 'toString', { value: function () {
        return this.original.map(JSON.stringify).join(" ")
      }, enumerable: false })
      return data
    }
    
    function clean (data, types, typeDefs) {
      typeDefs = typeDefs || exports.typeDefs
      var remove = {}
        , typeDefault = [false, true, null, String, Array]
    
      Object.keys(data).forEach(function (k) {
        if (k === "argv") return
        var val = data[k]
          , isArray = Array.isArray(val)
          , type = types[k]
        if (!isArray) val = [val]
        if (!type) type = typeDefault
        if (type === Array) type = typeDefault.concat(Array)
        if (!Array.isArray(type)) type = [type]
    
        debug("val=%j", val)
        debug("types=", type)
        val = val.map(function (val) {
          // if it's an unknown value, then parse false/true/null/numbers/dates
          if (typeof val === "string") {
            debug("string %j", val)
            val = val.trim()
            if ((val === "null" && ~type.indexOf(null))
                || (val === "true" &&
                   (~type.indexOf(true) || ~type.indexOf(Boolean)))
                || (val === "false" &&
                   (~type.indexOf(false) || ~type.indexOf(Boolean)))) {
              val = JSON.parse(val)
              debug("jsonable %j", val)
            } else if (~type.indexOf(Number) && !isNaN(val)) {
              debug("convert to number", val)
              val = +val
            } else if (~type.indexOf(Date) && !isNaN(Date.parse(val))) {
              debug("convert to date", val)
              val = new Date(val)
            }
          }
    
          if (!types.hasOwnProperty(k)) {
            return val
          }
    
          // allow `--no-blah` to set 'blah' to null if null is allowed
          if (val === false && ~type.indexOf(null) &&
              !(~type.indexOf(false) || ~type.indexOf(Boolean))) {
            val = null
          }
    
          var d = {}
          d[k] = val
          debug("prevalidated val", d, val, types[k])
          if (!validate(d, k, val, types[k], typeDefs)) {
            if (exports.invalidHandler) {
              exports.invalidHandler(k, val, types[k], data)
            } else if (exports.invalidHandler !== false) {
              debug("invalid: "+k+"="+val, types[k])
            }
            return remove
          }
          debug("validated val", d, val, types[k])
          return d[k]
        }).filter(function (val) { return val !== remove })
    
        if (!val.length) delete data[k]
        else if (isArray) {
          debug(isArray, data[k], val)
          data[k] = val
        } else data[k] = val[0]
    
        debug("k=%s val=%j", k, val, data[k])
      })
    }
    
    function validateString (data, k, val) {
      data[k] = String(val)
    }
    
    function validatePath (data, k, val) {
      if (val === true) return false
      if (val === null) return true
    
      val = String(val)
      var homePattern = process.platform === 'win32' ? /^~(\/|\\)/ : /^~\//
      if (val.match(homePattern) && process.env.HOME) {
        val = path.resolve(process.env.HOME, val.substr(2))
      }
      data[k] = path.resolve(String(val))
      return true
    }
    
    function validateNumber (data, k, val) {
      debug("validate Number %j %j %j", k, val, isNaN(val))
      if (isNaN(val)) return false
      data[k] = +val
    }
    
    function validateDate (data, k, val) {
      debug("validate Date %j %j %j", k, val, Date.parse(val))
      var s = Date.parse(val)
      if (isNaN(s)) return false
      data[k] = new Date(val)
    }
    
    function validateBoolean (data, k, val) {
      if (val instanceof Boolean) val = val.valueOf()
      else if (typeof val === "string") {
        if (!isNaN(val)) val = !!(+val)
        else if (val === "null" || val === "false") val = false
        else val = true
      } else val = !!val
      data[k] = val
    }
    
    function validateUrl (data, k, val) {
      val = url.parse(String(val))
      if (!val.host) return false
      data[k] = val.href
    }
    
    function validateStream (data, k, val) {
      if (!(val instanceof Stream)) return false
      data[k] = val
    }
    
    function validate (data, k, val, type, typeDefs) {
      // arrays are lists of types.
      if (Array.isArray(type)) {
        for (var i = 0, l = type.length; i < l; i ++) {
          if (type[i] === Array) continue
          if (validate(data, k, val, type[i], typeDefs)) return true
        }
        delete data[k]
        return false
      }
    
      // an array of anything?
      if (type === Array) return true
    
      // NaN is poisonous.  Means that something is not allowed.
      if (type !== type) {
        debug("Poison NaN", k, val, type)
        delete data[k]
        return false
      }
    
      // explicit list of values
      if (val === type) {
        debug("Explicitly allowed %j", val)
        // if (isArray) (data[k] = data[k] || []).push(val)
        // else data[k] = val
        data[k] = val
        return true
      }
    
      // now go through the list of typeDefs, validate against each one.
      var ok = false
        , types = Object.keys(typeDefs)
      for (var i = 0, l = types.length; i < l; i ++) {
        debug("test type %j %j %j", k, val, types[i])
        var t = typeDefs[types[i]]
        if (t && type === t.type) {
          var d = {}
          ok = false !== t.validate(d, k, val)
          val = d[k]
          if (ok) {
            // if (isArray) (data[k] = data[k] || []).push(val)
            // else data[k] = val
            data[k] = val
            break
          }
        }
      }
      debug("OK? %j (%j %j %j)", ok, k, val, types[i])
    
      if (!ok) delete data[k]
      return ok
    }
    
    function parse (args, data, remain, types, shorthands) {
      debug("parse", args, data, remain)
    
      var key = null
        , abbrevs = abbrev(Object.keys(types))
        , shortAbbr = abbrev(Object.keys(shorthands))
    
      for (var i = 0; i < args.length; i ++) {
        var arg = args[i]
        debug("arg", arg)
    
        if (arg.match(/^-{2,}$/)) {
          // done with keys.
          // the rest are args.
          remain.push.apply(remain, args.slice(i + 1))
          args[i] = "--"
          break
        }
        var hadEq = false
        if (arg.charAt(0) === "-" && arg.length > 1) {
          if (arg.indexOf("=") !== -1) {
            hadEq = true
            var v = arg.split("=")
            arg = v.shift()
            v = v.join("=")
            args.splice.apply(args, [i, 1].concat([arg, v]))
          }
    
          // see if it's a shorthand
          // if so, splice and back up to re-parse it.
          var shRes = resolveShort(arg, shorthands, shortAbbr, abbrevs)
          debug("arg=%j shRes=%j", arg, shRes)
          if (shRes) {
            debug(arg, shRes)
            args.splice.apply(args, [i, 1].concat(shRes))
            if (arg !== shRes[0]) {
              i --
              continue
            }
          }
          arg = arg.replace(/^-+/, "")
          var no = null
          while (arg.toLowerCase().indexOf("no-") === 0) {
            no = !no
            arg = arg.substr(3)
          }
    
          if (abbrevs[arg]) arg = abbrevs[arg]
    
          var isArray = types[arg] === Array ||
            Array.isArray(types[arg]) && types[arg].indexOf(Array) !== -1
    
          // allow unknown things to be arrays if specified multiple times.
          if (!types.hasOwnProperty(arg) && data.hasOwnProperty(arg)) {
            if (!Array.isArray(data[arg]))
              data[arg] = [data[arg]]
            isArray = true
          }
    
          var val
            , la = args[i + 1]
    
          var isBool = typeof no === 'boolean' ||
            types[arg] === Boolean ||
            Array.isArray(types[arg]) && types[arg].indexOf(Boolean) !== -1 ||
            (typeof types[arg] === 'undefined' && !hadEq) ||
            (la === "false" &&
             (types[arg] === null ||
              Array.isArray(types[arg]) && ~types[arg].indexOf(null)))
    
          if (isBool) {
            // just set and move along
            val = !no
            // however, also support --bool true or --bool false
            if (la === "true" || la === "false") {
              val = JSON.parse(la)
              la = null
              if (no) val = !val
              i ++
            }
    
            // also support "foo":[Boolean, "bar"] and "--foo bar"
            if (Array.isArray(types[arg]) && la) {
              if (~types[arg].indexOf(la)) {
                // an explicit type
                val = la
                i ++
              } else if ( la === "null" && ~types[arg].indexOf(null) ) {
                // null allowed
                val = null
                i ++
              } else if ( !la.match(/^-{2,}[^-]/) &&
                          !isNaN(la) &&
                          ~types[arg].indexOf(Number) ) {
                // number
                val = +la
                i ++
              } else if ( !la.match(/^-[^-]/) && ~types[arg].indexOf(String) ) {
                // string
                val = la
                i ++
              }
            }
    
            if (isArray) (data[arg] = data[arg] || []).push(val)
            else data[arg] = val
    
            continue
          }
    
          if (types[arg] === String && la === undefined)
            la = ""
    
          if (la && la.match(/^-{2,}$/)) {
            la = undefined
            i --
          }
    
          val = la === undefined ? true : la
          if (isArray) (data[arg] = data[arg] || []).push(val)
          else data[arg] = val
    
          i ++
          continue
        }
        remain.push(arg)
      }
    }
    
    function resolveShort (arg, shorthands, shortAbbr, abbrevs) {
      // handle single-char shorthands glommed together, like
      // npm ls -glp, but only if there is one dash, and only if
      // all of the chars are single-char shorthands, and it's
      // not a match to some other abbrev.
      arg = arg.replace(/^-+/, '')
    
      // if it's an exact known option, then don't go any further
      if (abbrevs[arg] === arg)
        return null
    
      // if it's an exact known shortopt, same deal
      if (shorthands[arg]) {
        // make it an array, if it's a list of words
        if (shorthands[arg] && !Array.isArray(shorthands[arg]))
          shorthands[arg] = shorthands[arg].split(/\s+/)
    
        return shorthands[arg]
      }
    
      // first check to see if this arg is a set of single-char shorthands
      var singles = shorthands.___singles
      if (!singles) {
        singles = Object.keys(shorthands).filter(function (s) {
          return s.length === 1
        }).reduce(function (l,r) {
          l[r] = true
          return l
        }, {})
        shorthands.___singles = singles
        debug('shorthand singles', singles)
      }
    
      var chrs = arg.split("").filter(function (c) {
        return singles[c]
      })
    
      if (chrs.join("") === arg) return chrs.map(function (c) {
        return shorthands[c]
      }).reduce(function (l, r) {
        return l.concat(r)
      }, [])
    
    
      // if it's an arg abbrev, and not a literal shorthand, then prefer the arg
      if (abbrevs[arg] && !shorthands[arg])
        return null
    
      // if it's an abbr for a shorthand, then use that
      if (shortAbbr[arg])
        arg = shortAbbr[arg]
    
      // make it an array, if it's a list of words
      if (shorthands[arg] && !Array.isArray(shorthands[arg]))
        shorthands[arg] = shorthands[arg].split(/\s+/)
    
      return shorthands[arg]
    }
    
  provide("nopt", module.exports);
}(global));

// pakmanager:gtoken
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var gp12pem = require('google-p12-pem');
    var request = require('request');
    var mime = require('mime');
    var jws = require('jws');
    var fs = require('fs');
    
    var GOOGLE_TOKEN_URL = 'https://accounts.google.com/o/oauth2/token';
    var GOOGLE_REVOKE_TOKEN_URL = 'https://accounts.google.com/o/oauth2/revoke?token=';
    
    /**
     * Create a GoogleToken.
     *
     * @param {object}   options  Configuration object.
     */
    function GoogleToken(options) {
      if (!(this instanceof GoogleToken)) {
        return new GoogleToken(options);
      }
      this._configure(options);
    }
    
    GoogleToken.prototype._mime = mime;
    
    /**
     * Returns whether the token has expired.
     *
     * @return {Boolean} true if the token has expired, false otherwise.
     */
    GoogleToken.prototype.hasExpired = function() {
      var now = (new Date()).getTime();
      if (this.token && this.expires_at) {
        return now >= this.expires_at;
      } else {
        return true;
      }
    };
    
    /**
     * Returns a cached token or retrieves a new one from Google.
     *
     * @param  {Function} callback The callback function.
     */
    GoogleToken.prototype.getToken = function(callback) {
      var self = this;
    
      if (!this.hasExpired()) {
        callback(null, this.token);
      } else {
        if (!this.key && !this.keyFile) {
          callback(new Error('No key or keyFile set.'));
          return;
        } else if (!this.key && this.keyFile) {
          var mimeType = this._mime.lookup(this.keyFile);
          if (mimeType === 'application/x-pkcs12') {
            // detect .p12 file and convert to .pem on the fly
            gp12pem(this.keyFile, handleKey);
          } else if (mimeType === 'application/json') {
            // json file
            fs.readFile(this.keyFile, handleJSONKey);
          } else {
            // assume .pem key otherwise
            fs.readFile(this.keyFile, handleKey);
          }
        } else {
          this._requestToken(callback);
        }
      }
    
      function handleJSONKey(err, key) {
        if (err) {
          callback(err);
          return;
        }
        try {
          var body = JSON.parse(key);
          self.key = body.private_key;
          self.iss = body.client_email;
        } catch (e) {
          callback(e);
          return;
        }
    
        self._requestToken(callback);
      }
    
      function handleKey(err, key) {
        if (err) {
          callback(err);
          return;
        }
        self.key = key;
        self._requestToken(callback);
      }
    };
    
    /**
     * Revoke the token if one is set.
     *
     * @param  {Function} callback The callback function.
     */
    GoogleToken.prototype.revokeToken = function(callback) {
      var self = this;
      if (this.token) {
        this._request(GOOGLE_REVOKE_TOKEN_URL + this.token, function(err, res) {
          if (err) {
            callback(err);
            return;
          }
          self._configure({
            email: self.iss,
            sub: self.sub,
            key: self.key,
            keyFile: self.keyFile,
            scope: self.scope
          });
          callback();
        });
      } else {
        callback(new Error('No token to revoke.'));
      }
    };
    
    /**
     * Configure the GoogleToken for re-use.
     * @param  {object} options Configuration object.
     */
    GoogleToken.prototype._configure = function(options) {
      var self = this;
      options = options || {};
      this.keyFile = options.keyFile;
      this.key = options.key;
      this._request = request;
      this.token = this.expires_at = this.raw_token = null;
      this.iss = options.email || options.iss;
    
      if (options.sub) {
        this.sub = options.sub;
      }
    
      if (typeof options.scope === 'object') {
        this.scope = options.scope.join(' ');
      } else {
        this.scope = options.scope;
      }
    };
    
    /**
     * Request the token from Google.
     *
     * @param  {Function} callback The callback function.
     */
    GoogleToken.prototype._requestToken = function(callback) {
      var self = this;
      var iat = Math.floor(new Date().getTime() / 1000);
      var payload = {
        iss: this.iss,
        scope: this.scope,
        aud: GOOGLE_TOKEN_URL,
        exp: iat + 3600, // 3600 seconds = 1 hour
        iat: iat
      };
    
      if (this.sub) {
        payload.sub = this.sub;
      }
    
      var toSign = {
        header: {
          alg: 'RS256',
          typ: 'JWT'
        },
        payload: payload,
        secret: this.key
      };
    
      this._signJWT(toSign, function(err, signedJWT) {
        if (err) {
          callback(err, null);
          return;
        }
    
        self._request({
          method: 'post',
          url: GOOGLE_TOKEN_URL,
          form: {
            grant_type: 'urn:ietf:params:oauth:grant-type:jwt-bearer',
            assertion: signedJWT
          }
        }, function(err, res, body) {
          try {
            body = JSON.parse(body);
          } catch (e) {
            body = {};
          }
    
          err = err || body.error && new Error(body.error);
    
          if (err) {
            self.token = null;
            self.token_expires = null;
            callback(err, null);
            return;
          }
    
          self.raw_token = body;
          self.token = body.access_token;
          self.expires_at = (iat + body.expires_in) * 1000;
          callback(null, self.token);
        });
      });
    };
    
    /**
     * Sign the JWT object, returning any errors in the callback.
     *
     * @param  {object}   opts     The configuration object.
     * @param  {Function} callback The callback function.
     */
    GoogleToken.prototype._signJWT = function(opts, callback) {
      try {
        var signedJWT = jws.sign(opts);
        callback(null, signedJWT);
      } catch (err) {
        callback(err, null);
      }
    };
    
    module.exports = GoogleToken;
    
  provide("gtoken", module.exports);
}(global));

// pakmanager:lodash.noop
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * lodash 3.0.0 (Custom Build) <https://lodash.com/>
     * Build: `lodash modern modularize exports="npm" -o ./`
     * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
     * Based on Underscore.js 1.7.0 <http://underscorejs.org/LICENSE>
     * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     * Available under MIT license <https://lodash.com/license>
     */
    
    /**
     * A no-operation function.
     *
     * @static
     * @memberOf _
     * @category Utility
     * @example
     *
     * var object = { 'user': 'fred' };
     * _.noop(object) === undefined;
     * // => true
     */
    function noop() {
      // No operation performed.
    }
    
    module.exports = noop;
    
  provide("lodash.noop", module.exports);
}(global));

// pakmanager:string-template
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var nargs = /\{([0-9a-zA-Z]+)\}/g
    var slice = Array.prototype.slice
    
    module.exports = template
    
    function template(string) {
        var args
    
        if (arguments.length === 2 && typeof arguments[1] === "object") {
            args = arguments[1]
        } else {
            args = slice.call(arguments, 1)
        }
    
        if (!args || !args.hasOwnProperty) {
            args = {}
        }
    
        return string.replace(nargs, function replaceArg(match, i, index) {
            var result
    
            if (string[index - 1] === "{" &&
                string[index + match.length] === "}") {
                return i
            } else {
                result = args.hasOwnProperty(i) ? args[i] : null
                if (result === null || result === undefined) {
                    return ""
                }
    
                return result
            }
        })
    }
    
  provide("string-template", module.exports);
}(global));

// pakmanager:query-string
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    exports.extract = function (maybeUrl) {
    	return maybeUrl.split('?')[1] || '';
    };
    
    exports.parse = function (str) {
    	if (typeof str !== 'string') {
    		return {};
    	}
    
    	str = str.trim().replace(/^(\?|#|&)/, '');
    
    	if (!str) {
    		return {};
    	}
    
    	return str.split('&').reduce(function (ret, param) {
    		var parts = param.replace(/\+/g, ' ').split('=');
    		var key = parts[0];
    		var val = parts[1];
    
    		key = decodeURIComponent(key);
    		// missing `=` should be `null`:
    		// http://w3.org/TR/2012/WD-url-20120524/#collect-url-parameters
    		val = val === undefined ? null : decodeURIComponent(val);
    
    		if (!ret.hasOwnProperty(key)) {
    			ret[key] = val;
    		} else if (Array.isArray(ret[key])) {
    			ret[key].push(val);
    		} else {
    			ret[key] = [ret[key], val];
    		}
    
    		return ret;
    	}, {});
    };
    
    exports.stringify = function (obj) {
    	return obj ? Object.keys(obj).sort().map(function (key) {
    		var val = obj[key];
    
    		if (Array.isArray(val)) {
    			return val.sort().map(function (val2) {
    				return encodeURIComponent(key) + '=' + encodeURIComponent(val2);
    			}).join('&');
    		}
    
    		return encodeURIComponent(key) + '=' + encodeURIComponent(val);
    	}).join('&') : '';
    };
    
  provide("query-string", module.exports);
}(global));

// pakmanager:sort-keys
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    module.exports = function (obj, compareFn) {
    	if (typeof obj !== 'object') {
    		throw new TypeError('Expected an object');
    	}
    
    	var ret = {};
    
    	Object.keys(obj).sort(compareFn).forEach(function (el) {
    		ret[el] = obj[el];
    	});
    
    	return ret;
    };
    
  provide("sort-keys", module.exports);
}(global));

// pakmanager:graceful-fs/fs.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict'
    
    var fs = require('fs')
    
    module.exports = clone(fs)
    
    function clone (obj) {
      if (obj === null || typeof obj !== 'object')
        return obj
    
      if (obj instanceof Object)
        var copy = { __proto__: obj.__proto__ }
      else
        var copy = Object.create(null)
    
      Object.getOwnPropertyNames(obj).forEach(function (key) {
        Object.defineProperty(copy, key, Object.getOwnPropertyDescriptor(obj, key))
      })
    
      return copy
    }
    
  provide("graceful-fs/fs.js", module.exports);
}(global));

// pakmanager:graceful-fs/polyfills.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var fs =  require('graceful-fs/fs.js')
    var constants = require('constants')
    
    var origCwd = process.cwd
    var cwd = null
    process.cwd = function() {
      if (!cwd)
        cwd = origCwd.call(process)
      return cwd
    }
    try {
      process.cwd()
    } catch (er) {}
    
    var chdir = process.chdir
    process.chdir = function(d) {
      cwd = null
      chdir.call(process, d)
    }
    
    module.exports = patch
    
    function patch (fs) {
      // (re-)implement some things that are known busted or missing.
    
      // lchmod, broken prior to 0.6.2
      // back-port the fix here.
      if (constants.hasOwnProperty('O_SYMLINK') &&
          process.version.match(/^v0\.6\.[0-2]|^v0\.5\./)) {
        patchLchmod(fs)
      }
    
      // lutimes implementation, or no-op
      if (!fs.lutimes) {
        patchLutimes(fs)
      }
    
      // https://github.com/isaacs/node-graceful-fs/issues/4
      // Chown should not fail on einval or eperm if non-root.
      // It should not fail on enosys ever, as this just indicates
      // that a fs doesn't support the intended operation.
    
      fs.chown = chownFix(fs.chown)
      fs.fchown = chownFix(fs.fchown)
      fs.lchown = chownFix(fs.lchown)
    
      fs.chmod = chownFix(fs.chmod)
      fs.fchmod = chownFix(fs.fchmod)
      fs.lchmod = chownFix(fs.lchmod)
    
      fs.chownSync = chownFixSync(fs.chownSync)
      fs.fchownSync = chownFixSync(fs.fchownSync)
      fs.lchownSync = chownFixSync(fs.lchownSync)
    
      fs.chmodSync = chownFix(fs.chmodSync)
      fs.fchmodSync = chownFix(fs.fchmodSync)
      fs.lchmodSync = chownFix(fs.lchmodSync)
    
      // if lchmod/lchown do not exist, then make them no-ops
      if (!fs.lchmod) {
        fs.lchmod = function (path, mode, cb) {
          process.nextTick(cb)
        }
        fs.lchmodSync = function () {}
      }
      if (!fs.lchown) {
        fs.lchown = function (path, uid, gid, cb) {
          process.nextTick(cb)
        }
        fs.lchownSync = function () {}
      }
    
      // on Windows, A/V software can lock the directory, causing this
      // to fail with an EACCES or EPERM if the directory contains newly
      // created files.  Try again on failure, for up to 1 second.
      if (process.platform === "win32") {
        fs.rename = (function (fs$rename) { return function (from, to, cb) {
          var start = Date.now()
          fs$rename(from, to, function CB (er) {
            if (er
                && (er.code === "EACCES" || er.code === "EPERM")
                && Date.now() - start < 1000) {
              return fs$rename(from, to, CB)
            }
            if (cb) cb(er)
          })
        }})(fs.rename)
      }
    
      // if read() returns EAGAIN, then just try it again.
      fs.read = (function (fs$read) { return function (fd, buffer, offset, length, position, callback_) {
        var callback
        if (callback_ && typeof callback_ === 'function') {
          var eagCounter = 0
          callback = function (er, _, __) {
            if (er && er.code === 'EAGAIN' && eagCounter < 10) {
              eagCounter ++
              return fs$read.call(fs, fd, buffer, offset, length, position, callback)
            }
            callback_.apply(this, arguments)
          }
        }
        return fs$read.call(fs, fd, buffer, offset, length, position, callback)
      }})(fs.read)
    
      fs.readSync = (function (fs$readSync) { return function (fd, buffer, offset, length, position) {
        var eagCounter = 0
        while (true) {
          try {
            return fs$readSync.call(fs, fd, buffer, offset, length, position)
          } catch (er) {
            if (er.code === 'EAGAIN' && eagCounter < 10) {
              eagCounter ++
              continue
            }
            throw er
          }
        }
      }})(fs.readSync)
    }
    
    function patchLchmod (fs) {
      fs.lchmod = function (path, mode, callback) {
        callback = callback || noop
        fs.open( path
               , constants.O_WRONLY | constants.O_SYMLINK
               , mode
               , function (err, fd) {
          if (err) {
            callback(err)
            return
          }
          // prefer to return the chmod error, if one occurs,
          // but still try to close, and report closing errors if they occur.
          fs.fchmod(fd, mode, function (err) {
            fs.close(fd, function(err2) {
              callback(err || err2)
            })
          })
        })
      }
    
      fs.lchmodSync = function (path, mode) {
        var fd = fs.openSync(path, constants.O_WRONLY | constants.O_SYMLINK, mode)
    
        // prefer to return the chmod error, if one occurs,
        // but still try to close, and report closing errors if they occur.
        var threw = true
        var ret
        try {
          ret = fs.fchmodSync(fd, mode)
          threw = false
        } finally {
          if (threw) {
            try {
              fs.closeSync(fd)
            } catch (er) {}
          } else {
            fs.closeSync(fd)
          }
        }
        return ret
      }
    }
    
    function patchLutimes (fs) {
      if (constants.hasOwnProperty("O_SYMLINK")) {
        fs.lutimes = function (path, at, mt, cb) {
          fs.open(path, constants.O_SYMLINK, function (er, fd) {
            cb = cb || noop
            if (er) return cb(er)
            fs.futimes(fd, at, mt, function (er) {
              fs.close(fd, function (er2) {
                return cb(er || er2)
              })
            })
          })
        }
    
        fs.lutimesSync = function (path, at, mt) {
          var fd = fs.openSync(path, constants.O_SYMLINK)
          var ret
          var threw = true
          try {
            ret = fs.futimesSync(fd, at, mt)
            threw = false
          } finally {
            if (threw) {
              try {
                fs.closeSync(fd)
              } catch (er) {}
            } else {
              fs.closeSync(fd)
            }
          }
          return ret
        }
    
      } else {
        fs.lutimes = function (_a, _b, _c, cb) { process.nextTick(cb) }
        fs.lutimesSync = function () {}
      }
    }
    
    function chownFix (orig) {
      if (!orig) return orig
      return function (target, uid, gid, cb) {
        return orig.call(fs, target, uid, gid, function (er, res) {
          if (chownErOk(er)) er = null
          cb(er, res)
        })
      }
    }
    
    function chownFixSync (orig) {
      if (!orig) return orig
      return function (target, uid, gid) {
        try {
          return orig.call(fs, target, uid, gid)
        } catch (er) {
          if (!chownErOk(er)) throw er
        }
      }
    }
    
    // ENOSYS means that the fs doesn't support the op. Just ignore
    // that, because it doesn't matter.
    //
    // if there's no getuid, or if getuid() is something other
    // than 0, and the error is EINVAL or EPERM, then just ignore
    // it.
    //
    // This specific case is a silent failure in cp, install, tar,
    // and most other unix tools that manage permissions.
    //
    // When running as root, or if other types of errors are
    // encountered, then it's strict.
    function chownErOk (er) {
      if (!er)
        return true
    
      if (er.code === "ENOSYS")
        return true
    
      var nonroot = !process.getuid || process.getuid() !== 0
      if (nonroot) {
        if (er.code === "EINVAL" || er.code === "EPERM")
          return true
      }
    
      return false
    }
    
  provide("graceful-fs/polyfills.js", module.exports);
}(global));

// pakmanager:graceful-fs/legacy-streams.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var Stream = require('stream').Stream
    
    module.exports = legacy
    
    function legacy (fs) {
      return {
        ReadStream: ReadStream,
        WriteStream: WriteStream
      }
    
      function ReadStream (path, options) {
        if (!(this instanceof ReadStream)) return new ReadStream(path, options);
    
        Stream.call(this);
    
        var self = this;
    
        this.path = path;
        this.fd = null;
        this.readable = true;
        this.paused = false;
    
        this.flags = 'r';
        this.mode = 438; /*=0666*/
        this.bufferSize = 64 * 1024;
    
        options = options || {};
    
        // Mixin options into this
        var keys = Object.keys(options);
        for (var index = 0, length = keys.length; index < length; index++) {
          var key = keys[index];
          this[key] = options[key];
        }
    
        if (this.encoding) this.setEncoding(this.encoding);
    
        if (this.start !== undefined) {
          if ('number' !== typeof this.start) {
            throw TypeError('start must be a Number');
          }
          if (this.end === undefined) {
            this.end = Infinity;
          } else if ('number' !== typeof this.end) {
            throw TypeError('end must be a Number');
          }
    
          if (this.start > this.end) {
            throw new Error('start must be <= end');
          }
    
          this.pos = this.start;
        }
    
        if (this.fd !== null) {
          process.nextTick(function() {
            self._read();
          });
          return;
        }
    
        fs.open(this.path, this.flags, this.mode, function (err, fd) {
          if (err) {
            self.emit('error', err);
            self.readable = false;
            return;
          }
    
          self.fd = fd;
          self.emit('open', fd);
          self._read();
        })
      }
    
      function WriteStream (path, options) {
        if (!(this instanceof WriteStream)) return new WriteStream(path, options);
    
        Stream.call(this);
    
        this.path = path;
        this.fd = null;
        this.writable = true;
    
        this.flags = 'w';
        this.encoding = 'binary';
        this.mode = 438; /*=0666*/
        this.bytesWritten = 0;
    
        options = options || {};
    
        // Mixin options into this
        var keys = Object.keys(options);
        for (var index = 0, length = keys.length; index < length; index++) {
          var key = keys[index];
          this[key] = options[key];
        }
    
        if (this.start !== undefined) {
          if ('number' !== typeof this.start) {
            throw TypeError('start must be a Number');
          }
          if (this.start < 0) {
            throw new Error('start must be >= zero');
          }
    
          this.pos = this.start;
        }
    
        this.busy = false;
        this._queue = [];
    
        if (this.fd === null) {
          this._open = fs.open;
          this._queue.push([this._open, this.path, this.flags, this.mode, undefined]);
          this.flush();
        }
      }
    }
    
  provide("graceful-fs/legacy-streams.js", module.exports);
}(global));

// pakmanager:graceful-fs
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var fs = require('fs')
    var polyfills =  require('graceful-fs/polyfills.js')
    var legacy =  require('graceful-fs/legacy-streams.js')
    var queue = []
    
    var util = require('util')
    
    function noop () {}
    
    var debug = noop
    if (util.debuglog)
      debug = util.debuglog('gfs4')
    else if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || ''))
      debug = function() {
        var m = util.format.apply(util, arguments)
        m = 'GFS4: ' + m.split(/\n/).join('\nGFS4: ')
        console.error(m)
      }
    
    if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || '')) {
      process.on('exit', function() {
        debug(queue)
        require('assert').equal(queue.length, 0)
      })
    }
    
    module.exports = patch( require('graceful-fs/fs.js'))
    if (process.env.TEST_GRACEFUL_FS_GLOBAL_PATCH) {
      module.exports = patch(fs)
    }
    
    // Always patch fs.close/closeSync, because we want to
    // retry() whenever a close happens *anywhere* in the program.
    // This is essential when multiple graceful-fs instances are
    // in play at the same time.
    fs.close = (function (fs$close) { return function (fd, cb) {
      return fs$close.call(fs, fd, function (err) {
        if (!err)
          retry()
    
        if (typeof cb === 'function')
          cb.apply(this, arguments)
      })
    }})(fs.close)
    
    fs.closeSync = (function (fs$closeSync) { return function (fd) {
      // Note that graceful-fs also retries when fs.closeSync() fails.
      // Looks like a bug to me, although it's probably a harmless one.
      var rval = fs$closeSync.apply(fs, arguments)
      retry()
      return rval
    }})(fs.closeSync)
    
    function patch (fs) {
      // Everything that references the open() function needs to be in here
      polyfills(fs)
      fs.gracefulify = patch
      fs.FileReadStream = ReadStream;  // Legacy name.
      fs.FileWriteStream = WriteStream;  // Legacy name.
      fs.createReadStream = createReadStream
      fs.createWriteStream = createWriteStream
      var fs$readFile = fs.readFile
      fs.readFile = readFile
      function readFile (path, options, cb) {
        if (typeof options === 'function')
          cb = options, options = null
    
        return go$readFile(path, options, cb)
    
        function go$readFile (path, options, cb) {
          return fs$readFile(path, options, function (err) {
            if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))
              enqueue([go$readFile, [path, options, cb]])
            else {
              if (typeof cb === 'function')
                cb.apply(this, arguments)
              retry()
            }
          })
        }
      }
    
      var fs$writeFile = fs.writeFile
      fs.writeFile = writeFile
      function writeFile (path, data, options, cb) {
        if (typeof options === 'function')
          cb = options, options = null
    
        return go$writeFile(path, data, options, cb)
    
        function go$writeFile (path, data, options, cb) {
          return fs$writeFile(path, data, options, function (err) {
            if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))
              enqueue([go$writeFile, [path, data, options, cb]])
            else {
              if (typeof cb === 'function')
                cb.apply(this, arguments)
              retry()
            }
          })
        }
      }
    
      var fs$appendFile = fs.appendFile
      if (fs$appendFile)
        fs.appendFile = appendFile
      function appendFile (path, data, options, cb) {
        if (typeof options === 'function')
          cb = options, options = null
    
        return go$appendFile(path, data, options, cb)
    
        function go$appendFile (path, data, options, cb) {
          return fs$appendFile(path, data, options, function (err) {
            if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))
              enqueue([go$appendFile, [path, data, options, cb]])
            else {
              if (typeof cb === 'function')
                cb.apply(this, arguments)
              retry()
            }
          })
        }
      }
    
      var fs$readdir = fs.readdir
      fs.readdir = readdir
      function readdir (path, cb) {
        return go$readdir(path, cb)
    
        function go$readdir () {
          return fs$readdir(path, function (err, files) {
            if (files && files.sort)
              files.sort();  // Backwards compatibility with graceful-fs.
    
            if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))
              enqueue([go$readdir, [path, cb]])
            else {
              if (typeof cb === 'function')
                cb.apply(this, arguments)
              retry()
            }
          })
        }
      }
    
    
      if (process.version.substr(0, 4) === 'v0.8') {
        var legStreams = legacy(fs)
        ReadStream = legStreams.ReadStream
        WriteStream = legStreams.WriteStream
      }
    
      var fs$ReadStream = fs.ReadStream
      ReadStream.prototype = Object.create(fs$ReadStream.prototype)
      ReadStream.prototype.open = ReadStream$open
    
      var fs$WriteStream = fs.WriteStream
      WriteStream.prototype = Object.create(fs$WriteStream.prototype)
      WriteStream.prototype.open = WriteStream$open
    
      fs.ReadStream = ReadStream
      fs.WriteStream = WriteStream
    
      function ReadStream (path, options) {
        if (this instanceof ReadStream)
          return fs$ReadStream.apply(this, arguments), this
        else
          return ReadStream.apply(Object.create(ReadStream.prototype), arguments)
      }
    
      function ReadStream$open () {
        var that = this
        open(that.path, that.flags, that.mode, function (err, fd) {
          if (err) {
            if (that.autoClose)
              that.destroy()
    
            that.emit('error', err)
          } else {
            that.fd = fd
            that.emit('open', fd)
            that.read()
          }
        })
      }
    
      function WriteStream (path, options) {
        if (this instanceof WriteStream)
          return fs$WriteStream.apply(this, arguments), this
        else
          return WriteStream.apply(Object.create(WriteStream.prototype), arguments)
      }
    
      function WriteStream$open () {
        var that = this
        open(that.path, that.flags, that.mode, function (err, fd) {
          if (err) {
            that.destroy()
            that.emit('error', err)
          } else {
            that.fd = fd
            that.emit('open', fd)
          }
        })
      }
    
      function createReadStream (path, options) {
        return new ReadStream(path, options)
      }
    
      function createWriteStream (path, options) {
        return new WriteStream(path, options)
      }
    
      var fs$open = fs.open
      fs.open = open
      function open (path, flags, mode, cb) {
        if (typeof mode === 'function')
          cb = mode, mode = null
    
        return go$open(path, flags, mode, cb)
    
        function go$open (path, flags, mode, cb) {
          return fs$open(path, flags, mode, function (err, fd) {
            if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))
              enqueue([go$open, [path, flags, mode, cb]])
            else {
              if (typeof cb === 'function')
                cb.apply(this, arguments)
              retry()
            }
          })
        }
      }
    
      return fs
    }
    
    function enqueue (elem) {
      debug('ENQUEUE', elem[0].name, elem[1])
      queue.push(elem)
    }
    
    function retry () {
      var elem = queue.shift()
      if (elem) {
        debug('RETRY', elem[0].name, elem[1])
        elem[0].apply(null, elem[1])
      }
    }
    
  provide("graceful-fs", module.exports);
}(global));

// pakmanager:mkdirp
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var path = require('path');
    var fs = require('fs');
    var _0777 = parseInt('0777', 8);
    
    module.exports = mkdirP.mkdirp = mkdirP.mkdirP = mkdirP;
    
    function mkdirP (p, opts, f, made) {
        if (typeof opts === 'function') {
            f = opts;
            opts = {};
        }
        else if (!opts || typeof opts !== 'object') {
            opts = { mode: opts };
        }
        
        var mode = opts.mode;
        var xfs = opts.fs || fs;
        
        if (mode === undefined) {
            mode = _0777 & (~process.umask());
        }
        if (!made) made = null;
        
        var cb = f || function () {};
        p = path.resolve(p);
        
        xfs.mkdir(p, mode, function (er) {
            if (!er) {
                made = made || p;
                return cb(null, made);
            }
            switch (er.code) {
                case 'ENOENT':
                    mkdirP(path.dirname(p), opts, function (er, made) {
                        if (er) cb(er, made);
                        else mkdirP(p, opts, cb, made);
                    });
                    break;
    
                // In the case of any other error, just see if there's a dir
                // there already.  If so, then hooray!  If not, then something
                // is borked.
                default:
                    xfs.stat(p, function (er2, stat) {
                        // if the stat fails, then that's super weird.
                        // let the original error be the failure reason.
                        if (er2 || !stat.isDirectory()) cb(er, made)
                        else cb(null, made);
                    });
                    break;
            }
        });
    }
    
    mkdirP.sync = function sync (p, opts, made) {
        if (!opts || typeof opts !== 'object') {
            opts = { mode: opts };
        }
        
        var mode = opts.mode;
        var xfs = opts.fs || fs;
        
        if (mode === undefined) {
            mode = _0777 & (~process.umask());
        }
        if (!made) made = null;
    
        p = path.resolve(p);
    
        try {
            xfs.mkdirSync(p, mode);
            made = made || p;
        }
        catch (err0) {
            switch (err0.code) {
                case 'ENOENT' :
                    made = sync(path.dirname(p), opts, made);
                    sync(p, opts, made);
                    break;
    
                // In the case of any other error, just see if there's a dir
                // there already.  If so, then hooray!  If not, then something
                // is borked.
                default:
                    var stat;
                    try {
                        stat = xfs.statSync(p);
                    }
                    catch (err1) {
                        throw err0;
                    }
                    if (!stat.isDirectory()) throw err0;
                    break;
            }
        }
    
        return made;
    };
    
  provide("mkdirp", module.exports);
}(global));

// pakmanager:osenv
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var isWindows = process.platform === 'win32'
    var path = require('path')
    var exec = require('child_process').exec
    var osTmpdir = require('os-tmpdir')
    var osHomedir = require('os-homedir')
    
    // looking up envs is a bit costly.
    // Also, sometimes we want to have a fallback
    // Pass in a callback to wait for the fallback on failures
    // After the first lookup, always returns the same thing.
    function memo (key, lookup, fallback) {
      var fell = false
      var falling = false
      exports[key] = function (cb) {
        var val = lookup()
        if (!val && !fell && !falling && fallback) {
          fell = true
          falling = true
          exec(fallback, function (er, output, stderr) {
            falling = false
            if (er) return // oh well, we tried
            val = output.trim()
          })
        }
        exports[key] = function (cb) {
          if (cb) process.nextTick(cb.bind(null, null, val))
          return val
        }
        if (cb && !falling) process.nextTick(cb.bind(null, null, val))
        return val
      }
    }
    
    memo('user', function () {
      return ( isWindows
             ? process.env.USERDOMAIN + '\\' + process.env.USERNAME
             : process.env.USER
             )
    }, 'whoami')
    
    memo('prompt', function () {
      return isWindows ? process.env.PROMPT : process.env.PS1
    })
    
    memo('hostname', function () {
      return isWindows ? process.env.COMPUTERNAME : process.env.HOSTNAME
    }, 'hostname')
    
    memo('tmpdir', function () {
      return osTmpdir()
    })
    
    memo('home', function () {
      return osHomedir()
    })
    
    memo('path', function () {
      return (process.env.PATH ||
              process.env.Path ||
              process.env.path).split(isWindows ? ';' : ':')
    })
    
    memo('editor', function () {
      return process.env.EDITOR ||
             process.env.VISUAL ||
             (isWindows ? 'notepad.exe' : 'vi')
    })
    
    memo('shell', function () {
      return isWindows ? process.env.ComSpec || 'cmd'
             : process.env.SHELL || 'bash'
    })
    
  provide("osenv", module.exports);
}(global));

// pakmanager:user-home
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    module.exports = require('os-homedir')();
    
  provide("user-home", module.exports);
}(global));

// pakmanager:uuid/rng
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var rb = require('crypto').randomBytes;
    module.exports = function() {
      return rb(16);
    };
    
  provide("uuid/rng", module.exports);
}(global));

// pakmanager:uuid
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  //     uuid.js
    //
    //     Copyright (c) 2010-2012 Robert Kieffer
    //     MIT License - http://opensource.org/licenses/mit-license.php
    
    // Unique ID creation requires a high quality random # generator.  We feature
    // detect to determine the best RNG source, normalizing to a function that
    // returns 128-bits of randomness, since that's what's usually required
    var _rng =  require('uuid/rng');
    
    // Maps for number <-> hex string conversion
    var _byteToHex = [];
    var _hexToByte = {};
    for (var i = 0; i < 256; i++) {
      _byteToHex[i] = (i + 0x100).toString(16).substr(1);
      _hexToByte[_byteToHex[i]] = i;
    }
    
    // **`parse()` - Parse a UUID into it's component bytes**
    function parse(s, buf, offset) {
      var i = (buf && offset) || 0, ii = 0;
    
      buf = buf || [];
      s.toLowerCase().replace(/[0-9a-f]{2}/g, function(oct) {
        if (ii < 16) { // Don't overflow!
          buf[i + ii++] = _hexToByte[oct];
        }
      });
    
      // Zero out remaining bytes if string was short
      while (ii < 16) {
        buf[i + ii++] = 0;
      }
    
      return buf;
    }
    
    // **`unparse()` - Convert UUID byte array (ala parse()) into a string**
    function unparse(buf, offset) {
      var i = offset || 0, bth = _byteToHex;
      return  bth[buf[i++]] + bth[buf[i++]] +
              bth[buf[i++]] + bth[buf[i++]] + '-' +
              bth[buf[i++]] + bth[buf[i++]] + '-' +
              bth[buf[i++]] + bth[buf[i++]] + '-' +
              bth[buf[i++]] + bth[buf[i++]] + '-' +
              bth[buf[i++]] + bth[buf[i++]] +
              bth[buf[i++]] + bth[buf[i++]] +
              bth[buf[i++]] + bth[buf[i++]];
    }
    
    // **`v1()` - Generate time-based UUID**
    //
    // Inspired by https://github.com/LiosK/UUID.js
    // and http://docs.python.org/library/uuid.html
    
    // random #'s we need to init node and clockseq
    var _seedBytes = _rng();
    
    // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)
    var _nodeId = [
      _seedBytes[0] | 0x01,
      _seedBytes[1], _seedBytes[2], _seedBytes[3], _seedBytes[4], _seedBytes[5]
    ];
    
    // Per 4.2.2, randomize (14 bit) clockseq
    var _clockseq = (_seedBytes[6] << 8 | _seedBytes[7]) & 0x3fff;
    
    // Previous uuid creation time
    var _lastMSecs = 0, _lastNSecs = 0;
    
    // See https://github.com/broofa/node-uuid for API details
    function v1(options, buf, offset) {
      var i = buf && offset || 0;
      var b = buf || [];
    
      options = options || {};
    
      var clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq;
    
      // UUID timestamps are 100 nano-second units since the Gregorian epoch,
      // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so
      // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'
      // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.
      var msecs = options.msecs !== undefined ? options.msecs : new Date().getTime();
    
      // Per 4.2.1.2, use count of uuid's generated during the current clock
      // cycle to simulate higher resolution clock
      var nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1;
    
      // Time since last uuid creation (in msecs)
      var dt = (msecs - _lastMSecs) + (nsecs - _lastNSecs)/10000;
    
      // Per 4.2.1.2, Bump clockseq on clock regression
      if (dt < 0 && options.clockseq === undefined) {
        clockseq = clockseq + 1 & 0x3fff;
      }
    
      // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new
      // time interval
      if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {
        nsecs = 0;
      }
    
      // Per 4.2.1.2 Throw error if too many uuids are requested
      if (nsecs >= 10000) {
        throw new Error('uuid.v1(): Can\'t create more than 10M uuids/sec');
      }
    
      _lastMSecs = msecs;
      _lastNSecs = nsecs;
      _clockseq = clockseq;
    
      // Per 4.1.4 - Convert from unix epoch to Gregorian epoch
      msecs += 12219292800000;
    
      // `time_low`
      var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;
      b[i++] = tl >>> 24 & 0xff;
      b[i++] = tl >>> 16 & 0xff;
      b[i++] = tl >>> 8 & 0xff;
      b[i++] = tl & 0xff;
    
      // `time_mid`
      var tmh = (msecs / 0x100000000 * 10000) & 0xfffffff;
      b[i++] = tmh >>> 8 & 0xff;
      b[i++] = tmh & 0xff;
    
      // `time_high_and_version`
      b[i++] = tmh >>> 24 & 0xf | 0x10; // include version
      b[i++] = tmh >>> 16 & 0xff;
    
      // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)
      b[i++] = clockseq >>> 8 | 0x80;
    
      // `clock_seq_low`
      b[i++] = clockseq & 0xff;
    
      // `node`
      var node = options.node || _nodeId;
      for (var n = 0; n < 6; n++) {
        b[i + n] = node[n];
      }
    
      return buf ? buf : unparse(b);
    }
    
    // **`v4()` - Generate random UUID**
    
    // See https://github.com/broofa/node-uuid for API details
    function v4(options, buf, offset) {
      // Deprecated - 'format' argument, as supported in v1.2
      var i = buf && offset || 0;
    
      if (typeof(options) == 'string') {
        buf = options == 'binary' ? new Array(16) : null;
        options = null;
      }
      options = options || {};
    
      var rnds = options.random || (options.rng || _rng)();
    
      // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`
      rnds[6] = (rnds[6] & 0x0f) | 0x40;
      rnds[8] = (rnds[8] & 0x3f) | 0x80;
    
      // Copy bytes to buffer, if provided
      if (buf) {
        for (var ii = 0; ii < 16; ii++) {
          buf[i + ii] = rnds[ii];
        }
      }
    
      return buf || unparse(rnds);
    }
    
    // Export public API
    var uuid = v4;
    uuid.v1 = v1;
    uuid.v4 = v4;
    uuid.parse = parse;
    uuid.unparse = unparse;
    
    module.exports = uuid;
    
  provide("uuid", module.exports);
}(global));

// pakmanager:xdg-basedir
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    var path = require('path');
    var osHomedir = require('os-homedir');
    var home = osHomedir();
    var env = process.env;
    
    exports.data = env.XDG_DATA_HOME ||
    	(home ? path.join(home, '.local', 'share') : null);
    
    exports.config = env.XDG_CONFIG_HOME ||
    	(home ? path.join(home, '.config') : null);
    
    exports.cache = env.XDG_CACHE_HOME || (home ? path.join(home, '.cache') : null);
    
    exports.runtime = env.XDG_RUNTIME_DIR || null;
    
    exports.dataDirs = (env.XDG_DATA_DIRS || '/usr/local/share/:/usr/share/').split(':');
    
    if (exports.data) {
    	exports.dataDirs.unshift(exports.data);
    }
    
    exports.configDirs = (env.XDG_CONFIG_DIRS || '/etc/xdg').split(':');
    
    if (exports.config) {
    	exports.configDirs.unshift(exports.config);
    }
    
  provide("xdg-basedir", module.exports);
}(global));

// pakmanager:package-json
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    var got = require('got');
    var registryUrl = require('registry-url');
    
    function get(url, cb) {
    	got(url, {json: true}, function (err, data) {
    		if (err && err.code === 404) {
    			cb(new Error('Package or version doesn\'t exist'));
    			return;
    		}
    
    		if (err) {
    			cb(err);
    			return;
    		}
    
    		cb(null, data);
    	});
    }
    
    module.exports = function (name, version, cb) {
    	var url = registryUrl(name.split('/')[0]) + name + '/';
    
    	if (typeof version !== 'string') {
    		cb = version;
    		version = '';
    	}
    
    	get(url + version, cb);
    };
    
    module.exports.field = function (name, field, cb) {
    	var url = registryUrl(name.split('/')[0]) +
    		'-/by-field/?key=%22' + name + '%22&field=' + field;
    
    	get(url, function (err, res) {
    		if (err) {
    			cb(err);
    			return;
    		}
    
    		if (Object.keys(res).length === 0) {
    			cb(new Error('Field `' + field + '` doesn\'t exist'));
    			return;
    		}
    
    		cb(null, res[name][field]);
    	});
    };
    
  provide("package-json", module.exports);
}(global));

// pakmanager:semver
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // export the class if we are in a Node-like system.
    if (typeof module === 'object' && module.exports === exports)
      exports = module.exports = SemVer;
    
    // The debug function is excluded entirely from the minified version.
    /* nomin */ var debug;
    /* nomin */ if (typeof process === 'object' &&
        /* nomin */ process.env &&
        /* nomin */ process.env.NODE_DEBUG &&
        /* nomin */ /\bsemver\b/i.test(process.env.NODE_DEBUG))
      /* nomin */ debug = function() {
        /* nomin */ var args = Array.prototype.slice.call(arguments, 0);
        /* nomin */ args.unshift('SEMVER');
        /* nomin */ console.log.apply(console, args);
        /* nomin */ };
    /* nomin */ else
      /* nomin */ debug = function() {};
    
    // Note: this is the semver.org version of the spec that it implements
    // Not necessarily the package version of this code.
    exports.SEMVER_SPEC_VERSION = '2.0.0';
    
    var MAX_LENGTH = 256;
    var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;
    
    // The actual regexps go on exports.re
    var re = exports.re = [];
    var src = exports.src = [];
    var R = 0;
    
    // The following Regular Expressions can be used for tokenizing,
    // validating, and parsing SemVer version strings.
    
    // ## Numeric Identifier
    // A single `0`, or a non-zero digit followed by zero or more digits.
    
    var NUMERICIDENTIFIER = R++;
    src[NUMERICIDENTIFIER] = '0|[1-9]\\d*';
    var NUMERICIDENTIFIERLOOSE = R++;
    src[NUMERICIDENTIFIERLOOSE] = '[0-9]+';
    
    
    // ## Non-numeric Identifier
    // Zero or more digits, followed by a letter or hyphen, and then zero or
    // more letters, digits, or hyphens.
    
    var NONNUMERICIDENTIFIER = R++;
    src[NONNUMERICIDENTIFIER] = '\\d*[a-zA-Z-][a-zA-Z0-9-]*';
    
    
    // ## Main Version
    // Three dot-separated numeric identifiers.
    
    var MAINVERSION = R++;
    src[MAINVERSION] = '(' + src[NUMERICIDENTIFIER] + ')\\.' +
                       '(' + src[NUMERICIDENTIFIER] + ')\\.' +
                       '(' + src[NUMERICIDENTIFIER] + ')';
    
    var MAINVERSIONLOOSE = R++;
    src[MAINVERSIONLOOSE] = '(' + src[NUMERICIDENTIFIERLOOSE] + ')\\.' +
                            '(' + src[NUMERICIDENTIFIERLOOSE] + ')\\.' +
                            '(' + src[NUMERICIDENTIFIERLOOSE] + ')';
    
    // ## Pre-release Version Identifier
    // A numeric identifier, or a non-numeric identifier.
    
    var PRERELEASEIDENTIFIER = R++;
    src[PRERELEASEIDENTIFIER] = '(?:' + src[NUMERICIDENTIFIER] +
                                '|' + src[NONNUMERICIDENTIFIER] + ')';
    
    var PRERELEASEIDENTIFIERLOOSE = R++;
    src[PRERELEASEIDENTIFIERLOOSE] = '(?:' + src[NUMERICIDENTIFIERLOOSE] +
                                     '|' + src[NONNUMERICIDENTIFIER] + ')';
    
    
    // ## Pre-release Version
    // Hyphen, followed by one or more dot-separated pre-release version
    // identifiers.
    
    var PRERELEASE = R++;
    src[PRERELEASE] = '(?:-(' + src[PRERELEASEIDENTIFIER] +
                      '(?:\\.' + src[PRERELEASEIDENTIFIER] + ')*))';
    
    var PRERELEASELOOSE = R++;
    src[PRERELEASELOOSE] = '(?:-?(' + src[PRERELEASEIDENTIFIERLOOSE] +
                           '(?:\\.' + src[PRERELEASEIDENTIFIERLOOSE] + ')*))';
    
    // ## Build Metadata Identifier
    // Any combination of digits, letters, or hyphens.
    
    var BUILDIDENTIFIER = R++;
    src[BUILDIDENTIFIER] = '[0-9A-Za-z-]+';
    
    // ## Build Metadata
    // Plus sign, followed by one or more period-separated build metadata
    // identifiers.
    
    var BUILD = R++;
    src[BUILD] = '(?:\\+(' + src[BUILDIDENTIFIER] +
                 '(?:\\.' + src[BUILDIDENTIFIER] + ')*))';
    
    
    // ## Full Version String
    // A main version, followed optionally by a pre-release version and
    // build metadata.
    
    // Note that the only major, minor, patch, and pre-release sections of
    // the version string are capturing groups.  The build metadata is not a
    // capturing group, because it should not ever be used in version
    // comparison.
    
    var FULL = R++;
    var FULLPLAIN = 'v?' + src[MAINVERSION] +
                    src[PRERELEASE] + '?' +
                    src[BUILD] + '?';
    
    src[FULL] = '^' + FULLPLAIN + '$';
    
    // like full, but allows v1.2.3 and =1.2.3, which people do sometimes.
    // also, 1.0.0alpha1 (prerelease without the hyphen) which is pretty
    // common in the npm registry.
    var LOOSEPLAIN = '[v=\\s]*' + src[MAINVERSIONLOOSE] +
                     src[PRERELEASELOOSE] + '?' +
                     src[BUILD] + '?';
    
    var LOOSE = R++;
    src[LOOSE] = '^' + LOOSEPLAIN + '$';
    
    var GTLT = R++;
    src[GTLT] = '((?:<|>)?=?)';
    
    // Something like "2.*" or "1.2.x".
    // Note that "x.x" is a valid xRange identifer, meaning "any version"
    // Only the first item is strictly required.
    var XRANGEIDENTIFIERLOOSE = R++;
    src[XRANGEIDENTIFIERLOOSE] = src[NUMERICIDENTIFIERLOOSE] + '|x|X|\\*';
    var XRANGEIDENTIFIER = R++;
    src[XRANGEIDENTIFIER] = src[NUMERICIDENTIFIER] + '|x|X|\\*';
    
    var XRANGEPLAIN = R++;
    src[XRANGEPLAIN] = '[v=\\s]*(' + src[XRANGEIDENTIFIER] + ')' +
                       '(?:\\.(' + src[XRANGEIDENTIFIER] + ')' +
                       '(?:\\.(' + src[XRANGEIDENTIFIER] + ')' +
                       '(?:' + src[PRERELEASE] + ')?' +
                       src[BUILD] + '?' +
                       ')?)?';
    
    var XRANGEPLAINLOOSE = R++;
    src[XRANGEPLAINLOOSE] = '[v=\\s]*(' + src[XRANGEIDENTIFIERLOOSE] + ')' +
                            '(?:\\.(' + src[XRANGEIDENTIFIERLOOSE] + ')' +
                            '(?:\\.(' + src[XRANGEIDENTIFIERLOOSE] + ')' +
                            '(?:' + src[PRERELEASELOOSE] + ')?' +
                            src[BUILD] + '?' +
                            ')?)?';
    
    var XRANGE = R++;
    src[XRANGE] = '^' + src[GTLT] + '\\s*' + src[XRANGEPLAIN] + '$';
    var XRANGELOOSE = R++;
    src[XRANGELOOSE] = '^' + src[GTLT] + '\\s*' + src[XRANGEPLAINLOOSE] + '$';
    
    // Tilde ranges.
    // Meaning is "reasonably at or greater than"
    var LONETILDE = R++;
    src[LONETILDE] = '(?:~>?)';
    
    var TILDETRIM = R++;
    src[TILDETRIM] = '(\\s*)' + src[LONETILDE] + '\\s+';
    re[TILDETRIM] = new RegExp(src[TILDETRIM], 'g');
    var tildeTrimReplace = '$1~';
    
    var TILDE = R++;
    src[TILDE] = '^' + src[LONETILDE] + src[XRANGEPLAIN] + '$';
    var TILDELOOSE = R++;
    src[TILDELOOSE] = '^' + src[LONETILDE] + src[XRANGEPLAINLOOSE] + '$';
    
    // Caret ranges.
    // Meaning is "at least and backwards compatible with"
    var LONECARET = R++;
    src[LONECARET] = '(?:\\^)';
    
    var CARETTRIM = R++;
    src[CARETTRIM] = '(\\s*)' + src[LONECARET] + '\\s+';
    re[CARETTRIM] = new RegExp(src[CARETTRIM], 'g');
    var caretTrimReplace = '$1^';
    
    var CARET = R++;
    src[CARET] = '^' + src[LONECARET] + src[XRANGEPLAIN] + '$';
    var CARETLOOSE = R++;
    src[CARETLOOSE] = '^' + src[LONECARET] + src[XRANGEPLAINLOOSE] + '$';
    
    // A simple gt/lt/eq thing, or just "" to indicate "any version"
    var COMPARATORLOOSE = R++;
    src[COMPARATORLOOSE] = '^' + src[GTLT] + '\\s*(' + LOOSEPLAIN + ')$|^$';
    var COMPARATOR = R++;
    src[COMPARATOR] = '^' + src[GTLT] + '\\s*(' + FULLPLAIN + ')$|^$';
    
    
    // An expression to strip any whitespace between the gtlt and the thing
    // it modifies, so that `> 1.2.3` ==> `>1.2.3`
    var COMPARATORTRIM = R++;
    src[COMPARATORTRIM] = '(\\s*)' + src[GTLT] +
                          '\\s*(' + LOOSEPLAIN + '|' + src[XRANGEPLAIN] + ')';
    
    // this one has to use the /g flag
    re[COMPARATORTRIM] = new RegExp(src[COMPARATORTRIM], 'g');
    var comparatorTrimReplace = '$1$2$3';
    
    
    // Something like `1.2.3 - 1.2.4`
    // Note that these all use the loose form, because they'll be
    // checked against either the strict or loose comparator form
    // later.
    var HYPHENRANGE = R++;
    src[HYPHENRANGE] = '^\\s*(' + src[XRANGEPLAIN] + ')' +
                       '\\s+-\\s+' +
                       '(' + src[XRANGEPLAIN] + ')' +
                       '\\s*$';
    
    var HYPHENRANGELOOSE = R++;
    src[HYPHENRANGELOOSE] = '^\\s*(' + src[XRANGEPLAINLOOSE] + ')' +
                            '\\s+-\\s+' +
                            '(' + src[XRANGEPLAINLOOSE] + ')' +
                            '\\s*$';
    
    // Star ranges basically just allow anything at all.
    var STAR = R++;
    src[STAR] = '(<|>)?=?\\s*\\*';
    
    // Compile to actual regexp objects.
    // All are flag-free, unless they were created above with a flag.
    for (var i = 0; i < R; i++) {
      debug(i, src[i]);
      if (!re[i])
        re[i] = new RegExp(src[i]);
    }
    
    exports.parse = parse;
    function parse(version, loose) {
      if (version instanceof SemVer)
        return version;
    
      if (typeof version !== 'string')
        return null;
    
      if (version.length > MAX_LENGTH)
        return null;
    
      var r = loose ? re[LOOSE] : re[FULL];
      if (!r.test(version))
        return null;
    
      try {
        return new SemVer(version, loose);
      } catch (er) {
        return null;
      }
    }
    
    exports.valid = valid;
    function valid(version, loose) {
      var v = parse(version, loose);
      return v ? v.version : null;
    }
    
    
    exports.clean = clean;
    function clean(version, loose) {
      var s = parse(version.trim().replace(/^[=v]+/, ''), loose);
      return s ? s.version : null;
    }
    
    exports.SemVer = SemVer;
    
    function SemVer(version, loose) {
      if (version instanceof SemVer) {
        if (version.loose === loose)
          return version;
        else
          version = version.version;
      } else if (typeof version !== 'string') {
        throw new TypeError('Invalid Version: ' + version);
      }
    
      if (version.length > MAX_LENGTH)
        throw new TypeError('version is longer than ' + MAX_LENGTH + ' characters')
    
      if (!(this instanceof SemVer))
        return new SemVer(version, loose);
    
      debug('SemVer', version, loose);
      this.loose = loose;
      var m = version.trim().match(loose ? re[LOOSE] : re[FULL]);
    
      if (!m)
        throw new TypeError('Invalid Version: ' + version);
    
      this.raw = version;
    
      // these are actually numbers
      this.major = +m[1];
      this.minor = +m[2];
      this.patch = +m[3];
    
      if (this.major > MAX_SAFE_INTEGER || this.major < 0)
        throw new TypeError('Invalid major version')
    
      if (this.minor > MAX_SAFE_INTEGER || this.minor < 0)
        throw new TypeError('Invalid minor version')
    
      if (this.patch > MAX_SAFE_INTEGER || this.patch < 0)
        throw new TypeError('Invalid patch version')
    
      // numberify any prerelease numeric ids
      if (!m[4])
        this.prerelease = [];
      else
        this.prerelease = m[4].split('.').map(function(id) {
          if (/^[0-9]+$/.test(id)) {
            var num = +id
            if (num >= 0 && num < MAX_SAFE_INTEGER)
              return num
          }
          return id;
        });
    
      this.build = m[5] ? m[5].split('.') : [];
      this.format();
    }
    
    SemVer.prototype.format = function() {
      this.version = this.major + '.' + this.minor + '.' + this.patch;
      if (this.prerelease.length)
        this.version += '-' + this.prerelease.join('.');
      return this.version;
    };
    
    SemVer.prototype.inspect = function() {
      return '<SemVer "' + this + '">';
    };
    
    SemVer.prototype.toString = function() {
      return this.version;
    };
    
    SemVer.prototype.compare = function(other) {
      debug('SemVer.compare', this.version, this.loose, other);
      if (!(other instanceof SemVer))
        other = new SemVer(other, this.loose);
    
      return this.compareMain(other) || this.comparePre(other);
    };
    
    SemVer.prototype.compareMain = function(other) {
      if (!(other instanceof SemVer))
        other = new SemVer(other, this.loose);
    
      return compareIdentifiers(this.major, other.major) ||
             compareIdentifiers(this.minor, other.minor) ||
             compareIdentifiers(this.patch, other.patch);
    };
    
    SemVer.prototype.comparePre = function(other) {
      if (!(other instanceof SemVer))
        other = new SemVer(other, this.loose);
    
      // NOT having a prerelease is > having one
      if (this.prerelease.length && !other.prerelease.length)
        return -1;
      else if (!this.prerelease.length && other.prerelease.length)
        return 1;
      else if (!this.prerelease.length && !other.prerelease.length)
        return 0;
    
      var i = 0;
      do {
        var a = this.prerelease[i];
        var b = other.prerelease[i];
        debug('prerelease compare', i, a, b);
        if (a === undefined && b === undefined)
          return 0;
        else if (b === undefined)
          return 1;
        else if (a === undefined)
          return -1;
        else if (a === b)
          continue;
        else
          return compareIdentifiers(a, b);
      } while (++i);
    };
    
    // preminor will bump the version up to the next minor release, and immediately
    // down to pre-release. premajor and prepatch work the same way.
    SemVer.prototype.inc = function(release, identifier) {
      switch (release) {
        case 'premajor':
          this.prerelease.length = 0;
          this.patch = 0;
          this.minor = 0;
          this.major++;
          this.inc('pre', identifier);
          break;
        case 'preminor':
          this.prerelease.length = 0;
          this.patch = 0;
          this.minor++;
          this.inc('pre', identifier);
          break;
        case 'prepatch':
          // If this is already a prerelease, it will bump to the next version
          // drop any prereleases that might already exist, since they are not
          // relevant at this point.
          this.prerelease.length = 0;
          this.inc('patch', identifier);
          this.inc('pre', identifier);
          break;
        // If the input is a non-prerelease version, this acts the same as
        // prepatch.
        case 'prerelease':
          if (this.prerelease.length === 0)
            this.inc('patch', identifier);
          this.inc('pre', identifier);
          break;
    
        case 'major':
          // If this is a pre-major version, bump up to the same major version.
          // Otherwise increment major.
          // 1.0.0-5 bumps to 1.0.0
          // 1.1.0 bumps to 2.0.0
          if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0)
            this.major++;
          this.minor = 0;
          this.patch = 0;
          this.prerelease = [];
          break;
        case 'minor':
          // If this is a pre-minor version, bump up to the same minor version.
          // Otherwise increment minor.
          // 1.2.0-5 bumps to 1.2.0
          // 1.2.1 bumps to 1.3.0
          if (this.patch !== 0 || this.prerelease.length === 0)
            this.minor++;
          this.patch = 0;
          this.prerelease = [];
          break;
        case 'patch':
          // If this is not a pre-release version, it will increment the patch.
          // If it is a pre-release it will bump up to the same patch version.
          // 1.2.0-5 patches to 1.2.0
          // 1.2.0 patches to 1.2.1
          if (this.prerelease.length === 0)
            this.patch++;
          this.prerelease = [];
          break;
        // This probably shouldn't be used publicly.
        // 1.0.0 "pre" would become 1.0.0-0 which is the wrong direction.
        case 'pre':
          if (this.prerelease.length === 0)
            this.prerelease = [0];
          else {
            var i = this.prerelease.length;
            while (--i >= 0) {
              if (typeof this.prerelease[i] === 'number') {
                this.prerelease[i]++;
                i = -2;
              }
            }
            if (i === -1) // didn't increment anything
              this.prerelease.push(0);
          }
          if (identifier) {
            // 1.2.0-beta.1 bumps to 1.2.0-beta.2,
            // 1.2.0-beta.fooblz or 1.2.0-beta bumps to 1.2.0-beta.0
            if (this.prerelease[0] === identifier) {
              if (isNaN(this.prerelease[1]))
                this.prerelease = [identifier, 0];
            } else
              this.prerelease = [identifier, 0];
          }
          break;
    
        default:
          throw new Error('invalid increment argument: ' + release);
      }
      this.format();
      return this;
    };
    
    exports.inc = inc;
    function inc(version, release, loose, identifier) {
      if (typeof(loose) === 'string') {
        identifier = loose;
        loose = undefined;
      }
    
      try {
        return new SemVer(version, loose).inc(release, identifier).version;
      } catch (er) {
        return null;
      }
    }
    
    exports.diff = diff;
    function diff(version1, version2) {
      if (eq(version1, version2)) {
        return null;
      } else {
        var v1 = parse(version1);
        var v2 = parse(version2);
        if (v1.prerelease.length || v2.prerelease.length) {
          for (var key in v1) {
            if (key === 'major' || key === 'minor' || key === 'patch') {
              if (v1[key] !== v2[key]) {
                return 'pre'+key;
              }
            }
          }
          return 'prerelease';
        }
        for (var key in v1) {
          if (key === 'major' || key === 'minor' || key === 'patch') {
            if (v1[key] !== v2[key]) {
              return key;
            }
          }
        }
      }
    }
    
    exports.compareIdentifiers = compareIdentifiers;
    
    var numeric = /^[0-9]+$/;
    function compareIdentifiers(a, b) {
      var anum = numeric.test(a);
      var bnum = numeric.test(b);
    
      if (anum && bnum) {
        a = +a;
        b = +b;
      }
    
      return (anum && !bnum) ? -1 :
             (bnum && !anum) ? 1 :
             a < b ? -1 :
             a > b ? 1 :
             0;
    }
    
    exports.rcompareIdentifiers = rcompareIdentifiers;
    function rcompareIdentifiers(a, b) {
      return compareIdentifiers(b, a);
    }
    
    exports.major = major;
    function major(a, loose) {
      return new SemVer(a, loose).major;
    }
    
    exports.minor = minor;
    function minor(a, loose) {
      return new SemVer(a, loose).minor;
    }
    
    exports.patch = patch;
    function patch(a, loose) {
      return new SemVer(a, loose).patch;
    }
    
    exports.compare = compare;
    function compare(a, b, loose) {
      return new SemVer(a, loose).compare(b);
    }
    
    exports.compareLoose = compareLoose;
    function compareLoose(a, b) {
      return compare(a, b, true);
    }
    
    exports.rcompare = rcompare;
    function rcompare(a, b, loose) {
      return compare(b, a, loose);
    }
    
    exports.sort = sort;
    function sort(list, loose) {
      return list.sort(function(a, b) {
        return exports.compare(a, b, loose);
      });
    }
    
    exports.rsort = rsort;
    function rsort(list, loose) {
      return list.sort(function(a, b) {
        return exports.rcompare(a, b, loose);
      });
    }
    
    exports.gt = gt;
    function gt(a, b, loose) {
      return compare(a, b, loose) > 0;
    }
    
    exports.lt = lt;
    function lt(a, b, loose) {
      return compare(a, b, loose) < 0;
    }
    
    exports.eq = eq;
    function eq(a, b, loose) {
      return compare(a, b, loose) === 0;
    }
    
    exports.neq = neq;
    function neq(a, b, loose) {
      return compare(a, b, loose) !== 0;
    }
    
    exports.gte = gte;
    function gte(a, b, loose) {
      return compare(a, b, loose) >= 0;
    }
    
    exports.lte = lte;
    function lte(a, b, loose) {
      return compare(a, b, loose) <= 0;
    }
    
    exports.cmp = cmp;
    function cmp(a, op, b, loose) {
      var ret;
      switch (op) {
        case '===':
          if (typeof a === 'object') a = a.version;
          if (typeof b === 'object') b = b.version;
          ret = a === b;
          break;
        case '!==':
          if (typeof a === 'object') a = a.version;
          if (typeof b === 'object') b = b.version;
          ret = a !== b;
          break;
        case '': case '=': case '==': ret = eq(a, b, loose); break;
        case '!=': ret = neq(a, b, loose); break;
        case '>': ret = gt(a, b, loose); break;
        case '>=': ret = gte(a, b, loose); break;
        case '<': ret = lt(a, b, loose); break;
        case '<=': ret = lte(a, b, loose); break;
        default: throw new TypeError('Invalid operator: ' + op);
      }
      return ret;
    }
    
    exports.Comparator = Comparator;
    function Comparator(comp, loose) {
      if (comp instanceof Comparator) {
        if (comp.loose === loose)
          return comp;
        else
          comp = comp.value;
      }
    
      if (!(this instanceof Comparator))
        return new Comparator(comp, loose);
    
      debug('comparator', comp, loose);
      this.loose = loose;
      this.parse(comp);
    
      if (this.semver === ANY)
        this.value = '';
      else
        this.value = this.operator + this.semver.version;
    
      debug('comp', this);
    }
    
    var ANY = {};
    Comparator.prototype.parse = function(comp) {
      var r = this.loose ? re[COMPARATORLOOSE] : re[COMPARATOR];
      var m = comp.match(r);
    
      if (!m)
        throw new TypeError('Invalid comparator: ' + comp);
    
      this.operator = m[1];
      if (this.operator === '=')
        this.operator = '';
    
      // if it literally is just '>' or '' then allow anything.
      if (!m[2])
        this.semver = ANY;
      else
        this.semver = new SemVer(m[2], this.loose);
    };
    
    Comparator.prototype.inspect = function() {
      return '<SemVer Comparator "' + this + '">';
    };
    
    Comparator.prototype.toString = function() {
      return this.value;
    };
    
    Comparator.prototype.test = function(version) {
      debug('Comparator.test', version, this.loose);
    
      if (this.semver === ANY)
        return true;
    
      if (typeof version === 'string')
        version = new SemVer(version, this.loose);
    
      return cmp(version, this.operator, this.semver, this.loose);
    };
    
    
    exports.Range = Range;
    function Range(range, loose) {
      if ((range instanceof Range) && range.loose === loose)
        return range;
    
      if (!(this instanceof Range))
        return new Range(range, loose);
    
      this.loose = loose;
    
      // First, split based on boolean or ||
      this.raw = range;
      this.set = range.split(/\s*\|\|\s*/).map(function(range) {
        return this.parseRange(range.trim());
      }, this).filter(function(c) {
        // throw out any that are not relevant for whatever reason
        return c.length;
      });
    
      if (!this.set.length) {
        throw new TypeError('Invalid SemVer Range: ' + range);
      }
    
      this.format();
    }
    
    Range.prototype.inspect = function() {
      return '<SemVer Range "' + this.range + '">';
    };
    
    Range.prototype.format = function() {
      this.range = this.set.map(function(comps) {
        return comps.join(' ').trim();
      }).join('||').trim();
      return this.range;
    };
    
    Range.prototype.toString = function() {
      return this.range;
    };
    
    Range.prototype.parseRange = function(range) {
      var loose = this.loose;
      range = range.trim();
      debug('range', range, loose);
      // `1.2.3 - 1.2.4` => `>=1.2.3 <=1.2.4`
      var hr = loose ? re[HYPHENRANGELOOSE] : re[HYPHENRANGE];
      range = range.replace(hr, hyphenReplace);
      debug('hyphen replace', range);
      // `> 1.2.3 < 1.2.5` => `>1.2.3 <1.2.5`
      range = range.replace(re[COMPARATORTRIM], comparatorTrimReplace);
      debug('comparator trim', range, re[COMPARATORTRIM]);
    
      // `~ 1.2.3` => `~1.2.3`
      range = range.replace(re[TILDETRIM], tildeTrimReplace);
    
      // `^ 1.2.3` => `^1.2.3`
      range = range.replace(re[CARETTRIM], caretTrimReplace);
    
      // normalize spaces
      range = range.split(/\s+/).join(' ');
    
      // At this point, the range is completely trimmed and
      // ready to be split into comparators.
    
      var compRe = loose ? re[COMPARATORLOOSE] : re[COMPARATOR];
      var set = range.split(' ').map(function(comp) {
        return parseComparator(comp, loose);
      }).join(' ').split(/\s+/);
      if (this.loose) {
        // in loose mode, throw out any that are not valid comparators
        set = set.filter(function(comp) {
          return !!comp.match(compRe);
        });
      }
      set = set.map(function(comp) {
        return new Comparator(comp, loose);
      });
    
      return set;
    };
    
    // Mostly just for testing and legacy API reasons
    exports.toComparators = toComparators;
    function toComparators(range, loose) {
      return new Range(range, loose).set.map(function(comp) {
        return comp.map(function(c) {
          return c.value;
        }).join(' ').trim().split(' ');
      });
    }
    
    // comprised of xranges, tildes, stars, and gtlt's at this point.
    // already replaced the hyphen ranges
    // turn into a set of JUST comparators.
    function parseComparator(comp, loose) {
      debug('comp', comp);
      comp = replaceCarets(comp, loose);
      debug('caret', comp);
      comp = replaceTildes(comp, loose);
      debug('tildes', comp);
      comp = replaceXRanges(comp, loose);
      debug('xrange', comp);
      comp = replaceStars(comp, loose);
      debug('stars', comp);
      return comp;
    }
    
    function isX(id) {
      return !id || id.toLowerCase() === 'x' || id === '*';
    }
    
    // ~, ~> --> * (any, kinda silly)
    // ~2, ~2.x, ~2.x.x, ~>2, ~>2.x ~>2.x.x --> >=2.0.0 <3.0.0
    // ~2.0, ~2.0.x, ~>2.0, ~>2.0.x --> >=2.0.0 <2.1.0
    // ~1.2, ~1.2.x, ~>1.2, ~>1.2.x --> >=1.2.0 <1.3.0
    // ~1.2.3, ~>1.2.3 --> >=1.2.3 <1.3.0
    // ~1.2.0, ~>1.2.0 --> >=1.2.0 <1.3.0
    function replaceTildes(comp, loose) {
      return comp.trim().split(/\s+/).map(function(comp) {
        return replaceTilde(comp, loose);
      }).join(' ');
    }
    
    function replaceTilde(comp, loose) {
      var r = loose ? re[TILDELOOSE] : re[TILDE];
      return comp.replace(r, function(_, M, m, p, pr) {
        debug('tilde', comp, _, M, m, p, pr);
        var ret;
    
        if (isX(M))
          ret = '';
        else if (isX(m))
          ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0';
        else if (isX(p))
          // ~1.2 == >=1.2.0- <1.3.0-
          ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0';
        else if (pr) {
          debug('replaceTilde pr', pr);
          if (pr.charAt(0) !== '-')
            pr = '-' + pr;
          ret = '>=' + M + '.' + m + '.' + p + pr +
                ' <' + M + '.' + (+m + 1) + '.0';
        } else
          // ~1.2.3 == >=1.2.3 <1.3.0
          ret = '>=' + M + '.' + m + '.' + p +
                ' <' + M + '.' + (+m + 1) + '.0';
    
        debug('tilde return', ret);
        return ret;
      });
    }
    
    // ^ --> * (any, kinda silly)
    // ^2, ^2.x, ^2.x.x --> >=2.0.0 <3.0.0
    // ^2.0, ^2.0.x --> >=2.0.0 <3.0.0
    // ^1.2, ^1.2.x --> >=1.2.0 <2.0.0
    // ^1.2.3 --> >=1.2.3 <2.0.0
    // ^1.2.0 --> >=1.2.0 <2.0.0
    function replaceCarets(comp, loose) {
      return comp.trim().split(/\s+/).map(function(comp) {
        return replaceCaret(comp, loose);
      }).join(' ');
    }
    
    function replaceCaret(comp, loose) {
      debug('caret', comp, loose);
      var r = loose ? re[CARETLOOSE] : re[CARET];
      return comp.replace(r, function(_, M, m, p, pr) {
        debug('caret', comp, _, M, m, p, pr);
        var ret;
    
        if (isX(M))
          ret = '';
        else if (isX(m))
          ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0';
        else if (isX(p)) {
          if (M === '0')
            ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0';
          else
            ret = '>=' + M + '.' + m + '.0 <' + (+M + 1) + '.0.0';
        } else if (pr) {
          debug('replaceCaret pr', pr);
          if (pr.charAt(0) !== '-')
            pr = '-' + pr;
          if (M === '0') {
            if (m === '0')
              ret = '>=' + M + '.' + m + '.' + p + pr +
                    ' <' + M + '.' + m + '.' + (+p + 1);
            else
              ret = '>=' + M + '.' + m + '.' + p + pr +
                    ' <' + M + '.' + (+m + 1) + '.0';
          } else
            ret = '>=' + M + '.' + m + '.' + p + pr +
                  ' <' + (+M + 1) + '.0.0';
        } else {
          debug('no pr');
          if (M === '0') {
            if (m === '0')
              ret = '>=' + M + '.' + m + '.' + p +
                    ' <' + M + '.' + m + '.' + (+p + 1);
            else
              ret = '>=' + M + '.' + m + '.' + p +
                    ' <' + M + '.' + (+m + 1) + '.0';
          } else
            ret = '>=' + M + '.' + m + '.' + p +
                  ' <' + (+M + 1) + '.0.0';
        }
    
        debug('caret return', ret);
        return ret;
      });
    }
    
    function replaceXRanges(comp, loose) {
      debug('replaceXRanges', comp, loose);
      return comp.split(/\s+/).map(function(comp) {
        return replaceXRange(comp, loose);
      }).join(' ');
    }
    
    function replaceXRange(comp, loose) {
      comp = comp.trim();
      var r = loose ? re[XRANGELOOSE] : re[XRANGE];
      return comp.replace(r, function(ret, gtlt, M, m, p, pr) {
        debug('xRange', comp, ret, gtlt, M, m, p, pr);
        var xM = isX(M);
        var xm = xM || isX(m);
        var xp = xm || isX(p);
        var anyX = xp;
    
        if (gtlt === '=' && anyX)
          gtlt = '';
    
        if (xM) {
          if (gtlt === '>' || gtlt === '<') {
            // nothing is allowed
            ret = '<0.0.0';
          } else {
            // nothing is forbidden
            ret = '*';
          }
        } else if (gtlt && anyX) {
          // replace X with 0
          if (xm)
            m = 0;
          if (xp)
            p = 0;
    
          if (gtlt === '>') {
            // >1 => >=2.0.0
            // >1.2 => >=1.3.0
            // >1.2.3 => >= 1.2.4
            gtlt = '>=';
            if (xm) {
              M = +M + 1;
              m = 0;
              p = 0;
            } else if (xp) {
              m = +m + 1;
              p = 0;
            }
          } else if (gtlt === '<=') {
            // <=0.7.x is actually <0.8.0, since any 0.7.x should
            // pass.  Similarly, <=7.x is actually <8.0.0, etc.
            gtlt = '<'
            if (xm)
              M = +M + 1
            else
              m = +m + 1
          }
    
          ret = gtlt + M + '.' + m + '.' + p;
        } else if (xm) {
          ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0';
        } else if (xp) {
          ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0';
        }
    
        debug('xRange return', ret);
    
        return ret;
      });
    }
    
    // Because * is AND-ed with everything else in the comparator,
    // and '' means "any version", just remove the *s entirely.
    function replaceStars(comp, loose) {
      debug('replaceStars', comp, loose);
      // Looseness is ignored here.  star is always as loose as it gets!
      return comp.trim().replace(re[STAR], '');
    }
    
    // This function is passed to string.replace(re[HYPHENRANGE])
    // M, m, patch, prerelease, build
    // 1.2 - 3.4.5 => >=1.2.0 <=3.4.5
    // 1.2.3 - 3.4 => >=1.2.0 <3.5.0 Any 3.4.x will do
    // 1.2 - 3.4 => >=1.2.0 <3.5.0
    function hyphenReplace($0,
                           from, fM, fm, fp, fpr, fb,
                           to, tM, tm, tp, tpr, tb) {
    
      if (isX(fM))
        from = '';
      else if (isX(fm))
        from = '>=' + fM + '.0.0';
      else if (isX(fp))
        from = '>=' + fM + '.' + fm + '.0';
      else
        from = '>=' + from;
    
      if (isX(tM))
        to = '';
      else if (isX(tm))
        to = '<' + (+tM + 1) + '.0.0';
      else if (isX(tp))
        to = '<' + tM + '.' + (+tm + 1) + '.0';
      else if (tpr)
        to = '<=' + tM + '.' + tm + '.' + tp + '-' + tpr;
      else
        to = '<=' + to;
    
      return (from + ' ' + to).trim();
    }
    
    
    // if ANY of the sets match ALL of its comparators, then pass
    Range.prototype.test = function(version) {
      if (!version)
        return false;
    
      if (typeof version === 'string')
        version = new SemVer(version, this.loose);
    
      for (var i = 0; i < this.set.length; i++) {
        if (testSet(this.set[i], version))
          return true;
      }
      return false;
    };
    
    function testSet(set, version) {
      for (var i = 0; i < set.length; i++) {
        if (!set[i].test(version))
          return false;
      }
    
      if (version.prerelease.length) {
        // Find the set of versions that are allowed to have prereleases
        // For example, ^1.2.3-pr.1 desugars to >=1.2.3-pr.1 <2.0.0
        // That should allow `1.2.3-pr.2` to pass.
        // However, `1.2.4-alpha.notready` should NOT be allowed,
        // even though it's within the range set by the comparators.
        for (var i = 0; i < set.length; i++) {
          debug(set[i].semver);
          if (set[i].semver === ANY)
            continue;
    
          if (set[i].semver.prerelease.length > 0) {
            var allowed = set[i].semver;
            if (allowed.major === version.major &&
                allowed.minor === version.minor &&
                allowed.patch === version.patch)
              return true;
          }
        }
    
        // Version has a -pre, but it's not one of the ones we like.
        return false;
      }
    
      return true;
    }
    
    exports.satisfies = satisfies;
    function satisfies(version, range, loose) {
      try {
        range = new Range(range, loose);
      } catch (er) {
        return false;
      }
      return range.test(version);
    }
    
    exports.maxSatisfying = maxSatisfying;
    function maxSatisfying(versions, range, loose) {
      return versions.filter(function(version) {
        return satisfies(version, range, loose);
      }).sort(function(a, b) {
        return rcompare(a, b, loose);
      })[0] || null;
    }
    
    exports.validRange = validRange;
    function validRange(range, loose) {
      try {
        // Return '*' instead of '' so that truthiness works.
        // This will throw if it's invalid anyway
        return new Range(range, loose).range || '*';
      } catch (er) {
        return null;
      }
    }
    
    // Determine if version is less than all the versions possible in the range
    exports.ltr = ltr;
    function ltr(version, range, loose) {
      return outside(version, range, '<', loose);
    }
    
    // Determine if version is greater than all the versions possible in the range.
    exports.gtr = gtr;
    function gtr(version, range, loose) {
      return outside(version, range, '>', loose);
    }
    
    exports.outside = outside;
    function outside(version, range, hilo, loose) {
      version = new SemVer(version, loose);
      range = new Range(range, loose);
    
      var gtfn, ltefn, ltfn, comp, ecomp;
      switch (hilo) {
        case '>':
          gtfn = gt;
          ltefn = lte;
          ltfn = lt;
          comp = '>';
          ecomp = '>=';
          break;
        case '<':
          gtfn = lt;
          ltefn = gte;
          ltfn = gt;
          comp = '<';
          ecomp = '<=';
          break;
        default:
          throw new TypeError('Must provide a hilo val of "<" or ">"');
      }
    
      // If it satisifes the range it is not outside
      if (satisfies(version, range, loose)) {
        return false;
      }
    
      // From now on, variable terms are as if we're in "gtr" mode.
      // but note that everything is flipped for the "ltr" function.
    
      for (var i = 0; i < range.set.length; ++i) {
        var comparators = range.set[i];
    
        var high = null;
        var low = null;
    
        comparators.forEach(function(comparator) {
          if (comparator.semver === ANY) {
            comparator = new Comparator('>=0.0.0')
          }
          high = high || comparator;
          low = low || comparator;
          if (gtfn(comparator.semver, high.semver, loose)) {
            high = comparator;
          } else if (ltfn(comparator.semver, low.semver, loose)) {
            low = comparator;
          }
        });
    
        // If the edge version comparator has a operator then our version
        // isn't outside it
        if (high.operator === comp || high.operator === ecomp) {
          return false;
        }
    
        // If the lowest version comparator has an operator and our version
        // is less than it then it isn't higher than the range
        if ((!low.operator || low.operator === comp) &&
            ltefn(version, low.semver)) {
          return false;
        } else if (low.operator === ecomp && ltfn(version, low.semver)) {
          return false;
        }
      }
      return true;
    }
    
    // Use the define() function if we're in AMD land
    if (typeof define === 'function' && define.amd)
      define(exports);
    
  provide("semver", module.exports);
}(global));

// pakmanager:binary/lib/vars.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  module.exports = function (store) {
        function getset (name, value) {
            var node = vars.store;
            var keys = name.split('.');
            keys.slice(0,-1).forEach(function (k) {
                if (node[k] === undefined) node[k] = {};
                node = node[k]
            });
            var key = keys[keys.length - 1];
            if (arguments.length == 1) {
                return node[key];
            }
            else {
                return node[key] = value;
            }
        }
        
        var vars = {
            get : function (name) {
                return getset(name);
            },
            set : function (name, value) {
                return getset(name, value);
            },
            store : store || {},
        };
        return vars;
    };
    
  provide("binary/lib/vars.js", module.exports);
}(global));

// pakmanager:binary
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var Chainsaw = require('chainsaw');
    var EventEmitter = require('events').EventEmitter;
    var Buffers = require('buffers');
    var Vars =  require('binary/lib/vars.js');
    var Stream = require('stream').Stream;
    
    exports = module.exports = function (bufOrEm, eventName) {
        if (Buffer.isBuffer(bufOrEm)) {
            return exports.parse(bufOrEm);
        }
        
        var s = exports.stream();
        if (bufOrEm && bufOrEm.pipe) {
            bufOrEm.pipe(s);
        }
        else if (bufOrEm) {
            bufOrEm.on(eventName || 'data', function (buf) {
                s.write(buf);
            });
            
            bufOrEm.on('end', function () {
                s.end();
            });
        }
        return s;
    };
    
    exports.stream = function (input) {
        if (input) return exports.apply(null, arguments);
        
        var pending = null;
        function getBytes (bytes, cb, skip) {
            pending = {
                bytes : bytes,
                skip : skip,
                cb : function (buf) {
                    pending = null;
                    cb(buf);
                },
            };
            dispatch();
        }
        
        var offset = null;
        function dispatch () {
            if (!pending) {
                if (caughtEnd) done = true;
                return;
            }
            if (typeof pending === 'function') {
                pending();
            }
            else {
                var bytes = offset + pending.bytes;
                
                if (buffers.length >= bytes) {
                    var buf;
                    if (offset == null) {
                        buf = buffers.splice(0, bytes);
                        if (!pending.skip) {
                            buf = buf.slice();
                        }
                    }
                    else {
                        if (!pending.skip) {
                            buf = buffers.slice(offset, bytes);
                        }
                        offset = bytes;
                    }
                    
                    if (pending.skip) {
                        pending.cb();
                    }
                    else {
                        pending.cb(buf);
                    }
                }
            }
        }
        
        function builder (saw) {
            function next () { if (!done) saw.next() }
            
            var self = words(function (bytes, cb) {
                return function (name) {
                    getBytes(bytes, function (buf) {
                        vars.set(name, cb(buf));
                        next();
                    });
                };
            });
            
            self.tap = function (cb) {
                saw.nest(cb, vars.store);
            };
            
            self.into = function (key, cb) {
                if (!vars.get(key)) vars.set(key, {});
                var parent = vars;
                vars = Vars(parent.get(key));
                
                saw.nest(function () {
                    cb.apply(this, arguments);
                    this.tap(function () {
                        vars = parent;
                    });
                }, vars.store);
            };
            
            self.flush = function () {
                vars.store = {};
                next();
            };
            
            self.loop = function (cb) {
                var end = false;
                
                saw.nest(false, function loop () {
                    this.vars = vars.store;
                    cb.call(this, function () {
                        end = true;
                        next();
                    }, vars.store);
                    this.tap(function () {
                        if (end) saw.next()
                        else loop.call(this)
                    }.bind(this));
                }, vars.store);
            };
            
            self.buffer = function (name, bytes) {
                if (typeof bytes === 'string') {
                    bytes = vars.get(bytes);
                }
                
                getBytes(bytes, function (buf) {
                    vars.set(name, buf);
                    next();
                });
            };
            
            self.skip = function (bytes) {
                if (typeof bytes === 'string') {
                    bytes = vars.get(bytes);
                }
                
                getBytes(bytes, function () {
                    next();
                });
            };
            
            self.scan = function find (name, search) {
                if (typeof search === 'string') {
                    search = new Buffer(search);
                }
                else if (!Buffer.isBuffer(search)) {
                    throw new Error('search must be a Buffer or a string');
                }
                
                var taken = 0;
                pending = function () {
                    var pos = buffers.indexOf(search, offset + taken);
                    var i = pos-offset-taken;
                    if (pos !== -1) {
                        pending = null;
                        if (offset != null) {
                            vars.set(
                                name,
                                buffers.slice(offset, offset + taken + i)
                            );
                            offset += taken + i + search.length;
                        }
                        else {
                            vars.set(
                                name,
                                buffers.slice(0, taken + i)
                            );
                            buffers.splice(0, taken + i + search.length);
                        }
                        next();
                        dispatch();
                    } else {
                        i = Math.max(buffers.length - search.length - offset - taken, 0);
    				}
                    taken += i;
                };
                dispatch();
            };
            
            self.peek = function (cb) {
                offset = 0;
                saw.nest(function () {
                    cb.call(this, vars.store);
                    this.tap(function () {
                        offset = null;
                    });
                });
            };
            
            return self;
        };
        
        var stream = Chainsaw.light(builder);
        stream.writable = true;
        
        var buffers = Buffers();
        
        stream.write = function (buf) {
            buffers.push(buf);
            dispatch();
        };
        
        var vars = Vars();
        
        var done = false, caughtEnd = false;
        stream.end = function () {
            caughtEnd = true;
        };
        
        stream.pipe = Stream.prototype.pipe;
        Object.getOwnPropertyNames(EventEmitter.prototype).forEach(function (name) {
            stream[name] = EventEmitter.prototype[name];
        });
        
        return stream;
    };
    
    exports.parse = function parse (buffer) {
        var self = words(function (bytes, cb) {
            return function (name) {
                if (offset + bytes <= buffer.length) {
                    var buf = buffer.slice(offset, offset + bytes);
                    offset += bytes;
                    vars.set(name, cb(buf));
                }
                else {
                    vars.set(name, null);
                }
                return self;
            };
        });
        
        var offset = 0;
        var vars = Vars();
        self.vars = vars.store;
        
        self.tap = function (cb) {
            cb.call(self, vars.store);
            return self;
        };
        
        self.into = function (key, cb) {
            if (!vars.get(key)) {
                vars.set(key, {});
            }
            var parent = vars;
            vars = Vars(parent.get(key));
            cb.call(self, vars.store);
            vars = parent;
            return self;
        };
        
        self.loop = function (cb) {
            var end = false;
            var ender = function () { end = true };
            while (end === false) {
                cb.call(self, ender, vars.store);
            }
            return self;
        };
        
        self.buffer = function (name, size) {
            if (typeof size === 'string') {
                size = vars.get(size);
            }
            var buf = buffer.slice(offset, Math.min(buffer.length, offset + size));
            offset += size;
            vars.set(name, buf);
            
            return self;
        };
        
        self.skip = function (bytes) {
            if (typeof bytes === 'string') {
                bytes = vars.get(bytes);
            }
            offset += bytes;
            
            return self;
        };
        
        self.scan = function (name, search) {
            if (typeof search === 'string') {
                search = new Buffer(search);
            }
            else if (!Buffer.isBuffer(search)) {
                throw new Error('search must be a Buffer or a string');
            }
            vars.set(name, null);
            
            // simple but slow string search
            for (var i = 0; i + offset <= buffer.length - search.length + 1; i++) {
                for (
                    var j = 0;
                    j < search.length && buffer[offset+i+j] === search[j];
                    j++
                );
                if (j === search.length) break;
            }
            
            vars.set(name, buffer.slice(offset, offset + i));
            offset += i + search.length;
            return self;
        };
        
        self.peek = function (cb) {
            var was = offset;
            cb.call(self, vars.store);
            offset = was;
            return self;
        };
        
        self.flush = function () {
            vars.store = {};
            return self;
        };
        
        self.eof = function () {
            return offset >= buffer.length;
        };
        
        return self;
    };
    
    // convert byte strings to unsigned little endian numbers
    function decodeLEu (bytes) {
        var acc = 0;
        for (var i = 0; i < bytes.length; i++) {
            acc += Math.pow(256,i) * bytes[i];
        }
        return acc;
    }
    
    // convert byte strings to unsigned big endian numbers
    function decodeBEu (bytes) {
        var acc = 0;
        for (var i = 0; i < bytes.length; i++) {
            acc += Math.pow(256, bytes.length - i - 1) * bytes[i];
        }
        return acc;
    }
    
    // convert byte strings to signed big endian numbers
    function decodeBEs (bytes) {
        var val = decodeBEu(bytes);
        if ((bytes[0] & 0x80) == 0x80) {
            val -= Math.pow(256, bytes.length);
        }
        return val;
    }
    
    // convert byte strings to signed little endian numbers
    function decodeLEs (bytes) {
        var val = decodeLEu(bytes);
        if ((bytes[bytes.length - 1] & 0x80) == 0x80) {
            val -= Math.pow(256, bytes.length);
        }
        return val;
    }
    
    function words (decode) {
        var self = {};
        
        [ 1, 2, 4, 8 ].forEach(function (bytes) {
            var bits = bytes * 8;
            
            self['word' + bits + 'le']
            = self['word' + bits + 'lu']
            = decode(bytes, decodeLEu);
            
            self['word' + bits + 'ls']
            = decode(bytes, decodeLEs);
            
            self['word' + bits + 'be']
            = self['word' + bits + 'bu']
            = decode(bytes, decodeBEu);
            
            self['word' + bits + 'bs']
            = decode(bytes, decodeBEs);
        });
        
        // word8be(n) == word8le(n) for all n
        self.word8 = self.word8u = self.word8be;
        self.word8s = self.word8bs;
        
        return self;
    }
    
  provide("binary", module.exports);
}(global));

// pakmanager:mkpath
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var fs = require('fs');
    var path = require('path');
    
    var mkpath = function mkpath(dirpath, mode, callback) {
        dirpath = path.resolve(dirpath);
        
        if (typeof mode === 'function' || typeof mode === 'undefined') {
            callback = mode;
            mode = 0777 & (~process.umask());
        }
        
        if (!callback) {
            callback = function () {};
        }
        
        fs.stat(dirpath, function (err, stats) {
            if (err) {
                if (err.code === 'ENOENT') {
                    mkpath(path.dirname(dirpath), mode, function (err) {
                        if (err) {
                            callback(err);
                        } else {
                            fs.mkdir(dirpath, mode, callback);
                        }
                    });
                } else {
                    callback(err);
                }
            } else if (stats.isDirectory()) {
                callback(null);
            } else {
                callback(new Error(dirpath + ' exists and is not a directory'));
            }
        });
    };
    
    mkpath.sync = function mkpathsync(dirpath, mode) {
        dirpath = path.resolve(dirpath);
        
        if (typeof mode === 'undefined') {
            mode = 0777 & (~process.umask());
        }
        
        try {
            if (!fs.statSync(dirpath).isDirectory()) {
                throw new Error(dirpath + ' exists and is not a directory');
            }
        } catch (err) {
            if (err.code === 'ENOENT') {
                mkpathsync(path.dirname(dirpath), mode);
                fs.mkdirSync(dirpath, mode);
            } else {
                throw err;
            }
        }
    };
    
    module.exports = mkpath;
    
    
  provide("mkpath", module.exports);
}(global));

// pakmanager:q
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // vim:ts=4:sts=4:sw=4:
    /*!
     *
     * Copyright 2009-2012 Kris Kowal under the terms of the MIT
     * license found at http://github.com/kriskowal/q/raw/master/LICENSE
     *
     * With parts by Tyler Close
     * Copyright 2007-2009 Tyler Close under the terms of the MIT X license found
     * at http://www.opensource.org/licenses/mit-license.html
     * Forked at ref_send.js version: 2009-05-11
     *
     * With parts by Mark Miller
     * Copyright (C) 2011 Google Inc.
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     *
     */
    
    (function (definition) {
        "use strict";
    
        // This file will function properly as a <script> tag, or a module
        // using CommonJS and NodeJS or RequireJS module formats.  In
        // Common/Node/RequireJS, the module exports the Q API and when
        // executed as a simple <script>, it creates a Q global instead.
    
        // Montage Require
        if (typeof bootstrap === "function") {
            bootstrap("promise", definition);
    
        // CommonJS
        } else if (typeof exports === "object" && typeof module === "object") {
            module.exports = definition();
    
        // RequireJS
        } else if (typeof define === "function" && define.amd) {
            define(definition);
    
        // SES (Secure EcmaScript)
        } else if (typeof ses !== "undefined") {
            if (!ses.ok()) {
                return;
            } else {
                ses.makeQ = definition;
            }
    
        // <script>
        } else if (typeof window !== "undefined" || typeof self !== "undefined") {
            // Prefer window over self for add-on scripts. Use self for
            // non-windowed contexts.
            var global = typeof window !== "undefined" ? window : self;
    
            // Get the `window` object, save the previous Q global
            // and initialize Q as a global.
            var previousQ = global.Q;
            global.Q = definition();
    
            // Add a noConflict function so Q can be removed from the
            // global namespace.
            global.Q.noConflict = function () {
                global.Q = previousQ;
                return this;
            };
    
        } else {
            throw new Error("This environment was not anticipated by Q. Please file a bug.");
        }
    
    })(function () {
    "use strict";
    
    var hasStacks = false;
    try {
        throw new Error();
    } catch (e) {
        hasStacks = !!e.stack;
    }
    
    // All code after this point will be filtered from stack traces reported
    // by Q.
    var qStartingLine = captureLine();
    var qFileName;
    
    // shims
    
    // used for fallback in "allResolved"
    var noop = function () {};
    
    // Use the fastest possible means to execute a task in a future turn
    // of the event loop.
    var nextTick =(function () {
        // linked list of tasks (single, with head node)
        var head = {task: void 0, next: null};
        var tail = head;
        var flushing = false;
        var requestTick = void 0;
        var isNodeJS = false;
        // queue for late tasks, used by unhandled rejection tracking
        var laterQueue = [];
    
        function flush() {
            /* jshint loopfunc: true */
            var task, domain;
    
            while (head.next) {
                head = head.next;
                task = head.task;
                head.task = void 0;
                domain = head.domain;
    
                if (domain) {
                    head.domain = void 0;
                    domain.enter();
                }
                runSingle(task, domain);
    
            }
            while (laterQueue.length) {
                task = laterQueue.pop();
                runSingle(task);
            }
            flushing = false;
        }
        // runs a single function in the async queue
        function runSingle(task, domain) {
            try {
                task();
    
            } catch (e) {
                if (isNodeJS) {
                    // In node, uncaught exceptions are considered fatal errors.
                    // Re-throw them synchronously to interrupt flushing!
    
                    // Ensure continuation if the uncaught exception is suppressed
                    // listening "uncaughtException" events (as domains does).
                    // Continue in next event to avoid tick recursion.
                    if (domain) {
                        domain.exit();
                    }
                    setTimeout(flush, 0);
                    if (domain) {
                        domain.enter();
                    }
    
                    throw e;
    
                } else {
                    // In browsers, uncaught exceptions are not fatal.
                    // Re-throw them asynchronously to avoid slow-downs.
                    setTimeout(function () {
                        throw e;
                    }, 0);
                }
            }
    
            if (domain) {
                domain.exit();
            }
        }
    
        nextTick = function (task) {
            tail = tail.next = {
                task: task,
                domain: isNodeJS && process.domain,
                next: null
            };
    
            if (!flushing) {
                flushing = true;
                requestTick();
            }
        };
    
        if (typeof process === "object" &&
            process.toString() === "[object process]" && process.nextTick) {
            // Ensure Q is in a real Node environment, with a `process.nextTick`.
            // To see through fake Node environments:
            // * Mocha test runner - exposes a `process` global without a `nextTick`
            // * Browserify - exposes a `process.nexTick` function that uses
            //   `setTimeout`. In this case `setImmediate` is preferred because
            //    it is faster. Browserify's `process.toString()` yields
            //   "[object Object]", while in a real Node environment
            //   `process.nextTick()` yields "[object process]".
            isNodeJS = true;
    
            requestTick = function () {
                process.nextTick(flush);
            };
    
        } else if (typeof setImmediate === "function") {
            // In IE10, Node.js 0.9+, or https://github.com/NobleJS/setImmediate
            if (typeof window !== "undefined") {
                requestTick = setImmediate.bind(window, flush);
            } else {
                requestTick = function () {
                    setImmediate(flush);
                };
            }
    
        } else if (typeof MessageChannel !== "undefined") {
            // modern browsers
            // http://www.nonblocking.io/2011/06/windownexttick.html
            var channel = new MessageChannel();
            // At least Safari Version 6.0.5 (8536.30.1) intermittently cannot create
            // working message ports the first time a page loads.
            channel.port1.onmessage = function () {
                requestTick = requestPortTick;
                channel.port1.onmessage = flush;
                flush();
            };
            var requestPortTick = function () {
                // Opera requires us to provide a message payload, regardless of
                // whether we use it.
                channel.port2.postMessage(0);
            };
            requestTick = function () {
                setTimeout(flush, 0);
                requestPortTick();
            };
    
        } else {
            // old browsers
            requestTick = function () {
                setTimeout(flush, 0);
            };
        }
        // runs a task after all other tasks have been run
        // this is useful for unhandled rejection tracking that needs to happen
        // after all `then`d tasks have been run.
        nextTick.runAfter = function (task) {
            laterQueue.push(task);
            if (!flushing) {
                flushing = true;
                requestTick();
            }
        };
        return nextTick;
    })();
    
    // Attempt to make generics safe in the face of downstream
    // modifications.
    // There is no situation where this is necessary.
    // If you need a security guarantee, these primordials need to be
    // deeply frozen anyway, and if you don’t need a security guarantee,
    // this is just plain paranoid.
    // However, this **might** have the nice side-effect of reducing the size of
    // the minified code by reducing x.call() to merely x()
    // See Mark Miller’s explanation of what this does.
    // http://wiki.ecmascript.org/doku.php?id=conventions:safe_meta_programming
    var call = Function.call;
    function uncurryThis(f) {
        return function () {
            return call.apply(f, arguments);
        };
    }
    // This is equivalent, but slower:
    // uncurryThis = Function_bind.bind(Function_bind.call);
    // http://jsperf.com/uncurrythis
    
    var array_slice = uncurryThis(Array.prototype.slice);
    
    var array_reduce = uncurryThis(
        Array.prototype.reduce || function (callback, basis) {
            var index = 0,
                length = this.length;
            // concerning the initial value, if one is not provided
            if (arguments.length === 1) {
                // seek to the first value in the array, accounting
                // for the possibility that is is a sparse array
                do {
                    if (index in this) {
                        basis = this[index++];
                        break;
                    }
                    if (++index >= length) {
                        throw new TypeError();
                    }
                } while (1);
            }
            // reduce
            for (; index < length; index++) {
                // account for the possibility that the array is sparse
                if (index in this) {
                    basis = callback(basis, this[index], index);
                }
            }
            return basis;
        }
    );
    
    var array_indexOf = uncurryThis(
        Array.prototype.indexOf || function (value) {
            // not a very good shim, but good enough for our one use of it
            for (var i = 0; i < this.length; i++) {
                if (this[i] === value) {
                    return i;
                }
            }
            return -1;
        }
    );
    
    var array_map = uncurryThis(
        Array.prototype.map || function (callback, thisp) {
            var self = this;
            var collect = [];
            array_reduce(self, function (undefined, value, index) {
                collect.push(callback.call(thisp, value, index, self));
            }, void 0);
            return collect;
        }
    );
    
    var object_create = Object.create || function (prototype) {
        function Type() { }
        Type.prototype = prototype;
        return new Type();
    };
    
    var object_hasOwnProperty = uncurryThis(Object.prototype.hasOwnProperty);
    
    var object_keys = Object.keys || function (object) {
        var keys = [];
        for (var key in object) {
            if (object_hasOwnProperty(object, key)) {
                keys.push(key);
            }
        }
        return keys;
    };
    
    var object_toString = uncurryThis(Object.prototype.toString);
    
    function isObject(value) {
        return value === Object(value);
    }
    
    // generator related shims
    
    // FIXME: Remove this function once ES6 generators are in SpiderMonkey.
    function isStopIteration(exception) {
        return (
            object_toString(exception) === "[object StopIteration]" ||
            exception instanceof QReturnValue
        );
    }
    
    // FIXME: Remove this helper and Q.return once ES6 generators are in
    // SpiderMonkey.
    var QReturnValue;
    if (typeof ReturnValue !== "undefined") {
        QReturnValue = ReturnValue;
    } else {
        QReturnValue = function (value) {
            this.value = value;
        };
    }
    
    // long stack traces
    
    var STACK_JUMP_SEPARATOR = "From previous event:";
    
    function makeStackTraceLong(error, promise) {
        // If possible, transform the error stack trace by removing Node and Q
        // cruft, then concatenating with the stack trace of `promise`. See #57.
        if (hasStacks &&
            promise.stack &&
            typeof error === "object" &&
            error !== null &&
            error.stack &&
            error.stack.indexOf(STACK_JUMP_SEPARATOR) === -1
        ) {
            var stacks = [];
            for (var p = promise; !!p; p = p.source) {
                if (p.stack) {
                    stacks.unshift(p.stack);
                }
            }
            stacks.unshift(error.stack);
    
            var concatedStacks = stacks.join("\n" + STACK_JUMP_SEPARATOR + "\n");
            error.stack = filterStackString(concatedStacks);
        }
    }
    
    function filterStackString(stackString) {
        var lines = stackString.split("\n");
        var desiredLines = [];
        for (var i = 0; i < lines.length; ++i) {
            var line = lines[i];
    
            if (!isInternalFrame(line) && !isNodeFrame(line) && line) {
                desiredLines.push(line);
            }
        }
        return desiredLines.join("\n");
    }
    
    function isNodeFrame(stackLine) {
        return stackLine.indexOf("(module.js:") !== -1 ||
               stackLine.indexOf("(node.js:") !== -1;
    }
    
    function getFileNameAndLineNumber(stackLine) {
        // Named functions: "at functionName (filename:lineNumber:columnNumber)"
        // In IE10 function name can have spaces ("Anonymous function") O_o
        var attempt1 = /at .+ \((.+):(\d+):(?:\d+)\)$/.exec(stackLine);
        if (attempt1) {
            return [attempt1[1], Number(attempt1[2])];
        }
    
        // Anonymous functions: "at filename:lineNumber:columnNumber"
        var attempt2 = /at ([^ ]+):(\d+):(?:\d+)$/.exec(stackLine);
        if (attempt2) {
            return [attempt2[1], Number(attempt2[2])];
        }
    
        // Firefox style: "function@filename:lineNumber or @filename:lineNumber"
        var attempt3 = /.*@(.+):(\d+)$/.exec(stackLine);
        if (attempt3) {
            return [attempt3[1], Number(attempt3[2])];
        }
    }
    
    function isInternalFrame(stackLine) {
        var fileNameAndLineNumber = getFileNameAndLineNumber(stackLine);
    
        if (!fileNameAndLineNumber) {
            return false;
        }
    
        var fileName = fileNameAndLineNumber[0];
        var lineNumber = fileNameAndLineNumber[1];
    
        return fileName === qFileName &&
            lineNumber >= qStartingLine &&
            lineNumber <= qEndingLine;
    }
    
    // discover own file name and line number range for filtering stack
    // traces
    function captureLine() {
        if (!hasStacks) {
            return;
        }
    
        try {
            throw new Error();
        } catch (e) {
            var lines = e.stack.split("\n");
            var firstLine = lines[0].indexOf("@") > 0 ? lines[1] : lines[2];
            var fileNameAndLineNumber = getFileNameAndLineNumber(firstLine);
            if (!fileNameAndLineNumber) {
                return;
            }
    
            qFileName = fileNameAndLineNumber[0];
            return fileNameAndLineNumber[1];
        }
    }
    
    function deprecate(callback, name, alternative) {
        return function () {
            if (typeof console !== "undefined" &&
                typeof console.warn === "function") {
                console.warn(name + " is deprecated, use " + alternative +
                             " instead.", new Error("").stack);
            }
            return callback.apply(callback, arguments);
        };
    }
    
    // end of shims
    // beginning of real work
    
    /**
     * Constructs a promise for an immediate reference, passes promises through, or
     * coerces promises from different systems.
     * @param value immediate reference or promise
     */
    function Q(value) {
        // If the object is already a Promise, return it directly.  This enables
        // the resolve function to both be used to created references from objects,
        // but to tolerably coerce non-promises to promises.
        if (value instanceof Promise) {
            return value;
        }
    
        // assimilate thenables
        if (isPromiseAlike(value)) {
            return coerce(value);
        } else {
            return fulfill(value);
        }
    }
    Q.resolve = Q;
    
    /**
     * Performs a task in a future turn of the event loop.
     * @param {Function} task
     */
    Q.nextTick = nextTick;
    
    /**
     * Controls whether or not long stack traces will be on
     */
    Q.longStackSupport = false;
    
    // enable long stacks if Q_DEBUG is set
    if (typeof process === "object" && process && process.env && process.env.Q_DEBUG) {
        Q.longStackSupport = true;
    }
    
    /**
     * Constructs a {promise, resolve, reject} object.
     *
     * `resolve` is a callback to invoke with a more resolved value for the
     * promise. To fulfill the promise, invoke `resolve` with any value that is
     * not a thenable. To reject the promise, invoke `resolve` with a rejected
     * thenable, or invoke `reject` with the reason directly. To resolve the
     * promise to another thenable, thus putting it in the same state, invoke
     * `resolve` with that other thenable.
     */
    Q.defer = defer;
    function defer() {
        // if "messages" is an "Array", that indicates that the promise has not yet
        // been resolved.  If it is "undefined", it has been resolved.  Each
        // element of the messages array is itself an array of complete arguments to
        // forward to the resolved promise.  We coerce the resolution value to a
        // promise using the `resolve` function because it handles both fully
        // non-thenable values and other thenables gracefully.
        var messages = [], progressListeners = [], resolvedPromise;
    
        var deferred = object_create(defer.prototype);
        var promise = object_create(Promise.prototype);
    
        promise.promiseDispatch = function (resolve, op, operands) {
            var args = array_slice(arguments);
            if (messages) {
                messages.push(args);
                if (op === "when" && operands[1]) { // progress operand
                    progressListeners.push(operands[1]);
                }
            } else {
                Q.nextTick(function () {
                    resolvedPromise.promiseDispatch.apply(resolvedPromise, args);
                });
            }
        };
    
        // XXX deprecated
        promise.valueOf = function () {
            if (messages) {
                return promise;
            }
            var nearerValue = nearer(resolvedPromise);
            if (isPromise(nearerValue)) {
                resolvedPromise = nearerValue; // shorten chain
            }
            return nearerValue;
        };
    
        promise.inspect = function () {
            if (!resolvedPromise) {
                return { state: "pending" };
            }
            return resolvedPromise.inspect();
        };
    
        if (Q.longStackSupport && hasStacks) {
            try {
                throw new Error();
            } catch (e) {
                // NOTE: don't try to use `Error.captureStackTrace` or transfer the
                // accessor around; that causes memory leaks as per GH-111. Just
                // reify the stack trace as a string ASAP.
                //
                // At the same time, cut off the first line; it's always just
                // "[object Promise]\n", as per the `toString`.
                promise.stack = e.stack.substring(e.stack.indexOf("\n") + 1);
            }
        }
    
        // NOTE: we do the checks for `resolvedPromise` in each method, instead of
        // consolidating them into `become`, since otherwise we'd create new
        // promises with the lines `become(whatever(value))`. See e.g. GH-252.
    
        function become(newPromise) {
            resolvedPromise = newPromise;
            promise.source = newPromise;
    
            array_reduce(messages, function (undefined, message) {
                Q.nextTick(function () {
                    newPromise.promiseDispatch.apply(newPromise, message);
                });
            }, void 0);
    
            messages = void 0;
            progressListeners = void 0;
        }
    
        deferred.promise = promise;
        deferred.resolve = function (value) {
            if (resolvedPromise) {
                return;
            }
    
            become(Q(value));
        };
    
        deferred.fulfill = function (value) {
            if (resolvedPromise) {
                return;
            }
    
            become(fulfill(value));
        };
        deferred.reject = function (reason) {
            if (resolvedPromise) {
                return;
            }
    
            become(reject(reason));
        };
        deferred.notify = function (progress) {
            if (resolvedPromise) {
                return;
            }
    
            array_reduce(progressListeners, function (undefined, progressListener) {
                Q.nextTick(function () {
                    progressListener(progress);
                });
            }, void 0);
        };
    
        return deferred;
    }
    
    /**
     * Creates a Node-style callback that will resolve or reject the deferred
     * promise.
     * @returns a nodeback
     */
    defer.prototype.makeNodeResolver = function () {
        var self = this;
        return function (error, value) {
            if (error) {
                self.reject(error);
            } else if (arguments.length > 2) {
                self.resolve(array_slice(arguments, 1));
            } else {
                self.resolve(value);
            }
        };
    };
    
    /**
     * @param resolver {Function} a function that returns nothing and accepts
     * the resolve, reject, and notify functions for a deferred.
     * @returns a promise that may be resolved with the given resolve and reject
     * functions, or rejected by a thrown exception in resolver
     */
    Q.Promise = promise; // ES6
    Q.promise = promise;
    function promise(resolver) {
        if (typeof resolver !== "function") {
            throw new TypeError("resolver must be a function.");
        }
        var deferred = defer();
        try {
            resolver(deferred.resolve, deferred.reject, deferred.notify);
        } catch (reason) {
            deferred.reject(reason);
        }
        return deferred.promise;
    }
    
    promise.race = race; // ES6
    promise.all = all; // ES6
    promise.reject = reject; // ES6
    promise.resolve = Q; // ES6
    
    // XXX experimental.  This method is a way to denote that a local value is
    // serializable and should be immediately dispatched to a remote upon request,
    // instead of passing a reference.
    Q.passByCopy = function (object) {
        //freeze(object);
        //passByCopies.set(object, true);
        return object;
    };
    
    Promise.prototype.passByCopy = function () {
        //freeze(object);
        //passByCopies.set(object, true);
        return this;
    };
    
    /**
     * If two promises eventually fulfill to the same value, promises that value,
     * but otherwise rejects.
     * @param x {Any*}
     * @param y {Any*}
     * @returns {Any*} a promise for x and y if they are the same, but a rejection
     * otherwise.
     *
     */
    Q.join = function (x, y) {
        return Q(x).join(y);
    };
    
    Promise.prototype.join = function (that) {
        return Q([this, that]).spread(function (x, y) {
            if (x === y) {
                // TODO: "===" should be Object.is or equiv
                return x;
            } else {
                throw new Error("Can't join: not the same: " + x + " " + y);
            }
        });
    };
    
    /**
     * Returns a promise for the first of an array of promises to become settled.
     * @param answers {Array[Any*]} promises to race
     * @returns {Any*} the first promise to be settled
     */
    Q.race = race;
    function race(answerPs) {
        return promise(function (resolve, reject) {
            // Switch to this once we can assume at least ES5
            // answerPs.forEach(function (answerP) {
            //     Q(answerP).then(resolve, reject);
            // });
            // Use this in the meantime
            for (var i = 0, len = answerPs.length; i < len; i++) {
                Q(answerPs[i]).then(resolve, reject);
            }
        });
    }
    
    Promise.prototype.race = function () {
        return this.then(Q.race);
    };
    
    /**
     * Constructs a Promise with a promise descriptor object and optional fallback
     * function.  The descriptor contains methods like when(rejected), get(name),
     * set(name, value), post(name, args), and delete(name), which all
     * return either a value, a promise for a value, or a rejection.  The fallback
     * accepts the operation name, a resolver, and any further arguments that would
     * have been forwarded to the appropriate method above had a method been
     * provided with the proper name.  The API makes no guarantees about the nature
     * of the returned object, apart from that it is usable whereever promises are
     * bought and sold.
     */
    Q.makePromise = Promise;
    function Promise(descriptor, fallback, inspect) {
        if (fallback === void 0) {
            fallback = function (op) {
                return reject(new Error(
                    "Promise does not support operation: " + op
                ));
            };
        }
        if (inspect === void 0) {
            inspect = function () {
                return {state: "unknown"};
            };
        }
    
        var promise = object_create(Promise.prototype);
    
        promise.promiseDispatch = function (resolve, op, args) {
            var result;
            try {
                if (descriptor[op]) {
                    result = descriptor[op].apply(promise, args);
                } else {
                    result = fallback.call(promise, op, args);
                }
            } catch (exception) {
                result = reject(exception);
            }
            if (resolve) {
                resolve(result);
            }
        };
    
        promise.inspect = inspect;
    
        // XXX deprecated `valueOf` and `exception` support
        if (inspect) {
            var inspected = inspect();
            if (inspected.state === "rejected") {
                promise.exception = inspected.reason;
            }
    
            promise.valueOf = function () {
                var inspected = inspect();
                if (inspected.state === "pending" ||
                    inspected.state === "rejected") {
                    return promise;
                }
                return inspected.value;
            };
        }
    
        return promise;
    }
    
    Promise.prototype.toString = function () {
        return "[object Promise]";
    };
    
    Promise.prototype.then = function (fulfilled, rejected, progressed) {
        var self = this;
        var deferred = defer();
        var done = false;   // ensure the untrusted promise makes at most a
                            // single call to one of the callbacks
    
        function _fulfilled(value) {
            try {
                return typeof fulfilled === "function" ? fulfilled(value) : value;
            } catch (exception) {
                return reject(exception);
            }
        }
    
        function _rejected(exception) {
            if (typeof rejected === "function") {
                makeStackTraceLong(exception, self);
                try {
                    return rejected(exception);
                } catch (newException) {
                    return reject(newException);
                }
            }
            return reject(exception);
        }
    
        function _progressed(value) {
            return typeof progressed === "function" ? progressed(value) : value;
        }
    
        Q.nextTick(function () {
            self.promiseDispatch(function (value) {
                if (done) {
                    return;
                }
                done = true;
    
                deferred.resolve(_fulfilled(value));
            }, "when", [function (exception) {
                if (done) {
                    return;
                }
                done = true;
    
                deferred.resolve(_rejected(exception));
            }]);
        });
    
        // Progress propagator need to be attached in the current tick.
        self.promiseDispatch(void 0, "when", [void 0, function (value) {
            var newValue;
            var threw = false;
            try {
                newValue = _progressed(value);
            } catch (e) {
                threw = true;
                if (Q.onerror) {
                    Q.onerror(e);
                } else {
                    throw e;
                }
            }
    
            if (!threw) {
                deferred.notify(newValue);
            }
        }]);
    
        return deferred.promise;
    };
    
    Q.tap = function (promise, callback) {
        return Q(promise).tap(callback);
    };
    
    /**
     * Works almost like "finally", but not called for rejections.
     * Original resolution value is passed through callback unaffected.
     * Callback may return a promise that will be awaited for.
     * @param {Function} callback
     * @returns {Q.Promise}
     * @example
     * doSomething()
     *   .then(...)
     *   .tap(console.log)
     *   .then(...);
     */
    Promise.prototype.tap = function (callback) {
        callback = Q(callback);
    
        return this.then(function (value) {
            return callback.fcall(value).thenResolve(value);
        });
    };
    
    /**
     * Registers an observer on a promise.
     *
     * Guarantees:
     *
     * 1. that fulfilled and rejected will be called only once.
     * 2. that either the fulfilled callback or the rejected callback will be
     *    called, but not both.
     * 3. that fulfilled and rejected will not be called in this turn.
     *
     * @param value      promise or immediate reference to observe
     * @param fulfilled  function to be called with the fulfilled value
     * @param rejected   function to be called with the rejection exception
     * @param progressed function to be called on any progress notifications
     * @return promise for the return value from the invoked callback
     */
    Q.when = when;
    function when(value, fulfilled, rejected, progressed) {
        return Q(value).then(fulfilled, rejected, progressed);
    }
    
    Promise.prototype.thenResolve = function (value) {
        return this.then(function () { return value; });
    };
    
    Q.thenResolve = function (promise, value) {
        return Q(promise).thenResolve(value);
    };
    
    Promise.prototype.thenReject = function (reason) {
        return this.then(function () { throw reason; });
    };
    
    Q.thenReject = function (promise, reason) {
        return Q(promise).thenReject(reason);
    };
    
    /**
     * If an object is not a promise, it is as "near" as possible.
     * If a promise is rejected, it is as "near" as possible too.
     * If it’s a fulfilled promise, the fulfillment value is nearer.
     * If it’s a deferred promise and the deferred has been resolved, the
     * resolution is "nearer".
     * @param object
     * @returns most resolved (nearest) form of the object
     */
    
    // XXX should we re-do this?
    Q.nearer = nearer;
    function nearer(value) {
        if (isPromise(value)) {
            var inspected = value.inspect();
            if (inspected.state === "fulfilled") {
                return inspected.value;
            }
        }
        return value;
    }
    
    /**
     * @returns whether the given object is a promise.
     * Otherwise it is a fulfilled value.
     */
    Q.isPromise = isPromise;
    function isPromise(object) {
        return object instanceof Promise;
    }
    
    Q.isPromiseAlike = isPromiseAlike;
    function isPromiseAlike(object) {
        return isObject(object) && typeof object.then === "function";
    }
    
    /**
     * @returns whether the given object is a pending promise, meaning not
     * fulfilled or rejected.
     */
    Q.isPending = isPending;
    function isPending(object) {
        return isPromise(object) && object.inspect().state === "pending";
    }
    
    Promise.prototype.isPending = function () {
        return this.inspect().state === "pending";
    };
    
    /**
     * @returns whether the given object is a value or fulfilled
     * promise.
     */
    Q.isFulfilled = isFulfilled;
    function isFulfilled(object) {
        return !isPromise(object) || object.inspect().state === "fulfilled";
    }
    
    Promise.prototype.isFulfilled = function () {
        return this.inspect().state === "fulfilled";
    };
    
    /**
     * @returns whether the given object is a rejected promise.
     */
    Q.isRejected = isRejected;
    function isRejected(object) {
        return isPromise(object) && object.inspect().state === "rejected";
    }
    
    Promise.prototype.isRejected = function () {
        return this.inspect().state === "rejected";
    };
    
    //// BEGIN UNHANDLED REJECTION TRACKING
    
    // This promise library consumes exceptions thrown in handlers so they can be
    // handled by a subsequent promise.  The exceptions get added to this array when
    // they are created, and removed when they are handled.  Note that in ES6 or
    // shimmed environments, this would naturally be a `Set`.
    var unhandledReasons = [];
    var unhandledRejections = [];
    var reportedUnhandledRejections = [];
    var trackUnhandledRejections = true;
    
    function resetUnhandledRejections() {
        unhandledReasons.length = 0;
        unhandledRejections.length = 0;
    
        if (!trackUnhandledRejections) {
            trackUnhandledRejections = true;
        }
    }
    
    function trackRejection(promise, reason) {
        if (!trackUnhandledRejections) {
            return;
        }
        if (typeof process === "object" && typeof process.emit === "function") {
            Q.nextTick.runAfter(function () {
                if (array_indexOf(unhandledRejections, promise) !== -1) {
                    process.emit("unhandledRejection", reason, promise);
                    reportedUnhandledRejections.push(promise);
                }
            });
        }
    
        unhandledRejections.push(promise);
        if (reason && typeof reason.stack !== "undefined") {
            unhandledReasons.push(reason.stack);
        } else {
            unhandledReasons.push("(no stack) " + reason);
        }
    }
    
    function untrackRejection(promise) {
        if (!trackUnhandledRejections) {
            return;
        }
    
        var at = array_indexOf(unhandledRejections, promise);
        if (at !== -1) {
            if (typeof process === "object" && typeof process.emit === "function") {
                Q.nextTick.runAfter(function () {
                    var atReport = array_indexOf(reportedUnhandledRejections, promise);
                    if (atReport !== -1) {
                        process.emit("rejectionHandled", unhandledReasons[at], promise);
                        reportedUnhandledRejections.splice(atReport, 1);
                    }
                });
            }
            unhandledRejections.splice(at, 1);
            unhandledReasons.splice(at, 1);
        }
    }
    
    Q.resetUnhandledRejections = resetUnhandledRejections;
    
    Q.getUnhandledReasons = function () {
        // Make a copy so that consumers can't interfere with our internal state.
        return unhandledReasons.slice();
    };
    
    Q.stopUnhandledRejectionTracking = function () {
        resetUnhandledRejections();
        trackUnhandledRejections = false;
    };
    
    resetUnhandledRejections();
    
    //// END UNHANDLED REJECTION TRACKING
    
    /**
     * Constructs a rejected promise.
     * @param reason value describing the failure
     */
    Q.reject = reject;
    function reject(reason) {
        var rejection = Promise({
            "when": function (rejected) {
                // note that the error has been handled
                if (rejected) {
                    untrackRejection(this);
                }
                return rejected ? rejected(reason) : this;
            }
        }, function fallback() {
            return this;
        }, function inspect() {
            return { state: "rejected", reason: reason };
        });
    
        // Note that the reason has not been handled.
        trackRejection(rejection, reason);
    
        return rejection;
    }
    
    /**
     * Constructs a fulfilled promise for an immediate reference.
     * @param value immediate reference
     */
    Q.fulfill = fulfill;
    function fulfill(value) {
        return Promise({
            "when": function () {
                return value;
            },
            "get": function (name) {
                return value[name];
            },
            "set": function (name, rhs) {
                value[name] = rhs;
            },
            "delete": function (name) {
                delete value[name];
            },
            "post": function (name, args) {
                // Mark Miller proposes that post with no name should apply a
                // promised function.
                if (name === null || name === void 0) {
                    return value.apply(void 0, args);
                } else {
                    return value[name].apply(value, args);
                }
            },
            "apply": function (thisp, args) {
                return value.apply(thisp, args);
            },
            "keys": function () {
                return object_keys(value);
            }
        }, void 0, function inspect() {
            return { state: "fulfilled", value: value };
        });
    }
    
    /**
     * Converts thenables to Q promises.
     * @param promise thenable promise
     * @returns a Q promise
     */
    function coerce(promise) {
        var deferred = defer();
        Q.nextTick(function () {
            try {
                promise.then(deferred.resolve, deferred.reject, deferred.notify);
            } catch (exception) {
                deferred.reject(exception);
            }
        });
        return deferred.promise;
    }
    
    /**
     * Annotates an object such that it will never be
     * transferred away from this process over any promise
     * communication channel.
     * @param object
     * @returns promise a wrapping of that object that
     * additionally responds to the "isDef" message
     * without a rejection.
     */
    Q.master = master;
    function master(object) {
        return Promise({
            "isDef": function () {}
        }, function fallback(op, args) {
            return dispatch(object, op, args);
        }, function () {
            return Q(object).inspect();
        });
    }
    
    /**
     * Spreads the values of a promised array of arguments into the
     * fulfillment callback.
     * @param fulfilled callback that receives variadic arguments from the
     * promised array
     * @param rejected callback that receives the exception if the promise
     * is rejected.
     * @returns a promise for the return value or thrown exception of
     * either callback.
     */
    Q.spread = spread;
    function spread(value, fulfilled, rejected) {
        return Q(value).spread(fulfilled, rejected);
    }
    
    Promise.prototype.spread = function (fulfilled, rejected) {
        return this.all().then(function (array) {
            return fulfilled.apply(void 0, array);
        }, rejected);
    };
    
    /**
     * The async function is a decorator for generator functions, turning
     * them into asynchronous generators.  Although generators are only part
     * of the newest ECMAScript 6 drafts, this code does not cause syntax
     * errors in older engines.  This code should continue to work and will
     * in fact improve over time as the language improves.
     *
     * ES6 generators are currently part of V8 version 3.19 with the
     * --harmony-generators runtime flag enabled.  SpiderMonkey has had them
     * for longer, but under an older Python-inspired form.  This function
     * works on both kinds of generators.
     *
     * Decorates a generator function such that:
     *  - it may yield promises
     *  - execution will continue when that promise is fulfilled
     *  - the value of the yield expression will be the fulfilled value
     *  - it returns a promise for the return value (when the generator
     *    stops iterating)
     *  - the decorated function returns a promise for the return value
     *    of the generator or the first rejected promise among those
     *    yielded.
     *  - if an error is thrown in the generator, it propagates through
     *    every following yield until it is caught, or until it escapes
     *    the generator function altogether, and is translated into a
     *    rejection for the promise returned by the decorated generator.
     */
    Q.async = async;
    function async(makeGenerator) {
        return function () {
            // when verb is "send", arg is a value
            // when verb is "throw", arg is an exception
            function continuer(verb, arg) {
                var result;
    
                // Until V8 3.19 / Chromium 29 is released, SpiderMonkey is the only
                // engine that has a deployed base of browsers that support generators.
                // However, SM's generators use the Python-inspired semantics of
                // outdated ES6 drafts.  We would like to support ES6, but we'd also
                // like to make it possible to use generators in deployed browsers, so
                // we also support Python-style generators.  At some point we can remove
                // this block.
    
                if (typeof StopIteration === "undefined") {
                    // ES6 Generators
                    try {
                        result = generator[verb](arg);
                    } catch (exception) {
                        return reject(exception);
                    }
                    if (result.done) {
                        return Q(result.value);
                    } else {
                        return when(result.value, callback, errback);
                    }
                } else {
                    // SpiderMonkey Generators
                    // FIXME: Remove this case when SM does ES6 generators.
                    try {
                        result = generator[verb](arg);
                    } catch (exception) {
                        if (isStopIteration(exception)) {
                            return Q(exception.value);
                        } else {
                            return reject(exception);
                        }
                    }
                    return when(result, callback, errback);
                }
            }
            var generator = makeGenerator.apply(this, arguments);
            var callback = continuer.bind(continuer, "next");
            var errback = continuer.bind(continuer, "throw");
            return callback();
        };
    }
    
    /**
     * The spawn function is a small wrapper around async that immediately
     * calls the generator and also ends the promise chain, so that any
     * unhandled errors are thrown instead of forwarded to the error
     * handler. This is useful because it's extremely common to run
     * generators at the top-level to work with libraries.
     */
    Q.spawn = spawn;
    function spawn(makeGenerator) {
        Q.done(Q.async(makeGenerator)());
    }
    
    // FIXME: Remove this interface once ES6 generators are in SpiderMonkey.
    /**
     * Throws a ReturnValue exception to stop an asynchronous generator.
     *
     * This interface is a stop-gap measure to support generator return
     * values in older Firefox/SpiderMonkey.  In browsers that support ES6
     * generators like Chromium 29, just use "return" in your generator
     * functions.
     *
     * @param value the return value for the surrounding generator
     * @throws ReturnValue exception with the value.
     * @example
     * // ES6 style
     * Q.async(function* () {
     *      var foo = yield getFooPromise();
     *      var bar = yield getBarPromise();
     *      return foo + bar;
     * })
     * // Older SpiderMonkey style
     * Q.async(function () {
     *      var foo = yield getFooPromise();
     *      var bar = yield getBarPromise();
     *      Q.return(foo + bar);
     * })
     */
    Q["return"] = _return;
    function _return(value) {
        throw new QReturnValue(value);
    }
    
    /**
     * The promised function decorator ensures that any promise arguments
     * are settled and passed as values (`this` is also settled and passed
     * as a value).  It will also ensure that the result of a function is
     * always a promise.
     *
     * @example
     * var add = Q.promised(function (a, b) {
     *     return a + b;
     * });
     * add(Q(a), Q(B));
     *
     * @param {function} callback The function to decorate
     * @returns {function} a function that has been decorated.
     */
    Q.promised = promised;
    function promised(callback) {
        return function () {
            return spread([this, all(arguments)], function (self, args) {
                return callback.apply(self, args);
            });
        };
    }
    
    /**
     * sends a message to a value in a future turn
     * @param object* the recipient
     * @param op the name of the message operation, e.g., "when",
     * @param args further arguments to be forwarded to the operation
     * @returns result {Promise} a promise for the result of the operation
     */
    Q.dispatch = dispatch;
    function dispatch(object, op, args) {
        return Q(object).dispatch(op, args);
    }
    
    Promise.prototype.dispatch = function (op, args) {
        var self = this;
        var deferred = defer();
        Q.nextTick(function () {
            self.promiseDispatch(deferred.resolve, op, args);
        });
        return deferred.promise;
    };
    
    /**
     * Gets the value of a property in a future turn.
     * @param object    promise or immediate reference for target object
     * @param name      name of property to get
     * @return promise for the property value
     */
    Q.get = function (object, key) {
        return Q(object).dispatch("get", [key]);
    };
    
    Promise.prototype.get = function (key) {
        return this.dispatch("get", [key]);
    };
    
    /**
     * Sets the value of a property in a future turn.
     * @param object    promise or immediate reference for object object
     * @param name      name of property to set
     * @param value     new value of property
     * @return promise for the return value
     */
    Q.set = function (object, key, value) {
        return Q(object).dispatch("set", [key, value]);
    };
    
    Promise.prototype.set = function (key, value) {
        return this.dispatch("set", [key, value]);
    };
    
    /**
     * Deletes a property in a future turn.
     * @param object    promise or immediate reference for target object
     * @param name      name of property to delete
     * @return promise for the return value
     */
    Q.del = // XXX legacy
    Q["delete"] = function (object, key) {
        return Q(object).dispatch("delete", [key]);
    };
    
    Promise.prototype.del = // XXX legacy
    Promise.prototype["delete"] = function (key) {
        return this.dispatch("delete", [key]);
    };
    
    /**
     * Invokes a method in a future turn.
     * @param object    promise or immediate reference for target object
     * @param name      name of method to invoke
     * @param value     a value to post, typically an array of
     *                  invocation arguments for promises that
     *                  are ultimately backed with `resolve` values,
     *                  as opposed to those backed with URLs
     *                  wherein the posted value can be any
     *                  JSON serializable object.
     * @return promise for the return value
     */
    // bound locally because it is used by other methods
    Q.mapply = // XXX As proposed by "Redsandro"
    Q.post = function (object, name, args) {
        return Q(object).dispatch("post", [name, args]);
    };
    
    Promise.prototype.mapply = // XXX As proposed by "Redsandro"
    Promise.prototype.post = function (name, args) {
        return this.dispatch("post", [name, args]);
    };
    
    /**
     * Invokes a method in a future turn.
     * @param object    promise or immediate reference for target object
     * @param name      name of method to invoke
     * @param ...args   array of invocation arguments
     * @return promise for the return value
     */
    Q.send = // XXX Mark Miller's proposed parlance
    Q.mcall = // XXX As proposed by "Redsandro"
    Q.invoke = function (object, name /*...args*/) {
        return Q(object).dispatch("post", [name, array_slice(arguments, 2)]);
    };
    
    Promise.prototype.send = // XXX Mark Miller's proposed parlance
    Promise.prototype.mcall = // XXX As proposed by "Redsandro"
    Promise.prototype.invoke = function (name /*...args*/) {
        return this.dispatch("post", [name, array_slice(arguments, 1)]);
    };
    
    /**
     * Applies the promised function in a future turn.
     * @param object    promise or immediate reference for target function
     * @param args      array of application arguments
     */
    Q.fapply = function (object, args) {
        return Q(object).dispatch("apply", [void 0, args]);
    };
    
    Promise.prototype.fapply = function (args) {
        return this.dispatch("apply", [void 0, args]);
    };
    
    /**
     * Calls the promised function in a future turn.
     * @param object    promise or immediate reference for target function
     * @param ...args   array of application arguments
     */
    Q["try"] =
    Q.fcall = function (object /* ...args*/) {
        return Q(object).dispatch("apply", [void 0, array_slice(arguments, 1)]);
    };
    
    Promise.prototype.fcall = function (/*...args*/) {
        return this.dispatch("apply", [void 0, array_slice(arguments)]);
    };
    
    /**
     * Binds the promised function, transforming return values into a fulfilled
     * promise and thrown errors into a rejected one.
     * @param object    promise or immediate reference for target function
     * @param ...args   array of application arguments
     */
    Q.fbind = function (object /*...args*/) {
        var promise = Q(object);
        var args = array_slice(arguments, 1);
        return function fbound() {
            return promise.dispatch("apply", [
                this,
                args.concat(array_slice(arguments))
            ]);
        };
    };
    Promise.prototype.fbind = function (/*...args*/) {
        var promise = this;
        var args = array_slice(arguments);
        return function fbound() {
            return promise.dispatch("apply", [
                this,
                args.concat(array_slice(arguments))
            ]);
        };
    };
    
    /**
     * Requests the names of the owned properties of a promised
     * object in a future turn.
     * @param object    promise or immediate reference for target object
     * @return promise for the keys of the eventually settled object
     */
    Q.keys = function (object) {
        return Q(object).dispatch("keys", []);
    };
    
    Promise.prototype.keys = function () {
        return this.dispatch("keys", []);
    };
    
    /**
     * Turns an array of promises into a promise for an array.  If any of
     * the promises gets rejected, the whole array is rejected immediately.
     * @param {Array*} an array (or promise for an array) of values (or
     * promises for values)
     * @returns a promise for an array of the corresponding values
     */
    // By Mark Miller
    // http://wiki.ecmascript.org/doku.php?id=strawman:concurrency&rev=1308776521#allfulfilled
    Q.all = all;
    function all(promises) {
        return when(promises, function (promises) {
            var pendingCount = 0;
            var deferred = defer();
            array_reduce(promises, function (undefined, promise, index) {
                var snapshot;
                if (
                    isPromise(promise) &&
                    (snapshot = promise.inspect()).state === "fulfilled"
                ) {
                    promises[index] = snapshot.value;
                } else {
                    ++pendingCount;
                    when(
                        promise,
                        function (value) {
                            promises[index] = value;
                            if (--pendingCount === 0) {
                                deferred.resolve(promises);
                            }
                        },
                        deferred.reject,
                        function (progress) {
                            deferred.notify({ index: index, value: progress });
                        }
                    );
                }
            }, void 0);
            if (pendingCount === 0) {
                deferred.resolve(promises);
            }
            return deferred.promise;
        });
    }
    
    Promise.prototype.all = function () {
        return all(this);
    };
    
    /**
     * Returns the first resolved promise of an array. Prior rejected promises are
     * ignored.  Rejects only if all promises are rejected.
     * @param {Array*} an array containing values or promises for values
     * @returns a promise fulfilled with the value of the first resolved promise,
     * or a rejected promise if all promises are rejected.
     */
    Q.any = any;
    
    function any(promises) {
        if (promises.length === 0) {
            return Q.resolve();
        }
    
        var deferred = Q.defer();
        var pendingCount = 0;
        array_reduce(promises, function (prev, current, index) {
            var promise = promises[index];
    
            pendingCount++;
    
            when(promise, onFulfilled, onRejected, onProgress);
            function onFulfilled(result) {
                deferred.resolve(result);
            }
            function onRejected() {
                pendingCount--;
                if (pendingCount === 0) {
                    deferred.reject(new Error(
                        "Can't get fulfillment value from any promise, all " +
                        "promises were rejected."
                    ));
                }
            }
            function onProgress(progress) {
                deferred.notify({
                    index: index,
                    value: progress
                });
            }
        }, undefined);
    
        return deferred.promise;
    }
    
    Promise.prototype.any = function () {
        return any(this);
    };
    
    /**
     * Waits for all promises to be settled, either fulfilled or
     * rejected.  This is distinct from `all` since that would stop
     * waiting at the first rejection.  The promise returned by
     * `allResolved` will never be rejected.
     * @param promises a promise for an array (or an array) of promises
     * (or values)
     * @return a promise for an array of promises
     */
    Q.allResolved = deprecate(allResolved, "allResolved", "allSettled");
    function allResolved(promises) {
        return when(promises, function (promises) {
            promises = array_map(promises, Q);
            return when(all(array_map(promises, function (promise) {
                return when(promise, noop, noop);
            })), function () {
                return promises;
            });
        });
    }
    
    Promise.prototype.allResolved = function () {
        return allResolved(this);
    };
    
    /**
     * @see Promise#allSettled
     */
    Q.allSettled = allSettled;
    function allSettled(promises) {
        return Q(promises).allSettled();
    }
    
    /**
     * Turns an array of promises into a promise for an array of their states (as
     * returned by `inspect`) when they have all settled.
     * @param {Array[Any*]} values an array (or promise for an array) of values (or
     * promises for values)
     * @returns {Array[State]} an array of states for the respective values.
     */
    Promise.prototype.allSettled = function () {
        return this.then(function (promises) {
            return all(array_map(promises, function (promise) {
                promise = Q(promise);
                function regardless() {
                    return promise.inspect();
                }
                return promise.then(regardless, regardless);
            }));
        });
    };
    
    /**
     * Captures the failure of a promise, giving an oportunity to recover
     * with a callback.  If the given promise is fulfilled, the returned
     * promise is fulfilled.
     * @param {Any*} promise for something
     * @param {Function} callback to fulfill the returned promise if the
     * given promise is rejected
     * @returns a promise for the return value of the callback
     */
    Q.fail = // XXX legacy
    Q["catch"] = function (object, rejected) {
        return Q(object).then(void 0, rejected);
    };
    
    Promise.prototype.fail = // XXX legacy
    Promise.prototype["catch"] = function (rejected) {
        return this.then(void 0, rejected);
    };
    
    /**
     * Attaches a listener that can respond to progress notifications from a
     * promise's originating deferred. This listener receives the exact arguments
     * passed to ``deferred.notify``.
     * @param {Any*} promise for something
     * @param {Function} callback to receive any progress notifications
     * @returns the given promise, unchanged
     */
    Q.progress = progress;
    function progress(object, progressed) {
        return Q(object).then(void 0, void 0, progressed);
    }
    
    Promise.prototype.progress = function (progressed) {
        return this.then(void 0, void 0, progressed);
    };
    
    /**
     * Provides an opportunity to observe the settling of a promise,
     * regardless of whether the promise is fulfilled or rejected.  Forwards
     * the resolution to the returned promise when the callback is done.
     * The callback can return a promise to defer completion.
     * @param {Any*} promise
     * @param {Function} callback to observe the resolution of the given
     * promise, takes no arguments.
     * @returns a promise for the resolution of the given promise when
     * ``fin`` is done.
     */
    Q.fin = // XXX legacy
    Q["finally"] = function (object, callback) {
        return Q(object)["finally"](callback);
    };
    
    Promise.prototype.fin = // XXX legacy
    Promise.prototype["finally"] = function (callback) {
        callback = Q(callback);
        return this.then(function (value) {
            return callback.fcall().then(function () {
                return value;
            });
        }, function (reason) {
            // TODO attempt to recycle the rejection with "this".
            return callback.fcall().then(function () {
                throw reason;
            });
        });
    };
    
    /**
     * Terminates a chain of promises, forcing rejections to be
     * thrown as exceptions.
     * @param {Any*} promise at the end of a chain of promises
     * @returns nothing
     */
    Q.done = function (object, fulfilled, rejected, progress) {
        return Q(object).done(fulfilled, rejected, progress);
    };
    
    Promise.prototype.done = function (fulfilled, rejected, progress) {
        var onUnhandledError = function (error) {
            // forward to a future turn so that ``when``
            // does not catch it and turn it into a rejection.
            Q.nextTick(function () {
                makeStackTraceLong(error, promise);
                if (Q.onerror) {
                    Q.onerror(error);
                } else {
                    throw error;
                }
            });
        };
    
        // Avoid unnecessary `nextTick`ing via an unnecessary `when`.
        var promise = fulfilled || rejected || progress ?
            this.then(fulfilled, rejected, progress) :
            this;
    
        if (typeof process === "object" && process && process.domain) {
            onUnhandledError = process.domain.bind(onUnhandledError);
        }
    
        promise.then(void 0, onUnhandledError);
    };
    
    /**
     * Causes a promise to be rejected if it does not get fulfilled before
     * some milliseconds time out.
     * @param {Any*} promise
     * @param {Number} milliseconds timeout
     * @param {Any*} custom error message or Error object (optional)
     * @returns a promise for the resolution of the given promise if it is
     * fulfilled before the timeout, otherwise rejected.
     */
    Q.timeout = function (object, ms, error) {
        return Q(object).timeout(ms, error);
    };
    
    Promise.prototype.timeout = function (ms, error) {
        var deferred = defer();
        var timeoutId = setTimeout(function () {
            if (!error || "string" === typeof error) {
                error = new Error(error || "Timed out after " + ms + " ms");
                error.code = "ETIMEDOUT";
            }
            deferred.reject(error);
        }, ms);
    
        this.then(function (value) {
            clearTimeout(timeoutId);
            deferred.resolve(value);
        }, function (exception) {
            clearTimeout(timeoutId);
            deferred.reject(exception);
        }, deferred.notify);
    
        return deferred.promise;
    };
    
    /**
     * Returns a promise for the given value (or promised value), some
     * milliseconds after it resolved. Passes rejections immediately.
     * @param {Any*} promise
     * @param {Number} milliseconds
     * @returns a promise for the resolution of the given promise after milliseconds
     * time has elapsed since the resolution of the given promise.
     * If the given promise rejects, that is passed immediately.
     */
    Q.delay = function (object, timeout) {
        if (timeout === void 0) {
            timeout = object;
            object = void 0;
        }
        return Q(object).delay(timeout);
    };
    
    Promise.prototype.delay = function (timeout) {
        return this.then(function (value) {
            var deferred = defer();
            setTimeout(function () {
                deferred.resolve(value);
            }, timeout);
            return deferred.promise;
        });
    };
    
    /**
     * Passes a continuation to a Node function, which is called with the given
     * arguments provided as an array, and returns a promise.
     *
     *      Q.nfapply(FS.readFile, [__filename])
     *      .then(function (content) {
     *      })
     *
     */
    Q.nfapply = function (callback, args) {
        return Q(callback).nfapply(args);
    };
    
    Promise.prototype.nfapply = function (args) {
        var deferred = defer();
        var nodeArgs = array_slice(args);
        nodeArgs.push(deferred.makeNodeResolver());
        this.fapply(nodeArgs).fail(deferred.reject);
        return deferred.promise;
    };
    
    /**
     * Passes a continuation to a Node function, which is called with the given
     * arguments provided individually, and returns a promise.
     * @example
     * Q.nfcall(FS.readFile, __filename)
     * .then(function (content) {
     * })
     *
     */
    Q.nfcall = function (callback /*...args*/) {
        var args = array_slice(arguments, 1);
        return Q(callback).nfapply(args);
    };
    
    Promise.prototype.nfcall = function (/*...args*/) {
        var nodeArgs = array_slice(arguments);
        var deferred = defer();
        nodeArgs.push(deferred.makeNodeResolver());
        this.fapply(nodeArgs).fail(deferred.reject);
        return deferred.promise;
    };
    
    /**
     * Wraps a NodeJS continuation passing function and returns an equivalent
     * version that returns a promise.
     * @example
     * Q.nfbind(FS.readFile, __filename)("utf-8")
     * .then(console.log)
     * .done()
     */
    Q.nfbind =
    Q.denodeify = function (callback /*...args*/) {
        var baseArgs = array_slice(arguments, 1);
        return function () {
            var nodeArgs = baseArgs.concat(array_slice(arguments));
            var deferred = defer();
            nodeArgs.push(deferred.makeNodeResolver());
            Q(callback).fapply(nodeArgs).fail(deferred.reject);
            return deferred.promise;
        };
    };
    
    Promise.prototype.nfbind =
    Promise.prototype.denodeify = function (/*...args*/) {
        var args = array_slice(arguments);
        args.unshift(this);
        return Q.denodeify.apply(void 0, args);
    };
    
    Q.nbind = function (callback, thisp /*...args*/) {
        var baseArgs = array_slice(arguments, 2);
        return function () {
            var nodeArgs = baseArgs.concat(array_slice(arguments));
            var deferred = defer();
            nodeArgs.push(deferred.makeNodeResolver());
            function bound() {
                return callback.apply(thisp, arguments);
            }
            Q(bound).fapply(nodeArgs).fail(deferred.reject);
            return deferred.promise;
        };
    };
    
    Promise.prototype.nbind = function (/*thisp, ...args*/) {
        var args = array_slice(arguments, 0);
        args.unshift(this);
        return Q.nbind.apply(void 0, args);
    };
    
    /**
     * Calls a method of a Node-style object that accepts a Node-style
     * callback with a given array of arguments, plus a provided callback.
     * @param object an object that has the named method
     * @param {String} name name of the method of object
     * @param {Array} args arguments to pass to the method; the callback
     * will be provided by Q and appended to these arguments.
     * @returns a promise for the value or error
     */
    Q.nmapply = // XXX As proposed by "Redsandro"
    Q.npost = function (object, name, args) {
        return Q(object).npost(name, args);
    };
    
    Promise.prototype.nmapply = // XXX As proposed by "Redsandro"
    Promise.prototype.npost = function (name, args) {
        var nodeArgs = array_slice(args || []);
        var deferred = defer();
        nodeArgs.push(deferred.makeNodeResolver());
        this.dispatch("post", [name, nodeArgs]).fail(deferred.reject);
        return deferred.promise;
    };
    
    /**
     * Calls a method of a Node-style object that accepts a Node-style
     * callback, forwarding the given variadic arguments, plus a provided
     * callback argument.
     * @param object an object that has the named method
     * @param {String} name name of the method of object
     * @param ...args arguments to pass to the method; the callback will
     * be provided by Q and appended to these arguments.
     * @returns a promise for the value or error
     */
    Q.nsend = // XXX Based on Mark Miller's proposed "send"
    Q.nmcall = // XXX Based on "Redsandro's" proposal
    Q.ninvoke = function (object, name /*...args*/) {
        var nodeArgs = array_slice(arguments, 2);
        var deferred = defer();
        nodeArgs.push(deferred.makeNodeResolver());
        Q(object).dispatch("post", [name, nodeArgs]).fail(deferred.reject);
        return deferred.promise;
    };
    
    Promise.prototype.nsend = // XXX Based on Mark Miller's proposed "send"
    Promise.prototype.nmcall = // XXX Based on "Redsandro's" proposal
    Promise.prototype.ninvoke = function (name /*...args*/) {
        var nodeArgs = array_slice(arguments, 1);
        var deferred = defer();
        nodeArgs.push(deferred.makeNodeResolver());
        this.dispatch("post", [name, nodeArgs]).fail(deferred.reject);
        return deferred.promise;
    };
    
    /**
     * If a function would like to support both Node continuation-passing-style and
     * promise-returning-style, it can end its internal promise chain with
     * `nodeify(nodeback)`, forwarding the optional nodeback argument.  If the user
     * elects to use a nodeback, the result will be sent there.  If they do not
     * pass a nodeback, they will receive the result promise.
     * @param object a result (or a promise for a result)
     * @param {Function} nodeback a Node.js-style callback
     * @returns either the promise or nothing
     */
    Q.nodeify = nodeify;
    function nodeify(object, nodeback) {
        return Q(object).nodeify(nodeback);
    }
    
    Promise.prototype.nodeify = function (nodeback) {
        if (nodeback) {
            this.then(function (value) {
                Q.nextTick(function () {
                    nodeback(null, value);
                });
            }, function (error) {
                Q.nextTick(function () {
                    nodeback(error);
                });
            });
        } else {
            return this;
        }
    };
    
    Q.noConflict = function() {
        throw new Error("Q.noConflict only works when Q is used as a global");
    };
    
    // All code before this point will be filtered from stack traces.
    var qEndingLine = captureLine();
    
    return Q;
    
    });
    
  provide("q", module.exports);
}(global));

// pakmanager:touch
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var fs = require("fs")
      , cons = require("constants")
    
    module.exports = touch
    touch.touchSync = touch.sync = function (f, options) {
      return touch(f, options)
    }
    
    touch.ftouch = ftouch
    touch.ftouchSync = function (fd, options) {
      return ftouch(fd, options)
    }
    
    function validOpts (options) {
      options = Object.create(options || {})
    
      // {mtime: true}, {ctime: true}
      // If set to something else, then treat as epoch ms value
      var now = new Date(options.time || Date.now())
      if (!options.atime && !options.mtime) {
        options.atime = options.mtime = now
      } else if (true === options.atime) {
        options.atime = now
      } else if (true === options.mtime) {
        options.mtime = now
      }
    
      var oflags = 0
      if (!options.force) {
        oflags = oflags | cons.O_RDWR
      }
      if (!options.nocreate) {
        oflags = oflags | cons.O_CREAT
      }
    
      options.oflags = oflags
      return options
    }
    
    function optionsRef (then, arg, options, cb) {
      if (!options.ref) return then(arg, options, cb)
    
      return cb
           ? fs.stat(options.ref, optionsRefcb(then, arg, options, cb))
           : optionsRefcb(then, arg, options)(null, fs.statSync(options.ref))
    }
    
    function optionsRefcb (then, arg, options, cb) { return function (er, s) {
      if (er) {
        er.path = er.file = options.ref
        return cb(er)
      }
      options.atime = options.atime && s.atime.getTime()
      options.mtime = options.mtime && s.mtime.getTime()
    
      // so we don't keep doing this.
      options.ref = null
    
      return then(arg, options, cb)
    }}
    
    function touch (f, options, cb) {
      if (typeof options === "function") cb = options, options = null
      options = validOpts(options)
      return optionsRef(touch_, f, validOpts(options), cb)
    }
    
    function touch_ (f, options, cb) {
      return openThenF(f, options, cb)
    }
    
    function openThenF (f, options, cb) {
      options.closeAfter = true
      return cb
           ? fs.open(f, options.oflags, openThenFcb(options, cb))
           : openThenFcb(options)(null, fs.openSync(f, options.oflags))
    }
    
    function openThenFcb (options, cb) { return function (er, fd) {
      if (er) {
        if (fd && options.closeAfter) fs.close(fd, function () {})
        return cb(er)
      }
      return ftouch(fd, options, cb)
    }}
    
    function ftouch (fd, options, cb) {
      if (typeof options === "function") cb = options, options = null
      return optionsRef(ftouch_, fd, validOpts(options), cb)
    }
    
    function ftouch_ (fd, options, cb) {
      // still not set.  leave as what the file already has.
      return fstatThenFutimes(fd, options, cb)
    }
    
    function fstatThenFutimes (fd, options, cb) {
      if (options.atime && options.mtime) return thenFutimes(fd, options, cb)
    
      return cb
           ? fs.fstat(fd, fstatThenFutimescb(fd, options, cb))
           : fstatThenFutimescb(fd, options)(null, fs.fstatSync(fd))
    }
    
    function fstatThenFutimescb (fd, options, cb) { return function (er, s) {
      if (er) {
        if (options.closeAfter) fs.close(fd, function () {})
        return cb(er)
      }
      options.atime = options.atime || s.atime.getTime()
      options.mtime = options.mtime || s.mtime.getTime()
      return thenFutimes(fd, options, cb)
    }}
    
    function thenFutimes (fd, options, cb) {
      if (typeof options.atime === "object") {
        options.atime = options.atime.getTime()
      }
      if (typeof options.mtime === "object") {
        options.mtime = options.mtime.getTime()
      }
    
      var a = parseInt(options.atime / 1000, 10)
        , m = parseInt(options.mtime / 1000, 10)
      return cb
           ? fs.futimes(fd, a, m, thenFutimescb(fd, options, cb))
           : thenFutimescb(fd, options)(null, fs.futimesSync(fd, a, m))
    }
    
    function thenFutimescb (fd, options, cb) { return function (er, res) {
      if (er) {
        if (options.closeAfter) fs.close(fd, function () {})
        return cb(er)
      }
      return finish(fd, options, res, cb)
    }}
    
    function finish (fd, options, res, cb) {
      return options.closeAfter ? finishClose(fd, options, res, cb)
           : cb ? cb(null, res)
           : res
    }
    
    function finishClose (fd, options, res, cb) {
      return cb
           ? fs.close(fd, finishClosecb(res, options, cb))
           : finishClosecb(res, options)(null, fs.closeSync(fd))
    }
    
    function finishClosecb (res, options, cb) { return function (er) {
      if (er) return cb(er)
      options.closeAfter = null
      return finish(null, options, res, cb)
    }}
    
  provide("touch", module.exports);
}(global));

// pakmanager:gapitoken
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    var jws = require('jws');
    var fs = require('fs');
    var request = require('request');
    
    var GAPI = function(options, callback) {
    	this.token = null;
    	this.token_expires = null;
    
    	this.iss = options.iss;
    	this.scope = options.scope;
    	this.sub = options.sub;
    	this.prn = options.prn;
    
        if (options.keyFile) {
            var self = this;
            process.nextTick(function() {
                fs.readFile(options.keyFile, function(err, res) {
                    if (err) { return callback(err); }
                    self.key = res;
                    callback();
                });
            });
        } else if (options.key) {
            this.key = options.key;
            process.nextTick(callback);
        } else {
            callback(new Error("Missing key, key or keyFile option must be provided!"));
        }
    };
    
    GAPI.prototype.getToken = function(callback) {
    	if (this.token && this.token_expires && (new Date()).getTime() < this.token_expires * 1000) {
            callback(null, this.token);
        } else {
            this.getAccessToken(callback);
        }
    };
    
    GAPI.prototype.getAccessToken = function(callback) {
        var self = this;
        var iat = Math.floor(new Date().getTime() / 1000);
    
        var payload = {
            iss: this.iss,
            scope: this.scope,
            aud: 'https://accounts.google.com/o/oauth2/token',
            exp: iat + 3600,
            iat: iat
        };
    
    	if(this.sub)
    		payload.sub = this.sub;
    
    	if(this.prn)
    		payload.prn = this.prn;
    
        var signedJWT = jws.sign({
            header: {alg: 'RS256', typ: 'JWT'},
            payload: payload,
            secret: this.key
        });
    
        var post_options = {
            url: 'https://accounts.google.com/o/oauth2/token',
            method: 'POST',
            strictSSL: false,
            form: {
              'grant_type': 'urn:ietf:params:oauth:grant-type:jwt-bearer',
              'assertion': signedJWT
            },
            headers: {
              'Content-Type': 'application/x-www-form-urlencoded'
            }
        };
    
        request(post_options, function(error, response, body) {
          if(error){
            self.token = null;
            self.token_expires = null;
            callback(error, null);
          } else {
            try {
              var d = JSON.parse(body);
              if (d.error) {
                self.token = null;
                self.token_expires = null;
                callback(d.error, null);
              } else {
                self.token = d.access_token;
                self.token_expires = iat + 3600;
                callback(null, self.token);
              }
            } catch (e) {
              callback(e, null);
            }
          }
        });
    };
    
    module.exports = GAPI;
    
  provide("gapitoken", module.exports);
}(global));

// pakmanager:google-auth-library/lib/transporters.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Copyright 2012 Google Inc. All Rights Reserved.
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    
    'use strict';
    
    var request = require('request'),
      pkg = require('../package.json');
    
    /**
     * Default transporter constructor.
     * Wraps request and callback functions.
     */
    function DefaultTransporter() {}
    
    /**
     * Default user agent.
     */
    DefaultTransporter.prototype.USER_AGENT =
      'google-api-nodejs-client/' + pkg.version;
    
    /**
     * Configures request options before making a request.
     * @param {object} opts Options to configure.
     * @return {object} Configured options.
     */
    DefaultTransporter.prototype.configure = function(opts) {
      // set transporter user agent
      opts.headers = opts.headers || {};
      opts.headers['User-Agent'] = opts.headers['User-Agent'] ?
        opts.headers['User-Agent'] + ' ' + this.USER_AGENT : this.USER_AGENT;
      return opts;
    };
    
    /**
     * Makes a request with given options and invokes callback.
     * @param {object} opts Options.
     * @param {Function=} opt_callback Optional callback.
     * @return {Request} Request object
     */
    DefaultTransporter.prototype.request = function(opts, opt_callback) {
      opts = this.configure(opts);
      return request(opts.uri || opts.url, opts, this.wrapCallback_(opt_callback));
    };
    
    /**
     * Wraps the response callback.
     * @param {Function=} opt_callback Optional callback.
     * @return {Function} Wrapped callback function.
     * @private
     */
    DefaultTransporter.prototype.wrapCallback_ = function(opt_callback) {
      return function(err, res, body) {
        if (err || !body) {
          return opt_callback && opt_callback(err, body, res);
        }
        // Only and only application/json responses should
        // be decoded back to JSON, but there are cases API back-ends
        // responds without proper content-type.
        try {
          body = JSON.parse(body);
        } catch (err) { /* no op */ }
    
        if (body && body.error) {
          if (typeof body.error === 'string') {
            err = new Error(body.error);
            err.code = res.statusCode;
    
          } else if (Array.isArray(body.error.errors)) {
            err = new Error(body.error.errors.map(
                             function(err) { return err.message; }
                           ).join('\n'));
            err.code = body.error.code;
            err.errors = body.error.errors;
    
          } else {
            err = new Error(body.error.message);
            err.code = body.error.code || res.statusCode;
          }
    
          body = null;
    
        } else if (res.statusCode >= 500) {
          // Consider all '500 responses' errors.
          err = new Error(body);
          err.code = res.statusCode;
          body = null;
        }
    
        if (opt_callback) {
          opt_callback(err, body, res);
        }
      };
    };
    
    /**
     * Exports DefaultTransporter.
     */
    module.exports = DefaultTransporter;
    
  provide("google-auth-library/lib/transporters.js", module.exports);
}(global));

// pakmanager:google-auth-library/lib/auth/authclient.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Copyright 2012 Google Inc. All Rights Reserved.
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    
    'use strict';
    
    var DefaultTransporter =  require('google-auth-library/lib/transporters.js');
    
    /**
     * Base class for authentication clients.
     */
    function AuthClient() {
      this.transporter = new DefaultTransporter();
    }
    
    /**
     * Provides an alternative request
     * implementations with auth credentials.
     */
    AuthClient.prototype.request = function() {
      throw new Error('Not implemented yet.');
    };
    
    /**
     * Sets auth credentials.
     * @param {object} credentials Credentials.
     */
    AuthClient.prototype.setCredentials = function(credentials) {
      this.credentials = credentials;
    };
    
    /**
     * Export AuthClient.
     */
    module.exports = AuthClient;
    
  provide("google-auth-library/lib/auth/authclient.js", module.exports);
}(global));

// pakmanager:google-auth-library/lib/auth/loginticket.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Copyright 2014 Google Inc. All Rights Reserved.
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    
    'use strict';
    
    var USER_ATTR = 'sub';
    
    /**
     * Create a simple class to extract user ID from an ID Token
     *
     * @param {string} env Envelope of the jwt
     * @param {string} pay Payload of the jwt
     * @constructor
     */
    function LoginTicket(env, pay) {
      var envelope = env;
      var payload = pay;
    
      this.getEnvelope = function() {
        return envelope;
      };
    
      this.getPayload = function() {
        return payload;
      };
    }
    
    /**
     * Create a simple class to extract user ID from an ID Token
     *
     * @return {string} The user ID
     */
    LoginTicket.prototype.getUserId = function() {
      var payload = this.getPayload();
      if (payload && payload[USER_ATTR]) {
        return payload[USER_ATTR];
      }
    
      return null;
    };
    
    /**
     * Returns attributes from the login ticket.  This can contain
     * various information about the user session.
     *
     * @return {Object} The envelope and payload
     */
    LoginTicket.prototype.getAttributes = function() {
      return {
        'envelope': this.getEnvelope(),
        'payload': this.getPayload()
      };
    };
    
    /**
     * Export LoginTicket.
     */
    module.exports = LoginTicket;
    
  provide("google-auth-library/lib/auth/loginticket.js", module.exports);
}(global));

// pakmanager:google-auth-library/lib/pemverifier.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Copyright 2014 Google Inc. All Rights Reserved.
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    
    'use strict';
    
    var crypto = require('crypto');
    
    function PemVerifier() {
      this.verify = function(pubkey, data, signature, encoding) {
        var verifier = crypto.createVerify('sha256');
        verifier.update(data);
        return verifier.verify(pubkey, signature, encoding);
      };
    }
    
    /**
     * Export PemVerifier.
     */
    module.exports = PemVerifier;
    
  provide("google-auth-library/lib/pemverifier.js", module.exports);
}(global));

// pakmanager:google-auth-library/lib/auth/oauth2client.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Copyright 2012 Google Inc. All Rights Reserved.
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    
    'use strict';
    
    var AuthClient =  require('google-auth-library/lib/auth/authclient.js');
    var LoginTicket =  require('google-auth-library/lib/auth/loginticket.js');
    var noop = require('lodash.noop');
    var PemVerifier =  require('google-auth-library/lib/pemverifier.js');
    var querystring = require('querystring');
    var util = require('util');
    
    var certificateCache = null;
    var certificateExpiry = null;
    
    /**
     * Handles OAuth2 flow for Google APIs.
     *
     * @param {string} clientId The authentication client ID.
     * @param {string} clientSecret The authentication client secret.
     * @param {string} redirectUri The URI to redirect to after completing the auth request.
     * @param {Object} opt_options optional options for overriding the given parameters.
     * @constructor
     */
    function OAuth2Client(clientId, clientSecret, redirectUri, opt_opts) {
      OAuth2Client.super_.call(this);
    
      this.clientId_ = clientId;
      this.clientSecret_ = clientSecret;
      this.redirectUri_ = redirectUri;
      this.opts = opt_opts || {};
      this.credentials = {};
    }
    
    /**
     * Inherit from AuthClient.
     */
    util.inherits(OAuth2Client, AuthClient);
    
    /**
     * The base URL for auth endpoints.
     * @const
     * @private
     */
    OAuth2Client.GOOGLE_OAUTH2_AUTH_BASE_URL_ =
      'https://accounts.google.com/o/oauth2/auth';
    
    /**
     * The base endpoint for token retrieval.
     * @const
     * @private
     */
    OAuth2Client.GOOGLE_OAUTH2_TOKEN_URL_ =
      'https://accounts.google.com/o/oauth2/token';
    
    /**
     * The base endpoint to revoke tokens.
     * @const
     * @private
     */
    OAuth2Client.GOOGLE_OAUTH2_REVOKE_URL_ =
      'https://accounts.google.com/o/oauth2/revoke';
    
    /**
     * Google Sign on certificates.
     * @const
     * @private
     */
    OAuth2Client.GOOGLE_OAUTH2_FEDERATED_SIGNON_CERTS_URL_ =
      'https://www.googleapis.com/oauth2/v1/certs';
    
    /**
     * Clock skew - five minutes in seconds
     * @const
     * @private
     */
    OAuth2Client.CLOCK_SKEW_SECS_ = 300;
    
    /**
     * Max Token Lifetime is one day in seconds
     * @const
     * @private
     */
    OAuth2Client.MAX_TOKEN_LIFETIME_SECS_ = 86400;
    
    /**
     * The oauth token issuer.
     * @const
     * @private
     */
    OAuth2Client.ISSUER_ = 'accounts.google.com';
    
    /**
     * Generates URL for consent page landing.
     * @param {object=} opt_opts Options.
     * @return {string} URL to consent page.
     */
    OAuth2Client.prototype.generateAuthUrl = function(opt_opts) {
      var opts = opt_opts || {};
      opts.response_type = opts.response_type || 'code';
      opts.client_id = opts.client_id || this.clientId_;
      opts.redirect_uri = opts.redirect_uri || this.redirectUri_;
    
      // Allow scopes to be passed either as array or a string
      if (opts.scope instanceof Array) {
        opts.scope = opts.scope.join(' ');
      }
    
      var rootUrl = this.opts.authBaseUrl ||
        OAuth2Client.GOOGLE_OAUTH2_AUTH_BASE_URL_;
    
      return rootUrl + '?' + querystring.stringify(opts);
    };
    
    /**
     * Gets the access token for the given code.
     * @param {string} code The authorization code.
     * @param {function=} opt_callback Optional callback fn.
     */
    OAuth2Client.prototype.getToken = function(code, opt_callback) {
      var uri = this.opts.tokenUrl || OAuth2Client.GOOGLE_OAUTH2_TOKEN_URL_;
      var values = {
        code: code,
        client_id: this.clientId_,
        client_secret: this.clientSecret_,
        redirect_uri: this.redirectUri_,
        grant_type: 'authorization_code'
      };
    
      this.transporter.request({
        method: 'POST',
        uri: uri,
        form: values,
        json: true
      }, function(err, tokens, response) {
        if (!err && tokens && tokens.expires_in) {
          tokens.expiry_date = ((new Date()).getTime() + (tokens.expires_in * 1000));
          delete tokens.expires_in;
        }
        var done = opt_callback || noop;
        done(err, tokens, response);
      });
    };
    
    /**
     * Refreshes the access token.
     * @param {string} refresh_token Existing refresh token.
     * @param {function=} opt_callback Optional callback.
     * @private
     */
    OAuth2Client.prototype.refreshToken_ = function(refresh_token, opt_callback) {
      var uri = this.opts.tokenUrl || OAuth2Client.GOOGLE_OAUTH2_TOKEN_URL_;
      var values = {
        refresh_token: refresh_token,
        client_id: this.clientId_,
        client_secret: this.clientSecret_,
        grant_type: 'refresh_token'
      };
    
      // request for new token
      return this.transporter.request({
        method: 'POST',
        uri: uri,
        form: values,
        json: true
      }, function(err, tokens, response) {
        if (!err && tokens && tokens.expires_in) {
          tokens.expiry_date = ((new Date()).getTime() + (tokens.expires_in * 1000));
          delete tokens.expires_in;
        }
        var done = opt_callback || noop;
        done(err, tokens, response);
      });
    };
    
    /**
     * Retrieves the access token using refresh token
     *
     * @deprecated use getRequestMetadata instead.
     * @param {function} callback callback
     */
    OAuth2Client.prototype.refreshAccessToken = function(callback) {
      var that = this;
    
      if (!this.credentials.refresh_token) {
        callback(new Error('No refresh token is set.'), null);
        return;
      }
    
      this.refreshToken_(this.credentials.refresh_token, function(err, result, response) {
        if (err) {
          callback(err, null, response);
        } else {
          var tokens = result;
          tokens.refresh_token = that.credentials.refresh_token;
          that.credentials = tokens;
          callback(null, that.credentials, response);
        }
      });
    };
    
    /**
     * Get a non-expired access token, after refreshing if necessary
     *
     * @param {function} callback Callback to call with the access token
     */
    OAuth2Client.prototype.getAccessToken = function(callback) {
      var credentials = this.credentials;
      var expiryDate = credentials.expiry_date;
    
      // if no expiry time, assume it's not expired
      var isTokenExpired = expiryDate ? expiryDate <= (new Date()).getTime() : false;
    
      if (!credentials.access_token && !credentials.refresh_token) {
        return callback(new Error('No access or refresh token is set.'), null);
      }
    
      var shouldRefresh = !credentials.access_token || isTokenExpired;
      if (shouldRefresh && credentials.refresh_token) {
        if (!this.credentials.refresh_token) {
          return callback(new Error('No refresh token is set.'), null);
        }
    
        this.refreshAccessToken(function(err, tokens, response) {
          if (err) {
            return callback(err, null, response);
          }
          if (!tokens || (tokens && !tokens.access_token)) {
            return callback(new Error('Could not refresh access token.'), null, response);
          }
          return callback(null, tokens.access_token, response);
        });
      } else {
        return callback(null, credentials.access_token, null);
      }
    };
    
    /**
     * getRequestMetadata obtains auth metadata to be used by requests.
     *
     * getRequestMetadata is the main authentication interface.  It takes an
     * optional uri which when present is the endpoint being accessed, and a
     * callback func(err, metadata_obj, response) where metadata_obj contains
     * authorization metadata fields and response is an optional response object.
     *
     * In OAuth2Client, metadata_obj has the form.
     *
     * {Authorization: 'Bearer <access_token_value>'}
     *
     * @param {string} opt_uri the Uri being authorized
     * @param {function} metadataCb the func described above
     */
    OAuth2Client.prototype.getRequestMetadata = function(opt_uri, metadataCb) {
      var that = this;
      var thisCreds = this.credentials;
    
      if (!thisCreds.access_token && !thisCreds.refresh_token) {
        return metadataCb(new Error('No access or refresh token is set.'), null);
      }
    
      // if no expiry time, assume it's not expired
      var expiryDate = thisCreds.expiry_date;
      var isTokenExpired = expiryDate ? expiryDate <= (new Date()).getTime() : false;
    
      if (thisCreds.access_token && !isTokenExpired) {
        thisCreds.token_type = thisCreds.token_type || 'Bearer';
        var headers = {'Authorization': thisCreds.token_type + ' ' + thisCreds.access_token };
        return metadataCb(null, headers , null);
      }
    
      return this.refreshToken_(thisCreds.refresh_token, function(err, tokens, response) {
        if (err) {
          return metadataCb(err, null, response);
        } else {
          if (!tokens || (tokens && !tokens.access_token)) {
            return metadataCb(new Error('Could not refresh access token.'), null, response);
          }
    
          var credentials = that.credentials;
          credentials.token_type = credentials.token_type || 'Bearer';
          tokens.refresh_token = credentials.refresh_token;
          that.credentials = tokens;
          var headers = {'Authorization': credentials.token_type + ' ' + tokens.access_token };
          return metadataCb(err, headers , response);
        }
      });
    };
    
    /**
     * Revokes the access given to token.
     * @param {string} token The existing token to be revoked.
     * @param {function=} opt_callback Optional callback fn.
     */
    OAuth2Client.prototype.revokeToken = function(token, opt_callback) {
      this.transporter.request({
        uri: OAuth2Client.GOOGLE_OAUTH2_REVOKE_URL_ +
          '?' + querystring.stringify({ token: token }),
        json: true
      }, opt_callback);
    };
    
    /**
     * Revokes access token and clears the credentials object
     * @param  {Function=} callback callback
     */
    OAuth2Client.prototype.revokeCredentials = function(callback) {
      var token = this.credentials.access_token;
      this.credentials = {};
      if (token) {
        this.revokeToken(token, callback);
      } else {
        callback(new Error('No access token to revoke.'), null);
      }
    };
    
    /**
     * Provides a request implementation with OAuth 2.0 flow.
     * If credentials have a refresh_token, in cases of HTTP
     * 401 and 403 responses, it automatically asks for a new
     * access token and replays the unsuccessful request.
     * @param {object} opts Request options.
     * @param {function} callback callback.
     * @return {Request} Request object
     */
    OAuth2Client.prototype.request = function(opts, callback) {
      var that = this;
    
      // Hook the callback routine to call the _postRequest method.
      var postRequestCb = function(err, body, resp) {
        that._postRequest(err, body, resp, callback);
      };
    
      var authCb = function(err, headers, response) {
        if (err) {
          postRequestCb(err, null, response);
        } else {
          if (headers) {
            opts.headers = opts.headers || {};
            opts.headers.Authorization = headers.Authorization;
          }
          return that._makeRequest(opts, postRequestCb);
        }
      };
      var unusedUri = null;
      return this.getRequestMetadata(unusedUri, authCb);
    };
    
    /**
     * Makes a request without paying attention to refreshing or anything
     * Assumes that all credentials are set correctly.
     * @param  {object}   opts     Options for request
     * @param  {Function} callback callback function
     * @return {Request}           The request object created
     */
    OAuth2Client.prototype._makeRequest = function(opts, callback) {
      return this.transporter.request(opts, callback);
    };
    
    /**
     * Allows inheriting classes to inspect and alter the request result.
     * @param {object} err Error result.
     * @param {object} result The result.
     * @param {object} result The HTTP response.
     * @param {Function} callback The callback.
     * @private
     */
    OAuth2Client.prototype._postRequest = function(err, result, response, callback) {
      callback(err, result, response);
    };
    
    /**
     * Verify id token is token by checking the certs and audience
     * @param {string} idToken ID Token.
     * @param {string} audience The audience to verify against the ID Token
     * @param {function=} callback Callback supplying GoogleLogin if successful
     */
    OAuth2Client.prototype.verifyIdToken = function(idToken, audience, callback) {
      if (!idToken || !callback) {
        throw new Error('The verifyIdToken method requires both ' +
          'an ID Token and a callback method');
      }
    
      this.getFederatedSignonCerts(function(err, certs) {
        if (err) {
          callback(err, null);
        }
        var login;
        try {
          login = this.verifySignedJwtWithCerts(idToken, certs, audience,
            OAuth2Client.ISSUER_);
        } catch (err) {
          callback(err);
          return;
        }
    
        callback(null, login);
      }.bind(this));
    };
    
    /**
     * Gets federated sign-on certificates to use for verifying identity tokens.
     * Returns certs as array structure, where keys are key ids, and values
     * are PEM encoded certificates.
     * @param {function=} callback Callback supplying the certificates
     */
    OAuth2Client.prototype.getFederatedSignonCerts = function(callback) {
      var nowTime = (new Date()).getTime();
      if (certificateExpiry && (nowTime < certificateExpiry.getTime())) {
        callback(null, certificateCache);
        return;
      }
    
      this.transporter.request({
        method: 'GET',
        uri: OAuth2Client.GOOGLE_OAUTH2_FEDERATED_SIGNON_CERTS_URL_,
        json: true
      }, function(err, body, response) {
        if (err) {
          callback('Failed to retrieve verification certificates: ' + err, null, response);
          return;
        }
    
        var cacheControl = response.headers['cache-control'];
        var cacheAge = -1;
        if (cacheControl) {
          var pattern = new RegExp('max-age=([0-9]*)');
          var regexResult = pattern.exec(cacheControl);
          if (regexResult.length === 2) {
            // Cache results with max-age (in seconds)
            cacheAge = regexResult[1] * 1000; // milliseconds
          }
        }
    
        var now = new Date();
        certificateExpiry = cacheAge === -1 ? null : new Date(now.getTime() + cacheAge);
        certificateCache = body;
        callback(null, body, response);
      });
    };
    
    /**
     * Verify the id token is signed with the correct certificate
     * and is from the correct audience.
     * @param {string} jwt The jwt to verify (The ID Token in this case).
     * @param {array} certs The array of certs to test the jwt against.
     * @param {string} requiredAudience The audience to test the jwt against.
     * @param {string} issuer The issuer of the jwt (Optional).
     * @param {string} maxExpiry The max expiry the certificate can be (Optional).
     * @return {LoginTicket} Returns a LoginTicket on verification.
     */
    OAuth2Client.prototype.verifySignedJwtWithCerts =
      function(jwt, certs, requiredAudience, issuer, maxExpiry) {
    
        if (!maxExpiry) {
          maxExpiry = OAuth2Client.MAX_TOKEN_LIFETIME_SECS_;
        }
    
        var segments = jwt.split('.');
        if (segments.length !== 3) {
          throw new Error('Wrong number of segments in token: ' + jwt);
        }
        var signed = segments[0] + '.' + segments[1];
    
        var signature = segments[2];
    
        var envelope, payload;
        try {
          envelope = JSON.parse(this.decodeBase64(segments[0]));
        } catch (err) { }
    
        if (!envelope) {
          throw new Error('Can\'t parse token envelope: ' + segments[0]);
        }
    
        try {
          payload = JSON.parse(this.decodeBase64(segments[1]));
        } catch (err) { }
        if (!payload) {
          throw new Error('Can\'t parse token payload: ' + segments[1]);
        }
    
        var pem = certs[envelope.kid];
        var pemVerifier = new PemVerifier();
        var verified = pemVerifier.verify(pem, signed, signature, 'base64');
    
        if (!verified) {
          throw new Error('Invalid token signature: ' + jwt);
        }
    
        if (!payload.iat) {
          throw new Error('No issue time in token: ' + JSON.stringify(payload));
        }
    
        if (!payload.exp) {
          throw new Error('No expiration time in token: ' + JSON.stringify(payload));
        }
    
        var iat = parseInt(payload.iat, 10);
        var exp = parseInt(payload.exp, 10);
        var now = new Date().getTime() / 1000;
    
        if (exp >= now + maxExpiry) {
          throw new Error('Expiration time too far in future: ' +
            JSON.stringify(payload));
        }
    
        var earliest = iat - OAuth2Client.CLOCK_SKEW_SECS_;
        var latest = exp + OAuth2Client.CLOCK_SKEW_SECS_;
    
        if (now < earliest) {
          throw new Error('Token used too early, ' + now + ' < ' + earliest + ': ' +
            JSON.stringify(payload));
        }
    
        if (now > latest) {
          throw new Error('Token used too late, ' + now + ' > ' + latest + ': ' +
            JSON.stringify(payload));
        }
    
        if (issuer && issuer !== payload.iss) {
          throw new Error('Invalid issuer, ' + issuer + ' != ' + payload.iss);
        }
    
        // Check the audience matches if we have one
        if (typeof requiredAudience !== 'undefined' && requiredAudience !== null) {
          var aud = payload.aud;
          if (aud !== requiredAudience) {
            throw new Error('Wrong recipient, payload audience != requiredAudience');
          }
        }
    
        return new LoginTicket(envelope, payload);
      };
    
    /**
     * This is a utils method to decode a base64 string
     * @param {string} b64String The string to base64 decode
     * @return {string} The decoded string
     */
    OAuth2Client.prototype.decodeBase64 = function(b64String) {
      var buffer = new Buffer(b64String, 'base64');
      return buffer.toString('utf-8');
    };
    
    /**
     * Export OAuth2Client.
     */
    module.exports = OAuth2Client;
    
  provide("google-auth-library/lib/auth/oauth2client.js", module.exports);
}(global));

// pakmanager:google-auth-library/lib/auth/jwtaccess.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Copyright 2015 Google Inc. All Rights Reserved.
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    
    'use strict';
    
    var jws = require('jws');
    var noop = require('lodash.noop');
    
    /**
     * JWTAccess service account credentials.
     *
     * Create a new access token by using the credential to create a new JWT token
     * that's recognized as the access token.
     *
     * @param {string=} email the service account email address.
     * @param {string=} key the private key that will be used to sign the token.
     * @constructor
     */
    function JWTAccess(email, key) {
      this.email = email;
      this.key = key;
    }
    
    /**
     * Indicates whether the credential requires scopes to be created by calling
     * createdScoped before use.
     *
     * @return {boolean} always false
     */
    JWTAccess.prototype.createScopedRequired = function() {
      // JWT Header authentication does not use scopes.
      return false;
    };
    
    /**
     * Get a non-expired access token, after refreshing if necessary
     *
     * @param {string} authURI the URI being authorized
     * @param {function} metadataCb a callback invoked with the jwt
     *                   request metadata.
     */
    JWTAccess.prototype.getRequestMetadata = function(authURI, metadataCb) {
      var iat = Math.floor(new Date().getTime() / 1000);
      var exp = iat + 3600; // 3600 seconds = 1 hour
    
      // The payload used for signed JWT headers has:
      // iss == sub == <client email>
      // aud == <the authorization uri>
      var payload = {
        iss: this.email,
        sub: this.email,
        aud: authURI,
        exp: exp,
        iat: iat
      };
      var assertion = {
        header: {
          alg: 'RS256',
          typ: 'JWT'
        },
        payload: payload,
        secret: this.key
      };
    
      // Sign the jwt and invoke metadataCb with it.
      return this._signJWT(assertion, function(err, signedJWT) {
        if (!err) {
          return metadataCb(null, {'Authorization': 'Bearer ' + signedJWT});
        } else {
          return metadataCb(err, null);
        }
      });
    };
    
    /**
     * Create a JWTAccess credentials instance using the given input options.
     * @param {object=} json The input object.
     * @param {function=} opt_callback Optional callback.
     */
    JWTAccess.prototype.fromJSON = function(json, opt_callback) {
      var that = this;
      var done = opt_callback || noop;
      if (!json) {
        done(new Error(
          'Must pass in a JSON object containing the service account auth settings.'));
        return;
      }
      if (!json.client_email) {
        done(new Error(
          'The incoming JSON object does not contain a client_email field'));
        return;
      }
      if (!json.private_key) {
        done(new Error(
          'The incoming JSON object does not contain a private_key field'));
        return;
      }
      // Extract the relevant information from the json key file.
      that.email = json.client_email;
      that.key = json.private_key;
      done();
    };
    
    /**
     * Create a JWTAccess credentials instance using the given input stream.
     * @param {object=} stream The input stream.
     * @param {function=} opt_callback Optional callback.
     */
    JWTAccess.prototype.fromStream = function(stream, opt_callback) {
      var that = this;
      var done = opt_callback || noop;
      if (!stream) {
        process.nextTick(function() {
            done(
                new Error('Must pass in a stream containing the service account auth settings.'));
        });
        return;
      }
      var s = '';
      stream.setEncoding('utf8');
      stream.on('data', function (chunk) {
        s += chunk;
      });
      stream.on('end', function () {
        try {
          var data = JSON.parse(s);
          that.fromJSON(data, opt_callback);
        } catch (err) {
          done(err);
        }
      });
    };
    
    /**
     * Sign the JWT object, returning any errors in the callback.
     *
     * signedJwtFn is a callback function(err, signedJWT); it is called with an
     * error if there is an exception during signing.
     *
     * @param  {object}   assertion   The assertion to sign
     * @param  {Function} signedJwtFn  fn(err, signedJWT)
     */
    JWTAccess.prototype._signJWT = function(assertion, signedJwtFn) {
      try {
        return signedJwtFn(null, jws.sign(assertion));
      } catch (err) {
        return signedJwtFn(err);
      }
    };
    
    /**
     * Export JWTAccess.
     */
    module.exports = JWTAccess;
    
  provide("google-auth-library/lib/auth/jwtaccess.js", module.exports);
}(global));

// pakmanager:google-auth-library/lib/auth/jwtclient.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Copyright 2013 Google Inc. All Rights Reserved.
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    
    'use strict';
    
    var Auth2Client =  require('google-auth-library/lib/auth/oauth2client.js');
    var gToken = require('gtoken');
    var JWTAccess =  require('google-auth-library/lib/auth/jwtaccess.js');
    var noop = require('lodash.noop');
    var util = require('util');
    
    
    /**
     * JWT service account credentials.
     *
     * Retrieve access token using gtoken.
     *
     * @param {string=} email service account email address.
     * @param {string=} keyFile path to private key file.
     * @param {string=} key value of key
     * @param {(string|array)=} scopes list of requested scopes or a single scope.
     * @param {string=} subject impersonated account's email address.
     * @constructor
     */
    function JWT(email, keyFile, key, scopes, subject) {
      JWT.super_.call(this);
      this.email = email;
      this.keyFile = keyFile;
      this.key = key;
      this.scopes = scopes;
      this.subject = subject;
      this.gToken = gToken;
    
      this.credentials = {
        refresh_token: 'jwt-placeholder',
        expiry_date: 1
      };
    }
    
    /**
     * Inherit from Auth2Client.
     */
    util.inherits(JWT, Auth2Client);
    
    /**
     * Creates a copy of the credential with the specified scopes.
     * @param {(string|array)=} scopes List of requested scopes or a single scope.
     * @return {object} The cloned instance.
     */
    JWT.prototype.createScoped = function(scopes) {
      return new JWT(this.email, this.keyFile, this.key, scopes, this.subject);
    };
    
    /**
     * Obtains the metadata to be sent with the request.
     *
     * @param {string} opt_uri the URI being authorized.
     * @param {function} metadataCb
     */
    JWT.prototype.getRequestMetadata = function(opt_uri, metadataCb) {
      if (this.createScopedRequired() && opt_uri) {
        // no scopes have been set, but a uri has been provided.  Use JWTAccess credentials.
        var alt = new JWTAccess(this.email, this.key);
        return alt.getRequestMetadata(opt_uri, metadataCb);
      } else {
        return JWT.super_.prototype.getRequestMetadata.call(
            this, opt_uri, metadataCb);
      }
    };
    
    /**
     * Indicates whether the credential requires scopes to be created by calling createdScoped before
     * use.
     * @return {boolean} false if createScoped does not need to be called.
     */
    JWT.prototype.createScopedRequired = function() {
      // If scopes is null, always return true.
      if (this.scopes) {
        // For arrays, check the array length.
        if (this.scopes instanceof Array) {
          return this.scopes.length === 0;
        }
    
        // For others, convert to a string and check the length.
        return String(this.scopes).length === 0;
      }
    
      return true;
    };
    
    /**
     * Get the initial access token using gToken.
     * @param {function=} opt_callback Optional callback.
     */
    JWT.prototype.authorize = function(opt_callback) {
      var that = this;
      var done = opt_callback || noop;
    
      that.refreshToken_(null, function(err, result) {
        if (!err) {
          that.credentials = result;
          that.credentials.refresh_token = 'jwt-placeholder';
          that.key = that.gtoken.key;
          that.email = that.gtoken.iss;
        }
        done(err, result);
      });
    };
    
    
    /**
     * Refreshes the access token.
     * @param {object=} ignored_
     * @param {function=} opt_callback Optional callback.
     * @private
     */
    JWT.prototype.refreshToken_ = function(ignored_, opt_callback) {
      var done = opt_callback || noop;
    
      return this._createGToken(function(err, gToken) {
        if (err) {
          return done(err);
        } else {
          return gToken.getToken(function (err, token) {
            return done(err, {
              access_token: token,
              token_type: 'Bearer',
              expiry_date: gToken.expires_at
            });
          });
        }
      });
    };
    
    
    /**
     * Create a JWT credentials instance using the given input options.
     * @param {object=} json The input object.
     * @param {function=} opt_callback Optional callback.
     */
    JWT.prototype.fromJSON = function(json, opt_callback) {
      var that = this;
      var done = opt_callback || noop;
      if (!json) {
        done(new Error(
          'Must pass in a JSON object containing the service account auth settings.'));
        return;
      }
      if (!json.client_email) {
        done(new Error(
          'The incoming JSON object does not contain a client_email field'));
        return;
      }
      if (!json.private_key) {
        done(new Error(
          'The incoming JSON object does not contain a private_key field'));
        return;
      }
      // Extract the relevant information from the json key file.
      that.email = json.client_email;
      that.key = json.private_key;
      done();
    };
    
    /**
     * Create a JWT credentials instance using the given input stream.
     * @param {object=} stream The input stream.
     * @param {function=} opt_callback Optional callback.
     */
    JWT.prototype.fromStream = function(stream, opt_callback) {
      var that = this;
      var done = opt_callback || noop;
    
      if (!stream) {
        process.nextTick(function() {
          done(
            new Error('Must pass in a stream containing the service account auth settings.'));
        });
        return;
      }
      var s = '';
      stream.setEncoding('utf8');
      stream.on('data', function (chunk) {
        s += chunk;
      });
      stream.on('end', function () {
        try {
          var data = JSON.parse(s);
          that.fromJSON(data, opt_callback);
        } catch (err) {
          done(err);
        }
      });
    };
    
    /**
     * Creates the gToken instance if it has not been created already.
     * @param {function=} callback Callback.
     * @private
     */
    JWT.prototype._createGToken = function(callback) {
      if (this.gtoken) {
        return callback(null, this.gtoken);
      } else {
        this.gtoken = this.gToken({
          iss: this.email,
          sub: this.subject,
          scope: this.scopes,
          keyFile: this.keyFile,
          key: this.key
        });
        return callback(null, this.gtoken);
      }
    };
    
    /**
     * Export JWT.
     */
    module.exports = JWT;
    
  provide("google-auth-library/lib/auth/jwtclient.js", module.exports);
}(global));

// pakmanager:google-auth-library/lib/auth/computeclient.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Copyright 2013 Google Inc. All Rights Reserved.
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    
    'use strict';
    
    var Auth2Client =  require('google-auth-library/lib/auth/oauth2client.js');
    var util = require('util');
    
    /**
     * Google Compute Engine metadata server token endpoint.
     * @private
     */
    Compute.GOOGLE_OAUTH2_TOKEN_URL_ =
      'http://metadata/computeMetadata/v1beta1/instance/service-accounts/default/token';
    
    /**
     * Google Compute Engine service account credentials.
     *
     * Retrieve access token from the metadata server.
     * See: https://developers.google.com/compute/docs/authentication
     * @constructor@constructor
     */
    function Compute() {
      Compute.super_.call(this);
      // Start with an expired refresh token, which will automatically be refreshed
      // before the first API call is made.
      this.credentials = {
        refresh_token: 'compute-placeholder',
        expiry_date: 1
      };
    
      // Hook the post request method so we can provide better error messages.
      this._postRequest = this._injectErrorMessage;
    }
    
    /**
     * Inherit from Auth2Client.
     */
    util.inherits(Compute, Auth2Client);
    
    /**
     * Indicates whether the credential requires scopes to be created by calling createdScoped before
     * use.
     * @return {object} The cloned instance.
     */
    Compute.prototype.createScopedRequired = function() {
      // On compute engine, scopes are specified at the compute instance's creation time,
      // and cannot be changed. For this reason, always return false.
      return false;
    };
    
    /**
     * Refreshes the access token.
     * @param {object=} ignored_
     * @param {function=} opt_callback Optional callback.
     * @private
     */
    Compute.prototype.refreshToken_ = function(ignored_, opt_callback) {
      var uri = this.opts.tokenUrl || Compute.GOOGLE_OAUTH2_TOKEN_URL_;
      // request for new token
      this.transporter.request({
        method: 'GET',
        uri: uri,
        json: true
      }, function(err, tokens, response) {
        if (!err && tokens && tokens.expires_in) {
          tokens.expiry_date = ((new Date()).getTime() + (tokens.expires_in * 1000));
          delete tokens.expires_in;
        }
    
        if (opt_callback) {
          opt_callback(err, tokens, response);
        }
      });
    };
    
    /**
     * Inserts a helpful error message guiding the user toward fixing common auth issues.
     * @param {object} err Error result.
     * @param {object} result The result.
     * @param {object} response The HTTP response.
     * @param {Function} callback The callback.
     * @private
     */
    Compute.prototype._injectErrorMessage = function(err, result, response, callback) {
      if (response && response.statusCode) {
        var helpfulMessage = null;
        if (response.statusCode === 403) {
          helpfulMessage = 'A Forbidden error was returned while attempting to retrieve an access ' +
            'token for the Compute Engine built-in service account. This may be because the Compute ' +
            'Engine instance does not have the correct permission scopes specified.';
        } else if (response.statusCode === 404) {
          helpfulMessage = 'A Not Found error was returned while attempting to retrieve an access' +
            'token for the Compute Engine built-in service account. This may be because the Compute ' +
            'Engine instance does not have any permission scopes specified.';
        }
        if (helpfulMessage) {
          if (err && err.message) {
            helpfulMessage += ' ' + err.message;
          }
    
          if (err) {
            err.message = helpfulMessage;
          } else {
            err = new Error(helpfulMessage);
            err.code = response.statusCode;
          }
        }
      }
      callback(err, result, response);
    };
    
    /**
     * Export Compute.
     */
    module.exports = Compute;
  provide("google-auth-library/lib/auth/computeclient.js", module.exports);
}(global));

// pakmanager:google-auth-library/lib/auth/iam.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Copyright 2015 Google Inc. All Rights Reserved.
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    
    'use strict';
    
    /**
     * IAM credentials.
     *
     * @param {string=} selector the iam authority selector
     * @param {string=} token the token
     * @constructor
     */
    function IAMAuth(selector, token) {
      this.selector = selector;
      this.token = token;
    }
    
    /**
     * Indicates whether the credential requires scopes to be created by calling
     * createdScoped before use.
     *
     * @return {boolean} always false
     */
    IAMAuth.prototype.createScopedRequired = function() {
      // IAM authorization does not use scopes.
      return false;
    };
    
    /**
     * Pass the selector and token to the metadataFn callback.
     *
     * @param {string} unused_uri_ is required of the credentials interface
     * @param {function} metadataFn a callback invoked with object
     *                   containing request metadata.
     */
    IAMAuth.prototype.getRequestMetadata = function(unused_uri_, metadataFn) {
      metadataFn(null, {
        'x-goog-iam-authority-selector': this.selector,
        'x-goog-iam-authorization-token': this.token
      });
    };
    
    /**
     * Export IAMAuth.
     */
    module.exports = IAMAuth;
    
  provide("google-auth-library/lib/auth/iam.js", module.exports);
}(global));

// pakmanager:google-auth-library/lib/auth/refreshclient.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Copyright 2015 Google Inc. All Rights Reserved.
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    
    'use strict';
    
    var Auth2Client =  require('google-auth-library/lib/auth/oauth2client.js');
    var util = require('util');
    
    /**
     * User Refresh Token credentials.
     *
     * @param {string} clientId The authentication client ID.
     * @param {string} clientSecret The authentication client secret.
     * @param {string} refreshToken The authentication refresh token.
     * @constructor
     */
    function UserRefreshClient(clientId, clientSecret, refreshToken) {
      UserRefreshClient.super_.call(this, clientId, clientSecret);
      // Named to avoid collision with the method refreshToken_
      this._refreshToken = refreshToken;
    }
    
    util.inherits(UserRefreshClient, Auth2Client);
    
    // Executes the given callback if it is not null.
    function callback(c, err, res) {
      if (c) {
        c(err, res);
      }
    }
    
    /**
     * Refreshes the access token.
     * @param {object=} ignored_
     * @param {function=} opt_callback Optional callback.
     * @private
     */
    UserRefreshClient.prototype.refreshToken_ = function(ignored_, opt_callback) {
      UserRefreshClient.super_.prototype.refreshToken_.call(
          this, this._refreshToken, opt_callback);
    };
    
    /**
     * Create a UserRefreshClient credentials instance using the given input options.
     * @param {object=} json The input object.
     * @param {function=} opt_callback Optional callback.
     */
    UserRefreshClient.prototype.fromJSON = function(json, opt_callback) {
      var that = this;
      if (!json) {
        callback(opt_callback, new Error(
            'Must pass in a JSON object containing the user refresh token'));
        return;
      }
      if (json.type !== 'authorized_user') {
        callback(opt_callback, new Error(
            'The incoming JSON object does not have the "authorized_user" type'));
        return;
      }
      if (!json.client_id) {
        callback(opt_callback, new Error(
            'The incoming JSON object does not contain a client_id field'));
        return;
      }
      if (!json.client_secret) {
        callback(opt_callback, new Error(
            'The incoming JSON object does not contain a client_secret field'));
        return;
      }
      if (!json.refresh_token) {
        callback(opt_callback, new Error(
            'The incoming JSON object does not contain a refresh_token field'));
        return;
      }
      that.clientId_ = json.client_id;
      that.clientSecret_ = json.client_secret;
      that._refreshToken = json.refresh_token;
      that.credentials.refresh_token = json.refresh_token;
      callback(opt_callback);
    };
    
    /**
     * Create a UserRefreshClient credentials instance using the given input stream.
     * @param {object=} stream The input stream.
     * @param {function=} opt_callback Optional callback.
     */
    UserRefreshClient.prototype.fromStream = function(stream, opt_callback) {
      var that = this;
      if (!stream) {
        process.nextTick(function() {
          callback(
            opt_callback,
            new Error('Must pass in a stream containing the user refresh token.'));
        });
        return;
      }
      var s = '';
      stream.setEncoding('utf8');
      stream.on('data', function (chunk) {
        s += chunk;
      });
      stream.on('end', function () {
        try {
          var data = JSON.parse(s);
          that.fromJSON(data, opt_callback);
        } catch (err) {
          callback(opt_callback, err);
        }
      });
    };
    
    /**
     * Export UserRefreshClient
     */
    module.exports = UserRefreshClient;
    
  provide("google-auth-library/lib/auth/refreshclient.js", module.exports);
}(global));

// pakmanager:google-auth-library
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Copyright 2014 Google Inc. All Rights Reserved.
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    
    'use strict';
    
    var JWTClient =  require('google-auth-library/lib/auth/jwtclient.js');
    var ComputeClient =  require('google-auth-library/lib/auth/computeclient.js');
    var fs = require('fs');
    var os = require('os');
    var path = require('path');
    var util = require('util');
    var defaultTransporter =  require('google-auth-library/lib/transporters.js');
    
    /**
     * GoogleAuth account manager.
     *
     * @constructor
     */
    function GoogleAuth() {
      this.JWTClient = JWTClient;
      this.ComputeClient = ComputeClient;
      this._cachedCredential = null;
    }
    
    // Executes the given callback if it is not null.
    function callback(c, err, res) {
      if (c) {
        c(err, res);
      }
    }
    
    // Creates an Error containing the given message, and includes the message from the optional err
    // passed in.
    function createError(message, err) {
      var s = message || '';
      if (err) {
        var errorMessage = String(err);
        if (errorMessage && errorMessage.length > 0) {
          if (s.length > 0) {
            s += ' ';
          }
          s += errorMessage;
        }
      }
      return Error(s);
    }
    
    /**
     * Convenience field mapping in the IAM credential type.
     */
    GoogleAuth.prototype.IAMAuth =  require('google-auth-library/lib/auth/iam.js');
    
    /**
     * Convenience field mapping in the Compute credential type.
     */
    GoogleAuth.prototype.Compute =  require('google-auth-library/lib/auth/computeclient.js');
    
    /**
     * Convenience field mapping in the JWT credential type.
     */
    GoogleAuth.prototype.JWT =  require('google-auth-library/lib/auth/jwtclient.js');
    
    /**
     * Convenience field mapping in the JWT Access credential type.
     */
    GoogleAuth.prototype.JWTAccess =  require('google-auth-library/lib/auth/jwtaccess.js');
    
    /**
     * Convenience field mapping in the OAuth2 credential type.
     */
    GoogleAuth.prototype.OAuth2 =  require('google-auth-library/lib/auth/oauth2client.js');
    
    /**
     * Convenience field mapping to the UserRefreshClient credential type.
     */
    GoogleAuth.prototype.UserRefreshClient =  require('google-auth-library/lib/auth/refreshclient.js');
    
    /**
     * Caches a value indicating whether the auth layer is running on Google Compute Engine.
     * @private
     */
    GoogleAuth.prototype._isGCE = false;
    
    /**
     * Caches a value indicating whether we've checked whether the auth layer is running on
     * Google Compute Engine.
     * @private
     */
    GoogleAuth.prototype._checked_isGCE = false;
    
    /**
     * Obtains the default service-level credentials for the application..
     * @param {function=} opt_callback Optional callback.
     */
    GoogleAuth.prototype.getApplicationDefault = function(opt_callback) {
      var that = this;
    
      // If we've already got a cached credential, just return it.
      if (that._cachedCredential) {
        process.nextTick(function() {
          callback(opt_callback, null, that._cachedCredential);
        });
      } else {
        // Inject our own callback routine, which will cache the credential once it's been created.
        // It also allows us to ensure that the ultimate callback is always async.
        var my_callback = function(err, result) {
          if (!err && result) {
            that._cachedCredential = result;
          }
          process.nextTick(function() {
            callback(opt_callback, err, result);
          });
        };
        // Check for the existence of a local environment variable pointing to the
        // location of the credential file. This is typically used in local developer scenarios.
        if (that._tryGetApplicationCredentialsFromEnvironmentVariable(my_callback)) {
          return;
        }
    
        // Look in the well-known credential file location.
        if (that._tryGetApplicationCredentialsFromWellKnownFile(my_callback)) {
          return;
        }
    
        // Determine if we're running on GCE.
        that._checkIsGCE(function(gce) {
          if (gce) {
            // For GCE, just return a default ComputeClient. It will take care of the rest.
            my_callback(null, new that.ComputeClient());
          } else {
            // We failed to find the default credentials. Bail out with an error.
            my_callback(new Error('Could not load the default credentials. Browse to ' +
              'https://developers.google.com/accounts/docs/application-default-credentials for ' +
              'more information.'));
          }
        });
      }
    };
    
    /**
     * Determines whether the auth layer is running on Google Compute Engine.
     * @param {function=} callback The callback.
     * @api private
     */
    GoogleAuth.prototype._checkIsGCE = function(callback) {
      var that = this;
      if (that._checked_isGCE) {
        callback(that._isGCE);
      } else {
        if (!that.transporter) {
          that.transporter = new defaultTransporter();
        }
        that.transporter.request({
          method: 'GET',
          uri: 'http://metadata.google.internal',
          json: true
        }, function(err, body, res) {
          if (!err && res && res.headers) {
            that._isGCE = res.headers['metadata-flavor'] === 'Google';
          }
          that._checked_isGCE = true;
          callback(that._isGCE);
        });
      }
    };
    
    /**
     * Attempts to load default credentials from the environment variable path..
     * @param {function=} opt_callback Optional callback.
     * @return {boolean} Returns true if the callback has been executed; false otherwise.
     * @api private
     */
    GoogleAuth.prototype._tryGetApplicationCredentialsFromEnvironmentVariable =
      function(opt_callback) {
    
        var that = this;
        var credentialsPath = that._getEnv('GOOGLE_APPLICATION_CREDENTIALS');
        if (!credentialsPath || credentialsPath.length === 0) {
          return false;
        }
        that._getApplicationCredentialsFromFilePath(credentialsPath, function(err, result) {
          var wrappedError = null;
          if (err) {
            wrappedError = createError(
                'Unable to read the credential file specified by the GOOGLE_APPLICATION_CREDENTIALS ' +
                'environment variable.',
              err);
          }
          callback(opt_callback, wrappedError, result);
        });
        return true;
      };
    
    /**
     * Attempts to load default credentials from a well-known file location
     * @param {function=} opt_callback Optional callback.
     * @return {boolean} Returns true if the callback has been executed; false otherwise.
     * @api private
     */
    GoogleAuth.prototype._tryGetApplicationCredentialsFromWellKnownFile =
      function(opt_callback) {
    
        var that = this;
        // First, figure out the location of the file, depending upon the OS type.
        var location = null;
        if (that._isWindows()) {
          // Windows
          location = that._getEnv('APPDATA');
        } else {
          // Linux or Mac
          var home = that._getEnv('HOME');
          if (home) {
            location = that._pathJoin(home, '.config');
          }
        }
        // If we found the root path, expand it.
        if (location) {
          location = that._pathJoin(location, 'gcloud');
          location = that._pathJoin(location, 'application_default_credentials.json');
          location = that._mockWellKnownFilePath(location);
          // Check whether the file exists.
          if (!that._fileExists(location)) {
            location = null;
          }
        }
        // The file does not exist.
        if (!location) {
          return false;
        }
        // The file seems to exist. Try to use it.
        this._getApplicationCredentialsFromFilePath(location, opt_callback);
        return true;
      };
    
    /**
     * Attempts to load default credentials from a file at the given path..
     * @param {string=} filePath The path to the file to read.
     * @param {function=} opt_callback Optional callback.
     * @api private
     */
    GoogleAuth.prototype._getApplicationCredentialsFromFilePath =
      function(filePath, opt_callback) {
    
        var that = this;
        var error = null;
        // Make sure the path looks like a string.
        if (!filePath || filePath.length === 0) {
          error = new Error('The file path is invalid.');
        }
        // Make sure there is a file at the path. lstatSync will throw if there is nothing there.
        if (!error) {
          try {
            if (!fs.lstatSync(filePath).isFile()) {
              throw '';
            }
          } catch (err) {
            error = createError(util.format('The file at %s does not exist, or it is not a file.',
              filePath), err);
          }
        }
        // Now open a read stream on the file, and parse it.
        if (!error) {
          try {
            var stream = that._createReadStream(filePath);
            that.fromStream(stream, opt_callback);
          } catch (err) {
            error = createError(util.format('Unable to read the file at %s.', filePath), err);
          }
        }
        if (error) {
          callback(opt_callback, error);
        }
      };
    
    /**
     * Create a credentials instance using the given input options.
     * @param {object=} json The input object.
     * @param {function=} opt_callback Optional callback.
     */
    GoogleAuth.prototype.fromJSON = function(json, opt_callback) {
      var that = this;
      var client;
      if (!json) {
        callback(opt_callback, new Error(
          'Must pass in a JSON object containing the Google auth settings.'));
        return;
      }
      if (json.type === 'authorized_user') {
        client = new that.UserRefreshClient();
      } else {
        client = new that.JWTClient();
      }
      client.fromJSON(json, function(err) {
        if (err) {
          callback(opt_callback, err);
        } else {
          callback(opt_callback, null, client);
        }
      });
    };
    
    /**
     * Create a credentials instance using the given input stream.
     * @param {object=} stream The input stream.
     * @param {function=} opt_callback Optional callback.
     */
    GoogleAuth.prototype.fromStream = function(stream, opt_callback) {
      var that = this;
      if (!stream) {
        process.nextTick(function() {
          callback(opt_callback, new Error(
              'Must pass in a stream containing the Google auth settings.'));
        });
        return;
      }
      var s = '';
      stream.setEncoding('utf8');
      stream.on('data', function (chunk) {
        s += chunk;
      });
      stream.on('end', function () {
        try {
          var data = JSON.parse(s);
          that.fromJSON(data, opt_callback);
        } catch (err) {
          callback(opt_callback, err);
        }
      });
    };
    
    /**
     * Determines whether the current operating system is Windows.
     * @api private
     * */
    GoogleAuth.prototype._isWindows = function() {
      var sys = this._osPlatform();
      if (sys && sys.length >= 3) {
        if (sys.substring(0, 3).toLowerCase() === 'win') {
          return true;
        }
      }
      return false;
    };
    
    /**
     * Creates a file stream. Allows mocking.
     * @api private
     * */
    GoogleAuth.prototype._createReadStream = function(filePath) {
      return fs.createReadStream(filePath);
    };
    
    /**
     * Gets the value of the environment variable with the given name. Allows mocking.
     * @api private
     * */
    GoogleAuth.prototype._getEnv = function(name) {
      return process.env[name];
    };
    
    /**
     * Gets the current operating system platform. Allows mocking.
     * @api private
     * */
    GoogleAuth.prototype._osPlatform = function() {
      return os.platform();
    };
    
    /**
     * Determines whether a file exists. Allows mocking.
     * @api private
     * */
    GoogleAuth.prototype._fileExists = function(filePath) {
      return fs.existsSync(filePath);
    };
    
    /**
     * Joins two parts of a path. Allows mocking.
     * @api private
     * */
    GoogleAuth.prototype._pathJoin = function(item1, item2) {
      return path.join(item1, item2);
    };
    
    /**
     * Allows mocking of the path to a well-known file.
     * @api private
     * */
    GoogleAuth.prototype._mockWellKnownFilePath = function(filePath) {
      return filePath;
    };
    
    /**
     * Export GoogleAuth.
     */
    module.exports = GoogleAuth;
    
  provide("google-auth-library", module.exports);
}(global));

// pakmanager:normalize-url
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    var url = require('url');
    var punycode = require('punycode');
    var queryString = require('query-string');
    var prependHttp = require('prepend-http');
    var sortKeys = require('sort-keys');
    var objectAssign = require('object-assign');
    
    var DEFAULT_PORTS = {
    	'http:': 80,
    	'https:': 443,
    	'ftp:': 21
    };
    
    module.exports = function (str, opts) {
    	opts = objectAssign({
    		normalizeProtocol: true,
    		stripFragment: true,
    		stripWWW: true
    	}, opts);
    
    	if (typeof str !== 'string') {
    		throw new TypeError('Expected a string');
    	}
    
    	var hasRelativeProtocol = str.indexOf('//') === 0;
    
    	// prepend protocol
    	str = prependHttp(str.trim()).replace(/^\/\//, 'http://');
    
    	var urlObj = url.parse(str);
    
    	// prevent these from being used by `url.format`
    	delete urlObj.host;
    	delete urlObj.query;
    
    	// remove fragment
    	if (opts.stripFragment) {
    		delete urlObj.hash;
    	}
    
    	// remove default port
    	var port = DEFAULT_PORTS[urlObj.protocol];
    	if (Number(urlObj.port) === port) {
    		delete urlObj.port;
    	}
    
    	// remove duplicate slashes
    	urlObj.pathname = urlObj.pathname.replace(/\/{2,}/, '/');
    
    	// resolve relative paths
    	var domain = urlObj.protocol + '//' + urlObj.hostname;
    	var relative = url.resolve(domain, urlObj.pathname);
    	urlObj.pathname = relative.replace(domain, '');
    
    	// IDN to Unicode
    	urlObj.hostname = punycode.toUnicode(urlObj.hostname).toLowerCase();
    
    	// remove `www.`
    	if (opts.stripWWW) {
    		urlObj.hostname = urlObj.hostname.replace(/^www\./, '');
    	}
    
    	// remove URL with empty query string
    	if (urlObj.search === '?') {
    		delete urlObj.search;
    	}
    
    	// sort query parameters
    	urlObj.search = queryString.stringify(sortKeys(queryString.parse(urlObj.search)));
    
    	// decode query parameters
    	urlObj.search = decodeURIComponent(urlObj.search);
    
    	// take advantage of many of the Node `url` normalizations
    	str = url.format(urlObj);
    
    	// remove ending `/`
    	str = str.replace(/\/$/, '');
    
    	// restore relative protocol, if applicable
    	if (hasRelativeProtocol && !opts.normalizeProtocol) {
    		str = str.replace(/^http:\/\//, '//');
    	}
    
    	return str;
    };
    
  provide("normalize-url", module.exports);
}(global));

// pakmanager:strip-url-auth
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    module.exports = function (str) {
    	if (typeof str !== 'string') {
    		throw new TypeError('Expected a string');
    	}
    
    	return str.replace(/^((?:\w+:)?\/\/)(?:[^@\/]+@)/, '$1');
    };
    
  provide("strip-url-auth", module.exports);
}(global));

// pakmanager:arrify
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    module.exports = function (val) {
    	if (val == null) {
    		return [];
    	}
    
    	return Array.isArray(val) ? val : [val];
    };
    
  provide("arrify", module.exports);
}(global));

// pakmanager:dot-prop
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    function isObjOrFn(x) {
    	return (typeof x === 'object' || typeof x === 'function') && x !== null;
    }
    
    module.exports.get = function (obj, path) {
    	if (!isObjOrFn(obj) || typeof path !== 'string') {
    		return obj;
    	}
    
    	var pathArr = path.split('.');
    
    	for (var i = 0; i < pathArr.length; i++) {
    		var p = pathArr[i];
    
    		while (p[p.length - 1] === '\\') {
    			p = p.slice(0, -1) + '.';
    			p += pathArr[++i];
    		}
    
    		obj = obj[p];
    
    		if (obj === undefined) {
    			break;
    		}
    	}
    
    	return obj;
    };
    
    module.exports.set = function (obj, path, value) {
    	if (!isObjOrFn(obj) || typeof path !== 'string') {
    		return;
    	}
    
    	var pathArr = path.split('.');
    
    	for (var i = 0; i < pathArr.length; i++) {
    		var p = pathArr[i];
    
    		while (p[p.length - 1] === '\\') {
    			p = p.slice(0, -1) + '.';
    			p += pathArr[++i];
    		}
    
    		if (!isObjOrFn(obj[p])) {
    			obj[p] = {};
    		}
    
    		if (i === pathArr.length - 1) {
    			obj[p] = value;
    		}
    
    		obj = obj[p];
    	}
    };
    
  provide("dot-prop", module.exports);
}(global));

// pakmanager:configstore
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    var path = require('path');
    var fs = require('graceful-fs');
    var osenv = require('osenv');
    var userHome = require('user-home');
    var assign = require('object-assign');
    var mkdirp = require('mkdirp');
    var uuid = require('uuid');
    var xdgBasedir = require('xdg-basedir');
    var osTmpdir = require('os-tmpdir');
    
    var user = (osenv.user() || uuid.v4()).replace(/\\/g, '');
    var configDir = xdgBasedir.config || path.join(osTmpdir(), user, '.config');
    var permissionError = 'You don\'t have access to this file.';
    var defaultPathMode = parseInt('0700', 8);
    var writeFileOptions = {mode: parseInt('0600', 8)};
    
    function Configstore(id, defaults) {
    	this.path = path.join(configDir, 'configstore', id + '.json');
    	this.all = assign({}, defaults || {}, this.all || {});
    }
    
    Configstore.prototype = Object.create(Object.prototype, {
    	all: {
    		get: function () {
    			try {
    				return JSON.parse(fs.readFileSync(this.path, 'utf8'));
    			} catch (err) {
    				// create dir if it doesn't exist
    				if (err.code === 'ENOENT') {
    					mkdirp.sync(path.dirname(this.path), defaultPathMode);
    					return {};
    				}
    
    				// improve the message of permission errors
    				if (err.code === 'EACCES') {
    					err.message = err.message + '\n' + permissionError + '\n';
    				}
    
    				// empty the file if it encounters invalid JSON
    				if (err.name === 'SyntaxError') {
    					fs.writeFileSync(this.path, '', writeFileOptions);
    					return {};
    				}
    
    				throw err;
    			}
    		},
    		set: function (val) {
    			try {
    				// make sure the folder exists as it
    				// could have been deleted in the meantime
    				mkdirp.sync(path.dirname(this.path), defaultPathMode);
    
    				fs.writeFileSync(this.path, JSON.stringify(val, null, '\t'), writeFileOptions);
    			} catch (err) {
    				// improve the message of permission errors
    				if (err.code === 'EACCES') {
    					err.message = err.message + '\n' + permissionError + '\n';
    				}
    
    				throw err;
    			}
    		}
    	},
    	size: {
    		get: function () {
    			return Object.keys(this.all || {}).length;
    		}
    	}
    });
    
    Configstore.prototype.get = function (key) {
    	return this.all[key];
    };
    
    Configstore.prototype.set = function (key, val) {
    	var config = this.all;
    	config[key] = val;
    	this.all = config;
    };
    
    Configstore.prototype.del = function (key) {
    	var config = this.all;
    	delete config[key];
    	this.all = config;
    };
    
    Configstore.prototype.clear = function () {
    	this.all = {};
    }
    
    module.exports = Configstore;
    
  provide("configstore", module.exports);
}(global));

// pakmanager:is-npm
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    module.exports = 'npm_config_username' in process.env ||
    	'npm_package_name' in process.env ||
    	'npm_config_heading' in process.env;
    
  provide("is-npm", module.exports);
}(global));

// pakmanager:latest-version
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    var packageJson = require('package-json');
    
    module.exports = function (name, cb) {
    	packageJson(name.toLowerCase(), 'latest', function (err, json) {
    		if (err) {
    			cb(err);
    			return;
    		}
    
    		cb(null, json.version);
    	});
    };
    
  provide("latest-version", module.exports);
}(global));

// pakmanager:semver-diff
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    var semver = require('semver');
    
    module.exports = function (a, b) {
    	if (semver.gt(a, b)) {
    		return null;
    	}
    
    	a = semver.parse(a);
    	b = semver.parse(b);
    
    	for (var key in a) {
    		if (key === 'major' || key === 'minor' || key === 'patch') {
    			if (a[key] !== b[key]) {
    				return key;
    			}
    		}
    
    		if (key === 'prerelease' || key === 'build') {
    			if (JSON.stringify(a[key]) !== JSON.stringify(b[key])) {
    				return key;
    			}
    		}
    	}
    
    	return null;
    };
    
  provide("semver-diff", module.exports);
}(global));

// pakmanager:string-length
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    var stripAnsi = require('strip-ansi');
    var reAstral = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
    
    module.exports = function (str) {
    	return stripAnsi(str).replace(reAstral, ' ').length;
    };
    
  provide("string-length", module.exports);
}(global));

// pakmanager:colors/lib/styles
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*
    The MIT License (MIT)
    
    Copyright (c) Sindre Sorhus <sindresorhus@gmail.com> (sindresorhus.com)
    
    Permission is hereby granted, free of charge, to any person obtaining a copy
    of this software and associated documentation files (the "Software"), to deal
    in the Software without restriction, including without limitation the rights
    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
    copies of the Software, and to permit persons to whom the Software is
    furnished to do so, subject to the following conditions:
    
    The above copyright notice and this permission notice shall be included in
    all copies or substantial portions of the Software.
    
    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
    THE SOFTWARE.
    
    */
    
    var styles = {};
    module['exports'] = styles;
    
    var codes = {
      reset: [0, 0],
    
      bold: [1, 22],
      dim: [2, 22],
      italic: [3, 23],
      underline: [4, 24],
      inverse: [7, 27],
      hidden: [8, 28],
      strikethrough: [9, 29],
    
      black: [30, 39],
      red: [31, 39],
      green: [32, 39],
      yellow: [33, 39],
      blue: [34, 39],
      magenta: [35, 39],
      cyan: [36, 39],
      white: [37, 39],
      gray: [90, 39],
      grey: [90, 39],
    
      bgBlack: [40, 49],
      bgRed: [41, 49],
      bgGreen: [42, 49],
      bgYellow: [43, 49],
      bgBlue: [44, 49],
      bgMagenta: [45, 49],
      bgCyan: [46, 49],
      bgWhite: [47, 49],
    
      // legacy styles for colors pre v1.0.0
      blackBG: [40, 49],
      redBG: [41, 49],
      greenBG: [42, 49],
      yellowBG: [43, 49],
      blueBG: [44, 49],
      magentaBG: [45, 49],
      cyanBG: [46, 49],
      whiteBG: [47, 49]
    
    };
    
    Object.keys(codes).forEach(function (key) {
      var val = codes[key];
      var style = styles[key] = [];
      style.open = '\u001b[' + val[0] + 'm';
      style.close = '\u001b[' + val[1] + 'm';
    });
  provide("colors/lib/styles", module.exports);
}(global));

// pakmanager:colors/lib/system/supports-colors
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*
    The MIT License (MIT)
    
    Copyright (c) Sindre Sorhus <sindresorhus@gmail.com> (sindresorhus.com)
    
    Permission is hereby granted, free of charge, to any person obtaining a copy
    of this software and associated documentation files (the "Software"), to deal
    in the Software without restriction, including without limitation the rights
    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
    copies of the Software, and to permit persons to whom the Software is
    furnished to do so, subject to the following conditions:
    
    The above copyright notice and this permission notice shall be included in
    all copies or substantial portions of the Software.
    
    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
    THE SOFTWARE.
    
    */
    
    var argv = process.argv;
    
    module.exports = (function () {
      if (argv.indexOf('--no-color') !== -1 ||
        argv.indexOf('--color=false') !== -1) {
        return false;
      }
    
      if (argv.indexOf('--color') !== -1 ||
        argv.indexOf('--color=true') !== -1 ||
        argv.indexOf('--color=always') !== -1) {
        return true;
      }
    
      if (process.stdout && !process.stdout.isTTY) {
        return false;
      }
    
      if (process.platform === 'win32') {
        return true;
      }
    
      if ('COLORTERM' in process.env) {
        return true;
      }
    
      if (process.env.TERM === 'dumb') {
        return false;
      }
    
      if (/^screen|^xterm|^vt100|color|ansi|cygwin|linux/i.test(process.env.TERM)) {
        return true;
      }
    
      return false;
    })();
  provide("colors/lib/system/supports-colors", module.exports);
}(global));

// pakmanager:colors/lib/custom/trap
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  module['exports'] = function runTheTrap (text, options) {
      var result = "";
      text = text || "Run the trap, drop the bass";
      text = text.split('');
      var trap = {
        a: ["\u0040", "\u0104", "\u023a", "\u0245", "\u0394", "\u039b", "\u0414"],
        b: ["\u00df", "\u0181", "\u0243", "\u026e", "\u03b2", "\u0e3f"],
        c: ["\u00a9", "\u023b", "\u03fe"],
        d: ["\u00d0", "\u018a", "\u0500" , "\u0501" ,"\u0502", "\u0503"],
        e: ["\u00cb", "\u0115", "\u018e", "\u0258", "\u03a3", "\u03be", "\u04bc", "\u0a6c"],
        f: ["\u04fa"],
        g: ["\u0262"],
        h: ["\u0126", "\u0195", "\u04a2", "\u04ba", "\u04c7", "\u050a"],
        i: ["\u0f0f"],
        j: ["\u0134"],
        k: ["\u0138", "\u04a0", "\u04c3", "\u051e"],
        l: ["\u0139"],
        m: ["\u028d", "\u04cd", "\u04ce", "\u0520", "\u0521", "\u0d69"],
        n: ["\u00d1", "\u014b", "\u019d", "\u0376", "\u03a0", "\u048a"],
        o: ["\u00d8", "\u00f5", "\u00f8", "\u01fe", "\u0298", "\u047a", "\u05dd", "\u06dd", "\u0e4f"],
        p: ["\u01f7", "\u048e"],
        q: ["\u09cd"],
        r: ["\u00ae", "\u01a6", "\u0210", "\u024c", "\u0280", "\u042f"],
        s: ["\u00a7", "\u03de", "\u03df", "\u03e8"],
        t: ["\u0141", "\u0166", "\u0373"],
        u: ["\u01b1", "\u054d"],
        v: ["\u05d8"],
        w: ["\u0428", "\u0460", "\u047c", "\u0d70"],
        x: ["\u04b2", "\u04fe", "\u04fc", "\u04fd"],
        y: ["\u00a5", "\u04b0", "\u04cb"],
        z: ["\u01b5", "\u0240"]
      }
      text.forEach(function(c){
        c = c.toLowerCase();
        var chars = trap[c] || [" "];
        var rand = Math.floor(Math.random() * chars.length);
        if (typeof trap[c] !== "undefined") {
          result += trap[c][rand];
        } else {
          result += c;
        }
      });
      return result;
    
    }
    
  provide("colors/lib/custom/trap", module.exports);
}(global));

// pakmanager:colors/lib/custom/zalgo
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // please no
    module['exports'] = function zalgo(text, options) {
      text = text || "   he is here   ";
      var soul = {
        "up" : [
          '̍', '̎', '̄', '̅',
          '̿', '̑', '̆', '̐',
          '͒', '͗', '͑', '̇',
          '̈', '̊', '͂', '̓',
          '̈', '͊', '͋', '͌',
          '̃', '̂', '̌', '͐',
          '̀', '́', '̋', '̏',
          '̒', '̓', '̔', '̽',
          '̉', 'ͣ', 'ͤ', 'ͥ',
          'ͦ', 'ͧ', 'ͨ', 'ͩ',
          'ͪ', 'ͫ', 'ͬ', 'ͭ',
          'ͮ', 'ͯ', '̾', '͛',
          '͆', '̚'
        ],
        "down" : [
          '̖', '̗', '̘', '̙',
          '̜', '̝', '̞', '̟',
          '̠', '̤', '̥', '̦',
          '̩', '̪', '̫', '̬',
          '̭', '̮', '̯', '̰',
          '̱', '̲', '̳', '̹',
          '̺', '̻', '̼', 'ͅ',
          '͇', '͈', '͉', '͍',
          '͎', '͓', '͔', '͕',
          '͖', '͙', '͚', '̣'
        ],
        "mid" : [
          '̕', '̛', '̀', '́',
          '͘', '̡', '̢', '̧',
          '̨', '̴', '̵', '̶',
          '͜', '͝', '͞',
          '͟', '͠', '͢', '̸',
          '̷', '͡', ' ҉'
        ]
      },
      all = [].concat(soul.up, soul.down, soul.mid),
      zalgo = {};
    
      function randomNumber(range) {
        var r = Math.floor(Math.random() * range);
        return r;
      }
    
      function is_char(character) {
        var bool = false;
        all.filter(function (i) {
          bool = (i === character);
        });
        return bool;
      }
      
    
      function heComes(text, options) {
        var result = '', counts, l;
        options = options || {};
        options["up"] =   typeof options["up"]   !== 'undefined' ? options["up"]   : true;
        options["mid"] =  typeof options["mid"]  !== 'undefined' ? options["mid"]  : true;
        options["down"] = typeof options["down"] !== 'undefined' ? options["down"] : true;
        options["size"] = typeof options["size"] !== 'undefined' ? options["size"] : "maxi";
        text = text.split('');
        for (l in text) {
          if (is_char(l)) {
            continue;
          }
          result = result + text[l];
          counts = {"up" : 0, "down" : 0, "mid" : 0};
          switch (options.size) {
          case 'mini':
            counts.up = randomNumber(8);
            counts.mid = randomNumber(2);
            counts.down = randomNumber(8);
            break;
          case 'maxi':
            counts.up = randomNumber(16) + 3;
            counts.mid = randomNumber(4) + 1;
            counts.down = randomNumber(64) + 3;
            break;
          default:
            counts.up = randomNumber(8) + 1;
            counts.mid = randomNumber(6) / 2;
            counts.down = randomNumber(8) + 1;
            break;
          }
    
          var arr = ["up", "mid", "down"];
          for (var d in arr) {
            var index = arr[d];
            for (var i = 0 ; i <= counts[index]; i++) {
              if (options[index]) {
                result = result + soul[index][randomNumber(soul[index].length)];
              }
            }
          }
        }
        return result;
      }
      // don't summon him
      return heComes(text, options);
    }
    
  provide("colors/lib/custom/zalgo", module.exports);
}(global));

// pakmanager:colors/lib/maps/america
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var colors =  require('colors/lib/colors');
    
    module['exports'] = (function() {
      return function (letter, i, exploded) {
        if(letter === " ") return letter;
        switch(i%3) {
          case 0: return colors.red(letter);
          case 1: return colors.white(letter)
          case 2: return colors.blue(letter)
        }
      }
    })();
  provide("colors/lib/maps/america", module.exports);
}(global));

// pakmanager:colors/lib/maps/zebra
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var colors =  require('colors/lib/colors');
    
    module['exports'] = function (letter, i, exploded) {
      return i % 2 === 0 ? letter : colors.inverse(letter);
    };
  provide("colors/lib/maps/zebra", module.exports);
}(global));

// pakmanager:colors/lib/maps/rainbow
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var colors =  require('colors/lib/colors');
    
    module['exports'] = (function () {
      var rainbowColors = ['red', 'yellow', 'green', 'blue', 'magenta']; //RoY G BiV
      return function (letter, i, exploded) {
        if (letter === " ") {
          return letter;
        } else {
          return colors[rainbowColors[i++ % rainbowColors.length]](letter);
        }
      };
    })();
    
    
  provide("colors/lib/maps/rainbow", module.exports);
}(global));

// pakmanager:colors/lib/maps/random
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var colors =  require('colors/lib/colors');
    
    module['exports'] = (function () {
      var available = ['underline', 'inverse', 'grey', 'yellow', 'red', 'green', 'blue', 'white', 'cyan', 'magenta'];
      return function(letter, i, exploded) {
        return letter === " " ? letter : colors[available[Math.round(Math.random() * (available.length - 1))]](letter);
      };
    })();
  provide("colors/lib/maps/random", module.exports);
}(global));

// pakmanager:colors/lib/colors
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*
    
    The MIT License (MIT)
    
    Original Library 
      - Copyright (c) Marak Squires
    
    Additional functionality
     - Copyright (c) Sindre Sorhus <sindresorhus@gmail.com> (sindresorhus.com)
    
    Permission is hereby granted, free of charge, to any person obtaining a copy
    of this software and associated documentation files (the "Software"), to deal
    in the Software without restriction, including without limitation the rights
    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
    copies of the Software, and to permit persons to whom the Software is
    furnished to do so, subject to the following conditions:
    
    The above copyright notice and this permission notice shall be included in
    all copies or substantial portions of the Software.
    
    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
    THE SOFTWARE.
    
    */
    
    var colors = {};
    module['exports'] = colors;
    
    colors.themes = {};
    
    var ansiStyles = colors.styles =  require('colors/lib/styles');
    var defineProps = Object.defineProperties;
    
    colors.supportsColor =  require('colors/lib/system/supports-colors');
    
    if (typeof colors.enabled === "undefined") {
      colors.enabled = colors.supportsColor;
    }
    
    colors.stripColors = colors.strip = function(str){
      return ("" + str).replace(/\x1B\[\d+m/g, '');
    };
    
    
    var stylize = colors.stylize = function stylize (str, style) {
      if (!colors.enabled) {
        return str+'';
      }
    
      return ansiStyles[style].open + str + ansiStyles[style].close;
    }
    
    var matchOperatorsRe = /[|\\{}()[\]^$+*?.]/g;
    var escapeStringRegexp = function (str) {
      if (typeof str !== 'string') {
        throw new TypeError('Expected a string');
      }
      return str.replace(matchOperatorsRe,  '\\$&');
    }
    
    function build(_styles) {
      var builder = function builder() {
        return applyStyle.apply(builder, arguments);
      };
      builder._styles = _styles;
      // __proto__ is used because we must return a function, but there is
      // no way to create a function with a different prototype.
      builder.__proto__ = proto;
      return builder;
    }
    
    var styles = (function () {
      var ret = {};
      ansiStyles.grey = ansiStyles.gray;
      Object.keys(ansiStyles).forEach(function (key) {
        ansiStyles[key].closeRe = new RegExp(escapeStringRegexp(ansiStyles[key].close), 'g');
        ret[key] = {
          get: function () {
            return build(this._styles.concat(key));
          }
        };
      });
      return ret;
    })();
    
    var proto = defineProps(function colors() {}, styles);
    
    function applyStyle() {
      var args = arguments;
      var argsLen = args.length;
      var str = argsLen !== 0 && String(arguments[0]);
      if (argsLen > 1) {
        for (var a = 1; a < argsLen; a++) {
          str += ' ' + args[a];
        }
      }
    
      if (!colors.enabled || !str) {
        return str;
      }
    
      var nestedStyles = this._styles;
    
      var i = nestedStyles.length;
      while (i--) {
        var code = ansiStyles[nestedStyles[i]];
        str = code.open + str.replace(code.closeRe, code.open) + code.close;
      }
    
      return str;
    }
    
    function applyTheme (theme) {
      for (var style in theme) {
        (function(style){
          colors[style] = function(str){
            if (typeof theme[style] === 'object'){
              var out = str;
              for (var i in theme[style]){
                out = colors[theme[style][i]](out);
              }
              return out;
            }
            return colors[theme[style]](str);
          };
        })(style)
      }
    }
    
    colors.setTheme = function (theme) {
      if (typeof theme === 'string') {
        try {
          colors.themes[theme] = require(theme);
          applyTheme(colors.themes[theme]);
          return colors.themes[theme];
        } catch (err) {
          console.log(err);
          return err;
        }
      } else {
        applyTheme(theme);
      }
    };
    
    function init() {
      var ret = {};
      Object.keys(styles).forEach(function (name) {
        ret[name] = {
          get: function () {
            return build([name]);
          }
        };
      });
      return ret;
    }
    
    var sequencer = function sequencer (map, str) {
      var exploded = str.split(""), i = 0;
      exploded = exploded.map(map);
      return exploded.join("");
    };
    
    // custom formatter methods
    colors.trap =  require('colors/lib/custom/trap');
    colors.zalgo =  require('colors/lib/custom/zalgo');
    
    // maps
    colors.maps = {};
    colors.maps.america =  require('colors/lib/maps/america');
    colors.maps.zebra =  require('colors/lib/maps/zebra');
    colors.maps.rainbow =  require('colors/lib/maps/rainbow');
    colors.maps.random =  require('colors/lib/maps/random')
    
    for (var map in colors.maps) {
      (function(map){
        colors[map] = function (str) {
          return sequencer(colors.maps[map], str);
        }
      })(map)
    }
    
    defineProps(colors, init());
  provide("colors/lib/colors", module.exports);
}(global));

// pakmanager:colors/lib/extendStringPrototype
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var colors =  require('colors/lib/colors');
    
    module['exports'] = function () {
    
      //
      // Extends prototype of native string object to allow for "foo".red syntax
      //
      var addProperty = function (color, func) {
        String.prototype.__defineGetter__(color, func);
      };
    
      var sequencer = function sequencer (map, str) {
          return function () {
            var exploded = this.split(""), i = 0;
            exploded = exploded.map(map);
            return exploded.join("");
          }
      };
    
      addProperty('strip', function () {
        return colors.strip(this);
      });
    
      addProperty('stripColors', function () {
        return colors.strip(this);
      });
    
      addProperty("trap", function(){
        return colors.trap(this);
      });
    
      addProperty("zalgo", function(){
        return colors.zalgo(this);
      });
    
      addProperty("zebra", function(){
        return colors.zebra(this);
      });
    
      addProperty("rainbow", function(){
        return colors.rainbow(this);
      });
    
      addProperty("random", function(){
        return colors.random(this);
      });
    
      addProperty("america", function(){
        return colors.america(this);
      });
    
      //
      // Iterate through all default styles and colors
      //
      var x = Object.keys(colors.styles);
      x.forEach(function (style) {
        addProperty(style, function () {
          return colors.stylize(this, style);
        });
      });
    
      function applyTheme(theme) {
        //
        // Remark: This is a list of methods that exist
        // on String that you should not overwrite.
        //
        var stringPrototypeBlacklist = [
          '__defineGetter__', '__defineSetter__', '__lookupGetter__', '__lookupSetter__', 'charAt', 'constructor',
          'hasOwnProperty', 'isPrototypeOf', 'propertyIsEnumerable', 'toLocaleString', 'toString', 'valueOf', 'charCodeAt',
          'indexOf', 'lastIndexof', 'length', 'localeCompare', 'match', 'replace', 'search', 'slice', 'split', 'substring',
          'toLocaleLowerCase', 'toLocaleUpperCase', 'toLowerCase', 'toUpperCase', 'trim', 'trimLeft', 'trimRight'
        ];
    
        Object.keys(theme).forEach(function (prop) {
          if (stringPrototypeBlacklist.indexOf(prop) !== -1) {
            console.log('warn: '.red + ('String.prototype' + prop).magenta + ' is probably something you don\'t want to override. Ignoring style name');
          }
          else {
            if (typeof(theme[prop]) === 'string') {
              colors[prop] = colors[theme[prop]];
              addProperty(prop, function () {
                return colors[theme[prop]](this);
              });
            }
            else {
              addProperty(prop, function () {
                var ret = this;
                for (var t = 0; t < theme[prop].length; t++) {
                  ret = colors[theme[prop][t]](ret);
                }
                return ret;
              });
            }
          }
        });
      }
    
      colors.setTheme = function (theme) {
        if (typeof theme === 'string') {
          try {
            colors.themes[theme] = require(theme);
            applyTheme(colors.themes[theme]);
            return colors.themes[theme];
          } catch (err) {
            console.log(err);
            return err;
          }
        } else {
          applyTheme(theme);
        }
      };
    
    };
  provide("colors/lib/extendStringPrototype", module.exports);
}(global));

// pakmanager:colors
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var colors =  require('colors/lib/colors');
    module['exports'] = colors;
    
    // Remark: By default, colors will add style properties to String.prototype
    //
    // If you don't wish to extend String.prototype you can do this instead and native String will not be touched
    //
    //   var colors = require('colors/safe);
    //   colors.red("foo")
    //
    //
     require('colors/lib/extendStringPrototype')();
  provide("colors", module.exports);
}(global));

// pakmanager:decompress-zip/lib/structures
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    var binary = require('binary');
    
    var convertDateTime = function (dosDate, dosTime) {
        var year = ((dosDate >> 9) & 0x7F) + 1980;
        var month = (dosDate >> 5) & 0x0F;
        var day = dosDate & 0x1F;
    
        var hour = (dosTime >> 11);
        var minute = (dosTime >> 5) & 0x3F;
        var second = (dosTime & 0x1F) * 2;
    
        var result = new Date(year, month - 1, day, hour, minute, second, 0);
    
        return result;
    };
    
    var convertGeneralPurposeFlags = function (value) {
        var bits = [];
    
        for (var i = 0; i < 16; i++) {
            bits[i] = (value >> i) & 1;
        }
    
        return {
            encrypted: !!bits[0],
            compressionFlag1: !!bits[1],
            compressionFlag2: !!bits[2],
            useDataDescriptor: !!bits[3],
            enhancedDeflating: !!bits[4],
            compressedPatched: !!bits[5],
            strongEncryption: !!bits[6],
            utf8: !!bits[11],
            encryptedCD: !!bits[13]
        };
    };
    
    var parseExternalFileAttributes = function (externalAttributes, platform) {
        var types = {
            // In theory, any of these could be set. Realistically, though, it will
            // be regular, directory or symlink
            1: 'NamedPipe',
            2: 'Character',
            4: 'Directory',
            6: 'Block',
            8: 'File',
            10: 'SymbolicLink',
            12: 'Socket'
        };
    
        switch (platform) {
    
        case 3: // Unix
            return {
                platform: 'Unix',
                type: types[(externalAttributes >> 28) & 0x0F],
                mode: (externalAttributes >> 16) & 0xFFF
            };
    
        // case 0: // MSDOS
        default:
            if (platform !== 0) {
                console.warn('Possibly unsupported ZIP platform type, ' + platform);
            }
    
            var attribs = {
                A: (externalAttributes >> 5) & 0x01,
                D: (externalAttributes >> 4) & 0x01,
                V: (externalAttributes >> 3) & 0x01,
                S: (externalAttributes >> 2) & 0x01,
                H: (externalAttributes >> 1) & 0x01,
                R: externalAttributes & 0x01
            };
    
            // With no better guidance we'll make the default permissions ugo+r
            var mode = parseInt('0444', 8);
    
            if (attribs.D) {
                mode |= parseInt('0111', 8); // Set the execute bit
            }
    
            if (!attribs.R) {
                mode |= parseInt('0222', 8); // Set the write bit
            }
    
            mode &= ~process.umask();
    
            return {
                platform: 'DOS',
                type: attribs.D ? 'Directory' : 'File',
                mode: mode
            };
        }
    };
    
    var readEndRecord = function (buffer) {
        var data = binary.parse(buffer)
        .word32lu('signature')
        .word16lu('diskNumber')
        .word16lu('directoryStartDisk')
        .word16lu('directoryEntryCountDisk')
        .word16lu('directoryEntryCount')
        .word32lu('directorySize')
        .word32lu('directoryOffset')
        .word16lu('commentLength')
        .buffer('comment', 'commentLength')
        .vars;
    
        data.comment = data.comment.toString();
    
        return data;
    };
    
    var directorySort = function (a, b) {
        return a.relativeOffsetOfLocalHeader - b.relativeOffsetOfLocalHeader;
    };
    
    var readDirectory = function (buffer) {
        var directory = [];
        var current;
        var index = 0;
    
        while (index < buffer.length) {
            current = binary.parse(buffer.slice(index, index + 46))
            .word32lu('signature')
            .word8lu('creatorSpecVersion')
            .word8lu('creatorPlatform')
            .word8lu('requiredSpecVersion')
            .word8lu('requiredPlatform')
            .word16lu('generalPurposeBitFlag')
            .word16lu('compressionMethod')
            .word16lu('lastModFileTime')
            .word16lu('lastModFileDate')
            .word32lu('crc32')
            .word32lu('compressedSize')
            .word32lu('uncompressedSize')
            .word16lu('fileNameLength')
            .word16lu('extraFieldLength')
            .word16lu('fileCommentLength')
            .word16lu('diskNumberStart')
            .word16lu('internalFileAttributes')
            .word32lu('externalFileAttributes')
            .word32lu('relativeOffsetOfLocalHeader')
            .vars;
    
            index += 46;
    
            current.generalPurposeFlags = convertGeneralPurposeFlags(current.generalPurposeBitFlag);
            current.fileAttributes = parseExternalFileAttributes(current.externalFileAttributes, current.creatorPlatform);
    
            current.modifiedTime = convertDateTime(current.lastModFileDate, current.lastModFileTime);
            current.fileName = current.extraField = current.fileComment = '';
            current.headerLength = 46 + current.fileNameLength + current.extraFieldLength + current.fileCommentLength;
    
            if (current.fileNameLength > 0) {
                current.fileName = buffer.slice(index, index + current.fileNameLength).toString();
                index += current.fileNameLength;
            }
    
            if (current.extraFieldLength > 0) {
                current.extraField = buffer.slice(index, index + current.extraFieldLength).toString();
                index += current.extraFieldLength;
            }
    
            if (current.fileCommentLength > 0) {
                current.fileComment = buffer.slice(index, index + current.fileCommentLength).toString();
                index += current.fileCommentLength;
            }
    
            if (current.fileAttributes.type !== 'Directory' && current.fileName.substr(-1) === '/') {
                // TODO: check that this is a reasonable check
                current.fileAttributes.type = 'Directory';
            }
    
            directory.push(current);
        }
    
        directory.sort(directorySort);
    
        return directory;
    };
    
    var readFileEntry = function (buffer) {
        var index = 0;
    
        var fileEntry = binary.parse(buffer.slice(index, 30))
        .word32lu('signature')
        .word16lu('versionNeededToExtract')
        .word16lu('generalPurposeBitFlag')
        .word16lu('compressionMethod')
        .word16lu('lastModFileTime')
        .word16lu('lastModFileDate')
        .word32lu('crc32')
        .word32lu('compressedSize')
        .word32lu('uncompressedSize')
        .word16lu('fileNameLength')
        .word16lu('extraFieldLength')
        .vars;
    
        index += 30;
    
        fileEntry.fileName = fileEntry.extraField = '';
    
        fileEntry.entryLength = 30 + fileEntry.fileNameLength + fileEntry.extraFieldLength;
    
        if (fileEntry.entryLength > structures.maxFileEntrySize) {
            throw new Error('File entry unexpectedly large: ' + fileEntry.entryLength + ' (max: ' + structures.maxFileEntrySize + ')');
        }
    
        if (fileEntry.fileNameLength > 0) {
            fileEntry.fileName = buffer.slice(index, index + fileEntry.fileNameLength).toString();
            index += fileEntry.fileNameLength;
        }
    
        if (fileEntry.extraFieldLength > 0) {
            fileEntry.extraField = buffer.slice(index, index + fileEntry.extraFieldLength).toString();
            index += fileEntry.extraFieldLength;
        }
    
        return fileEntry;
    };
    
    var structures = module.exports = {
        readEndRecord: readEndRecord,
        readDirectory: readDirectory,
        readFileEntry: readFileEntry,
        maxFileEntrySize: 4096
    };
    
  provide("decompress-zip/lib/structures", module.exports);
}(global));

// pakmanager:decompress-zip/lib/signatures
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  module.exports = {
        LOCAL_FILE_HEADER: 0x04034b50,
        DATA_DESCRIPTOR_RECORD: 0x08074b50,
        ARCHIVE_EXTRA_DATA: 0x08064b50,
        CENTRAL_FILE_HEADER: 0x02014b50,
        HEADER: 0x05054b50,
        ZIP64_END_OF_CENTRAL_DIRECTORY: 0x06064b50,
        ZIP64_END_OF_CENTRAL_DIRECTORY_LOCATOR: 0x07064b50,
        END_OF_CENTRAL_DIRECTORY: 0x06054b50
    };
    
  provide("decompress-zip/lib/signatures", module.exports);
}(global));

// pakmanager:decompress-zip/lib/extractors
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var stream = require('stream');
    if (!stream.Readable) {
        var stream = require('readable-stream');
    }
    var fs = require('graceful-fs');
    var Q = require('q');
    var path = require('path');
    var zlib = require('zlib');
    var touch = Q.denodeify(require('touch'));
    var mkpath = Q.denodeify(require('mkpath'));
    var writeFile = Q.denodeify(fs.writeFile);
    var inflateRaw = Q.denodeify(zlib.inflateRaw);
    var symlink = Q.denodeify(fs.symlink);
    var stat = Q.denodeify(fs.stat);
    
    // Use a cache of promises for building the directory tree. This allows us to
    // correctly queue up file extractions for after their path has been created,
    // avoid trying to create the path twice and still be async.
    var mkdir = function (dir, cache) {
        dir = path.normalize(path.resolve(process.cwd(), dir) + path.sep);
    
        if (!cache[dir]) {
            var parent;
    
            if (fs.existsSync(dir)) {
                parent = new Q();
            } else {
                parent = mkdir(path.dirname(dir), cache);
            }
    
            cache[dir] = parent.then(function () {
                return mkpath(dir);
            });
        }
    
        return cache[dir];
    };
    
    // Utility methods for writing output files
    var extractors = {
        folder: function (folder, destination, zip) {
            return mkdir(destination, zip.dirCache)
            .then(function () {
                return {folder: folder.path};
            });
        },
        store: function (file, destination, zip) {
            var writer;
    
            if (file.uncompressedSize === 0) {
                writer = touch.bind(null, destination);
            } else if (file.uncompressedSize <= zip.chunkSize) {
                writer = function () {
                    return zip.getBuffer(file._offset, file._offset + file.uncompressedSize)
                    .then(writeFile.bind(null, destination));
                };
            } else {
                var input = new stream.Readable();
                input.wrap(fs.createReadStream(zip.filename, {start: file._offset, end: file._offset + file.uncompressedSize - 1}));
                writer = pipePromise.bind(null, input, destination);
            }
    
            return mkdir(path.dirname(destination), zip.dirCache)
            .then(writer)
            .then(function () {
                return {stored: file.path};
            });
        },
        deflate: function (file, destination, zip) {
            // For Deflate you don't actually need to specify the end offset - and
            // in fact many ZIP files don't include compressed file sizes for
            // Deflated files so we don't even know what the end offset is.
    
            return mkdir(path.dirname(destination), zip.dirCache)
            .then(function () {
                if (file._maxSize <= zip.chunkSize) {
                    return zip.getBuffer(file._offset, file._offset + file._maxSize)
                    .then(inflateRaw)
                    .then(function (buffer) {
                        return writeFile(destination, buffer);
                    });
                } else {
                    // For node 0.8 we need to create the Zlib stream and attach
                    // handlers in the same tick of the event loop, which is why we do
                    // the creation in here
                    var input = new stream.Readable();
                    input.wrap(fs.createReadStream(zip.filename, {start: file._offset}));
                    var inflater = input.pipe(zlib.createInflateRaw({highWaterMark: 32 * 1024}));
    
                    return pipePromise(inflater, destination);
                }
            })
            .then(function () {
                return {deflated: file.path};
            });
        },
        symlink: function (file, destination, zip, basePath) {
            var parent = path.dirname(destination);
            return mkdir(parent, zip.dirCache)
            .then(function () {
                return getLinkLocation(file, destination, zip, basePath);
            })
            .then(function (linkTo) {
                return symlink(path.resolve(parent, linkTo), destination)
                .then(function () {
                    return {symlink: file.path, linkTo: linkTo};
                });
            });
        },
        // Make a shallow copy of the file/directory this symlink points to instead
        // of actually creating a link
        copy: function (file, destination, zip, basePath) {
            var type;
            var parent = path.dirname(destination);
    
            return mkdir(parent, zip.dirCache)
            .then(function () {
                return getLinkLocation(file, destination, zip, basePath);
            })
            .then(function (linkTo) {
                return stat(path.resolve(parent, linkTo))
                .then(function (stats) {
                    if (stats.isFile()) {
                        type = 'File';
                        var input = new stream.Readable();
                        input.wrap(fs.createReadStream(path.resolve(parent, linkTo)));
                        return pipePromise(input, destination);
                    } else if (stats.isDirectory()) {
                        type = 'Directory';
                        return mkdir(destination, zip.dirCache);
                    } else {
                        throw new Error('Could not follow symlink to unknown file type');
                    }
                })
                .then(function () {
                    return {copy: file.path, original: linkTo, type: type};
                });
            });
        }
    };
    
    var getLinkLocation = function (file, destination, zip, basePath) {
        var parent = path.dirname(destination);
        return zip.getBuffer(file._offset, file._offset + file.uncompressedSize)
        .then(function (buffer) {
            var linkTo = buffer.toString();
            var fullLink = path.resolve(parent, linkTo);
    
            if (path.relative(basePath, fullLink).slice(0, 2) === '..') {
                throw new Error('Symlink links outside archive');
            }
    
            return linkTo;
        });
    };
    
    var pipePromise = function (input, destination) {
        var deferred = Q.defer();
        var output = fs.createWriteStream(destination);
        var errorHandler = function (error) {
            deferred.reject(error);
        };
    
        input.on('error', errorHandler);
        output.on('error', errorHandler);
    
        // For node 0.8 we can't just use the 'finish' event of the pipe
        input.on('end', function () {
            output.end(function () {
                deferred.resolve();
            });
        });
    
        input.pipe(output, {end: false});
    
        return deferred.promise;
    };
    
    module.exports = extractors;
    
  provide("decompress-zip/lib/extractors", module.exports);
}(global));

// pakmanager:decompress-zip/lib/file-details
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Objects with this prototype are used as the public representation of a file
    var path = require('path');
    
    var FileDetails = function (directoryEntry) {
        // TODO: Add 'extra field' support
    
        this._offset = 0;
        this._maxSize = 0;
    
        this.parent = path.dirname(directoryEntry.fileName);
        this.filename = path.basename(directoryEntry.fileName);
        this.path = path.normalize(directoryEntry.fileName);
    
        this.type = directoryEntry.fileAttributes.type;
        this.mode = directoryEntry.fileAttributes.mode;
        this.compressionMethod = directoryEntry.compressionMethod;
        this.modified = directoryEntry.modifiedTime;
        this.crc32 = directoryEntry.crc32;
        this.compressedSize = directoryEntry.compressedSize;
        this.uncompressedSize = directoryEntry.uncompressedSize;
        this.comment = directoryEntry.fileComment;
    
        this.flags = {
            encrypted: directoryEntry.generalPurposeFlags.encrypted,
            compressionFlag1: directoryEntry.generalPurposeFlags.compressionFlag1,
            compressionFlag2: directoryEntry.generalPurposeFlags.compressionFlag2,
            useDataDescriptor: directoryEntry.generalPurposeFlags.useDataDescriptor,
            enhancedDeflating: directoryEntry.generalPurposeFlags.enhancedDeflating,
            compressedPatched: directoryEntry.generalPurposeFlags.compressedPatched,
            strongEncryption: directoryEntry.generalPurposeFlags.strongEncryption,
            utf8: directoryEntry.generalPurposeFlags.utf8,
            encryptedCD: directoryEntry.generalPurposeFlags.encryptedCD
        };
    
    };
    
    module.exports = FileDetails;
    
  provide("decompress-zip/lib/file-details", module.exports);
}(global));

// pakmanager:decompress-zip
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    // The zip file spec is at http://www.pkware.com/documents/casestudies/APPNOTE.TXT
    // TODO: There is fair chunk of the spec that I have ignored. Need to add
    // assertions everywhere to make sure that we are not dealing with a ZIP type
    // that I haven't designed for. Things like spanning archives, non-DEFLATE
    // compression, encryption, etc.
    var fs = require('graceful-fs');
    var Q = require('q');
    var path = require('path');
    var util = require('util');
    var events = require('events');
    var structures =  require('decompress-zip/lib/structures');
    var signatures =  require('decompress-zip/lib/signatures');
    var extractors =  require('decompress-zip/lib/extractors');
    var FileDetails =  require('decompress-zip/lib/file-details');
    
    var fstat = Q.denodeify(fs.fstat);
    var read = Q.denodeify(fs.read);
    var fopen = Q.denodeify(fs.open);
    
    function DecompressZip(filename) {
        events.EventEmitter.call(this);
    
        this.filename = filename;
        this.stats = null;
        this.fd = null;
        this.chunkSize = 1024 * 1024; // Buffer up to 1Mb at a time
        this.dirCache = {};
    
        // When we need a resource, we should check if there is a promise for it
        // already and use that. If the promise is already fulfilled we don't do the
        // async work again and we get to queue up dependant tasks.
        this._p = {}; // _p instead of _promises because it is a lot easier to read
    }
    
    util.inherits(DecompressZip, events.EventEmitter);
    
    DecompressZip.prototype.openFile = function () {
        return fopen(this.filename, 'r');
    };
    
    DecompressZip.prototype.closeFile = function () {
        if (this.fd) {
            fs.closeSync(this.fd);
            this.fd = null;
        }
    };
    
    DecompressZip.prototype.statFile = function (fd) {
        this.fd = fd;
        return fstat(fd);
    };
    
    DecompressZip.prototype.list = function () {
        var self = this;
    
        this.getFiles()
        .then(function (files) {
            var result = [];
    
            files.forEach(function (file) {
                result.push(file.path);
            });
    
            self.emit('list', result);
        })
        .fail(function (error) {
            self.emit('error', error);
        })
        .fin(self.closeFile.bind(self));
    
        return this;
    };
    
    DecompressZip.prototype.extract = function (options) {
        var self = this;
    
        options = options || {};
        options.path = options.path || '.';
        options.filter = options.filter || null;
        options.follow = !!options.follow;
        options.strip = +options.strip || 0;
    
        this.getFiles()
        .then(function (files) {
            var copies = [];
    
            if (options.filter) {
                files = files.filter(options.filter);
            }
    
            if (options.follow) {
                copies = files.filter(function (file) {
                    return file.type === 'SymbolicLink';
                });
                files = files.filter(function (file) {
                    return file.type !== 'SymbolicLink';
                });
            }
    
            if (options.strip) {
                files = files.map(function (file) {
                    if (file.type !== 'Directory') {
                        // we don't use `path.sep` as we're using `/` in Windows too
                        var dir = file.parent.split('/');
                        var filename = file.filename;
    
                        if (options.strip > dir.length) {
                            throw new Error('You cannot strip more levels than there are directories');
                        } else {
                            dir = dir.slice(options.strip);
                        }
    
                        file.path = path.join(dir.join(path.sep), filename);
                        return file;
                    }
                });
            }
    
            return self.extractFiles(files, options)
            .then(self.extractFiles.bind(self, copies, options));
        })
        .then(function (results) {
            self.emit('extract', results);
        })
        .fail(function (error) {
            self.emit('error', error);
        })
        .fin(self.closeFile.bind(self));
    
        return this;
    };
    
    // Utility methods
    DecompressZip.prototype.getSearchBuffer = function (stats) {
        var size = Math.min(stats.size, this.chunkSize);
        this.stats = stats;
        return this.getBuffer(stats.size - size, stats.size);
    };
    
    DecompressZip.prototype.getBuffer = function (start, end) {
        var size = end - start;
        return read(this.fd, new Buffer(size), 0, size, start)
        .then(function (result) {
            return result[1];
        });
    };
    
    DecompressZip.prototype.findEndOfDirectory = function (buffer) {
        var index = buffer.length - 3;
        var chunk = '';
    
        // Apparently the ZIP spec is not very good and it is impossible to
        // guarantee that you have read a zip file correctly, or to determine
        // the location of the CD without hunting.
        // Search backwards through the buffer, as it is very likely to be near the
        // end of the file.
        while (index > Math.max(buffer.length - this.chunkSize, 0) && chunk !== signatures.END_OF_CENTRAL_DIRECTORY) {
            index--;
            chunk = buffer.readUInt32LE(index);
        }
    
        if (chunk !== signatures.END_OF_CENTRAL_DIRECTORY) {
            throw new Error('Could not find the End of Central Directory Record');
        }
    
        return buffer.slice(index);
    };
    
    // Directory here means the ZIP Central Directory, not a folder
    DecompressZip.prototype.readDirectory = function (recordBuffer) {
        var record = structures.readEndRecord(recordBuffer);
    
        return this.getBuffer(record.directoryOffset, record.directoryOffset + record.directorySize)
        .then(structures.readDirectory.bind(null));
    };
    
    DecompressZip.prototype.getFiles = function () {
        if (!this._p.getFiles) {
            this._p.getFiles = this.openFile()
            .then(this.statFile.bind(this))
            .then(this.getSearchBuffer.bind(this))
            .then(this.findEndOfDirectory.bind(this))
            .then(this.readDirectory.bind(this))
            .then(this.readFileEntries.bind(this));
        }
    
        return this._p.getFiles;
    };
    
    DecompressZip.prototype.readFileEntries = function (directory) {
        var promises = [];
        var files = [];
        var self = this;
    
        directory.forEach(function (directoryEntry, index) {
            var start = directoryEntry.relativeOffsetOfLocalHeader;
            var end = Math.min(self.stats.size, start + structures.maxFileEntrySize);
            var fileDetails = new FileDetails(directoryEntry);
    
            var promise = self.getBuffer(start, end)
            .then(structures.readFileEntry.bind(null))
            .then(function (fileEntry) {
                var maxSize;
    
                if (fileDetails.compressedSize > 0) {
                    maxSize = fileDetails.compressedSize;
                } else {
                    maxSize = self.stats.size;
    
                    if (index < directory.length - 1) {
                        maxSize = directory[index + 1].relativeOffsetOfLocalHeader;
                    }
    
                    maxSize -= start + fileEntry.entryLength;
                }
    
                fileDetails._offset = start + fileEntry.entryLength;
                fileDetails._maxSize = maxSize;
    
                self.emit('file', fileDetails);
                files[index] = fileDetails;
            });
    
            promises.push(promise);
        });
    
        return Q.all(promises)
        .then(function () {
            return files;
        });
    };
    
    DecompressZip.prototype.extractFiles = function (files, options, results) {
        var promises = [];
        var self = this;
    
        results = results || [];
        var fileIndex = 0;
        files.forEach(function (file) {
            var promise = self.extractFile(file, options)
            .then(function (result) {
                self.emit('progress', fileIndex++, files.length);
                results.push(result);
            });
    
            promises.push(promise);
        });
    
        return Q.all(promises)
        .then(function () {
            return results;
        });
    };
    
    DecompressZip.prototype.extractFile = function (file, options) {
        var destination = path.join(options.path, file.path);
    
        // Possible compression methods:
        //    0 - The file is stored (no compression)
        //    1 - The file is Shrunk
        //    2 - The file is Reduced with compression factor 1
        //    3 - The file is Reduced with compression factor 2
        //    4 - The file is Reduced with compression factor 3
        //    5 - The file is Reduced with compression factor 4
        //    6 - The file is Imploded
        //    7 - Reserved for Tokenizing compression algorithm
        //    8 - The file is Deflated
        //    9 - Enhanced Deflating using Deflate64(tm)
        //   10 - PKWARE Data Compression Library Imploding (old IBM TERSE)
        //   11 - Reserved by PKWARE
        //   12 - File is compressed using BZIP2 algorithm
        //   13 - Reserved by PKWARE
        //   14 - LZMA (EFS)
        //   15 - Reserved by PKWARE
        //   16 - Reserved by PKWARE
        //   17 - Reserved by PKWARE
        //   18 - File is compressed using IBM TERSE (new)
        //   19 - IBM LZ77 z Architecture (PFS)
        //   97 - WavPack compressed data
        //   98 - PPMd version I, Rev 1
    
        if (file.type === 'Directory') {
            return extractors.folder(file, destination, this);
        }
    
        if (file.type === 'File') {
            switch (file.compressionMethod) {
            case 0:
                return extractors.store(file, destination, this);
    
            case 8:
                return extractors.deflate(file, destination, this);
    
            default:
                throw new Error('Unsupported compression type');
            }
        }
    
        if (file.type === 'SymbolicLink') {
            if (options.follow) {
                return extractors.copy(file, destination, this, options.path);
            } else {
                return extractors.symlink(file, destination, this, options.path);
            }
        }
    
        throw new Error('Unsupported file type "' + file.type + '"');
    };
    
    module.exports = DecompressZip;
    
  provide("decompress-zip", module.exports);
}(global));

// pakmanager:googleapis/apis
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Copyright 2014 Google Inc. All Rights Reserved.
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    'use strict';
    
    var path = require('path');
    var util = require('util');
    /**
     * Return a Function that requires an API from the disk
     * @param  {String} filename Filename of API
     * @return {function}        function used to require the API from disk
     * @private
     */
    function requireAPI(filename) {
      return function(options) {
        var type = typeof options;
        var version;
        if (type === 'string') {
          version = options;
          options = {};
        } else if (type === 'object') {
          version = options.version;
          delete options.version;
        } else {
          throw new Error('Argument error: Accepts only string or object');
        }
        try {
          var endpointPath = path.join(__dirname, filename, path.basename(version));
          var Endpoint = require(endpointPath);
          var ep = new Endpoint(options);
          ep.google = this; // for drive.google.transporter
          return Object.freeze(ep); // create new & freeze
        } catch (e) {
          throw new Error(util.format('Unable to load endpoint %s("%s"): %s',
            filename, version, e.message));
        }
      };
    }
    /**
     * APIs to be exported
     * @type {Object}
     * @private
     */
    var APIs = {
      'adexchangebuyer': requireAPI('adexchangebuyer'),
      'adexchangeseller': requireAPI('adexchangeseller'),
      'admin': requireAPI('admin'),
      'adsense': requireAPI('adsense'),
      'adsensehost': requireAPI('adsensehost'),
      'analytics': requireAPI('analytics'),
      'androidenterprise': requireAPI('androidenterprise'),
      'androidpublisher': requireAPI('androidpublisher'),
      'appsactivity': requireAPI('appsactivity'),
      'appstate': requireAPI('appstate'),
      'autoscaler': requireAPI('autoscaler'),
      'bigquery': requireAPI('bigquery'),
      'blogger': requireAPI('blogger'),
      'books': requireAPI('books'),
      'calendar': requireAPI('calendar'),
      'civicinfo': requireAPI('civicinfo'),
      'cloudlatencytest': requireAPI('cloudlatencytest'),
      'cloudmonitoring': requireAPI('cloudmonitoring'),
      'clouduseraccounts': requireAPI('clouduseraccounts'),
      'compute': requireAPI('compute'),
      'computeaccounts': requireAPI('computeaccounts'),
      'container': requireAPI('container'),
      'content': requireAPI('content'),
      'coordinate': requireAPI('coordinate'),
      'customsearch': requireAPI('customsearch'),
      'dataflow': requireAPI('dataflow'),
      'datastore': requireAPI('datastore'),
      'deploymentmanager': requireAPI('deploymentmanager'),
      'dfareporting': requireAPI('dfareporting'),
      'discovery': requireAPI('discovery'),
      'dns': requireAPI('dns'),
      'doubleclickbidmanager': requireAPI('doubleclickbidmanager'),
      'doubleclicksearch': requireAPI('doubleclicksearch'),
      'drive': requireAPI('drive'),
      'fitness': requireAPI('fitness'),
      'freebase': requireAPI('freebase'),
      'fusiontables': requireAPI('fusiontables'),
      'games': requireAPI('games'),
      'gamesConfiguration': requireAPI('gamesConfiguration'),
      'gamesManagement': requireAPI('gamesManagement'),
      'gan': requireAPI('gan'),
      'genomics': requireAPI('genomics'),
      'gmail': requireAPI('gmail'),
      'groupsmigration': requireAPI('groupsmigration'),
      'groupssettings': requireAPI('groupssettings'),
      'classroom': requireAPI('classroom'),
      'cloudresourcemanager': requireAPI('cloudresourcemanager'),
      'logging': requireAPI('logging'),
      'playmoviespartner': requireAPI('playmoviespartner'),
      'pubsub': requireAPI('pubsub'),
      'identitytoolkit': requireAPI('identitytoolkit'),
      'licensing': requireAPI('licensing'),
      'manager': requireAPI('manager'),
      'mapsengine': requireAPI('mapsengine'),
      'mirror': requireAPI('mirror'),
      'oauth2': requireAPI('oauth2'),
      'pagespeedonline': requireAPI('pagespeedonline'),
      'plus': requireAPI('plus'),
      'plusDomains': requireAPI('plusDomains'),
      'prediction': requireAPI('prediction'),
      'qpxExpress': requireAPI('qpxExpress'),
      'replicapool': requireAPI('replicapool'),
      'replicapoolupdater': requireAPI('replicapoolupdater'),
      'reseller': requireAPI('reseller'),
      'resourceviews': requireAPI('resourceviews'),
      'siteVerification': requireAPI('siteVerification'),
      'spectrum': requireAPI('spectrum'),
      'sqladmin': requireAPI('sqladmin'),
      'storage': requireAPI('storage'),
      'tagmanager': requireAPI('tagmanager'),
      'taskqueue': requireAPI('taskqueue'),
      'tasks': requireAPI('tasks'),
      'translate': requireAPI('translate'),
      'urlshortener': requireAPI('urlshortener'),
      'webfonts': requireAPI('webfonts'),
      'webmasters': requireAPI('webmasters'),
      'youtube': requireAPI('youtube'),
      'youtubeAnalytics': requireAPI('youtubeAnalytics')
    };
    
    /**
     * Exports the APIs
     * @type {Object}
     */
    module.exports = APIs;
    
    /**
     * @callback callback
     * @param {Error} err Error object if an error occurred.
     * @param {object} data Response data object.
     */
  provide("googleapis/apis", module.exports);
}(global));

// pakmanager:googleapis
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Copyright 2012 Google Inc. All Rights Reserved.
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    
    'use strict';
    
    /**
     * A module for interacting with Google APIs
     * @module google
     */
    
    /**
     * Load the apis from apis index file
     * This file holds all version information
     * @private
     */
    var apis =  require('googleapis/apis');
    var googleAuth = require('google-auth-library');
    
    /**
     * GoogleApis constructor.
     * @param {object} options Options to be passed in
     * @constructor
     */
    function GoogleApis(options) {
      this.options(options);
      this.addAPIs(apis);
      this.auth = new googleAuth();
      this.GoogleApis = GoogleApis;
    }
    
    /**
     * Set options
     * @param  {Object} opts Options to set
     */
    GoogleApis.prototype.options = function(opts) {
      this._options = opts || {};
    };
    
    /**
     * Add APIs endpoints to googleapis object
     * E.g. googleapis.drive and googleapis.datastore
     *
     * @param {Array} apis Apis to be added
     * @private
     */
    GoogleApis.prototype.addAPIs = function(apis) {
      for (var apiName in apis) {
        this[apiName] = apis[apiName].bind(this);
      }
    };
    
    var google = new GoogleApis();
    
    /**
     * Exports googleapis.
     */
    module.exports = google;
    
  provide("googleapis", module.exports);
}(global));

// pakmanager:humanize-url
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    var normalizeUrl = require('normalize-url');
    var stripUrlAuth = require('strip-url-auth');
    
    module.exports = function (str) {
    	if (typeof str !== 'string') {
    		throw new TypeError('Expected a string');
    	}
    
    	return normalizeUrl(stripUrlAuth(str)).replace(/^(?:https?:)?\/\//, '');
    };
    
  provide("humanize-url", module.exports);
}(global));

// pakmanager:lodash
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * @license
     * lodash 3.10.0 (Custom Build) <https://lodash.com/>
     * Build: `lodash modern -d -o ./index.js`
     * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
     * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
     * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     * Available under MIT license <https://lodash.com/license>
     */
    ;(function() {
    
      /** Used as a safe reference for `undefined` in pre-ES5 environments. */
      var undefined;
    
      /** Used as the semantic version number. */
      var VERSION = '3.10.0';
    
      /** Used to compose bitmasks for wrapper metadata. */
      var BIND_FLAG = 1,
          BIND_KEY_FLAG = 2,
          CURRY_BOUND_FLAG = 4,
          CURRY_FLAG = 8,
          CURRY_RIGHT_FLAG = 16,
          PARTIAL_FLAG = 32,
          PARTIAL_RIGHT_FLAG = 64,
          ARY_FLAG = 128,
          REARG_FLAG = 256;
    
      /** Used as default options for `_.trunc`. */
      var DEFAULT_TRUNC_LENGTH = 30,
          DEFAULT_TRUNC_OMISSION = '...';
    
      /** Used to detect when a function becomes hot. */
      var HOT_COUNT = 150,
          HOT_SPAN = 16;
    
      /** Used as the size to enable large array optimizations. */
      var LARGE_ARRAY_SIZE = 200;
    
      /** Used to indicate the type of lazy iteratees. */
      var LAZY_FILTER_FLAG = 1,
          LAZY_MAP_FLAG = 2;
    
      /** Used as the `TypeError` message for "Functions" methods. */
      var FUNC_ERROR_TEXT = 'Expected a function';
    
      /** Used as the internal argument placeholder. */
      var PLACEHOLDER = '__lodash_placeholder__';
    
      /** `Object#toString` result references. */
      var argsTag = '[object Arguments]',
          arrayTag = '[object Array]',
          boolTag = '[object Boolean]',
          dateTag = '[object Date]',
          errorTag = '[object Error]',
          funcTag = '[object Function]',
          mapTag = '[object Map]',
          numberTag = '[object Number]',
          objectTag = '[object Object]',
          regexpTag = '[object RegExp]',
          setTag = '[object Set]',
          stringTag = '[object String]',
          weakMapTag = '[object WeakMap]';
    
      var arrayBufferTag = '[object ArrayBuffer]',
          float32Tag = '[object Float32Array]',
          float64Tag = '[object Float64Array]',
          int8Tag = '[object Int8Array]',
          int16Tag = '[object Int16Array]',
          int32Tag = '[object Int32Array]',
          uint8Tag = '[object Uint8Array]',
          uint8ClampedTag = '[object Uint8ClampedArray]',
          uint16Tag = '[object Uint16Array]',
          uint32Tag = '[object Uint32Array]';
    
      /** Used to match empty string literals in compiled template source. */
      var reEmptyStringLeading = /\b__p \+= '';/g,
          reEmptyStringMiddle = /\b(__p \+=) '' \+/g,
          reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
    
      /** Used to match HTML entities and HTML characters. */
      var reEscapedHtml = /&(?:amp|lt|gt|quot|#39|#96);/g,
          reUnescapedHtml = /[&<>"'`]/g,
          reHasEscapedHtml = RegExp(reEscapedHtml.source),
          reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
    
      /** Used to match template delimiters. */
      var reEscape = /<%-([\s\S]+?)%>/g,
          reEvaluate = /<%([\s\S]+?)%>/g,
          reInterpolate = /<%=([\s\S]+?)%>/g;
    
      /** Used to match property names within property paths. */
      var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\n\\]|\\.)*?\1)\]/,
          reIsPlainProp = /^\w*$/,
          rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\n\\]|\\.)*?)\2)\]/g;
    
      /**
       * Used to match `RegExp` [syntax characters](http://ecma-international.org/ecma-262/6.0/#sec-patterns)
       * and those outlined by [`EscapeRegExpPattern`](http://ecma-international.org/ecma-262/6.0/#sec-escaperegexppattern).
       */
      var reRegExpChars = /^[:!,]|[\\^$.*+?()[\]{}|\/]|(^[0-9a-fA-Fnrtuvx])|([\n\r\u2028\u2029])/g,
          reHasRegExpChars = RegExp(reRegExpChars.source);
    
      /** Used to match [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks). */
      var reComboMark = /[\u0300-\u036f\ufe20-\ufe23]/g;
    
      /** Used to match backslashes in property paths. */
      var reEscapeChar = /\\(\\)?/g;
    
      /** Used to match [ES template delimiters](http://ecma-international.org/ecma-262/6.0/#sec-template-literal-lexical-components). */
      var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
    
      /** Used to match `RegExp` flags from their coerced string values. */
      var reFlags = /\w*$/;
    
      /** Used to detect hexadecimal string values. */
      var reHasHexPrefix = /^0[xX]/;
    
      /** Used to detect host constructors (Safari > 5). */
      var reIsHostCtor = /^\[object .+?Constructor\]$/;
    
      /** Used to detect unsigned integer values. */
      var reIsUint = /^\d+$/;
    
      /** Used to match latin-1 supplementary letters (excluding mathematical operators). */
      var reLatin1 = /[\xc0-\xd6\xd8-\xde\xdf-\xf6\xf8-\xff]/g;
    
      /** Used to ensure capturing order of template delimiters. */
      var reNoMatch = /($^)/;
    
      /** Used to match unescaped characters in compiled string literals. */
      var reUnescapedString = /['\n\r\u2028\u2029\\]/g;
    
      /** Used to match words to create compound words. */
      var reWords = (function() {
        var upper = '[A-Z\\xc0-\\xd6\\xd8-\\xde]',
            lower = '[a-z\\xdf-\\xf6\\xf8-\\xff]+';
    
        return RegExp(upper + '+(?=' + upper + lower + ')|' + upper + '?' + lower + '|' + upper + '+|[0-9]+', 'g');
      }());
    
      /** Used to assign default `context` object properties. */
      var contextProps = [
        'Array', 'ArrayBuffer', 'Date', 'Error', 'Float32Array', 'Float64Array',
        'Function', 'Int8Array', 'Int16Array', 'Int32Array', 'Math', 'Number',
        'Object', 'RegExp', 'Set', 'String', '_', 'clearTimeout', 'isFinite',
        'parseFloat', 'parseInt', 'setTimeout', 'TypeError', 'Uint8Array',
        'Uint8ClampedArray', 'Uint16Array', 'Uint32Array', 'WeakMap'
      ];
    
      /** Used to make template sourceURLs easier to identify. */
      var templateCounter = -1;
    
      /** Used to identify `toStringTag` values of typed arrays. */
      var typedArrayTags = {};
      typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
      typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
      typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
      typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
      typedArrayTags[uint32Tag] = true;
      typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
      typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
      typedArrayTags[dateTag] = typedArrayTags[errorTag] =
      typedArrayTags[funcTag] = typedArrayTags[mapTag] =
      typedArrayTags[numberTag] = typedArrayTags[objectTag] =
      typedArrayTags[regexpTag] = typedArrayTags[setTag] =
      typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
    
      /** Used to identify `toStringTag` values supported by `_.clone`. */
      var cloneableTags = {};
      cloneableTags[argsTag] = cloneableTags[arrayTag] =
      cloneableTags[arrayBufferTag] = cloneableTags[boolTag] =
      cloneableTags[dateTag] = cloneableTags[float32Tag] =
      cloneableTags[float64Tag] = cloneableTags[int8Tag] =
      cloneableTags[int16Tag] = cloneableTags[int32Tag] =
      cloneableTags[numberTag] = cloneableTags[objectTag] =
      cloneableTags[regexpTag] = cloneableTags[stringTag] =
      cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =
      cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
      cloneableTags[errorTag] = cloneableTags[funcTag] =
      cloneableTags[mapTag] = cloneableTags[setTag] =
      cloneableTags[weakMapTag] = false;
    
      /** Used to map latin-1 supplementary letters to basic latin letters. */
      var deburredLetters = {
        '\xc0': 'A',  '\xc1': 'A', '\xc2': 'A', '\xc3': 'A', '\xc4': 'A', '\xc5': 'A',
        '\xe0': 'a',  '\xe1': 'a', '\xe2': 'a', '\xe3': 'a', '\xe4': 'a', '\xe5': 'a',
        '\xc7': 'C',  '\xe7': 'c',
        '\xd0': 'D',  '\xf0': 'd',
        '\xc8': 'E',  '\xc9': 'E', '\xca': 'E', '\xcb': 'E',
        '\xe8': 'e',  '\xe9': 'e', '\xea': 'e', '\xeb': 'e',
        '\xcC': 'I',  '\xcd': 'I', '\xce': 'I', '\xcf': 'I',
        '\xeC': 'i',  '\xed': 'i', '\xee': 'i', '\xef': 'i',
        '\xd1': 'N',  '\xf1': 'n',
        '\xd2': 'O',  '\xd3': 'O', '\xd4': 'O', '\xd5': 'O', '\xd6': 'O', '\xd8': 'O',
        '\xf2': 'o',  '\xf3': 'o', '\xf4': 'o', '\xf5': 'o', '\xf6': 'o', '\xf8': 'o',
        '\xd9': 'U',  '\xda': 'U', '\xdb': 'U', '\xdc': 'U',
        '\xf9': 'u',  '\xfa': 'u', '\xfb': 'u', '\xfc': 'u',
        '\xdd': 'Y',  '\xfd': 'y', '\xff': 'y',
        '\xc6': 'Ae', '\xe6': 'ae',
        '\xde': 'Th', '\xfe': 'th',
        '\xdf': 'ss'
      };
    
      /** Used to map characters to HTML entities. */
      var htmlEscapes = {
        '&': '&amp;',
        '<': '&lt;',
        '>': '&gt;',
        '"': '&quot;',
        "'": '&#39;',
        '`': '&#96;'
      };
    
      /** Used to map HTML entities to characters. */
      var htmlUnescapes = {
        '&amp;': '&',
        '&lt;': '<',
        '&gt;': '>',
        '&quot;': '"',
        '&#39;': "'",
        '&#96;': '`'
      };
    
      /** Used to determine if values are of the language type `Object`. */
      var objectTypes = {
        'function': true,
        'object': true
      };
    
      /** Used to escape characters for inclusion in compiled regexes. */
      var regexpEscapes = {
        '0': 'x30', '1': 'x31', '2': 'x32', '3': 'x33', '4': 'x34',
        '5': 'x35', '6': 'x36', '7': 'x37', '8': 'x38', '9': 'x39',
        'A': 'x41', 'B': 'x42', 'C': 'x43', 'D': 'x44', 'E': 'x45', 'F': 'x46',
        'a': 'x61', 'b': 'x62', 'c': 'x63', 'd': 'x64', 'e': 'x65', 'f': 'x66',
        'n': 'x6e', 'r': 'x72', 't': 'x74', 'u': 'x75', 'v': 'x76', 'x': 'x78'
      };
    
      /** Used to escape characters for inclusion in compiled string literals. */
      var stringEscapes = {
        '\\': '\\',
        "'": "'",
        '\n': 'n',
        '\r': 'r',
        '\u2028': 'u2028',
        '\u2029': 'u2029'
      };
    
      /** Detect free variable `exports`. */
      var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;
    
      /** Detect free variable `module`. */
      var freeModule = objectTypes[typeof module] && module && !module.nodeType && module;
    
      /** Detect free variable `global` from Node.js. */
      var freeGlobal = freeExports && freeModule && typeof global == 'object' && global && global.Object && global;
    
      /** Detect free variable `self`. */
      var freeSelf = objectTypes[typeof self] && self && self.Object && self;
    
      /** Detect free variable `window`. */
      var freeWindow = objectTypes[typeof window] && window && window.Object && window;
    
      /** Detect the popular CommonJS extension `module.exports`. */
      var moduleExports = freeModule && freeModule.exports === freeExports && freeExports;
    
      /**
       * Used as a reference to the global object.
       *
       * The `this` value is used if it's the global object to avoid Greasemonkey's
       * restricted `window` object, otherwise the `window` object is used.
       */
      var root = freeGlobal || ((freeWindow !== (this && this.window)) && freeWindow) || freeSelf || this;
    
      /*--------------------------------------------------------------------------*/
    
      /**
       * The base implementation of `compareAscending` which compares values and
       * sorts them in ascending order without guaranteeing a stable sort.
       *
       * @private
       * @param {*} value The value to compare.
       * @param {*} other The other value to compare.
       * @returns {number} Returns the sort order indicator for `value`.
       */
      function baseCompareAscending(value, other) {
        if (value !== other) {
          var valIsNull = value === null,
              valIsUndef = value === undefined,
              valIsReflexive = value === value;
    
          var othIsNull = other === null,
              othIsUndef = other === undefined,
              othIsReflexive = other === other;
    
          if ((value > other && !othIsNull) || !valIsReflexive ||
              (valIsNull && !othIsUndef && othIsReflexive) ||
              (valIsUndef && othIsReflexive)) {
            return 1;
          }
          if ((value < other && !valIsNull) || !othIsReflexive ||
              (othIsNull && !valIsUndef && valIsReflexive) ||
              (othIsUndef && valIsReflexive)) {
            return -1;
          }
        }
        return 0;
      }
    
      /**
       * The base implementation of `_.findIndex` and `_.findLastIndex` without
       * support for callback shorthands and `this` binding.
       *
       * @private
       * @param {Array} array The array to search.
       * @param {Function} predicate The function invoked per iteration.
       * @param {boolean} [fromRight] Specify iterating from right to left.
       * @returns {number} Returns the index of the matched value, else `-1`.
       */
      function baseFindIndex(array, predicate, fromRight) {
        var length = array.length,
            index = fromRight ? length : -1;
    
        while ((fromRight ? index-- : ++index < length)) {
          if (predicate(array[index], index, array)) {
            return index;
          }
        }
        return -1;
      }
    
      /**
       * The base implementation of `_.indexOf` without support for binary searches.
       *
       * @private
       * @param {Array} array The array to search.
       * @param {*} value The value to search for.
       * @param {number} fromIndex The index to search from.
       * @returns {number} Returns the index of the matched value, else `-1`.
       */
      function baseIndexOf(array, value, fromIndex) {
        if (value !== value) {
          return indexOfNaN(array, fromIndex);
        }
        var index = fromIndex - 1,
            length = array.length;
    
        while (++index < length) {
          if (array[index] === value) {
            return index;
          }
        }
        return -1;
      }
    
      /**
       * The base implementation of `_.isFunction` without support for environments
       * with incorrect `typeof` results.
       *
       * @private
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
       */
      function baseIsFunction(value) {
        // Avoid a Chakra JIT bug in compatibility modes of IE 11.
        // See https://github.com/jashkenas/underscore/issues/1621 for more details.
        return typeof value == 'function' || false;
      }
    
      /**
       * Converts `value` to a string if it's not one. An empty string is returned
       * for `null` or `undefined` values.
       *
       * @private
       * @param {*} value The value to process.
       * @returns {string} Returns the string.
       */
      function baseToString(value) {
        return value == null ? '' : (value + '');
      }
    
      /**
       * Used by `_.trim` and `_.trimLeft` to get the index of the first character
       * of `string` that is not found in `chars`.
       *
       * @private
       * @param {string} string The string to inspect.
       * @param {string} chars The characters to find.
       * @returns {number} Returns the index of the first character not found in `chars`.
       */
      function charsLeftIndex(string, chars) {
        var index = -1,
            length = string.length;
    
        while (++index < length && chars.indexOf(string.charAt(index)) > -1) {}
        return index;
      }
    
      /**
       * Used by `_.trim` and `_.trimRight` to get the index of the last character
       * of `string` that is not found in `chars`.
       *
       * @private
       * @param {string} string The string to inspect.
       * @param {string} chars The characters to find.
       * @returns {number} Returns the index of the last character not found in `chars`.
       */
      function charsRightIndex(string, chars) {
        var index = string.length;
    
        while (index-- && chars.indexOf(string.charAt(index)) > -1) {}
        return index;
      }
    
      /**
       * Used by `_.sortBy` to compare transformed elements of a collection and stable
       * sort them in ascending order.
       *
       * @private
       * @param {Object} object The object to compare.
       * @param {Object} other The other object to compare.
       * @returns {number} Returns the sort order indicator for `object`.
       */
      function compareAscending(object, other) {
        return baseCompareAscending(object.criteria, other.criteria) || (object.index - other.index);
      }
    
      /**
       * Used by `_.sortByOrder` to compare multiple properties of a value to another
       * and stable sort them.
       *
       * If `orders` is unspecified, all valuess are sorted in ascending order. Otherwise,
       * a value is sorted in ascending order if its corresponding order is "asc", and
       * descending if "desc".
       *
       * @private
       * @param {Object} object The object to compare.
       * @param {Object} other The other object to compare.
       * @param {boolean[]} orders The order to sort by for each property.
       * @returns {number} Returns the sort order indicator for `object`.
       */
      function compareMultiple(object, other, orders) {
        var index = -1,
            objCriteria = object.criteria,
            othCriteria = other.criteria,
            length = objCriteria.length,
            ordersLength = orders.length;
    
        while (++index < length) {
          var result = baseCompareAscending(objCriteria[index], othCriteria[index]);
          if (result) {
            if (index >= ordersLength) {
              return result;
            }
            var order = orders[index];
            return result * ((order === 'asc' || order === true) ? 1 : -1);
          }
        }
        // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications
        // that causes it, under certain circumstances, to provide the same value for
        // `object` and `other`. See https://github.com/jashkenas/underscore/pull/1247
        // for more details.
        //
        // This also ensures a stable sort in V8 and other engines.
        // See https://code.google.com/p/v8/issues/detail?id=90 for more details.
        return object.index - other.index;
      }
    
      /**
       * Used by `_.deburr` to convert latin-1 supplementary letters to basic latin letters.
       *
       * @private
       * @param {string} letter The matched letter to deburr.
       * @returns {string} Returns the deburred letter.
       */
      function deburrLetter(letter) {
        return deburredLetters[letter];
      }
    
      /**
       * Used by `_.escape` to convert characters to HTML entities.
       *
       * @private
       * @param {string} chr The matched character to escape.
       * @returns {string} Returns the escaped character.
       */
      function escapeHtmlChar(chr) {
        return htmlEscapes[chr];
      }
    
      /**
       * Used by `_.escapeRegExp` to escape characters for inclusion in compiled regexes.
       *
       * @private
       * @param {string} chr The matched character to escape.
       * @param {string} leadingChar The capture group for a leading character.
       * @param {string} whitespaceChar The capture group for a whitespace character.
       * @returns {string} Returns the escaped character.
       */
      function escapeRegExpChar(chr, leadingChar, whitespaceChar) {
        if (leadingChar) {
          chr = regexpEscapes[chr];
        } else if (whitespaceChar) {
          chr = stringEscapes[chr];
        }
        return '\\' + chr;
      }
    
      /**
       * Used by `_.template` to escape characters for inclusion in compiled string literals.
       *
       * @private
       * @param {string} chr The matched character to escape.
       * @returns {string} Returns the escaped character.
       */
      function escapeStringChar(chr) {
        return '\\' + stringEscapes[chr];
      }
    
      /**
       * Gets the index at which the first occurrence of `NaN` is found in `array`.
       *
       * @private
       * @param {Array} array The array to search.
       * @param {number} fromIndex The index to search from.
       * @param {boolean} [fromRight] Specify iterating from right to left.
       * @returns {number} Returns the index of the matched `NaN`, else `-1`.
       */
      function indexOfNaN(array, fromIndex, fromRight) {
        var length = array.length,
            index = fromIndex + (fromRight ? 0 : -1);
    
        while ((fromRight ? index-- : ++index < length)) {
          var other = array[index];
          if (other !== other) {
            return index;
          }
        }
        return -1;
      }
    
      /**
       * Checks if `value` is object-like.
       *
       * @private
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
       */
      function isObjectLike(value) {
        return !!value && typeof value == 'object';
      }
    
      /**
       * Used by `trimmedLeftIndex` and `trimmedRightIndex` to determine if a
       * character code is whitespace.
       *
       * @private
       * @param {number} charCode The character code to inspect.
       * @returns {boolean} Returns `true` if `charCode` is whitespace, else `false`.
       */
      function isSpace(charCode) {
        return ((charCode <= 160 && (charCode >= 9 && charCode <= 13) || charCode == 32 || charCode == 160) || charCode == 5760 || charCode == 6158 ||
          (charCode >= 8192 && (charCode <= 8202 || charCode == 8232 || charCode == 8233 || charCode == 8239 || charCode == 8287 || charCode == 12288 || charCode == 65279)));
      }
    
      /**
       * Replaces all `placeholder` elements in `array` with an internal placeholder
       * and returns an array of their indexes.
       *
       * @private
       * @param {Array} array The array to modify.
       * @param {*} placeholder The placeholder to replace.
       * @returns {Array} Returns the new array of placeholder indexes.
       */
      function replaceHolders(array, placeholder) {
        var index = -1,
            length = array.length,
            resIndex = -1,
            result = [];
    
        while (++index < length) {
          if (array[index] === placeholder) {
            array[index] = PLACEHOLDER;
            result[++resIndex] = index;
          }
        }
        return result;
      }
    
      /**
       * An implementation of `_.uniq` optimized for sorted arrays without support
       * for callback shorthands and `this` binding.
       *
       * @private
       * @param {Array} array The array to inspect.
       * @param {Function} [iteratee] The function invoked per iteration.
       * @returns {Array} Returns the new duplicate-value-free array.
       */
      function sortedUniq(array, iteratee) {
        var seen,
            index = -1,
            length = array.length,
            resIndex = -1,
            result = [];
    
        while (++index < length) {
          var value = array[index],
              computed = iteratee ? iteratee(value, index, array) : value;
    
          if (!index || seen !== computed) {
            seen = computed;
            result[++resIndex] = value;
          }
        }
        return result;
      }
    
      /**
       * Used by `_.trim` and `_.trimLeft` to get the index of the first non-whitespace
       * character of `string`.
       *
       * @private
       * @param {string} string The string to inspect.
       * @returns {number} Returns the index of the first non-whitespace character.
       */
      function trimmedLeftIndex(string) {
        var index = -1,
            length = string.length;
    
        while (++index < length && isSpace(string.charCodeAt(index))) {}
        return index;
      }
    
      /**
       * Used by `_.trim` and `_.trimRight` to get the index of the last non-whitespace
       * character of `string`.
       *
       * @private
       * @param {string} string The string to inspect.
       * @returns {number} Returns the index of the last non-whitespace character.
       */
      function trimmedRightIndex(string) {
        var index = string.length;
    
        while (index-- && isSpace(string.charCodeAt(index))) {}
        return index;
      }
    
      /**
       * Used by `_.unescape` to convert HTML entities to characters.
       *
       * @private
       * @param {string} chr The matched character to unescape.
       * @returns {string} Returns the unescaped character.
       */
      function unescapeHtmlChar(chr) {
        return htmlUnescapes[chr];
      }
    
      /*--------------------------------------------------------------------------*/
    
      /**
       * Create a new pristine `lodash` function using the given `context` object.
       *
       * @static
       * @memberOf _
       * @category Utility
       * @param {Object} [context=root] The context object.
       * @returns {Function} Returns a new `lodash` function.
       * @example
       *
       * _.mixin({ 'foo': _.constant('foo') });
       *
       * var lodash = _.runInContext();
       * lodash.mixin({ 'bar': lodash.constant('bar') });
       *
       * _.isFunction(_.foo);
       * // => true
       * _.isFunction(_.bar);
       * // => false
       *
       * lodash.isFunction(lodash.foo);
       * // => false
       * lodash.isFunction(lodash.bar);
       * // => true
       *
       * // using `context` to mock `Date#getTime` use in `_.now`
       * var mock = _.runInContext({
       *   'Date': function() {
       *     return { 'getTime': getTimeMock };
       *   }
       * });
       *
       * // or creating a suped-up `defer` in Node.js
       * var defer = _.runInContext({ 'setTimeout': setImmediate }).defer;
       */
      function runInContext(context) {
        // Avoid issues with some ES3 environments that attempt to use values, named
        // after built-in constructors like `Object`, for the creation of literals.
        // ES5 clears this up by stating that literals must use built-in constructors.
        // See https://es5.github.io/#x11.1.5 for more details.
        context = context ? _.defaults(root.Object(), context, _.pick(root, contextProps)) : root;
    
        /** Native constructor references. */
        var Array = context.Array,
            Date = context.Date,
            Error = context.Error,
            Function = context.Function,
            Math = context.Math,
            Number = context.Number,
            Object = context.Object,
            RegExp = context.RegExp,
            String = context.String,
            TypeError = context.TypeError;
    
        /** Used for native method references. */
        var arrayProto = Array.prototype,
            objectProto = Object.prototype,
            stringProto = String.prototype;
    
        /** Used to resolve the decompiled source of functions. */
        var fnToString = Function.prototype.toString;
    
        /** Used to check objects for own properties. */
        var hasOwnProperty = objectProto.hasOwnProperty;
    
        /** Used to generate unique IDs. */
        var idCounter = 0;
    
        /**
         * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
         * of values.
         */
        var objToString = objectProto.toString;
    
        /** Used to restore the original `_` reference in `_.noConflict`. */
        var oldDash = root._;
    
        /** Used to detect if a method is native. */
        var reIsNative = RegExp('^' +
          fnToString.call(hasOwnProperty).replace(/[\\^$.*+?()[\]{}|]/g, '\\$&')
          .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
        );
    
        /** Native method references. */
        var ArrayBuffer = context.ArrayBuffer,
            clearTimeout = context.clearTimeout,
            parseFloat = context.parseFloat,
            pow = Math.pow,
            propertyIsEnumerable = objectProto.propertyIsEnumerable,
            Set = getNative(context, 'Set'),
            setTimeout = context.setTimeout,
            splice = arrayProto.splice,
            Uint8Array = context.Uint8Array,
            WeakMap = getNative(context, 'WeakMap');
    
        /* Native method references for those with the same name as other `lodash` methods. */
        var nativeCeil = Math.ceil,
            nativeCreate = getNative(Object, 'create'),
            nativeFloor = Math.floor,
            nativeIsArray = getNative(Array, 'isArray'),
            nativeIsFinite = context.isFinite,
            nativeKeys = getNative(Object, 'keys'),
            nativeMax = Math.max,
            nativeMin = Math.min,
            nativeNow = getNative(Date, 'now'),
            nativeParseInt = context.parseInt,
            nativeRandom = Math.random;
    
        /** Used as references for `-Infinity` and `Infinity`. */
        var NEGATIVE_INFINITY = Number.NEGATIVE_INFINITY,
            POSITIVE_INFINITY = Number.POSITIVE_INFINITY;
    
        /** Used as references for the maximum length and index of an array. */
        var MAX_ARRAY_LENGTH = 4294967295,
            MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1,
            HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;
    
        /**
         * Used as the [maximum length](http://ecma-international.org/ecma-262/6.0/#sec-number.max_safe_integer)
         * of an array-like value.
         */
        var MAX_SAFE_INTEGER = 9007199254740991;
    
        /** Used to store function metadata. */
        var metaMap = WeakMap && new WeakMap;
    
        /** Used to lookup unminified function names. */
        var realNames = {};
    
        /*------------------------------------------------------------------------*/
    
        /**
         * Creates a `lodash` object which wraps `value` to enable implicit chaining.
         * Methods that operate on and return arrays, collections, and functions can
         * be chained together. Methods that retrieve a single value or may return a
         * primitive value will automatically end the chain returning the unwrapped
         * value. Explicit chaining may be enabled using `_.chain`. The execution of
         * chained methods is lazy, that is, execution is deferred until `_#value`
         * is implicitly or explicitly called.
         *
         * Lazy evaluation allows several methods to support shortcut fusion. Shortcut
         * fusion is an optimization strategy which merge iteratee calls; this can help
         * to avoid the creation of intermediate data structures and greatly reduce the
         * number of iteratee executions.
         *
         * Chaining is supported in custom builds as long as the `_#value` method is
         * directly or indirectly included in the build.
         *
         * In addition to lodash methods, wrappers have `Array` and `String` methods.
         *
         * The wrapper `Array` methods are:
         * `concat`, `join`, `pop`, `push`, `reverse`, `shift`, `slice`, `sort`,
         * `splice`, and `unshift`
         *
         * The wrapper `String` methods are:
         * `replace` and `split`
         *
         * The wrapper methods that support shortcut fusion are:
         * `compact`, `drop`, `dropRight`, `dropRightWhile`, `dropWhile`, `filter`,
         * `first`, `initial`, `last`, `map`, `pluck`, `reject`, `rest`, `reverse`,
         * `slice`, `take`, `takeRight`, `takeRightWhile`, `takeWhile`, `toArray`,
         * and `where`
         *
         * The chainable wrapper methods are:
         * `after`, `ary`, `assign`, `at`, `before`, `bind`, `bindAll`, `bindKey`,
         * `callback`, `chain`, `chunk`, `commit`, `compact`, `concat`, `constant`,
         * `countBy`, `create`, `curry`, `debounce`, `defaults`, `defaultsDeep`,
         * `defer`, `delay`, `difference`, `drop`, `dropRight`, `dropRightWhile`,
         * `dropWhile`, `fill`, `filter`, `flatten`, `flattenDeep`, `flow`, `flowRight`,
         * `forEach`, `forEachRight`, `forIn`, `forInRight`, `forOwn`, `forOwnRight`,
         * `functions`, `groupBy`, `indexBy`, `initial`, `intersection`, `invert`,
         * `invoke`, `keys`, `keysIn`, `map`, `mapKeys`, `mapValues`, `matches`,
         * `matchesProperty`, `memoize`, `merge`, `method`, `methodOf`, `mixin`,
         * `modArgs`, `negate`, `omit`, `once`, `pairs`, `partial`, `partialRight`,
         * `partition`, `pick`, `plant`, `pluck`, `property`, `propertyOf`, `pull`,
         * `pullAt`, `push`, `range`, `rearg`, `reject`, `remove`, `rest`, `restParam`,
         * `reverse`, `set`, `shuffle`, `slice`, `sort`, `sortBy`, `sortByAll`,
         * `sortByOrder`, `splice`, `spread`, `take`, `takeRight`, `takeRightWhile`,
         * `takeWhile`, `tap`, `throttle`, `thru`, `times`, `toArray`, `toPlainObject`,
         * `transform`, `union`, `uniq`, `unshift`, `unzip`, `unzipWith`, `values`,
         * `valuesIn`, `where`, `without`, `wrap`, `xor`, `zip`, `zipObject`, `zipWith`
         *
         * The wrapper methods that are **not** chainable by default are:
         * `add`, `attempt`, `camelCase`, `capitalize`, `ceil`, `clone`, `cloneDeep`,
         * `deburr`, `endsWith`, `escape`, `escapeRegExp`, `every`, `find`, `findIndex`,
         * `findKey`, `findLast`, `findLastIndex`, `findLastKey`, `findWhere`, `first`,
         * `floor`, `get`, `gt`, `gte`, `has`, `identity`, `includes`, `indexOf`,
         * `inRange`, `isArguments`, `isArray`, `isBoolean`, `isDate`, `isElement`,
         * `isEmpty`, `isEqual`, `isError`, `isFinite` `isFunction`, `isMatch`,
         * `isNative`, `isNaN`, `isNull`, `isNumber`, `isObject`, `isPlainObject`,
         * `isRegExp`, `isString`, `isUndefined`, `isTypedArray`, `join`, `kebabCase`,
         * `last`, `lastIndexOf`, `lt`, `lte`, `max`, `min`, `noConflict`, `noop`,
         * `now`, `pad`, `padLeft`, `padRight`, `parseInt`, `pop`, `random`, `reduce`,
         * `reduceRight`, `repeat`, `result`, `round`, `runInContext`, `shift`, `size`,
         * `snakeCase`, `some`, `sortedIndex`, `sortedLastIndex`, `startCase`,
         * `startsWith`, `sum`, `template`, `trim`, `trimLeft`, `trimRight`, `trunc`,
         * `unescape`, `uniqueId`, `value`, and `words`
         *
         * The wrapper method `sample` will return a wrapped value when `n` is provided,
         * otherwise an unwrapped value is returned.
         *
         * @name _
         * @constructor
         * @category Chain
         * @param {*} value The value to wrap in a `lodash` instance.
         * @returns {Object} Returns the new `lodash` wrapper instance.
         * @example
         *
         * var wrapped = _([1, 2, 3]);
         *
         * // returns an unwrapped value
         * wrapped.reduce(function(total, n) {
         *   return total + n;
         * });
         * // => 6
         *
         * // returns a wrapped value
         * var squares = wrapped.map(function(n) {
         *   return n * n;
         * });
         *
         * _.isArray(squares);
         * // => false
         *
         * _.isArray(squares.value());
         * // => true
         */
        function lodash(value) {
          if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {
            if (value instanceof LodashWrapper) {
              return value;
            }
            if (hasOwnProperty.call(value, '__chain__') && hasOwnProperty.call(value, '__wrapped__')) {
              return wrapperClone(value);
            }
          }
          return new LodashWrapper(value);
        }
    
        /**
         * The function whose prototype all chaining wrappers inherit from.
         *
         * @private
         */
        function baseLodash() {
          // No operation performed.
        }
    
        /**
         * The base constructor for creating `lodash` wrapper objects.
         *
         * @private
         * @param {*} value The value to wrap.
         * @param {boolean} [chainAll] Enable chaining for all wrapper methods.
         * @param {Array} [actions=[]] Actions to peform to resolve the unwrapped value.
         */
        function LodashWrapper(value, chainAll, actions) {
          this.__wrapped__ = value;
          this.__actions__ = actions || [];
          this.__chain__ = !!chainAll;
        }
    
        /**
         * An object environment feature flags.
         *
         * @static
         * @memberOf _
         * @type Object
         */
        var support = lodash.support = {};
    
        /**
         * By default, the template delimiters used by lodash are like those in
         * embedded Ruby (ERB). Change the following template settings to use
         * alternative delimiters.
         *
         * @static
         * @memberOf _
         * @type Object
         */
        lodash.templateSettings = {
    
          /**
           * Used to detect `data` property values to be HTML-escaped.
           *
           * @memberOf _.templateSettings
           * @type RegExp
           */
          'escape': reEscape,
    
          /**
           * Used to detect code to be evaluated.
           *
           * @memberOf _.templateSettings
           * @type RegExp
           */
          'evaluate': reEvaluate,
    
          /**
           * Used to detect `data` property values to inject.
           *
           * @memberOf _.templateSettings
           * @type RegExp
           */
          'interpolate': reInterpolate,
    
          /**
           * Used to reference the data object in the template text.
           *
           * @memberOf _.templateSettings
           * @type string
           */
          'variable': '',
    
          /**
           * Used to import variables into the compiled template.
           *
           * @memberOf _.templateSettings
           * @type Object
           */
          'imports': {
    
            /**
             * A reference to the `lodash` function.
             *
             * @memberOf _.templateSettings.imports
             * @type Function
             */
            '_': lodash
          }
        };
    
        /*------------------------------------------------------------------------*/
    
        /**
         * Creates a lazy wrapper object which wraps `value` to enable lazy evaluation.
         *
         * @private
         * @param {*} value The value to wrap.
         */
        function LazyWrapper(value) {
          this.__wrapped__ = value;
          this.__actions__ = [];
          this.__dir__ = 1;
          this.__filtered__ = false;
          this.__iteratees__ = [];
          this.__takeCount__ = POSITIVE_INFINITY;
          this.__views__ = [];
        }
    
        /**
         * Creates a clone of the lazy wrapper object.
         *
         * @private
         * @name clone
         * @memberOf LazyWrapper
         * @returns {Object} Returns the cloned `LazyWrapper` object.
         */
        function lazyClone() {
          var result = new LazyWrapper(this.__wrapped__);
          result.__actions__ = arrayCopy(this.__actions__);
          result.__dir__ = this.__dir__;
          result.__filtered__ = this.__filtered__;
          result.__iteratees__ = arrayCopy(this.__iteratees__);
          result.__takeCount__ = this.__takeCount__;
          result.__views__ = arrayCopy(this.__views__);
          return result;
        }
    
        /**
         * Reverses the direction of lazy iteration.
         *
         * @private
         * @name reverse
         * @memberOf LazyWrapper
         * @returns {Object} Returns the new reversed `LazyWrapper` object.
         */
        function lazyReverse() {
          if (this.__filtered__) {
            var result = new LazyWrapper(this);
            result.__dir__ = -1;
            result.__filtered__ = true;
          } else {
            result = this.clone();
            result.__dir__ *= -1;
          }
          return result;
        }
    
        /**
         * Extracts the unwrapped value from its lazy wrapper.
         *
         * @private
         * @name value
         * @memberOf LazyWrapper
         * @returns {*} Returns the unwrapped value.
         */
        function lazyValue() {
          var array = this.__wrapped__.value(),
              dir = this.__dir__,
              isArr = isArray(array),
              isRight = dir < 0,
              arrLength = isArr ? array.length : 0,
              view = getView(0, arrLength, this.__views__),
              start = view.start,
              end = view.end,
              length = end - start,
              index = isRight ? end : (start - 1),
              iteratees = this.__iteratees__,
              iterLength = iteratees.length,
              resIndex = 0,
              takeCount = nativeMin(length, this.__takeCount__);
    
          if (!isArr || arrLength < LARGE_ARRAY_SIZE || (arrLength == length && takeCount == length)) {
            return baseWrapperValue((isRight && isArr) ? array.reverse() : array, this.__actions__);
          }
          var result = [];
    
          outer:
          while (length-- && resIndex < takeCount) {
            index += dir;
    
            var iterIndex = -1,
                value = array[index];
    
            while (++iterIndex < iterLength) {
              var data = iteratees[iterIndex],
                  iteratee = data.iteratee,
                  type = data.type,
                  computed = iteratee(value);
    
              if (type == LAZY_MAP_FLAG) {
                value = computed;
              } else if (!computed) {
                if (type == LAZY_FILTER_FLAG) {
                  continue outer;
                } else {
                  break outer;
                }
              }
            }
            result[resIndex++] = value;
          }
          return result;
        }
    
        /*------------------------------------------------------------------------*/
    
        /**
         * Creates a cache object to store key/value pairs.
         *
         * @private
         * @static
         * @name Cache
         * @memberOf _.memoize
         */
        function MapCache() {
          this.__data__ = {};
        }
    
        /**
         * Removes `key` and its value from the cache.
         *
         * @private
         * @name delete
         * @memberOf _.memoize.Cache
         * @param {string} key The key of the value to remove.
         * @returns {boolean} Returns `true` if the entry was removed successfully, else `false`.
         */
        function mapDelete(key) {
          return this.has(key) && delete this.__data__[key];
        }
    
        /**
         * Gets the cached value for `key`.
         *
         * @private
         * @name get
         * @memberOf _.memoize.Cache
         * @param {string} key The key of the value to get.
         * @returns {*} Returns the cached value.
         */
        function mapGet(key) {
          return key == '__proto__' ? undefined : this.__data__[key];
        }
    
        /**
         * Checks if a cached value for `key` exists.
         *
         * @private
         * @name has
         * @memberOf _.memoize.Cache
         * @param {string} key The key of the entry to check.
         * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
         */
        function mapHas(key) {
          return key != '__proto__' && hasOwnProperty.call(this.__data__, key);
        }
    
        /**
         * Sets `value` to `key` of the cache.
         *
         * @private
         * @name set
         * @memberOf _.memoize.Cache
         * @param {string} key The key of the value to cache.
         * @param {*} value The value to cache.
         * @returns {Object} Returns the cache object.
         */
        function mapSet(key, value) {
          if (key != '__proto__') {
            this.__data__[key] = value;
          }
          return this;
        }
    
        /*------------------------------------------------------------------------*/
    
        /**
         *
         * Creates a cache object to store unique values.
         *
         * @private
         * @param {Array} [values] The values to cache.
         */
        function SetCache(values) {
          var length = values ? values.length : 0;
    
          this.data = { 'hash': nativeCreate(null), 'set': new Set };
          while (length--) {
            this.push(values[length]);
          }
        }
    
        /**
         * Checks if `value` is in `cache` mimicking the return signature of
         * `_.indexOf` by returning `0` if the value is found, else `-1`.
         *
         * @private
         * @param {Object} cache The cache to search.
         * @param {*} value The value to search for.
         * @returns {number} Returns `0` if `value` is found, else `-1`.
         */
        function cacheIndexOf(cache, value) {
          var data = cache.data,
              result = (typeof value == 'string' || isObject(value)) ? data.set.has(value) : data.hash[value];
    
          return result ? 0 : -1;
        }
    
        /**
         * Adds `value` to the cache.
         *
         * @private
         * @name push
         * @memberOf SetCache
         * @param {*} value The value to cache.
         */
        function cachePush(value) {
          var data = this.data;
          if (typeof value == 'string' || isObject(value)) {
            data.set.add(value);
          } else {
            data.hash[value] = true;
          }
        }
    
        /*------------------------------------------------------------------------*/
    
        /**
         * Creates a new array joining `array` with `other`.
         *
         * @private
         * @param {Array} array The array to join.
         * @param {Array} other The other array to join.
         * @returns {Array} Returns the new concatenated array.
         */
        function arrayConcat(array, other) {
          var index = -1,
              length = array.length,
              othIndex = -1,
              othLength = other.length,
              result = Array(length + othLength);
    
          while (++index < length) {
            result[index] = array[index];
          }
          while (++othIndex < othLength) {
            result[index++] = other[othIndex];
          }
          return result;
        }
    
        /**
         * Copies the values of `source` to `array`.
         *
         * @private
         * @param {Array} source The array to copy values from.
         * @param {Array} [array=[]] The array to copy values to.
         * @returns {Array} Returns `array`.
         */
        function arrayCopy(source, array) {
          var index = -1,
              length = source.length;
    
          array || (array = Array(length));
          while (++index < length) {
            array[index] = source[index];
          }
          return array;
        }
    
        /**
         * A specialized version of `_.forEach` for arrays without support for callback
         * shorthands and `this` binding.
         *
         * @private
         * @param {Array} array The array to iterate over.
         * @param {Function} iteratee The function invoked per iteration.
         * @returns {Array} Returns `array`.
         */
        function arrayEach(array, iteratee) {
          var index = -1,
              length = array.length;
    
          while (++index < length) {
            if (iteratee(array[index], index, array) === false) {
              break;
            }
          }
          return array;
        }
    
        /**
         * A specialized version of `_.forEachRight` for arrays without support for
         * callback shorthands and `this` binding.
         *
         * @private
         * @param {Array} array The array to iterate over.
         * @param {Function} iteratee The function invoked per iteration.
         * @returns {Array} Returns `array`.
         */
        function arrayEachRight(array, iteratee) {
          var length = array.length;
    
          while (length--) {
            if (iteratee(array[length], length, array) === false) {
              break;
            }
          }
          return array;
        }
    
        /**
         * A specialized version of `_.every` for arrays without support for callback
         * shorthands and `this` binding.
         *
         * @private
         * @param {Array} array The array to iterate over.
         * @param {Function} predicate The function invoked per iteration.
         * @returns {boolean} Returns `true` if all elements pass the predicate check,
         *  else `false`.
         */
        function arrayEvery(array, predicate) {
          var index = -1,
              length = array.length;
    
          while (++index < length) {
            if (!predicate(array[index], index, array)) {
              return false;
            }
          }
          return true;
        }
    
        /**
         * A specialized version of `baseExtremum` for arrays which invokes `iteratee`
         * with one argument: (value).
         *
         * @private
         * @param {Array} array The array to iterate over.
         * @param {Function} iteratee The function invoked per iteration.
         * @param {Function} comparator The function used to compare values.
         * @param {*} exValue The initial extremum value.
         * @returns {*} Returns the extremum value.
         */
        function arrayExtremum(array, iteratee, comparator, exValue) {
          var index = -1,
              length = array.length,
              computed = exValue,
              result = computed;
    
          while (++index < length) {
            var value = array[index],
                current = +iteratee(value);
    
            if (comparator(current, computed)) {
              computed = current;
              result = value;
            }
          }
          return result;
        }
    
        /**
         * A specialized version of `_.filter` for arrays without support for callback
         * shorthands and `this` binding.
         *
         * @private
         * @param {Array} array The array to iterate over.
         * @param {Function} predicate The function invoked per iteration.
         * @returns {Array} Returns the new filtered array.
         */
        function arrayFilter(array, predicate) {
          var index = -1,
              length = array.length,
              resIndex = -1,
              result = [];
    
          while (++index < length) {
            var value = array[index];
            if (predicate(value, index, array)) {
              result[++resIndex] = value;
            }
          }
          return result;
        }
    
        /**
         * A specialized version of `_.map` for arrays without support for callback
         * shorthands and `this` binding.
         *
         * @private
         * @param {Array} array The array to iterate over.
         * @param {Function} iteratee The function invoked per iteration.
         * @returns {Array} Returns the new mapped array.
         */
        function arrayMap(array, iteratee) {
          var index = -1,
              length = array.length,
              result = Array(length);
    
          while (++index < length) {
            result[index] = iteratee(array[index], index, array);
          }
          return result;
        }
    
        /**
         * Appends the elements of `values` to `array`.
         *
         * @private
         * @param {Array} array The array to modify.
         * @param {Array} values The values to append.
         * @returns {Array} Returns `array`.
         */
        function arrayPush(array, values) {
          var index = -1,
              length = values.length,
              offset = array.length;
    
          while (++index < length) {
            array[offset + index] = values[index];
          }
          return array;
        }
    
        /**
         * A specialized version of `_.reduce` for arrays without support for callback
         * shorthands and `this` binding.
         *
         * @private
         * @param {Array} array The array to iterate over.
         * @param {Function} iteratee The function invoked per iteration.
         * @param {*} [accumulator] The initial value.
         * @param {boolean} [initFromArray] Specify using the first element of `array`
         *  as the initial value.
         * @returns {*} Returns the accumulated value.
         */
        function arrayReduce(array, iteratee, accumulator, initFromArray) {
          var index = -1,
              length = array.length;
    
          if (initFromArray && length) {
            accumulator = array[++index];
          }
          while (++index < length) {
            accumulator = iteratee(accumulator, array[index], index, array);
          }
          return accumulator;
        }
    
        /**
         * A specialized version of `_.reduceRight` for arrays without support for
         * callback shorthands and `this` binding.
         *
         * @private
         * @param {Array} array The array to iterate over.
         * @param {Function} iteratee The function invoked per iteration.
         * @param {*} [accumulator] The initial value.
         * @param {boolean} [initFromArray] Specify using the last element of `array`
         *  as the initial value.
         * @returns {*} Returns the accumulated value.
         */
        function arrayReduceRight(array, iteratee, accumulator, initFromArray) {
          var length = array.length;
          if (initFromArray && length) {
            accumulator = array[--length];
          }
          while (length--) {
            accumulator = iteratee(accumulator, array[length], length, array);
          }
          return accumulator;
        }
    
        /**
         * A specialized version of `_.some` for arrays without support for callback
         * shorthands and `this` binding.
         *
         * @private
         * @param {Array} array The array to iterate over.
         * @param {Function} predicate The function invoked per iteration.
         * @returns {boolean} Returns `true` if any element passes the predicate check,
         *  else `false`.
         */
        function arraySome(array, predicate) {
          var index = -1,
              length = array.length;
    
          while (++index < length) {
            if (predicate(array[index], index, array)) {
              return true;
            }
          }
          return false;
        }
    
        /**
         * A specialized version of `_.sum` for arrays without support for callback
         * shorthands and `this` binding..
         *
         * @private
         * @param {Array} array The array to iterate over.
         * @param {Function} iteratee The function invoked per iteration.
         * @returns {number} Returns the sum.
         */
        function arraySum(array, iteratee) {
          var length = array.length,
              result = 0;
    
          while (length--) {
            result += +iteratee(array[length]) || 0;
          }
          return result;
        }
    
        /**
         * Used by `_.defaults` to customize its `_.assign` use.
         *
         * @private
         * @param {*} objectValue The destination object property value.
         * @param {*} sourceValue The source object property value.
         * @returns {*} Returns the value to assign to the destination object.
         */
        function assignDefaults(objectValue, sourceValue) {
          return objectValue === undefined ? sourceValue : objectValue;
        }
    
        /**
         * Used by `_.template` to customize its `_.assign` use.
         *
         * **Note:** This function is like `assignDefaults` except that it ignores
         * inherited property values when checking if a property is `undefined`.
         *
         * @private
         * @param {*} objectValue The destination object property value.
         * @param {*} sourceValue The source object property value.
         * @param {string} key The key associated with the object and source values.
         * @param {Object} object The destination object.
         * @returns {*} Returns the value to assign to the destination object.
         */
        function assignOwnDefaults(objectValue, sourceValue, key, object) {
          return (objectValue === undefined || !hasOwnProperty.call(object, key))
            ? sourceValue
            : objectValue;
        }
    
        /**
         * A specialized version of `_.assign` for customizing assigned values without
         * support for argument juggling, multiple sources, and `this` binding `customizer`
         * functions.
         *
         * @private
         * @param {Object} object The destination object.
         * @param {Object} source The source object.
         * @param {Function} customizer The function to customize assigned values.
         * @returns {Object} Returns `object`.
         */
        function assignWith(object, source, customizer) {
          var index = -1,
              props = keys(source),
              length = props.length;
    
          while (++index < length) {
            var key = props[index],
                value = object[key],
                result = customizer(value, source[key], key, object, source);
    
            if ((result === result ? (result !== value) : (value === value)) ||
                (value === undefined && !(key in object))) {
              object[key] = result;
            }
          }
          return object;
        }
    
        /**
         * The base implementation of `_.assign` without support for argument juggling,
         * multiple sources, and `customizer` functions.
         *
         * @private
         * @param {Object} object The destination object.
         * @param {Object} source The source object.
         * @returns {Object} Returns `object`.
         */
        function baseAssign(object, source) {
          return source == null
            ? object
            : baseCopy(source, keys(source), object);
        }
    
        /**
         * The base implementation of `_.at` without support for string collections
         * and individual key arguments.
         *
         * @private
         * @param {Array|Object} collection The collection to iterate over.
         * @param {number[]|string[]} props The property names or indexes of elements to pick.
         * @returns {Array} Returns the new array of picked elements.
         */
        function baseAt(collection, props) {
          var index = -1,
              isNil = collection == null,
              isArr = !isNil && isArrayLike(collection),
              length = isArr ? collection.length : 0,
              propsLength = props.length,
              result = Array(propsLength);
    
          while(++index < propsLength) {
            var key = props[index];
            if (isArr) {
              result[index] = isIndex(key, length) ? collection[key] : undefined;
            } else {
              result[index] = isNil ? undefined : collection[key];
            }
          }
          return result;
        }
    
        /**
         * Copies properties of `source` to `object`.
         *
         * @private
         * @param {Object} source The object to copy properties from.
         * @param {Array} props The property names to copy.
         * @param {Object} [object={}] The object to copy properties to.
         * @returns {Object} Returns `object`.
         */
        function baseCopy(source, props, object) {
          object || (object = {});
    
          var index = -1,
              length = props.length;
    
          while (++index < length) {
            var key = props[index];
            object[key] = source[key];
          }
          return object;
        }
    
        /**
         * The base implementation of `_.callback` which supports specifying the
         * number of arguments to provide to `func`.
         *
         * @private
         * @param {*} [func=_.identity] The value to convert to a callback.
         * @param {*} [thisArg] The `this` binding of `func`.
         * @param {number} [argCount] The number of arguments to provide to `func`.
         * @returns {Function} Returns the callback.
         */
        function baseCallback(func, thisArg, argCount) {
          var type = typeof func;
          if (type == 'function') {
            return thisArg === undefined
              ? func
              : bindCallback(func, thisArg, argCount);
          }
          if (func == null) {
            return identity;
          }
          if (type == 'object') {
            return baseMatches(func);
          }
          return thisArg === undefined
            ? property(func)
            : baseMatchesProperty(func, thisArg);
        }
    
        /**
         * The base implementation of `_.clone` without support for argument juggling
         * and `this` binding `customizer` functions.
         *
         * @private
         * @param {*} value The value to clone.
         * @param {boolean} [isDeep] Specify a deep clone.
         * @param {Function} [customizer] The function to customize cloning values.
         * @param {string} [key] The key of `value`.
         * @param {Object} [object] The object `value` belongs to.
         * @param {Array} [stackA=[]] Tracks traversed source objects.
         * @param {Array} [stackB=[]] Associates clones with source counterparts.
         * @returns {*} Returns the cloned value.
         */
        function baseClone(value, isDeep, customizer, key, object, stackA, stackB) {
          var result;
          if (customizer) {
            result = object ? customizer(value, key, object) : customizer(value);
          }
          if (result !== undefined) {
            return result;
          }
          if (!isObject(value)) {
            return value;
          }
          var isArr = isArray(value);
          if (isArr) {
            result = initCloneArray(value);
            if (!isDeep) {
              return arrayCopy(value, result);
            }
          } else {
            var tag = objToString.call(value),
                isFunc = tag == funcTag;
    
            if (tag == objectTag || tag == argsTag || (isFunc && !object)) {
              result = initCloneObject(isFunc ? {} : value);
              if (!isDeep) {
                return baseAssign(result, value);
              }
            } else {
              return cloneableTags[tag]
                ? initCloneByTag(value, tag, isDeep)
                : (object ? value : {});
            }
          }
          // Check for circular references and return its corresponding clone.
          stackA || (stackA = []);
          stackB || (stackB = []);
    
          var length = stackA.length;
          while (length--) {
            if (stackA[length] == value) {
              return stackB[length];
            }
          }
          // Add the source value to the stack of traversed objects and associate it with its clone.
          stackA.push(value);
          stackB.push(result);
    
          // Recursively populate clone (susceptible to call stack limits).
          (isArr ? arrayEach : baseForOwn)(value, function(subValue, key) {
            result[key] = baseClone(subValue, isDeep, customizer, key, value, stackA, stackB);
          });
          return result;
        }
    
        /**
         * The base implementation of `_.create` without support for assigning
         * properties to the created object.
         *
         * @private
         * @param {Object} prototype The object to inherit from.
         * @returns {Object} Returns the new object.
         */
        var baseCreate = (function() {
          function object() {}
          return function(prototype) {
            if (isObject(prototype)) {
              object.prototype = prototype;
              var result = new object;
              object.prototype = undefined;
            }
            return result || {};
          };
        }());
    
        /**
         * The base implementation of `_.delay` and `_.defer` which accepts an index
         * of where to slice the arguments to provide to `func`.
         *
         * @private
         * @param {Function} func The function to delay.
         * @param {number} wait The number of milliseconds to delay invocation.
         * @param {Object} args The arguments provide to `func`.
         * @returns {number} Returns the timer id.
         */
        function baseDelay(func, wait, args) {
          if (typeof func != 'function') {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          return setTimeout(function() { func.apply(undefined, args); }, wait);
        }
    
        /**
         * The base implementation of `_.difference` which accepts a single array
         * of values to exclude.
         *
         * @private
         * @param {Array} array The array to inspect.
         * @param {Array} values The values to exclude.
         * @returns {Array} Returns the new array of filtered values.
         */
        function baseDifference(array, values) {
          var length = array ? array.length : 0,
              result = [];
    
          if (!length) {
            return result;
          }
          var index = -1,
              indexOf = getIndexOf(),
              isCommon = indexOf == baseIndexOf,
              cache = (isCommon && values.length >= LARGE_ARRAY_SIZE) ? createCache(values) : null,
              valuesLength = values.length;
    
          if (cache) {
            indexOf = cacheIndexOf;
            isCommon = false;
            values = cache;
          }
          outer:
          while (++index < length) {
            var value = array[index];
    
            if (isCommon && value === value) {
              var valuesIndex = valuesLength;
              while (valuesIndex--) {
                if (values[valuesIndex] === value) {
                  continue outer;
                }
              }
              result.push(value);
            }
            else if (indexOf(values, value, 0) < 0) {
              result.push(value);
            }
          }
          return result;
        }
    
        /**
         * The base implementation of `_.forEach` without support for callback
         * shorthands and `this` binding.
         *
         * @private
         * @param {Array|Object|string} collection The collection to iterate over.
         * @param {Function} iteratee The function invoked per iteration.
         * @returns {Array|Object|string} Returns `collection`.
         */
        var baseEach = createBaseEach(baseForOwn);
    
        /**
         * The base implementation of `_.forEachRight` without support for callback
         * shorthands and `this` binding.
         *
         * @private
         * @param {Array|Object|string} collection The collection to iterate over.
         * @param {Function} iteratee The function invoked per iteration.
         * @returns {Array|Object|string} Returns `collection`.
         */
        var baseEachRight = createBaseEach(baseForOwnRight, true);
    
        /**
         * The base implementation of `_.every` without support for callback
         * shorthands and `this` binding.
         *
         * @private
         * @param {Array|Object|string} collection The collection to iterate over.
         * @param {Function} predicate The function invoked per iteration.
         * @returns {boolean} Returns `true` if all elements pass the predicate check,
         *  else `false`
         */
        function baseEvery(collection, predicate) {
          var result = true;
          baseEach(collection, function(value, index, collection) {
            result = !!predicate(value, index, collection);
            return result;
          });
          return result;
        }
    
        /**
         * Gets the extremum value of `collection` invoking `iteratee` for each value
         * in `collection` to generate the criterion by which the value is ranked.
         * The `iteratee` is invoked with three arguments: (value, index|key, collection).
         *
         * @private
         * @param {Array|Object|string} collection The collection to iterate over.
         * @param {Function} iteratee The function invoked per iteration.
         * @param {Function} comparator The function used to compare values.
         * @param {*} exValue The initial extremum value.
         * @returns {*} Returns the extremum value.
         */
        function baseExtremum(collection, iteratee, comparator, exValue) {
          var computed = exValue,
              result = computed;
    
          baseEach(collection, function(value, index, collection) {
            var current = +iteratee(value, index, collection);
            if (comparator(current, computed) || (current === exValue && current === result)) {
              computed = current;
              result = value;
            }
          });
          return result;
        }
    
        /**
         * The base implementation of `_.fill` without an iteratee call guard.
         *
         * @private
         * @param {Array} array The array to fill.
         * @param {*} value The value to fill `array` with.
         * @param {number} [start=0] The start position.
         * @param {number} [end=array.length] The end position.
         * @returns {Array} Returns `array`.
         */
        function baseFill(array, value, start, end) {
          var length = array.length;
    
          start = start == null ? 0 : (+start || 0);
          if (start < 0) {
            start = -start > length ? 0 : (length + start);
          }
          end = (end === undefined || end > length) ? length : (+end || 0);
          if (end < 0) {
            end += length;
          }
          length = start > end ? 0 : (end >>> 0);
          start >>>= 0;
    
          while (start < length) {
            array[start++] = value;
          }
          return array;
        }
    
        /**
         * The base implementation of `_.filter` without support for callback
         * shorthands and `this` binding.
         *
         * @private
         * @param {Array|Object|string} collection The collection to iterate over.
         * @param {Function} predicate The function invoked per iteration.
         * @returns {Array} Returns the new filtered array.
         */
        function baseFilter(collection, predicate) {
          var result = [];
          baseEach(collection, function(value, index, collection) {
            if (predicate(value, index, collection)) {
              result.push(value);
            }
          });
          return result;
        }
    
        /**
         * The base implementation of `_.find`, `_.findLast`, `_.findKey`, and `_.findLastKey`,
         * without support for callback shorthands and `this` binding, which iterates
         * over `collection` using the provided `eachFunc`.
         *
         * @private
         * @param {Array|Object|string} collection The collection to search.
         * @param {Function} predicate The function invoked per iteration.
         * @param {Function} eachFunc The function to iterate over `collection`.
         * @param {boolean} [retKey] Specify returning the key of the found element
         *  instead of the element itself.
         * @returns {*} Returns the found element or its key, else `undefined`.
         */
        function baseFind(collection, predicate, eachFunc, retKey) {
          var result;
          eachFunc(collection, function(value, key, collection) {
            if (predicate(value, key, collection)) {
              result = retKey ? key : value;
              return false;
            }
          });
          return result;
        }
    
        /**
         * The base implementation of `_.flatten` with added support for restricting
         * flattening and specifying the start index.
         *
         * @private
         * @param {Array} array The array to flatten.
         * @param {boolean} [isDeep] Specify a deep flatten.
         * @param {boolean} [isStrict] Restrict flattening to arrays-like objects.
         * @param {Array} [result=[]] The initial result value.
         * @returns {Array} Returns the new flattened array.
         */
        function baseFlatten(array, isDeep, isStrict, result) {
          result || (result = []);
    
          var index = -1,
              length = array.length;
    
          while (++index < length) {
            var value = array[index];
            if (isObjectLike(value) && isArrayLike(value) &&
                (isStrict || isArray(value) || isArguments(value))) {
              if (isDeep) {
                // Recursively flatten arrays (susceptible to call stack limits).
                baseFlatten(value, isDeep, isStrict, result);
              } else {
                arrayPush(result, value);
              }
            } else if (!isStrict) {
              result[result.length] = value;
            }
          }
          return result;
        }
    
        /**
         * The base implementation of `baseForIn` and `baseForOwn` which iterates
         * over `object` properties returned by `keysFunc` invoking `iteratee` for
         * each property. Iteratee functions may exit iteration early by explicitly
         * returning `false`.
         *
         * @private
         * @param {Object} object The object to iterate over.
         * @param {Function} iteratee The function invoked per iteration.
         * @param {Function} keysFunc The function to get the keys of `object`.
         * @returns {Object} Returns `object`.
         */
        var baseFor = createBaseFor();
    
        /**
         * This function is like `baseFor` except that it iterates over properties
         * in the opposite order.
         *
         * @private
         * @param {Object} object The object to iterate over.
         * @param {Function} iteratee The function invoked per iteration.
         * @param {Function} keysFunc The function to get the keys of `object`.
         * @returns {Object} Returns `object`.
         */
        var baseForRight = createBaseFor(true);
    
        /**
         * The base implementation of `_.forIn` without support for callback
         * shorthands and `this` binding.
         *
         * @private
         * @param {Object} object The object to iterate over.
         * @param {Function} iteratee The function invoked per iteration.
         * @returns {Object} Returns `object`.
         */
        function baseForIn(object, iteratee) {
          return baseFor(object, iteratee, keysIn);
        }
    
        /**
         * The base implementation of `_.forOwn` without support for callback
         * shorthands and `this` binding.
         *
         * @private
         * @param {Object} object The object to iterate over.
         * @param {Function} iteratee The function invoked per iteration.
         * @returns {Object} Returns `object`.
         */
        function baseForOwn(object, iteratee) {
          return baseFor(object, iteratee, keys);
        }
    
        /**
         * The base implementation of `_.forOwnRight` without support for callback
         * shorthands and `this` binding.
         *
         * @private
         * @param {Object} object The object to iterate over.
         * @param {Function} iteratee The function invoked per iteration.
         * @returns {Object} Returns `object`.
         */
        function baseForOwnRight(object, iteratee) {
          return baseForRight(object, iteratee, keys);
        }
    
        /**
         * The base implementation of `_.functions` which creates an array of
         * `object` function property names filtered from those provided.
         *
         * @private
         * @param {Object} object The object to inspect.
         * @param {Array} props The property names to filter.
         * @returns {Array} Returns the new array of filtered property names.
         */
        function baseFunctions(object, props) {
          var index = -1,
              length = props.length,
              resIndex = -1,
              result = [];
    
          while (++index < length) {
            var key = props[index];
            if (isFunction(object[key])) {
              result[++resIndex] = key;
            }
          }
          return result;
        }
    
        /**
         * The base implementation of `get` without support for string paths
         * and default values.
         *
         * @private
         * @param {Object} object The object to query.
         * @param {Array} path The path of the property to get.
         * @param {string} [pathKey] The key representation of path.
         * @returns {*} Returns the resolved value.
         */
        function baseGet(object, path, pathKey) {
          if (object == null) {
            return;
          }
          if (pathKey !== undefined && pathKey in toObject(object)) {
            path = [pathKey];
          }
          var index = 0,
              length = path.length;
    
          while (object != null && index < length) {
            object = object[path[index++]];
          }
          return (index && index == length) ? object : undefined;
        }
    
        /**
         * The base implementation of `_.isEqual` without support for `this` binding
         * `customizer` functions.
         *
         * @private
         * @param {*} value The value to compare.
         * @param {*} other The other value to compare.
         * @param {Function} [customizer] The function to customize comparing values.
         * @param {boolean} [isLoose] Specify performing partial comparisons.
         * @param {Array} [stackA] Tracks traversed `value` objects.
         * @param {Array} [stackB] Tracks traversed `other` objects.
         * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
         */
        function baseIsEqual(value, other, customizer, isLoose, stackA, stackB) {
          if (value === other) {
            return true;
          }
          if (value == null || other == null || (!isObject(value) && !isObjectLike(other))) {
            return value !== value && other !== other;
          }
          return baseIsEqualDeep(value, other, baseIsEqual, customizer, isLoose, stackA, stackB);
        }
    
        /**
         * A specialized version of `baseIsEqual` for arrays and objects which performs
         * deep comparisons and tracks traversed objects enabling objects with circular
         * references to be compared.
         *
         * @private
         * @param {Object} object The object to compare.
         * @param {Object} other The other object to compare.
         * @param {Function} equalFunc The function to determine equivalents of values.
         * @param {Function} [customizer] The function to customize comparing objects.
         * @param {boolean} [isLoose] Specify performing partial comparisons.
         * @param {Array} [stackA=[]] Tracks traversed `value` objects.
         * @param {Array} [stackB=[]] Tracks traversed `other` objects.
         * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
         */
        function baseIsEqualDeep(object, other, equalFunc, customizer, isLoose, stackA, stackB) {
          var objIsArr = isArray(object),
              othIsArr = isArray(other),
              objTag = arrayTag,
              othTag = arrayTag;
    
          if (!objIsArr) {
            objTag = objToString.call(object);
            if (objTag == argsTag) {
              objTag = objectTag;
            } else if (objTag != objectTag) {
              objIsArr = isTypedArray(object);
            }
          }
          if (!othIsArr) {
            othTag = objToString.call(other);
            if (othTag == argsTag) {
              othTag = objectTag;
            } else if (othTag != objectTag) {
              othIsArr = isTypedArray(other);
            }
          }
          var objIsObj = objTag == objectTag,
              othIsObj = othTag == objectTag,
              isSameTag = objTag == othTag;
    
          if (isSameTag && !(objIsArr || objIsObj)) {
            return equalByTag(object, other, objTag);
          }
          if (!isLoose) {
            var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
                othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');
    
            if (objIsWrapped || othIsWrapped) {
              return equalFunc(objIsWrapped ? object.value() : object, othIsWrapped ? other.value() : other, customizer, isLoose, stackA, stackB);
            }
          }
          if (!isSameTag) {
            return false;
          }
          // Assume cyclic values are equal.
          // For more information on detecting circular references see https://es5.github.io/#JO.
          stackA || (stackA = []);
          stackB || (stackB = []);
    
          var length = stackA.length;
          while (length--) {
            if (stackA[length] == object) {
              return stackB[length] == other;
            }
          }
          // Add `object` and `other` to the stack of traversed objects.
          stackA.push(object);
          stackB.push(other);
    
          var result = (objIsArr ? equalArrays : equalObjects)(object, other, equalFunc, customizer, isLoose, stackA, stackB);
    
          stackA.pop();
          stackB.pop();
    
          return result;
        }
    
        /**
         * The base implementation of `_.isMatch` without support for callback
         * shorthands and `this` binding.
         *
         * @private
         * @param {Object} object The object to inspect.
         * @param {Array} matchData The propery names, values, and compare flags to match.
         * @param {Function} [customizer] The function to customize comparing objects.
         * @returns {boolean} Returns `true` if `object` is a match, else `false`.
         */
        function baseIsMatch(object, matchData, customizer) {
          var index = matchData.length,
              length = index,
              noCustomizer = !customizer;
    
          if (object == null) {
            return !length;
          }
          object = toObject(object);
          while (index--) {
            var data = matchData[index];
            if ((noCustomizer && data[2])
                  ? data[1] !== object[data[0]]
                  : !(data[0] in object)
                ) {
              return false;
            }
          }
          while (++index < length) {
            data = matchData[index];
            var key = data[0],
                objValue = object[key],
                srcValue = data[1];
    
            if (noCustomizer && data[2]) {
              if (objValue === undefined && !(key in object)) {
                return false;
              }
            } else {
              var result = customizer ? customizer(objValue, srcValue, key) : undefined;
              if (!(result === undefined ? baseIsEqual(srcValue, objValue, customizer, true) : result)) {
                return false;
              }
            }
          }
          return true;
        }
    
        /**
         * The base implementation of `_.map` without support for callback shorthands
         * and `this` binding.
         *
         * @private
         * @param {Array|Object|string} collection The collection to iterate over.
         * @param {Function} iteratee The function invoked per iteration.
         * @returns {Array} Returns the new mapped array.
         */
        function baseMap(collection, iteratee) {
          var index = -1,
              result = isArrayLike(collection) ? Array(collection.length) : [];
    
          baseEach(collection, function(value, key, collection) {
            result[++index] = iteratee(value, key, collection);
          });
          return result;
        }
    
        /**
         * The base implementation of `_.matches` which does not clone `source`.
         *
         * @private
         * @param {Object} source The object of property values to match.
         * @returns {Function} Returns the new function.
         */
        function baseMatches(source) {
          var matchData = getMatchData(source);
          if (matchData.length == 1 && matchData[0][2]) {
            var key = matchData[0][0],
                value = matchData[0][1];
    
            return function(object) {
              if (object == null) {
                return false;
              }
              return object[key] === value && (value !== undefined || (key in toObject(object)));
            };
          }
          return function(object) {
            return baseIsMatch(object, matchData);
          };
        }
    
        /**
         * The base implementation of `_.matchesProperty` which does not clone `srcValue`.
         *
         * @private
         * @param {string} path The path of the property to get.
         * @param {*} srcValue The value to compare.
         * @returns {Function} Returns the new function.
         */
        function baseMatchesProperty(path, srcValue) {
          var isArr = isArray(path),
              isCommon = isKey(path) && isStrictComparable(srcValue),
              pathKey = (path + '');
    
          path = toPath(path);
          return function(object) {
            if (object == null) {
              return false;
            }
            var key = pathKey;
            object = toObject(object);
            if ((isArr || !isCommon) && !(key in object)) {
              object = path.length == 1 ? object : baseGet(object, baseSlice(path, 0, -1));
              if (object == null) {
                return false;
              }
              key = last(path);
              object = toObject(object);
            }
            return object[key] === srcValue
              ? (srcValue !== undefined || (key in object))
              : baseIsEqual(srcValue, object[key], undefined, true);
          };
        }
    
        /**
         * The base implementation of `_.merge` without support for argument juggling,
         * multiple sources, and `this` binding `customizer` functions.
         *
         * @private
         * @param {Object} object The destination object.
         * @param {Object} source The source object.
         * @param {Function} [customizer] The function to customize merged values.
         * @param {Array} [stackA=[]] Tracks traversed source objects.
         * @param {Array} [stackB=[]] Associates values with source counterparts.
         * @returns {Object} Returns `object`.
         */
        function baseMerge(object, source, customizer, stackA, stackB) {
          if (!isObject(object)) {
            return object;
          }
          var isSrcArr = isArrayLike(source) && (isArray(source) || isTypedArray(source)),
              props = isSrcArr ? undefined : keys(source);
    
          arrayEach(props || source, function(srcValue, key) {
            if (props) {
              key = srcValue;
              srcValue = source[key];
            }
            if (isObjectLike(srcValue)) {
              stackA || (stackA = []);
              stackB || (stackB = []);
              baseMergeDeep(object, source, key, baseMerge, customizer, stackA, stackB);
            }
            else {
              var value = object[key],
                  result = customizer ? customizer(value, srcValue, key, object, source) : undefined,
                  isCommon = result === undefined;
    
              if (isCommon) {
                result = srcValue;
              }
              if ((result !== undefined || (isSrcArr && !(key in object))) &&
                  (isCommon || (result === result ? (result !== value) : (value === value)))) {
                object[key] = result;
              }
            }
          });
          return object;
        }
    
        /**
         * A specialized version of `baseMerge` for arrays and objects which performs
         * deep merges and tracks traversed objects enabling objects with circular
         * references to be merged.
         *
         * @private
         * @param {Object} object The destination object.
         * @param {Object} source The source object.
         * @param {string} key The key of the value to merge.
         * @param {Function} mergeFunc The function to merge values.
         * @param {Function} [customizer] The function to customize merged values.
         * @param {Array} [stackA=[]] Tracks traversed source objects.
         * @param {Array} [stackB=[]] Associates values with source counterparts.
         * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
         */
        function baseMergeDeep(object, source, key, mergeFunc, customizer, stackA, stackB) {
          var length = stackA.length,
              srcValue = source[key];
    
          while (length--) {
            if (stackA[length] == srcValue) {
              object[key] = stackB[length];
              return;
            }
          }
          var value = object[key],
              result = customizer ? customizer(value, srcValue, key, object, source) : undefined,
              isCommon = result === undefined;
    
          if (isCommon) {
            result = srcValue;
            if (isArrayLike(srcValue) && (isArray(srcValue) || isTypedArray(srcValue))) {
              result = isArray(value)
                ? value
                : (isArrayLike(value) ? arrayCopy(value) : []);
            }
            else if (isPlainObject(srcValue) || isArguments(srcValue)) {
              result = isArguments(value)
                ? toPlainObject(value)
                : (isPlainObject(value) ? value : {});
            }
            else {
              isCommon = false;
            }
          }
          // Add the source value to the stack of traversed objects and associate
          // it with its merged value.
          stackA.push(srcValue);
          stackB.push(result);
    
          if (isCommon) {
            // Recursively merge objects and arrays (susceptible to call stack limits).
            object[key] = mergeFunc(result, srcValue, customizer, stackA, stackB);
          } else if (result === result ? (result !== value) : (value === value)) {
            object[key] = result;
          }
        }
    
        /**
         * The base implementation of `_.property` without support for deep paths.
         *
         * @private
         * @param {string} key The key of the property to get.
         * @returns {Function} Returns the new function.
         */
        function baseProperty(key) {
          return function(object) {
            return object == null ? undefined : object[key];
          };
        }
    
        /**
         * A specialized version of `baseProperty` which supports deep paths.
         *
         * @private
         * @param {Array|string} path The path of the property to get.
         * @returns {Function} Returns the new function.
         */
        function basePropertyDeep(path) {
          var pathKey = (path + '');
          path = toPath(path);
          return function(object) {
            return baseGet(object, path, pathKey);
          };
        }
    
        /**
         * The base implementation of `_.pullAt` without support for individual
         * index arguments and capturing the removed elements.
         *
         * @private
         * @param {Array} array The array to modify.
         * @param {number[]} indexes The indexes of elements to remove.
         * @returns {Array} Returns `array`.
         */
        function basePullAt(array, indexes) {
          var length = array ? indexes.length : 0;
          while (length--) {
            var index = indexes[length];
            if (index != previous && isIndex(index)) {
              var previous = index;
              splice.call(array, index, 1);
            }
          }
          return array;
        }
    
        /**
         * The base implementation of `_.random` without support for argument juggling
         * and returning floating-point numbers.
         *
         * @private
         * @param {number} min The minimum possible value.
         * @param {number} max The maximum possible value.
         * @returns {number} Returns the random number.
         */
        function baseRandom(min, max) {
          return min + nativeFloor(nativeRandom() * (max - min + 1));
        }
    
        /**
         * The base implementation of `_.reduce` and `_.reduceRight` without support
         * for callback shorthands and `this` binding, which iterates over `collection`
         * using the provided `eachFunc`.
         *
         * @private
         * @param {Array|Object|string} collection The collection to iterate over.
         * @param {Function} iteratee The function invoked per iteration.
         * @param {*} accumulator The initial value.
         * @param {boolean} initFromCollection Specify using the first or last element
         *  of `collection` as the initial value.
         * @param {Function} eachFunc The function to iterate over `collection`.
         * @returns {*} Returns the accumulated value.
         */
        function baseReduce(collection, iteratee, accumulator, initFromCollection, eachFunc) {
          eachFunc(collection, function(value, index, collection) {
            accumulator = initFromCollection
              ? (initFromCollection = false, value)
              : iteratee(accumulator, value, index, collection);
          });
          return accumulator;
        }
    
        /**
         * The base implementation of `setData` without support for hot loop detection.
         *
         * @private
         * @param {Function} func The function to associate metadata with.
         * @param {*} data The metadata.
         * @returns {Function} Returns `func`.
         */
        var baseSetData = !metaMap ? identity : function(func, data) {
          metaMap.set(func, data);
          return func;
        };
    
        /**
         * The base implementation of `_.slice` without an iteratee call guard.
         *
         * @private
         * @param {Array} array The array to slice.
         * @param {number} [start=0] The start position.
         * @param {number} [end=array.length] The end position.
         * @returns {Array} Returns the slice of `array`.
         */
        function baseSlice(array, start, end) {
          var index = -1,
              length = array.length;
    
          start = start == null ? 0 : (+start || 0);
          if (start < 0) {
            start = -start > length ? 0 : (length + start);
          }
          end = (end === undefined || end > length) ? length : (+end || 0);
          if (end < 0) {
            end += length;
          }
          length = start > end ? 0 : ((end - start) >>> 0);
          start >>>= 0;
    
          var result = Array(length);
          while (++index < length) {
            result[index] = array[index + start];
          }
          return result;
        }
    
        /**
         * The base implementation of `_.some` without support for callback shorthands
         * and `this` binding.
         *
         * @private
         * @param {Array|Object|string} collection The collection to iterate over.
         * @param {Function} predicate The function invoked per iteration.
         * @returns {boolean} Returns `true` if any element passes the predicate check,
         *  else `false`.
         */
        function baseSome(collection, predicate) {
          var result;
    
          baseEach(collection, function(value, index, collection) {
            result = predicate(value, index, collection);
            return !result;
          });
          return !!result;
        }
    
        /**
         * The base implementation of `_.sortBy` which uses `comparer` to define
         * the sort order of `array` and replaces criteria objects with their
         * corresponding values.
         *
         * @private
         * @param {Array} array The array to sort.
         * @param {Function} comparer The function to define sort order.
         * @returns {Array} Returns `array`.
         */
        function baseSortBy(array, comparer) {
          var length = array.length;
    
          array.sort(comparer);
          while (length--) {
            array[length] = array[length].value;
          }
          return array;
        }
    
        /**
         * The base implementation of `_.sortByOrder` without param guards.
         *
         * @private
         * @param {Array|Object|string} collection The collection to iterate over.
         * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.
         * @param {boolean[]} orders The sort orders of `iteratees`.
         * @returns {Array} Returns the new sorted array.
         */
        function baseSortByOrder(collection, iteratees, orders) {
          var callback = getCallback(),
              index = -1;
    
          iteratees = arrayMap(iteratees, function(iteratee) { return callback(iteratee); });
    
          var result = baseMap(collection, function(value) {
            var criteria = arrayMap(iteratees, function(iteratee) { return iteratee(value); });
            return { 'criteria': criteria, 'index': ++index, 'value': value };
          });
    
          return baseSortBy(result, function(object, other) {
            return compareMultiple(object, other, orders);
          });
        }
    
        /**
         * The base implementation of `_.sum` without support for callback shorthands
         * and `this` binding.
         *
         * @private
         * @param {Array|Object|string} collection The collection to iterate over.
         * @param {Function} iteratee The function invoked per iteration.
         * @returns {number} Returns the sum.
         */
        function baseSum(collection, iteratee) {
          var result = 0;
          baseEach(collection, function(value, index, collection) {
            result += +iteratee(value, index, collection) || 0;
          });
          return result;
        }
    
        /**
         * The base implementation of `_.uniq` without support for callback shorthands
         * and `this` binding.
         *
         * @private
         * @param {Array} array The array to inspect.
         * @param {Function} [iteratee] The function invoked per iteration.
         * @returns {Array} Returns the new duplicate-value-free array.
         */
        function baseUniq(array, iteratee) {
          var index = -1,
              indexOf = getIndexOf(),
              length = array.length,
              isCommon = indexOf == baseIndexOf,
              isLarge = isCommon && length >= LARGE_ARRAY_SIZE,
              seen = isLarge ? createCache() : null,
              result = [];
    
          if (seen) {
            indexOf = cacheIndexOf;
            isCommon = false;
          } else {
            isLarge = false;
            seen = iteratee ? [] : result;
          }
          outer:
          while (++index < length) {
            var value = array[index],
                computed = iteratee ? iteratee(value, index, array) : value;
    
            if (isCommon && value === value) {
              var seenIndex = seen.length;
              while (seenIndex--) {
                if (seen[seenIndex] === computed) {
                  continue outer;
                }
              }
              if (iteratee) {
                seen.push(computed);
              }
              result.push(value);
            }
            else if (indexOf(seen, computed, 0) < 0) {
              if (iteratee || isLarge) {
                seen.push(computed);
              }
              result.push(value);
            }
          }
          return result;
        }
    
        /**
         * The base implementation of `_.values` and `_.valuesIn` which creates an
         * array of `object` property values corresponding to the property names
         * of `props`.
         *
         * @private
         * @param {Object} object The object to query.
         * @param {Array} props The property names to get values for.
         * @returns {Object} Returns the array of property values.
         */
        function baseValues(object, props) {
          var index = -1,
              length = props.length,
              result = Array(length);
    
          while (++index < length) {
            result[index] = object[props[index]];
          }
          return result;
        }
    
        /**
         * The base implementation of `_.dropRightWhile`, `_.dropWhile`, `_.takeRightWhile`,
         * and `_.takeWhile` without support for callback shorthands and `this` binding.
         *
         * @private
         * @param {Array} array The array to query.
         * @param {Function} predicate The function invoked per iteration.
         * @param {boolean} [isDrop] Specify dropping elements instead of taking them.
         * @param {boolean} [fromRight] Specify iterating from right to left.
         * @returns {Array} Returns the slice of `array`.
         */
        function baseWhile(array, predicate, isDrop, fromRight) {
          var length = array.length,
              index = fromRight ? length : -1;
    
          while ((fromRight ? index-- : ++index < length) && predicate(array[index], index, array)) {}
          return isDrop
            ? baseSlice(array, (fromRight ? 0 : index), (fromRight ? index + 1 : length))
            : baseSlice(array, (fromRight ? index + 1 : 0), (fromRight ? length : index));
        }
    
        /**
         * The base implementation of `wrapperValue` which returns the result of
         * performing a sequence of actions on the unwrapped `value`, where each
         * successive action is supplied the return value of the previous.
         *
         * @private
         * @param {*} value The unwrapped value.
         * @param {Array} actions Actions to peform to resolve the unwrapped value.
         * @returns {*} Returns the resolved value.
         */
        function baseWrapperValue(value, actions) {
          var result = value;
          if (result instanceof LazyWrapper) {
            result = result.value();
          }
          var index = -1,
              length = actions.length;
    
          while (++index < length) {
            var action = actions[index];
            result = action.func.apply(action.thisArg, arrayPush([result], action.args));
          }
          return result;
        }
    
        /**
         * Performs a binary search of `array` to determine the index at which `value`
         * should be inserted into `array` in order to maintain its sort order.
         *
         * @private
         * @param {Array} array The sorted array to inspect.
         * @param {*} value The value to evaluate.
         * @param {boolean} [retHighest] Specify returning the highest qualified index.
         * @returns {number} Returns the index at which `value` should be inserted
         *  into `array`.
         */
        function binaryIndex(array, value, retHighest) {
          var low = 0,
              high = array ? array.length : low;
    
          if (typeof value == 'number' && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
            while (low < high) {
              var mid = (low + high) >>> 1,
                  computed = array[mid];
    
              if ((retHighest ? (computed <= value) : (computed < value)) && computed !== null) {
                low = mid + 1;
              } else {
                high = mid;
              }
            }
            return high;
          }
          return binaryIndexBy(array, value, identity, retHighest);
        }
    
        /**
         * This function is like `binaryIndex` except that it invokes `iteratee` for
         * `value` and each element of `array` to compute their sort ranking. The
         * iteratee is invoked with one argument; (value).
         *
         * @private
         * @param {Array} array The sorted array to inspect.
         * @param {*} value The value to evaluate.
         * @param {Function} iteratee The function invoked per iteration.
         * @param {boolean} [retHighest] Specify returning the highest qualified index.
         * @returns {number} Returns the index at which `value` should be inserted
         *  into `array`.
         */
        function binaryIndexBy(array, value, iteratee, retHighest) {
          value = iteratee(value);
    
          var low = 0,
              high = array ? array.length : 0,
              valIsNaN = value !== value,
              valIsNull = value === null,
              valIsUndef = value === undefined;
    
          while (low < high) {
            var mid = nativeFloor((low + high) / 2),
                computed = iteratee(array[mid]),
                isDef = computed !== undefined,
                isReflexive = computed === computed;
    
            if (valIsNaN) {
              var setLow = isReflexive || retHighest;
            } else if (valIsNull) {
              setLow = isReflexive && isDef && (retHighest || computed != null);
            } else if (valIsUndef) {
              setLow = isReflexive && (retHighest || isDef);
            } else if (computed == null) {
              setLow = false;
            } else {
              setLow = retHighest ? (computed <= value) : (computed < value);
            }
            if (setLow) {
              low = mid + 1;
            } else {
              high = mid;
            }
          }
          return nativeMin(high, MAX_ARRAY_INDEX);
        }
    
        /**
         * A specialized version of `baseCallback` which only supports `this` binding
         * and specifying the number of arguments to provide to `func`.
         *
         * @private
         * @param {Function} func The function to bind.
         * @param {*} thisArg The `this` binding of `func`.
         * @param {number} [argCount] The number of arguments to provide to `func`.
         * @returns {Function} Returns the callback.
         */
        function bindCallback(func, thisArg, argCount) {
          if (typeof func != 'function') {
            return identity;
          }
          if (thisArg === undefined) {
            return func;
          }
          switch (argCount) {
            case 1: return function(value) {
              return func.call(thisArg, value);
            };
            case 3: return function(value, index, collection) {
              return func.call(thisArg, value, index, collection);
            };
            case 4: return function(accumulator, value, index, collection) {
              return func.call(thisArg, accumulator, value, index, collection);
            };
            case 5: return function(value, other, key, object, source) {
              return func.call(thisArg, value, other, key, object, source);
            };
          }
          return function() {
            return func.apply(thisArg, arguments);
          };
        }
    
        /**
         * Creates a clone of the given array buffer.
         *
         * @private
         * @param {ArrayBuffer} buffer The array buffer to clone.
         * @returns {ArrayBuffer} Returns the cloned array buffer.
         */
        function bufferClone(buffer) {
          var result = new ArrayBuffer(buffer.byteLength),
              view = new Uint8Array(result);
    
          view.set(new Uint8Array(buffer));
          return result;
        }
    
        /**
         * Creates an array that is the composition of partially applied arguments,
         * placeholders, and provided arguments into a single array of arguments.
         *
         * @private
         * @param {Array|Object} args The provided arguments.
         * @param {Array} partials The arguments to prepend to those provided.
         * @param {Array} holders The `partials` placeholder indexes.
         * @returns {Array} Returns the new array of composed arguments.
         */
        function composeArgs(args, partials, holders) {
          var holdersLength = holders.length,
              argsIndex = -1,
              argsLength = nativeMax(args.length - holdersLength, 0),
              leftIndex = -1,
              leftLength = partials.length,
              result = Array(leftLength + argsLength);
    
          while (++leftIndex < leftLength) {
            result[leftIndex] = partials[leftIndex];
          }
          while (++argsIndex < holdersLength) {
            result[holders[argsIndex]] = args[argsIndex];
          }
          while (argsLength--) {
            result[leftIndex++] = args[argsIndex++];
          }
          return result;
        }
    
        /**
         * This function is like `composeArgs` except that the arguments composition
         * is tailored for `_.partialRight`.
         *
         * @private
         * @param {Array|Object} args The provided arguments.
         * @param {Array} partials The arguments to append to those provided.
         * @param {Array} holders The `partials` placeholder indexes.
         * @returns {Array} Returns the new array of composed arguments.
         */
        function composeArgsRight(args, partials, holders) {
          var holdersIndex = -1,
              holdersLength = holders.length,
              argsIndex = -1,
              argsLength = nativeMax(args.length - holdersLength, 0),
              rightIndex = -1,
              rightLength = partials.length,
              result = Array(argsLength + rightLength);
    
          while (++argsIndex < argsLength) {
            result[argsIndex] = args[argsIndex];
          }
          var offset = argsIndex;
          while (++rightIndex < rightLength) {
            result[offset + rightIndex] = partials[rightIndex];
          }
          while (++holdersIndex < holdersLength) {
            result[offset + holders[holdersIndex]] = args[argsIndex++];
          }
          return result;
        }
    
        /**
         * Creates a `_.countBy`, `_.groupBy`, `_.indexBy`, or `_.partition` function.
         *
         * @private
         * @param {Function} setter The function to set keys and values of the accumulator object.
         * @param {Function} [initializer] The function to initialize the accumulator object.
         * @returns {Function} Returns the new aggregator function.
         */
        function createAggregator(setter, initializer) {
          return function(collection, iteratee, thisArg) {
            var result = initializer ? initializer() : {};
            iteratee = getCallback(iteratee, thisArg, 3);
    
            if (isArray(collection)) {
              var index = -1,
                  length = collection.length;
    
              while (++index < length) {
                var value = collection[index];
                setter(result, value, iteratee(value, index, collection), collection);
              }
            } else {
              baseEach(collection, function(value, key, collection) {
                setter(result, value, iteratee(value, key, collection), collection);
              });
            }
            return result;
          };
        }
    
        /**
         * Creates a `_.assign`, `_.defaults`, or `_.merge` function.
         *
         * @private
         * @param {Function} assigner The function to assign values.
         * @returns {Function} Returns the new assigner function.
         */
        function createAssigner(assigner) {
          return restParam(function(object, sources) {
            var index = -1,
                length = object == null ? 0 : sources.length,
                customizer = length > 2 ? sources[length - 2] : undefined,
                guard = length > 2 ? sources[2] : undefined,
                thisArg = length > 1 ? sources[length - 1] : undefined;
    
            if (typeof customizer == 'function') {
              customizer = bindCallback(customizer, thisArg, 5);
              length -= 2;
            } else {
              customizer = typeof thisArg == 'function' ? thisArg : undefined;
              length -= (customizer ? 1 : 0);
            }
            if (guard && isIterateeCall(sources[0], sources[1], guard)) {
              customizer = length < 3 ? undefined : customizer;
              length = 1;
            }
            while (++index < length) {
              var source = sources[index];
              if (source) {
                assigner(object, source, customizer);
              }
            }
            return object;
          });
        }
    
        /**
         * Creates a `baseEach` or `baseEachRight` function.
         *
         * @private
         * @param {Function} eachFunc The function to iterate over a collection.
         * @param {boolean} [fromRight] Specify iterating from right to left.
         * @returns {Function} Returns the new base function.
         */
        function createBaseEach(eachFunc, fromRight) {
          return function(collection, iteratee) {
            var length = collection ? getLength(collection) : 0;
            if (!isLength(length)) {
              return eachFunc(collection, iteratee);
            }
            var index = fromRight ? length : -1,
                iterable = toObject(collection);
    
            while ((fromRight ? index-- : ++index < length)) {
              if (iteratee(iterable[index], index, iterable) === false) {
                break;
              }
            }
            return collection;
          };
        }
    
        /**
         * Creates a base function for `_.forIn` or `_.forInRight`.
         *
         * @private
         * @param {boolean} [fromRight] Specify iterating from right to left.
         * @returns {Function} Returns the new base function.
         */
        function createBaseFor(fromRight) {
          return function(object, iteratee, keysFunc) {
            var iterable = toObject(object),
                props = keysFunc(object),
                length = props.length,
                index = fromRight ? length : -1;
    
            while ((fromRight ? index-- : ++index < length)) {
              var key = props[index];
              if (iteratee(iterable[key], key, iterable) === false) {
                break;
              }
            }
            return object;
          };
        }
    
        /**
         * Creates a function that wraps `func` and invokes it with the `this`
         * binding of `thisArg`.
         *
         * @private
         * @param {Function} func The function to bind.
         * @param {*} [thisArg] The `this` binding of `func`.
         * @returns {Function} Returns the new bound function.
         */
        function createBindWrapper(func, thisArg) {
          var Ctor = createCtorWrapper(func);
    
          function wrapper() {
            var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;
            return fn.apply(thisArg, arguments);
          }
          return wrapper;
        }
    
        /**
         * Creates a `Set` cache object to optimize linear searches of large arrays.
         *
         * @private
         * @param {Array} [values] The values to cache.
         * @returns {null|Object} Returns the new cache object if `Set` is supported, else `null`.
         */
        function createCache(values) {
          return (nativeCreate && Set) ? new SetCache(values) : null;
        }
    
        /**
         * Creates a function that produces compound words out of the words in a
         * given string.
         *
         * @private
         * @param {Function} callback The function to combine each word.
         * @returns {Function} Returns the new compounder function.
         */
        function createCompounder(callback) {
          return function(string) {
            var index = -1,
                array = words(deburr(string)),
                length = array.length,
                result = '';
    
            while (++index < length) {
              result = callback(result, array[index], index);
            }
            return result;
          };
        }
    
        /**
         * Creates a function that produces an instance of `Ctor` regardless of
         * whether it was invoked as part of a `new` expression or by `call` or `apply`.
         *
         * @private
         * @param {Function} Ctor The constructor to wrap.
         * @returns {Function} Returns the new wrapped function.
         */
        function createCtorWrapper(Ctor) {
          return function() {
            // Use a `switch` statement to work with class constructors.
            // See http://ecma-international.org/ecma-262/6.0/#sec-ecmascript-function-objects-call-thisargument-argumentslist
            // for more details.
            var args = arguments;
            switch (args.length) {
              case 0: return new Ctor;
              case 1: return new Ctor(args[0]);
              case 2: return new Ctor(args[0], args[1]);
              case 3: return new Ctor(args[0], args[1], args[2]);
              case 4: return new Ctor(args[0], args[1], args[2], args[3]);
              case 5: return new Ctor(args[0], args[1], args[2], args[3], args[4]);
              case 6: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
              case 7: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
            }
            var thisBinding = baseCreate(Ctor.prototype),
                result = Ctor.apply(thisBinding, args);
    
            // Mimic the constructor's `return` behavior.
            // See https://es5.github.io/#x13.2.2 for more details.
            return isObject(result) ? result : thisBinding;
          };
        }
    
        /**
         * Creates a `_.curry` or `_.curryRight` function.
         *
         * @private
         * @param {boolean} flag The curry bit flag.
         * @returns {Function} Returns the new curry function.
         */
        function createCurry(flag) {
          function curryFunc(func, arity, guard) {
            if (guard && isIterateeCall(func, arity, guard)) {
              arity = undefined;
            }
            var result = createWrapper(func, flag, undefined, undefined, undefined, undefined, undefined, arity);
            result.placeholder = curryFunc.placeholder;
            return result;
          }
          return curryFunc;
        }
    
        /**
         * Creates a `_.defaults` or `_.defaultsDeep` function.
         *
         * @private
         * @param {Function} assigner The function to assign values.
         * @param {Function} customizer The function to customize assigned values.
         * @returns {Function} Returns the new defaults function.
         */
        function createDefaults(assigner, customizer) {
          return restParam(function(args) {
            var object = args[0];
            if (object == null) {
              return object;
            }
            args.push(customizer);
            return assigner.apply(undefined, args);
          });
        }
    
        /**
         * Creates a `_.max` or `_.min` function.
         *
         * @private
         * @param {Function} comparator The function used to compare values.
         * @param {*} exValue The initial extremum value.
         * @returns {Function} Returns the new extremum function.
         */
        function createExtremum(comparator, exValue) {
          return function(collection, iteratee, thisArg) {
            if (thisArg && isIterateeCall(collection, iteratee, thisArg)) {
              iteratee = undefined;
            }
            iteratee = getCallback(iteratee, thisArg, 3);
            if (iteratee.length == 1) {
              collection = isArray(collection) ? collection : toIterable(collection);
              var result = arrayExtremum(collection, iteratee, comparator, exValue);
              if (!(collection.length && result === exValue)) {
                return result;
              }
            }
            return baseExtremum(collection, iteratee, comparator, exValue);
          };
        }
    
        /**
         * Creates a `_.find` or `_.findLast` function.
         *
         * @private
         * @param {Function} eachFunc The function to iterate over a collection.
         * @param {boolean} [fromRight] Specify iterating from right to left.
         * @returns {Function} Returns the new find function.
         */
        function createFind(eachFunc, fromRight) {
          return function(collection, predicate, thisArg) {
            predicate = getCallback(predicate, thisArg, 3);
            if (isArray(collection)) {
              var index = baseFindIndex(collection, predicate, fromRight);
              return index > -1 ? collection[index] : undefined;
            }
            return baseFind(collection, predicate, eachFunc);
          };
        }
    
        /**
         * Creates a `_.findIndex` or `_.findLastIndex` function.
         *
         * @private
         * @param {boolean} [fromRight] Specify iterating from right to left.
         * @returns {Function} Returns the new find function.
         */
        function createFindIndex(fromRight) {
          return function(array, predicate, thisArg) {
            if (!(array && array.length)) {
              return -1;
            }
            predicate = getCallback(predicate, thisArg, 3);
            return baseFindIndex(array, predicate, fromRight);
          };
        }
    
        /**
         * Creates a `_.findKey` or `_.findLastKey` function.
         *
         * @private
         * @param {Function} objectFunc The function to iterate over an object.
         * @returns {Function} Returns the new find function.
         */
        function createFindKey(objectFunc) {
          return function(object, predicate, thisArg) {
            predicate = getCallback(predicate, thisArg, 3);
            return baseFind(object, predicate, objectFunc, true);
          };
        }
    
        /**
         * Creates a `_.flow` or `_.flowRight` function.
         *
         * @private
         * @param {boolean} [fromRight] Specify iterating from right to left.
         * @returns {Function} Returns the new flow function.
         */
        function createFlow(fromRight) {
          return function() {
            var wrapper,
                length = arguments.length,
                index = fromRight ? length : -1,
                leftIndex = 0,
                funcs = Array(length);
    
            while ((fromRight ? index-- : ++index < length)) {
              var func = funcs[leftIndex++] = arguments[index];
              if (typeof func != 'function') {
                throw new TypeError(FUNC_ERROR_TEXT);
              }
              if (!wrapper && LodashWrapper.prototype.thru && getFuncName(func) == 'wrapper') {
                wrapper = new LodashWrapper([], true);
              }
            }
            index = wrapper ? -1 : length;
            while (++index < length) {
              func = funcs[index];
    
              var funcName = getFuncName(func),
                  data = funcName == 'wrapper' ? getData(func) : undefined;
    
              if (data && isLaziable(data[0]) && data[1] == (ARY_FLAG | CURRY_FLAG | PARTIAL_FLAG | REARG_FLAG) && !data[4].length && data[9] == 1) {
                wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);
              } else {
                wrapper = (func.length == 1 && isLaziable(func)) ? wrapper[funcName]() : wrapper.thru(func);
              }
            }
            return function() {
              var args = arguments,
                  value = args[0];
    
              if (wrapper && args.length == 1 && isArray(value) && value.length >= LARGE_ARRAY_SIZE) {
                return wrapper.plant(value).value();
              }
              var index = 0,
                  result = length ? funcs[index].apply(this, args) : value;
    
              while (++index < length) {
                result = funcs[index].call(this, result);
              }
              return result;
            };
          };
        }
    
        /**
         * Creates a function for `_.forEach` or `_.forEachRight`.
         *
         * @private
         * @param {Function} arrayFunc The function to iterate over an array.
         * @param {Function} eachFunc The function to iterate over a collection.
         * @returns {Function} Returns the new each function.
         */
        function createForEach(arrayFunc, eachFunc) {
          return function(collection, iteratee, thisArg) {
            return (typeof iteratee == 'function' && thisArg === undefined && isArray(collection))
              ? arrayFunc(collection, iteratee)
              : eachFunc(collection, bindCallback(iteratee, thisArg, 3));
          };
        }
    
        /**
         * Creates a function for `_.forIn` or `_.forInRight`.
         *
         * @private
         * @param {Function} objectFunc The function to iterate over an object.
         * @returns {Function} Returns the new each function.
         */
        function createForIn(objectFunc) {
          return function(object, iteratee, thisArg) {
            if (typeof iteratee != 'function' || thisArg !== undefined) {
              iteratee = bindCallback(iteratee, thisArg, 3);
            }
            return objectFunc(object, iteratee, keysIn);
          };
        }
    
        /**
         * Creates a function for `_.forOwn` or `_.forOwnRight`.
         *
         * @private
         * @param {Function} objectFunc The function to iterate over an object.
         * @returns {Function} Returns the new each function.
         */
        function createForOwn(objectFunc) {
          return function(object, iteratee, thisArg) {
            if (typeof iteratee != 'function' || thisArg !== undefined) {
              iteratee = bindCallback(iteratee, thisArg, 3);
            }
            return objectFunc(object, iteratee);
          };
        }
    
        /**
         * Creates a function for `_.mapKeys` or `_.mapValues`.
         *
         * @private
         * @param {boolean} [isMapKeys] Specify mapping keys instead of values.
         * @returns {Function} Returns the new map function.
         */
        function createObjectMapper(isMapKeys) {
          return function(object, iteratee, thisArg) {
            var result = {};
            iteratee = getCallback(iteratee, thisArg, 3);
    
            baseForOwn(object, function(value, key, object) {
              var mapped = iteratee(value, key, object);
              key = isMapKeys ? mapped : key;
              value = isMapKeys ? value : mapped;
              result[key] = value;
            });
            return result;
          };
        }
    
        /**
         * Creates a function for `_.padLeft` or `_.padRight`.
         *
         * @private
         * @param {boolean} [fromRight] Specify padding from the right.
         * @returns {Function} Returns the new pad function.
         */
        function createPadDir(fromRight) {
          return function(string, length, chars) {
            string = baseToString(string);
            return (fromRight ? string : '') + createPadding(string, length, chars) + (fromRight ? '' : string);
          };
        }
    
        /**
         * Creates a `_.partial` or `_.partialRight` function.
         *
         * @private
         * @param {boolean} flag The partial bit flag.
         * @returns {Function} Returns the new partial function.
         */
        function createPartial(flag) {
          var partialFunc = restParam(function(func, partials) {
            var holders = replaceHolders(partials, partialFunc.placeholder);
            return createWrapper(func, flag, undefined, partials, holders);
          });
          return partialFunc;
        }
    
        /**
         * Creates a function for `_.reduce` or `_.reduceRight`.
         *
         * @private
         * @param {Function} arrayFunc The function to iterate over an array.
         * @param {Function} eachFunc The function to iterate over a collection.
         * @returns {Function} Returns the new each function.
         */
        function createReduce(arrayFunc, eachFunc) {
          return function(collection, iteratee, accumulator, thisArg) {
            var initFromArray = arguments.length < 3;
            return (typeof iteratee == 'function' && thisArg === undefined && isArray(collection))
              ? arrayFunc(collection, iteratee, accumulator, initFromArray)
              : baseReduce(collection, getCallback(iteratee, thisArg, 4), accumulator, initFromArray, eachFunc);
          };
        }
    
        /**
         * Creates a function that wraps `func` and invokes it with optional `this`
         * binding of, partial application, and currying.
         *
         * @private
         * @param {Function|string} func The function or method name to reference.
         * @param {number} bitmask The bitmask of flags. See `createWrapper` for more details.
         * @param {*} [thisArg] The `this` binding of `func`.
         * @param {Array} [partials] The arguments to prepend to those provided to the new function.
         * @param {Array} [holders] The `partials` placeholder indexes.
         * @param {Array} [partialsRight] The arguments to append to those provided to the new function.
         * @param {Array} [holdersRight] The `partialsRight` placeholder indexes.
         * @param {Array} [argPos] The argument positions of the new function.
         * @param {number} [ary] The arity cap of `func`.
         * @param {number} [arity] The arity of `func`.
         * @returns {Function} Returns the new wrapped function.
         */
        function createHybridWrapper(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity) {
          var isAry = bitmask & ARY_FLAG,
              isBind = bitmask & BIND_FLAG,
              isBindKey = bitmask & BIND_KEY_FLAG,
              isCurry = bitmask & CURRY_FLAG,
              isCurryBound = bitmask & CURRY_BOUND_FLAG,
              isCurryRight = bitmask & CURRY_RIGHT_FLAG,
              Ctor = isBindKey ? undefined : createCtorWrapper(func);
    
          function wrapper() {
            // Avoid `arguments` object use disqualifying optimizations by
            // converting it to an array before providing it to other functions.
            var length = arguments.length,
                index = length,
                args = Array(length);
    
            while (index--) {
              args[index] = arguments[index];
            }
            if (partials) {
              args = composeArgs(args, partials, holders);
            }
            if (partialsRight) {
              args = composeArgsRight(args, partialsRight, holdersRight);
            }
            if (isCurry || isCurryRight) {
              var placeholder = wrapper.placeholder,
                  argsHolders = replaceHolders(args, placeholder);
    
              length -= argsHolders.length;
              if (length < arity) {
                var newArgPos = argPos ? arrayCopy(argPos) : undefined,
                    newArity = nativeMax(arity - length, 0),
                    newsHolders = isCurry ? argsHolders : undefined,
                    newHoldersRight = isCurry ? undefined : argsHolders,
                    newPartials = isCurry ? args : undefined,
                    newPartialsRight = isCurry ? undefined : args;
    
                bitmask |= (isCurry ? PARTIAL_FLAG : PARTIAL_RIGHT_FLAG);
                bitmask &= ~(isCurry ? PARTIAL_RIGHT_FLAG : PARTIAL_FLAG);
    
                if (!isCurryBound) {
                  bitmask &= ~(BIND_FLAG | BIND_KEY_FLAG);
                }
                var newData = [func, bitmask, thisArg, newPartials, newsHolders, newPartialsRight, newHoldersRight, newArgPos, ary, newArity],
                    result = createHybridWrapper.apply(undefined, newData);
    
                if (isLaziable(func)) {
                  setData(result, newData);
                }
                result.placeholder = placeholder;
                return result;
              }
            }
            var thisBinding = isBind ? thisArg : this,
                fn = isBindKey ? thisBinding[func] : func;
    
            if (argPos) {
              args = reorder(args, argPos);
            }
            if (isAry && ary < args.length) {
              args.length = ary;
            }
            if (this && this !== root && this instanceof wrapper) {
              fn = Ctor || createCtorWrapper(func);
            }
            return fn.apply(thisBinding, args);
          }
          return wrapper;
        }
    
        /**
         * Creates the padding required for `string` based on the given `length`.
         * The `chars` string is truncated if the number of characters exceeds `length`.
         *
         * @private
         * @param {string} string The string to create padding for.
         * @param {number} [length=0] The padding length.
         * @param {string} [chars=' '] The string used as padding.
         * @returns {string} Returns the pad for `string`.
         */
        function createPadding(string, length, chars) {
          var strLength = string.length;
          length = +length;
    
          if (strLength >= length || !nativeIsFinite(length)) {
            return '';
          }
          var padLength = length - strLength;
          chars = chars == null ? ' ' : (chars + '');
          return repeat(chars, nativeCeil(padLength / chars.length)).slice(0, padLength);
        }
    
        /**
         * Creates a function that wraps `func` and invokes it with the optional `this`
         * binding of `thisArg` and the `partials` prepended to those provided to
         * the wrapper.
         *
         * @private
         * @param {Function} func The function to partially apply arguments to.
         * @param {number} bitmask The bitmask of flags. See `createWrapper` for more details.
         * @param {*} thisArg The `this` binding of `func`.
         * @param {Array} partials The arguments to prepend to those provided to the new function.
         * @returns {Function} Returns the new bound function.
         */
        function createPartialWrapper(func, bitmask, thisArg, partials) {
          var isBind = bitmask & BIND_FLAG,
              Ctor = createCtorWrapper(func);
    
          function wrapper() {
            // Avoid `arguments` object use disqualifying optimizations by
            // converting it to an array before providing it `func`.
            var argsIndex = -1,
                argsLength = arguments.length,
                leftIndex = -1,
                leftLength = partials.length,
                args = Array(leftLength + argsLength);
    
            while (++leftIndex < leftLength) {
              args[leftIndex] = partials[leftIndex];
            }
            while (argsLength--) {
              args[leftIndex++] = arguments[++argsIndex];
            }
            var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;
            return fn.apply(isBind ? thisArg : this, args);
          }
          return wrapper;
        }
    
        /**
         * Creates a `_.ceil`, `_.floor`, or `_.round` function.
         *
         * @private
         * @param {string} methodName The name of the `Math` method to use when rounding.
         * @returns {Function} Returns the new round function.
         */
        function createRound(methodName) {
          var func = Math[methodName];
          return function(number, precision) {
            precision = precision === undefined ? 0 : (+precision || 0);
            if (precision) {
              precision = pow(10, precision);
              return func(number * precision) / precision;
            }
            return func(number);
          };
        }
    
        /**
         * Creates a `_.sortedIndex` or `_.sortedLastIndex` function.
         *
         * @private
         * @param {boolean} [retHighest] Specify returning the highest qualified index.
         * @returns {Function} Returns the new index function.
         */
        function createSortedIndex(retHighest) {
          return function(array, value, iteratee, thisArg) {
            var callback = getCallback(iteratee);
            return (iteratee == null && callback === baseCallback)
              ? binaryIndex(array, value, retHighest)
              : binaryIndexBy(array, value, callback(iteratee, thisArg, 1), retHighest);
          };
        }
    
        /**
         * Creates a function that either curries or invokes `func` with optional
         * `this` binding and partially applied arguments.
         *
         * @private
         * @param {Function|string} func The function or method name to reference.
         * @param {number} bitmask The bitmask of flags.
         *  The bitmask may be composed of the following flags:
         *     1 - `_.bind`
         *     2 - `_.bindKey`
         *     4 - `_.curry` or `_.curryRight` of a bound function
         *     8 - `_.curry`
         *    16 - `_.curryRight`
         *    32 - `_.partial`
         *    64 - `_.partialRight`
         *   128 - `_.rearg`
         *   256 - `_.ary`
         * @param {*} [thisArg] The `this` binding of `func`.
         * @param {Array} [partials] The arguments to be partially applied.
         * @param {Array} [holders] The `partials` placeholder indexes.
         * @param {Array} [argPos] The argument positions of the new function.
         * @param {number} [ary] The arity cap of `func`.
         * @param {number} [arity] The arity of `func`.
         * @returns {Function} Returns the new wrapped function.
         */
        function createWrapper(func, bitmask, thisArg, partials, holders, argPos, ary, arity) {
          var isBindKey = bitmask & BIND_KEY_FLAG;
          if (!isBindKey && typeof func != 'function') {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          var length = partials ? partials.length : 0;
          if (!length) {
            bitmask &= ~(PARTIAL_FLAG | PARTIAL_RIGHT_FLAG);
            partials = holders = undefined;
          }
          length -= (holders ? holders.length : 0);
          if (bitmask & PARTIAL_RIGHT_FLAG) {
            var partialsRight = partials,
                holdersRight = holders;
    
            partials = holders = undefined;
          }
          var data = isBindKey ? undefined : getData(func),
              newData = [func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity];
    
          if (data) {
            mergeData(newData, data);
            bitmask = newData[1];
            arity = newData[9];
          }
          newData[9] = arity == null
            ? (isBindKey ? 0 : func.length)
            : (nativeMax(arity - length, 0) || 0);
    
          if (bitmask == BIND_FLAG) {
            var result = createBindWrapper(newData[0], newData[2]);
          } else if ((bitmask == PARTIAL_FLAG || bitmask == (BIND_FLAG | PARTIAL_FLAG)) && !newData[4].length) {
            result = createPartialWrapper.apply(undefined, newData);
          } else {
            result = createHybridWrapper.apply(undefined, newData);
          }
          var setter = data ? baseSetData : setData;
          return setter(result, newData);
        }
    
        /**
         * A specialized version of `baseIsEqualDeep` for arrays with support for
         * partial deep comparisons.
         *
         * @private
         * @param {Array} array The array to compare.
         * @param {Array} other The other array to compare.
         * @param {Function} equalFunc The function to determine equivalents of values.
         * @param {Function} [customizer] The function to customize comparing arrays.
         * @param {boolean} [isLoose] Specify performing partial comparisons.
         * @param {Array} [stackA] Tracks traversed `value` objects.
         * @param {Array} [stackB] Tracks traversed `other` objects.
         * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
         */
        function equalArrays(array, other, equalFunc, customizer, isLoose, stackA, stackB) {
          var index = -1,
              arrLength = array.length,
              othLength = other.length;
    
          if (arrLength != othLength && !(isLoose && othLength > arrLength)) {
            return false;
          }
          // Ignore non-index properties.
          while (++index < arrLength) {
            var arrValue = array[index],
                othValue = other[index],
                result = customizer ? customizer(isLoose ? othValue : arrValue, isLoose ? arrValue : othValue, index) : undefined;
    
            if (result !== undefined) {
              if (result) {
                continue;
              }
              return false;
            }
            // Recursively compare arrays (susceptible to call stack limits).
            if (isLoose) {
              if (!arraySome(other, function(othValue) {
                    return arrValue === othValue || equalFunc(arrValue, othValue, customizer, isLoose, stackA, stackB);
                  })) {
                return false;
              }
            } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, customizer, isLoose, stackA, stackB))) {
              return false;
            }
          }
          return true;
        }
    
        /**
         * A specialized version of `baseIsEqualDeep` for comparing objects of
         * the same `toStringTag`.
         *
         * **Note:** This function only supports comparing values with tags of
         * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
         *
         * @private
         * @param {Object} object The object to compare.
         * @param {Object} other The other object to compare.
         * @param {string} tag The `toStringTag` of the objects to compare.
         * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
         */
        function equalByTag(object, other, tag) {
          switch (tag) {
            case boolTag:
            case dateTag:
              // Coerce dates and booleans to numbers, dates to milliseconds and booleans
              // to `1` or `0` treating invalid dates coerced to `NaN` as not equal.
              return +object == +other;
    
            case errorTag:
              return object.name == other.name && object.message == other.message;
    
            case numberTag:
              // Treat `NaN` vs. `NaN` as equal.
              return (object != +object)
                ? other != +other
                : object == +other;
    
            case regexpTag:
            case stringTag:
              // Coerce regexes to strings and treat strings primitives and string
              // objects as equal. See https://es5.github.io/#x15.10.6.4 for more details.
              return object == (other + '');
          }
          return false;
        }
    
        /**
         * A specialized version of `baseIsEqualDeep` for objects with support for
         * partial deep comparisons.
         *
         * @private
         * @param {Object} object The object to compare.
         * @param {Object} other The other object to compare.
         * @param {Function} equalFunc The function to determine equivalents of values.
         * @param {Function} [customizer] The function to customize comparing values.
         * @param {boolean} [isLoose] Specify performing partial comparisons.
         * @param {Array} [stackA] Tracks traversed `value` objects.
         * @param {Array} [stackB] Tracks traversed `other` objects.
         * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
         */
        function equalObjects(object, other, equalFunc, customizer, isLoose, stackA, stackB) {
          var objProps = keys(object),
              objLength = objProps.length,
              othProps = keys(other),
              othLength = othProps.length;
    
          if (objLength != othLength && !isLoose) {
            return false;
          }
          var index = objLength;
          while (index--) {
            var key = objProps[index];
            if (!(isLoose ? key in other : hasOwnProperty.call(other, key))) {
              return false;
            }
          }
          var skipCtor = isLoose;
          while (++index < objLength) {
            key = objProps[index];
            var objValue = object[key],
                othValue = other[key],
                result = customizer ? customizer(isLoose ? othValue : objValue, isLoose? objValue : othValue, key) : undefined;
    
            // Recursively compare objects (susceptible to call stack limits).
            if (!(result === undefined ? equalFunc(objValue, othValue, customizer, isLoose, stackA, stackB) : result)) {
              return false;
            }
            skipCtor || (skipCtor = key == 'constructor');
          }
          if (!skipCtor) {
            var objCtor = object.constructor,
                othCtor = other.constructor;
    
            // Non `Object` object instances with different constructors are not equal.
            if (objCtor != othCtor &&
                ('constructor' in object && 'constructor' in other) &&
                !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
                  typeof othCtor == 'function' && othCtor instanceof othCtor)) {
              return false;
            }
          }
          return true;
        }
    
        /**
         * Gets the appropriate "callback" function. If the `_.callback` method is
         * customized this function returns the custom method, otherwise it returns
         * the `baseCallback` function. If arguments are provided the chosen function
         * is invoked with them and its result is returned.
         *
         * @private
         * @returns {Function} Returns the chosen function or its result.
         */
        function getCallback(func, thisArg, argCount) {
          var result = lodash.callback || callback;
          result = result === callback ? baseCallback : result;
          return argCount ? result(func, thisArg, argCount) : result;
        }
    
        /**
         * Gets metadata for `func`.
         *
         * @private
         * @param {Function} func The function to query.
         * @returns {*} Returns the metadata for `func`.
         */
        var getData = !metaMap ? noop : function(func) {
          return metaMap.get(func);
        };
    
        /**
         * Gets the name of `func`.
         *
         * @private
         * @param {Function} func The function to query.
         * @returns {string} Returns the function name.
         */
        function getFuncName(func) {
          var result = func.name,
              array = realNames[result],
              length = array ? array.length : 0;
    
          while (length--) {
            var data = array[length],
                otherFunc = data.func;
            if (otherFunc == null || otherFunc == func) {
              return data.name;
            }
          }
          return result;
        }
    
        /**
         * Gets the appropriate "indexOf" function. If the `_.indexOf` method is
         * customized this function returns the custom method, otherwise it returns
         * the `baseIndexOf` function. If arguments are provided the chosen function
         * is invoked with them and its result is returned.
         *
         * @private
         * @returns {Function|number} Returns the chosen function or its result.
         */
        function getIndexOf(collection, target, fromIndex) {
          var result = lodash.indexOf || indexOf;
          result = result === indexOf ? baseIndexOf : result;
          return collection ? result(collection, target, fromIndex) : result;
        }
    
        /**
         * Gets the "length" property value of `object`.
         *
         * **Note:** This function is used to avoid a [JIT bug](https://bugs.webkit.org/show_bug.cgi?id=142792)
         * that affects Safari on at least iOS 8.1-8.3 ARM64.
         *
         * @private
         * @param {Object} object The object to query.
         * @returns {*} Returns the "length" value.
         */
        var getLength = baseProperty('length');
    
        /**
         * Gets the propery names, values, and compare flags of `object`.
         *
         * @private
         * @param {Object} object The object to query.
         * @returns {Array} Returns the match data of `object`.
         */
        function getMatchData(object) {
          var result = pairs(object),
              length = result.length;
    
          while (length--) {
            result[length][2] = isStrictComparable(result[length][1]);
          }
          return result;
        }
    
        /**
         * Gets the native function at `key` of `object`.
         *
         * @private
         * @param {Object} object The object to query.
         * @param {string} key The key of the method to get.
         * @returns {*} Returns the function if it's native, else `undefined`.
         */
        function getNative(object, key) {
          var value = object == null ? undefined : object[key];
          return isNative(value) ? value : undefined;
        }
    
        /**
         * Gets the view, applying any `transforms` to the `start` and `end` positions.
         *
         * @private
         * @param {number} start The start of the view.
         * @param {number} end The end of the view.
         * @param {Array} transforms The transformations to apply to the view.
         * @returns {Object} Returns an object containing the `start` and `end`
         *  positions of the view.
         */
        function getView(start, end, transforms) {
          var index = -1,
              length = transforms.length;
    
          while (++index < length) {
            var data = transforms[index],
                size = data.size;
    
            switch (data.type) {
              case 'drop':      start += size; break;
              case 'dropRight': end -= size; break;
              case 'take':      end = nativeMin(end, start + size); break;
              case 'takeRight': start = nativeMax(start, end - size); break;
            }
          }
          return { 'start': start, 'end': end };
        }
    
        /**
         * Initializes an array clone.
         *
         * @private
         * @param {Array} array The array to clone.
         * @returns {Array} Returns the initialized clone.
         */
        function initCloneArray(array) {
          var length = array.length,
              result = new array.constructor(length);
    
          // Add array properties assigned by `RegExp#exec`.
          if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
            result.index = array.index;
            result.input = array.input;
          }
          return result;
        }
    
        /**
         * Initializes an object clone.
         *
         * @private
         * @param {Object} object The object to clone.
         * @returns {Object} Returns the initialized clone.
         */
        function initCloneObject(object) {
          var Ctor = object.constructor;
          if (!(typeof Ctor == 'function' && Ctor instanceof Ctor)) {
            Ctor = Object;
          }
          return new Ctor;
        }
    
        /**
         * Initializes an object clone based on its `toStringTag`.
         *
         * **Note:** This function only supports cloning values with tags of
         * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
         *
         * @private
         * @param {Object} object The object to clone.
         * @param {string} tag The `toStringTag` of the object to clone.
         * @param {boolean} [isDeep] Specify a deep clone.
         * @returns {Object} Returns the initialized clone.
         */
        function initCloneByTag(object, tag, isDeep) {
          var Ctor = object.constructor;
          switch (tag) {
            case arrayBufferTag:
              return bufferClone(object);
    
            case boolTag:
            case dateTag:
              return new Ctor(+object);
    
            case float32Tag: case float64Tag:
            case int8Tag: case int16Tag: case int32Tag:
            case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:
              var buffer = object.buffer;
              return new Ctor(isDeep ? bufferClone(buffer) : buffer, object.byteOffset, object.length);
    
            case numberTag:
            case stringTag:
              return new Ctor(object);
    
            case regexpTag:
              var result = new Ctor(object.source, reFlags.exec(object));
              result.lastIndex = object.lastIndex;
          }
          return result;
        }
    
        /**
         * Invokes the method at `path` on `object`.
         *
         * @private
         * @param {Object} object The object to query.
         * @param {Array|string} path The path of the method to invoke.
         * @param {Array} args The arguments to invoke the method with.
         * @returns {*} Returns the result of the invoked method.
         */
        function invokePath(object, path, args) {
          if (object != null && !isKey(path, object)) {
            path = toPath(path);
            object = path.length == 1 ? object : baseGet(object, baseSlice(path, 0, -1));
            path = last(path);
          }
          var func = object == null ? object : object[path];
          return func == null ? undefined : func.apply(object, args);
        }
    
        /**
         * Checks if `value` is array-like.
         *
         * @private
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
         */
        function isArrayLike(value) {
          return value != null && isLength(getLength(value));
        }
    
        /**
         * Checks if `value` is a valid array-like index.
         *
         * @private
         * @param {*} value The value to check.
         * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
         * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
         */
        function isIndex(value, length) {
          value = (typeof value == 'number' || reIsUint.test(value)) ? +value : -1;
          length = length == null ? MAX_SAFE_INTEGER : length;
          return value > -1 && value % 1 == 0 && value < length;
        }
    
        /**
         * Checks if the provided arguments are from an iteratee call.
         *
         * @private
         * @param {*} value The potential iteratee value argument.
         * @param {*} index The potential iteratee index or key argument.
         * @param {*} object The potential iteratee object argument.
         * @returns {boolean} Returns `true` if the arguments are from an iteratee call, else `false`.
         */
        function isIterateeCall(value, index, object) {
          if (!isObject(object)) {
            return false;
          }
          var type = typeof index;
          if (type == 'number'
              ? (isArrayLike(object) && isIndex(index, object.length))
              : (type == 'string' && index in object)) {
            var other = object[index];
            return value === value ? (value === other) : (other !== other);
          }
          return false;
        }
    
        /**
         * Checks if `value` is a property name and not a property path.
         *
         * @private
         * @param {*} value The value to check.
         * @param {Object} [object] The object to query keys on.
         * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
         */
        function isKey(value, object) {
          var type = typeof value;
          if ((type == 'string' && reIsPlainProp.test(value)) || type == 'number') {
            return true;
          }
          if (isArray(value)) {
            return false;
          }
          var result = !reIsDeepProp.test(value);
          return result || (object != null && value in toObject(object));
        }
    
        /**
         * Checks if `func` has a lazy counterpart.
         *
         * @private
         * @param {Function} func The function to check.
         * @returns {boolean} Returns `true` if `func` has a lazy counterpart, else `false`.
         */
        function isLaziable(func) {
          var funcName = getFuncName(func);
          if (!(funcName in LazyWrapper.prototype)) {
            return false;
          }
          var other = lodash[funcName];
          if (func === other) {
            return true;
          }
          var data = getData(other);
          return !!data && func === data[0];
        }
    
        /**
         * Checks if `value` is a valid array-like length.
         *
         * **Note:** This function is based on [`ToLength`](http://ecma-international.org/ecma-262/6.0/#sec-tolength).
         *
         * @private
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
         */
        function isLength(value) {
          return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
        }
    
        /**
         * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
         *
         * @private
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` if suitable for strict
         *  equality comparisons, else `false`.
         */
        function isStrictComparable(value) {
          return value === value && !isObject(value);
        }
    
        /**
         * Merges the function metadata of `source` into `data`.
         *
         * Merging metadata reduces the number of wrappers required to invoke a function.
         * This is possible because methods like `_.bind`, `_.curry`, and `_.partial`
         * may be applied regardless of execution order. Methods like `_.ary` and `_.rearg`
         * augment function arguments, making the order in which they are executed important,
         * preventing the merging of metadata. However, we make an exception for a safe
         * common case where curried functions have `_.ary` and or `_.rearg` applied.
         *
         * @private
         * @param {Array} data The destination metadata.
         * @param {Array} source The source metadata.
         * @returns {Array} Returns `data`.
         */
        function mergeData(data, source) {
          var bitmask = data[1],
              srcBitmask = source[1],
              newBitmask = bitmask | srcBitmask,
              isCommon = newBitmask < ARY_FLAG;
    
          var isCombo =
            (srcBitmask == ARY_FLAG && bitmask == CURRY_FLAG) ||
            (srcBitmask == ARY_FLAG && bitmask == REARG_FLAG && data[7].length <= source[8]) ||
            (srcBitmask == (ARY_FLAG | REARG_FLAG) && bitmask == CURRY_FLAG);
    
          // Exit early if metadata can't be merged.
          if (!(isCommon || isCombo)) {
            return data;
          }
          // Use source `thisArg` if available.
          if (srcBitmask & BIND_FLAG) {
            data[2] = source[2];
            // Set when currying a bound function.
            newBitmask |= (bitmask & BIND_FLAG) ? 0 : CURRY_BOUND_FLAG;
          }
          // Compose partial arguments.
          var value = source[3];
          if (value) {
            var partials = data[3];
            data[3] = partials ? composeArgs(partials, value, source[4]) : arrayCopy(value);
            data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : arrayCopy(source[4]);
          }
          // Compose partial right arguments.
          value = source[5];
          if (value) {
            partials = data[5];
            data[5] = partials ? composeArgsRight(partials, value, source[6]) : arrayCopy(value);
            data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : arrayCopy(source[6]);
          }
          // Use source `argPos` if available.
          value = source[7];
          if (value) {
            data[7] = arrayCopy(value);
          }
          // Use source `ary` if it's smaller.
          if (srcBitmask & ARY_FLAG) {
            data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
          }
          // Use source `arity` if one is not provided.
          if (data[9] == null) {
            data[9] = source[9];
          }
          // Use source `func` and merge bitmasks.
          data[0] = source[0];
          data[1] = newBitmask;
    
          return data;
        }
    
        /**
         * Used by `_.defaultsDeep` to customize its `_.merge` use.
         *
         * @private
         * @param {*} objectValue The destination object property value.
         * @param {*} sourceValue The source object property value.
         * @returns {*} Returns the value to assign to the destination object.
         */
        function mergeDefaults(objectValue, sourceValue) {
          return objectValue === undefined ? sourceValue : merge(objectValue, sourceValue, mergeDefaults);
        }
    
        /**
         * A specialized version of `_.pick` which picks `object` properties specified
         * by `props`.
         *
         * @private
         * @param {Object} object The source object.
         * @param {string[]} props The property names to pick.
         * @returns {Object} Returns the new object.
         */
        function pickByArray(object, props) {
          object = toObject(object);
    
          var index = -1,
              length = props.length,
              result = {};
    
          while (++index < length) {
            var key = props[index];
            if (key in object) {
              result[key] = object[key];
            }
          }
          return result;
        }
    
        /**
         * A specialized version of `_.pick` which picks `object` properties `predicate`
         * returns truthy for.
         *
         * @private
         * @param {Object} object The source object.
         * @param {Function} predicate The function invoked per iteration.
         * @returns {Object} Returns the new object.
         */
        function pickByCallback(object, predicate) {
          var result = {};
          baseForIn(object, function(value, key, object) {
            if (predicate(value, key, object)) {
              result[key] = value;
            }
          });
          return result;
        }
    
        /**
         * Reorder `array` according to the specified indexes where the element at
         * the first index is assigned as the first element, the element at
         * the second index is assigned as the second element, and so on.
         *
         * @private
         * @param {Array} array The array to reorder.
         * @param {Array} indexes The arranged array indexes.
         * @returns {Array} Returns `array`.
         */
        function reorder(array, indexes) {
          var arrLength = array.length,
              length = nativeMin(indexes.length, arrLength),
              oldArray = arrayCopy(array);
    
          while (length--) {
            var index = indexes[length];
            array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined;
          }
          return array;
        }
    
        /**
         * Sets metadata for `func`.
         *
         * **Note:** If this function becomes hot, i.e. is invoked a lot in a short
         * period of time, it will trip its breaker and transition to an identity function
         * to avoid garbage collection pauses in V8. See [V8 issue 2070](https://code.google.com/p/v8/issues/detail?id=2070)
         * for more details.
         *
         * @private
         * @param {Function} func The function to associate metadata with.
         * @param {*} data The metadata.
         * @returns {Function} Returns `func`.
         */
        var setData = (function() {
          var count = 0,
              lastCalled = 0;
    
          return function(key, value) {
            var stamp = now(),
                remaining = HOT_SPAN - (stamp - lastCalled);
    
            lastCalled = stamp;
            if (remaining > 0) {
              if (++count >= HOT_COUNT) {
                return key;
              }
            } else {
              count = 0;
            }
            return baseSetData(key, value);
          };
        }());
    
        /**
         * A fallback implementation of `Object.keys` which creates an array of the
         * own enumerable property names of `object`.
         *
         * @private
         * @param {Object} object The object to query.
         * @returns {Array} Returns the array of property names.
         */
        function shimKeys(object) {
          var props = keysIn(object),
              propsLength = props.length,
              length = propsLength && object.length;
    
          var allowIndexes = !!length && isLength(length) &&
            (isArray(object) || isArguments(object));
    
          var index = -1,
              result = [];
    
          while (++index < propsLength) {
            var key = props[index];
            if ((allowIndexes && isIndex(key, length)) || hasOwnProperty.call(object, key)) {
              result.push(key);
            }
          }
          return result;
        }
    
        /**
         * Converts `value` to an array-like object if it's not one.
         *
         * @private
         * @param {*} value The value to process.
         * @returns {Array|Object} Returns the array-like object.
         */
        function toIterable(value) {
          if (value == null) {
            return [];
          }
          if (!isArrayLike(value)) {
            return values(value);
          }
          return isObject(value) ? value : Object(value);
        }
    
        /**
         * Converts `value` to an object if it's not one.
         *
         * @private
         * @param {*} value The value to process.
         * @returns {Object} Returns the object.
         */
        function toObject(value) {
          return isObject(value) ? value : Object(value);
        }
    
        /**
         * Converts `value` to property path array if it's not one.
         *
         * @private
         * @param {*} value The value to process.
         * @returns {Array} Returns the property path array.
         */
        function toPath(value) {
          if (isArray(value)) {
            return value;
          }
          var result = [];
          baseToString(value).replace(rePropName, function(match, number, quote, string) {
            result.push(quote ? string.replace(reEscapeChar, '$1') : (number || match));
          });
          return result;
        }
    
        /**
         * Creates a clone of `wrapper`.
         *
         * @private
         * @param {Object} wrapper The wrapper to clone.
         * @returns {Object} Returns the cloned wrapper.
         */
        function wrapperClone(wrapper) {
          return wrapper instanceof LazyWrapper
            ? wrapper.clone()
            : new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__, arrayCopy(wrapper.__actions__));
        }
    
        /*------------------------------------------------------------------------*/
    
        /**
         * Creates an array of elements split into groups the length of `size`.
         * If `collection` can't be split evenly, the final chunk will be the remaining
         * elements.
         *
         * @static
         * @memberOf _
         * @category Array
         * @param {Array} array The array to process.
         * @param {number} [size=1] The length of each chunk.
         * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
         * @returns {Array} Returns the new array containing chunks.
         * @example
         *
         * _.chunk(['a', 'b', 'c', 'd'], 2);
         * // => [['a', 'b'], ['c', 'd']]
         *
         * _.chunk(['a', 'b', 'c', 'd'], 3);
         * // => [['a', 'b', 'c'], ['d']]
         */
        function chunk(array, size, guard) {
          if (guard ? isIterateeCall(array, size, guard) : size == null) {
            size = 1;
          } else {
            size = nativeMax(nativeFloor(size) || 1, 1);
          }
          var index = 0,
              length = array ? array.length : 0,
              resIndex = -1,
              result = Array(nativeCeil(length / size));
    
          while (index < length) {
            result[++resIndex] = baseSlice(array, index, (index += size));
          }
          return result;
        }
    
        /**
         * Creates an array with all falsey values removed. The values `false`, `null`,
         * `0`, `""`, `undefined`, and `NaN` are falsey.
         *
         * @static
         * @memberOf _
         * @category Array
         * @param {Array} array The array to compact.
         * @returns {Array} Returns the new array of filtered values.
         * @example
         *
         * _.compact([0, 1, false, 2, '', 3]);
         * // => [1, 2, 3]
         */
        function compact(array) {
          var index = -1,
              length = array ? array.length : 0,
              resIndex = -1,
              result = [];
    
          while (++index < length) {
            var value = array[index];
            if (value) {
              result[++resIndex] = value;
            }
          }
          return result;
        }
    
        /**
         * Creates an array of unique `array` values not included in the other
         * provided arrays using [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
         * for equality comparisons.
         *
         * @static
         * @memberOf _
         * @category Array
         * @param {Array} array The array to inspect.
         * @param {...Array} [values] The arrays of values to exclude.
         * @returns {Array} Returns the new array of filtered values.
         * @example
         *
         * _.difference([1, 2, 3], [4, 2]);
         * // => [1, 3]
         */
        var difference = restParam(function(array, values) {
          return (isObjectLike(array) && isArrayLike(array))
            ? baseDifference(array, baseFlatten(values, false, true))
            : [];
        });
    
        /**
         * Creates a slice of `array` with `n` elements dropped from the beginning.
         *
         * @static
         * @memberOf _
         * @category Array
         * @param {Array} array The array to query.
         * @param {number} [n=1] The number of elements to drop.
         * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
         * @returns {Array} Returns the slice of `array`.
         * @example
         *
         * _.drop([1, 2, 3]);
         * // => [2, 3]
         *
         * _.drop([1, 2, 3], 2);
         * // => [3]
         *
         * _.drop([1, 2, 3], 5);
         * // => []
         *
         * _.drop([1, 2, 3], 0);
         * // => [1, 2, 3]
         */
        function drop(array, n, guard) {
          var length = array ? array.length : 0;
          if (!length) {
            return [];
          }
          if (guard ? isIterateeCall(array, n, guard) : n == null) {
            n = 1;
          }
          return baseSlice(array, n < 0 ? 0 : n);
        }
    
        /**
         * Creates a slice of `array` with `n` elements dropped from the end.
         *
         * @static
         * @memberOf _
         * @category Array
         * @param {Array} array The array to query.
         * @param {number} [n=1] The number of elements to drop.
         * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
         * @returns {Array} Returns the slice of `array`.
         * @example
         *
         * _.dropRight([1, 2, 3]);
         * // => [1, 2]
         *
         * _.dropRight([1, 2, 3], 2);
         * // => [1]
         *
         * _.dropRight([1, 2, 3], 5);
         * // => []
         *
         * _.dropRight([1, 2, 3], 0);
         * // => [1, 2, 3]
         */
        function dropRight(array, n, guard) {
          var length = array ? array.length : 0;
          if (!length) {
            return [];
          }
          if (guard ? isIterateeCall(array, n, guard) : n == null) {
            n = 1;
          }
          n = length - (+n || 0);
          return baseSlice(array, 0, n < 0 ? 0 : n);
        }
    
        /**
         * Creates a slice of `array` excluding elements dropped from the end.
         * Elements are dropped until `predicate` returns falsey. The predicate is
         * bound to `thisArg` and invoked with three arguments: (value, index, array).
         *
         * If a property name is provided for `predicate` the created `_.property`
         * style callback returns the property value of the given element.
         *
         * If a value is also provided for `thisArg` the created `_.matchesProperty`
         * style callback returns `true` for elements that have a matching property
         * value, else `false`.
         *
         * If an object is provided for `predicate` the created `_.matches` style
         * callback returns `true` for elements that match the properties of the given
         * object, else `false`.
         *
         * @static
         * @memberOf _
         * @category Array
         * @param {Array} array The array to query.
         * @param {Function|Object|string} [predicate=_.identity] The function invoked
         *  per iteration.
         * @param {*} [thisArg] The `this` binding of `predicate`.
         * @returns {Array} Returns the slice of `array`.
         * @example
         *
         * _.dropRightWhile([1, 2, 3], function(n) {
         *   return n > 1;
         * });
         * // => [1]
         *
         * var users = [
         *   { 'user': 'barney',  'active': true },
         *   { 'user': 'fred',    'active': false },
         *   { 'user': 'pebbles', 'active': false }
         * ];
         *
         * // using the `_.matches` callback shorthand
         * _.pluck(_.dropRightWhile(users, { 'user': 'pebbles', 'active': false }), 'user');
         * // => ['barney', 'fred']
         *
         * // using the `_.matchesProperty` callback shorthand
         * _.pluck(_.dropRightWhile(users, 'active', false), 'user');
         * // => ['barney']
         *
         * // using the `_.property` callback shorthand
         * _.pluck(_.dropRightWhile(users, 'active'), 'user');
         * // => ['barney', 'fred', 'pebbles']
         */
        function dropRightWhile(array, predicate, thisArg) {
          return (array && array.length)
            ? baseWhile(array, getCallback(predicate, thisArg, 3), true, true)
            : [];
        }
    
        /**
         * Creates a slice of `array` excluding elements dropped from the beginning.
         * Elements are dropped until `predicate` returns falsey. The predicate is
         * bound to `thisArg` and invoked with three arguments: (value, index, array).
         *
         * If a property name is provided for `predicate` the created `_.property`
         * style callback returns the property value of the given element.
         *
         * If a value is also provided for `thisArg` the created `_.matchesProperty`
         * style callback returns `true` for elements that have a matching property
         * value, else `false`.
         *
         * If an object is provided for `predicate` the created `_.matches` style
         * callback returns `true` for elements that have the properties of the given
         * object, else `false`.
         *
         * @static
         * @memberOf _
         * @category Array
         * @param {Array} array The array to query.
         * @param {Function|Object|string} [predicate=_.identity] The function invoked
         *  per iteration.
         * @param {*} [thisArg] The `this` binding of `predicate`.
         * @returns {Array} Returns the slice of `array`.
         * @example
         *
         * _.dropWhile([1, 2, 3], function(n) {
         *   return n < 3;
         * });
         * // => [3]
         *
         * var users = [
         *   { 'user': 'barney',  'active': false },
         *   { 'user': 'fred',    'active': false },
         *   { 'user': 'pebbles', 'active': true }
         * ];
         *
         * // using the `_.matches` callback shorthand
         * _.pluck(_.dropWhile(users, { 'user': 'barney', 'active': false }), 'user');
         * // => ['fred', 'pebbles']
         *
         * // using the `_.matchesProperty` callback shorthand
         * _.pluck(_.dropWhile(users, 'active', false), 'user');
         * // => ['pebbles']
         *
         * // using the `_.property` callback shorthand
         * _.pluck(_.dropWhile(users, 'active'), 'user');
         * // => ['barney', 'fred', 'pebbles']
         */
        function dropWhile(array, predicate, thisArg) {
          return (array && array.length)
            ? baseWhile(array, getCallback(predicate, thisArg, 3), true)
            : [];
        }
    
        /**
         * Fills elements of `array` with `value` from `start` up to, but not
         * including, `end`.
         *
         * **Note:** This method mutates `array`.
         *
         * @static
         * @memberOf _
         * @category Array
         * @param {Array} array The array to fill.
         * @param {*} value The value to fill `array` with.
         * @param {number} [start=0] The start position.
         * @param {number} [end=array.length] The end position.
         * @returns {Array} Returns `array`.
         * @example
         *
         * var array = [1, 2, 3];
         *
         * _.fill(array, 'a');
         * console.log(array);
         * // => ['a', 'a', 'a']
         *
         * _.fill(Array(3), 2);
         * // => [2, 2, 2]
         *
         * _.fill([4, 6, 8], '*', 1, 2);
         * // => [4, '*', 8]
         */
        function fill(array, value, start, end) {
          var length = array ? array.length : 0;
          if (!length) {
            return [];
          }
          if (start && typeof start != 'number' && isIterateeCall(array, value, start)) {
            start = 0;
            end = length;
          }
          return baseFill(array, value, start, end);
        }
    
        /**
         * This method is like `_.find` except that it returns the index of the first
         * element `predicate` returns truthy for instead of the element itself.
         *
         * If a property name is provided for `predicate` the created `_.property`
         * style callback returns the property value of the given element.
         *
         * If a value is also provided for `thisArg` the created `_.matchesProperty`
         * style callback returns `true` for elements that have a matching property
         * value, else `false`.
         *
         * If an object is provided for `predicate` the created `_.matches` style
         * callback returns `true` for elements that have the properties of the given
         * object, else `false`.
         *
         * @static
         * @memberOf _
         * @category Array
         * @param {Array} array The array to search.
         * @param {Function|Object|string} [predicate=_.identity] The function invoked
         *  per iteration.
         * @param {*} [thisArg] The `this` binding of `predicate`.
         * @returns {number} Returns the index of the found element, else `-1`.
         * @example
         *
         * var users = [
         *   { 'user': 'barney',  'active': false },
         *   { 'user': 'fred',    'active': false },
         *   { 'user': 'pebbles', 'active': true }
         * ];
         *
         * _.findIndex(users, function(chr) {
         *   return chr.user == 'barney';
         * });
         * // => 0
         *
         * // using the `_.matches` callback shorthand
         * _.findIndex(users, { 'user': 'fred', 'active': false });
         * // => 1
         *
         * // using the `_.matchesProperty` callback shorthand
         * _.findIndex(users, 'active', false);
         * // => 0
         *
         * // using the `_.property` callback shorthand
         * _.findIndex(users, 'active');
         * // => 2
         */
        var findIndex = createFindIndex();
    
        /**
         * This method is like `_.findIndex` except that it iterates over elements
         * of `collection` from right to left.
         *
         * If a property name is provided for `predicate` the created `_.property`
         * style callback returns the property value of the given element.
         *
         * If a value is also provided for `thisArg` the created `_.matchesProperty`
         * style callback returns `true` for elements that have a matching property
         * value, else `false`.
         *
         * If an object is provided for `predicate` the created `_.matches` style
         * callback returns `true` for elements that have the properties of the given
         * object, else `false`.
         *
         * @static
         * @memberOf _
         * @category Array
         * @param {Array} array The array to search.
         * @param {Function|Object|string} [predicate=_.identity] The function invoked
         *  per iteration.
         * @param {*} [thisArg] The `this` binding of `predicate`.
         * @returns {number} Returns the index of the found element, else `-1`.
         * @example
         *
         * var users = [
         *   { 'user': 'barney',  'active': true },
         *   { 'user': 'fred',    'active': false },
         *   { 'user': 'pebbles', 'active': false }
         * ];
         *
         * _.findLastIndex(users, function(chr) {
         *   return chr.user == 'pebbles';
         * });
         * // => 2
         *
         * // using the `_.matches` callback shorthand
         * _.findLastIndex(users, { 'user': 'barney', 'active': true });
         * // => 0
         *
         * // using the `_.matchesProperty` callback shorthand
         * _.findLastIndex(users, 'active', false);
         * // => 2
         *
         * // using the `_.property` callback shorthand
         * _.findLastIndex(users, 'active');
         * // => 0
         */
        var findLastIndex = createFindIndex(true);
    
        /**
         * Gets the first element of `array`.
         *
         * @static
         * @memberOf _
         * @alias head
         * @category Array
         * @param {Array} array The array to query.
         * @returns {*} Returns the first element of `array`.
         * @example
         *
         * _.first([1, 2, 3]);
         * // => 1
         *
         * _.first([]);
         * // => undefined
         */
        function first(array) {
          return array ? array[0] : undefined;
        }
    
        /**
         * Flattens a nested array. If `isDeep` is `true` the array is recursively
         * flattened, otherwise it is only flattened a single level.
         *
         * @static
         * @memberOf _
         * @category Array
         * @param {Array} array The array to flatten.
         * @param {boolean} [isDeep] Specify a deep flatten.
         * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
         * @returns {Array} Returns the new flattened array.
         * @example
         *
         * _.flatten([1, [2, 3, [4]]]);
         * // => [1, 2, 3, [4]]
         *
         * // using `isDeep`
         * _.flatten([1, [2, 3, [4]]], true);
         * // => [1, 2, 3, 4]
         */
        function flatten(array, isDeep, guard) {
          var length = array ? array.length : 0;
          if (guard && isIterateeCall(array, isDeep, guard)) {
            isDeep = false;
          }
          return length ? baseFlatten(array, isDeep) : [];
        }
    
        /**
         * Recursively flattens a nested array.
         *
         * @static
         * @memberOf _
         * @category Array
         * @param {Array} array The array to recursively flatten.
         * @returns {Array} Returns the new flattened array.
         * @example
         *
         * _.flattenDeep([1, [2, 3, [4]]]);
         * // => [1, 2, 3, 4]
         */
        function flattenDeep(array) {
          var length = array ? array.length : 0;
          return length ? baseFlatten(array, true) : [];
        }
    
        /**
         * Gets the index at which the first occurrence of `value` is found in `array`
         * using [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
         * for equality comparisons. If `fromIndex` is negative, it is used as the offset
         * from the end of `array`. If `array` is sorted providing `true` for `fromIndex`
         * performs a faster binary search.
         *
         * @static
         * @memberOf _
         * @category Array
         * @param {Array} array The array to search.
         * @param {*} value The value to search for.
         * @param {boolean|number} [fromIndex=0] The index to search from or `true`
         *  to perform a binary search on a sorted array.
         * @returns {number} Returns the index of the matched value, else `-1`.
         * @example
         *
         * _.indexOf([1, 2, 1, 2], 2);
         * // => 1
         *
         * // using `fromIndex`
         * _.indexOf([1, 2, 1, 2], 2, 2);
         * // => 3
         *
         * // performing a binary search
         * _.indexOf([1, 1, 2, 2], 2, true);
         * // => 2
         */
        function indexOf(array, value, fromIndex) {
          var length = array ? array.length : 0;
          if (!length) {
            return -1;
          }
          if (typeof fromIndex == 'number') {
            fromIndex = fromIndex < 0 ? nativeMax(length + fromIndex, 0) : fromIndex;
          } else if (fromIndex) {
            var index = binaryIndex(array, value);
            if (index < length &&
                (value === value ? (value === array[index]) : (array[index] !== array[index]))) {
              return index;
            }
            return -1;
          }
          return baseIndexOf(array, value, fromIndex || 0);
        }
    
        /**
         * Gets all but the last element of `array`.
         *
         * @static
         * @memberOf _
         * @category Array
         * @param {Array} array The array to query.
         * @returns {Array} Returns the slice of `array`.
         * @example
         *
         * _.initial([1, 2, 3]);
         * // => [1, 2]
         */
        function initial(array) {
          return dropRight(array, 1);
        }
    
        /**
         * Creates an array of unique values that are included in all of the provided
         * arrays using [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
         * for equality comparisons.
         *
         * @static
         * @memberOf _
         * @category Array
         * @param {...Array} [arrays] The arrays to inspect.
         * @returns {Array} Returns the new array of shared values.
         * @example
         * _.intersection([1, 2], [4, 2], [2, 1]);
         * // => [2]
         */
        var intersection = restParam(function(arrays) {
          var othLength = arrays.length,
              othIndex = othLength,
              caches = Array(length),
              indexOf = getIndexOf(),
              isCommon = indexOf == baseIndexOf,
              result = [];
    
          while (othIndex--) {
            var value = arrays[othIndex] = isArrayLike(value = arrays[othIndex]) ? value : [];
            caches[othIndex] = (isCommon && value.length >= 120) ? createCache(othIndex && value) : null;
          }
          var array = arrays[0],
              index = -1,
              length = array ? array.length : 0,
              seen = caches[0];
    
          outer:
          while (++index < length) {
            value = array[index];
            if ((seen ? cacheIndexOf(seen, value) : indexOf(result, value, 0)) < 0) {
              var othIndex = othLength;
              while (--othIndex) {
                var cache = caches[othIndex];
                if ((cache ? cacheIndexOf(cache, value) : indexOf(arrays[othIndex], value, 0)) < 0) {
                  continue outer;
                }
              }
              if (seen) {
                seen.push(value);
              }
              result.push(value);
            }
          }
          return result;
        });
    
        /**
         * Gets the last element of `array`.
         *
         * @static
         * @memberOf _
         * @category Array
         * @param {Array} array The array to query.
         * @returns {*} Returns the last element of `array`.
         * @example
         *
         * _.last([1, 2, 3]);
         * // => 3
         */
        function last(array) {
          var length = array ? array.length : 0;
          return length ? array[length - 1] : undefined;
        }
    
        /**
         * This method is like `_.indexOf` except that it iterates over elements of
         * `array` from right to left.
         *
         * @static
         * @memberOf _
         * @category Array
         * @param {Array} array The array to search.
         * @param {*} value The value to search for.
         * @param {boolean|number} [fromIndex=array.length-1] The index to search from
         *  or `true` to perform a binary search on a sorted array.
         * @returns {number} Returns the index of the matched value, else `-1`.
         * @example
         *
         * _.lastIndexOf([1, 2, 1, 2], 2);
         * // => 3
         *
         * // using `fromIndex`
         * _.lastIndexOf([1, 2, 1, 2], 2, 2);
         * // => 1
         *
         * // performing a binary search
         * _.lastIndexOf([1, 1, 2, 2], 2, true);
         * // => 3
         */
        function lastIndexOf(array, value, fromIndex) {
          var length = array ? array.length : 0;
          if (!length) {
            return -1;
          }
          var index = length;
          if (typeof fromIndex == 'number') {
            index = (fromIndex < 0 ? nativeMax(length + fromIndex, 0) : nativeMin(fromIndex || 0, length - 1)) + 1;
          } else if (fromIndex) {
            index = binaryIndex(array, value, true) - 1;
            var other = array[index];
            if (value === value ? (value === other) : (other !== other)) {
              return index;
            }
            return -1;
          }
          if (value !== value) {
            return indexOfNaN(array, index, true);
          }
          while (index--) {
            if (array[index] === value) {
              return index;
            }
          }
          return -1;
        }
    
        /**
         * Removes all provided values from `array` using
         * [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
         * for equality comparisons.
         *
         * **Note:** Unlike `_.without`, this method mutates `array`.
         *
         * @static
         * @memberOf _
         * @category Array
         * @param {Array} array The array to modify.
         * @param {...*} [values] The values to remove.
         * @returns {Array} Returns `array`.
         * @example
         *
         * var array = [1, 2, 3, 1, 2, 3];
         *
         * _.pull(array, 2, 3);
         * console.log(array);
         * // => [1, 1]
         */
        function pull() {
          var args = arguments,
              array = args[0];
    
          if (!(array && array.length)) {
            return array;
          }
          var index = 0,
              indexOf = getIndexOf(),
              length = args.length;
    
          while (++index < length) {
            var fromIndex = 0,
                value = args[index];
    
            while ((fromIndex = indexOf(array, value, fromIndex)) > -1) {
              splice.call(array, fromIndex, 1);
            }
          }
          return array;
        }
    
        /**
         * Removes elements from `array` corresponding to the given indexes and returns
         * an array of the removed elements. Indexes may be specified as an array of
         * indexes or as individual arguments.
         *
         * **Note:** Unlike `_.at`, this method mutates `array`.
         *
         * @static
         * @memberOf _
         * @category Array
         * @param {Array} array The array to modify.
         * @param {...(number|number[])} [indexes] The indexes of elements to remove,
         *  specified as individual indexes or arrays of indexes.
         * @returns {Array} Returns the new array of removed elements.
         * @example
         *
         * var array = [5, 10, 15, 20];
         * var evens = _.pullAt(array, 1, 3);
         *
         * console.log(array);
         * // => [5, 15]
         *
         * console.log(evens);
         * // => [10, 20]
         */
        var pullAt = restParam(function(array, indexes) {
          indexes = baseFlatten(indexes);
    
          var result = baseAt(array, indexes);
          basePullAt(array, indexes.sort(baseCompareAscending));
          return result;
        });
    
        /**
         * Removes all elements from `array` that `predicate` returns truthy for
         * and returns an array of the removed elements. The predicate is bound to
         * `thisArg` and invoked with three arguments: (value, index, array).
         *
         * If a property name is provided for `predicate` the created `_.property`
         * style callback returns the property value of the given element.
         *
         * If a value is also provided for `thisArg` the created `_.matchesProperty`
         * style callback returns `true` for elements that have a matching property
         * value, else `false`.
         *
         * If an object is provided for `predicate` the created `_.matches` style
         * callback returns `true` for elements that have the properties of the given
         * object, else `false`.
         *
         * **Note:** Unlike `_.filter`, this method mutates `array`.
         *
         * @static
         * @memberOf _
         * @category Array
         * @param {Array} array The array to modify.
         * @param {Function|Object|string} [predicate=_.identity] The function invoked
         *  per iteration.
         * @param {*} [thisArg] The `this` binding of `predicate`.
         * @returns {Array} Returns the new array of removed elements.
         * @example
         *
         * var array = [1, 2, 3, 4];
         * var evens = _.remove(array, function(n) {
         *   return n % 2 == 0;
         * });
         *
         * console.log(array);
         * // => [1, 3]
         *
         * console.log(evens);
         * // => [2, 4]
         */
        function remove(array, predicate, thisArg) {
          var result = [];
          if (!(array && array.length)) {
            return result;
          }
          var index = -1,
              indexes = [],
              length = array.length;
    
          predicate = getCallback(predicate, thisArg, 3);
          while (++index < length) {
            var value = array[index];
            if (predicate(value, index, array)) {
              result.push(value);
              indexes.push(index);
            }
          }
          basePullAt(array, indexes);
          return result;
        }
    
        /**
         * Gets all but the first element of `array`.
         *
         * @static
         * @memberOf _
         * @alias tail
         * @category Array
         * @param {Array} array The array to query.
         * @returns {Array} Returns the slice of `array`.
         * @example
         *
         * _.rest([1, 2, 3]);
         * // => [2, 3]
         */
        function rest(array) {
          return drop(array, 1);
        }
    
        /**
         * Creates a slice of `array` from `start` up to, but not including, `end`.
         *
         * **Note:** This method is used instead of `Array#slice` to support node
         * lists in IE < 9 and to ensure dense arrays are returned.
         *
         * @static
         * @memberOf _
         * @category Array
         * @param {Array} array The array to slice.
         * @param {number} [start=0] The start position.
         * @param {number} [end=array.length] The end position.
         * @returns {Array} Returns the slice of `array`.
         */
        function slice(array, start, end) {
          var length = array ? array.length : 0;
          if (!length) {
            return [];
          }
          if (end && typeof end != 'number' && isIterateeCall(array, start, end)) {
            start = 0;
            end = length;
          }
          return baseSlice(array, start, end);
        }
    
        /**
         * Uses a binary search to determine the lowest index at which `value` should
         * be inserted into `array` in order to maintain its sort order. If an iteratee
         * function is provided it is invoked for `value` and each element of `array`
         * to compute their sort ranking. The iteratee is bound to `thisArg` and
         * invoked with one argument; (value).
         *
         * If a property name is provided for `iteratee` the created `_.property`
         * style callback returns the property value of the given element.
         *
         * If a value is also provided for `thisArg` the created `_.matchesProperty`
         * style callback returns `true` for elements that have a matching property
         * value, else `false`.
         *
         * If an object is provided for `iteratee` the created `_.matches` style
         * callback returns `true` for elements that have the properties of the given
         * object, else `false`.
         *
         * @static
         * @memberOf _
         * @category Array
         * @param {Array} array The sorted array to inspect.
         * @param {*} value The value to evaluate.
         * @param {Function|Object|string} [iteratee=_.identity] The function invoked
         *  per iteration.
         * @param {*} [thisArg] The `this` binding of `iteratee`.
         * @returns {number} Returns the index at which `value` should be inserted
         *  into `array`.
         * @example
         *
         * _.sortedIndex([30, 50], 40);
         * // => 1
         *
         * _.sortedIndex([4, 4, 5, 5], 5);
         * // => 2
         *
         * var dict = { 'data': { 'thirty': 30, 'forty': 40, 'fifty': 50 } };
         *
         * // using an iteratee function
         * _.sortedIndex(['thirty', 'fifty'], 'forty', function(word) {
         *   return this.data[word];
         * }, dict);
         * // => 1
         *
         * // using the `_.property` callback shorthand
         * _.sortedIndex([{ 'x': 30 }, { 'x': 50 }], { 'x': 40 }, 'x');
         * // => 1
         */
        var sortedIndex = createSortedIndex();
    
        /**
         * This method is like `_.sortedIndex` except that it returns the highest
         * index at which `value` should be inserted into `array` in order to
         * maintain its sort order.
         *
         * @static
         * @memberOf _
         * @category Array
         * @param {Array} array The sorted array to inspect.
         * @param {*} value The value to evaluate.
         * @param {Function|Object|string} [iteratee=_.identity] The function invoked
         *  per iteration.
         * @param {*} [thisArg] The `this` binding of `iteratee`.
         * @returns {number} Returns the index at which `value` should be inserted
         *  into `array`.
         * @example
         *
         * _.sortedLastIndex([4, 4, 5, 5], 5);
         * // => 4
         */
        var sortedLastIndex = createSortedIndex(true);
    
        /**
         * Creates a slice of `array` with `n` elements taken from the beginning.
         *
         * @static
         * @memberOf _
         * @category Array
         * @param {Array} array The array to query.
         * @param {number} [n=1] The number of elements to take.
         * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
         * @returns {Array} Returns the slice of `array`.
         * @example
         *
         * _.take([1, 2, 3]);
         * // => [1]
         *
         * _.take([1, 2, 3], 2);
         * // => [1, 2]
         *
         * _.take([1, 2, 3], 5);
         * // => [1, 2, 3]
         *
         * _.take([1, 2, 3], 0);
         * // => []
         */
        function take(array, n, guard) {
          var length = array ? array.length : 0;
          if (!length) {
            return [];
          }
          if (guard ? isIterateeCall(array, n, guard) : n == null) {
            n = 1;
          }
          return baseSlice(array, 0, n < 0 ? 0 : n);
        }
    
        /**
         * Creates a slice of `array` with `n` elements taken from the end.
         *
         * @static
         * @memberOf _
         * @category Array
         * @param {Array} array The array to query.
         * @param {number} [n=1] The number of elements to take.
         * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
         * @returns {Array} Returns the slice of `array`.
         * @example
         *
         * _.takeRight([1, 2, 3]);
         * // => [3]
         *
         * _.takeRight([1, 2, 3], 2);
         * // => [2, 3]
         *
         * _.takeRight([1, 2, 3], 5);
         * // => [1, 2, 3]
         *
         * _.takeRight([1, 2, 3], 0);
         * // => []
         */
        function takeRight(array, n, guard) {
          var length = array ? array.length : 0;
          if (!length) {
            return [];
          }
          if (guard ? isIterateeCall(array, n, guard) : n == null) {
            n = 1;
          }
          n = length - (+n || 0);
          return baseSlice(array, n < 0 ? 0 : n);
        }
    
        /**
         * Creates a slice of `array` with elements taken from the end. Elements are
         * taken until `predicate` returns falsey. The predicate is bound to `thisArg`
         * and invoked with three arguments: (value, index, array).
         *
         * If a property name is provided for `predicate` the created `_.property`
         * style callback returns the property value of the given element.
         *
         * If a value is also provided for `thisArg` the created `_.matchesProperty`
         * style callback returns `true` for elements that have a matching property
         * value, else `false`.
         *
         * If an object is provided for `predicate` the created `_.matches` style
         * callback returns `true` for elements that have the properties of the given
         * object, else `false`.
         *
         * @static
         * @memberOf _
         * @category Array
         * @param {Array} array The array to query.
         * @param {Function|Object|string} [predicate=_.identity] The function invoked
         *  per iteration.
         * @param {*} [thisArg] The `this` binding of `predicate`.
         * @returns {Array} Returns the slice of `array`.
         * @example
         *
         * _.takeRightWhile([1, 2, 3], function(n) {
         *   return n > 1;
         * });
         * // => [2, 3]
         *
         * var users = [
         *   { 'user': 'barney',  'active': true },
         *   { 'user': 'fred',    'active': false },
         *   { 'user': 'pebbles', 'active': false }
         * ];
         *
         * // using the `_.matches` callback shorthand
         * _.pluck(_.takeRightWhile(users, { 'user': 'pebbles', 'active': false }), 'user');
         * // => ['pebbles']
         *
         * // using the `_.matchesProperty` callback shorthand
         * _.pluck(_.takeRightWhile(users, 'active', false), 'user');
         * // => ['fred', 'pebbles']
         *
         * // using the `_.property` callback shorthand
         * _.pluck(_.takeRightWhile(users, 'active'), 'user');
         * // => []
         */
        function takeRightWhile(array, predicate, thisArg) {
          return (array && array.length)
            ? baseWhile(array, getCallback(predicate, thisArg, 3), false, true)
            : [];
        }
    
        /**
         * Creates a slice of `array` with elements taken from the beginning. Elements
         * are taken until `predicate` returns falsey. The predicate is bound to
         * `thisArg` and invoked with three arguments: (value, index, array).
         *
         * If a property name is provided for `predicate` the created `_.property`
         * style callback returns the property value of the given element.
         *
         * If a value is also provided for `thisArg` the created `_.matchesProperty`
         * style callback returns `true` for elements that have a matching property
         * value, else `false`.
         *
         * If an object is provided for `predicate` the created `_.matches` style
         * callback returns `true` for elements that have the properties of the given
         * object, else `false`.
         *
         * @static
         * @memberOf _
         * @category Array
         * @param {Array} array The array to query.
         * @param {Function|Object|string} [predicate=_.identity] The function invoked
         *  per iteration.
         * @param {*} [thisArg] The `this` binding of `predicate`.
         * @returns {Array} Returns the slice of `array`.
         * @example
         *
         * _.takeWhile([1, 2, 3], function(n) {
         *   return n < 3;
         * });
         * // => [1, 2]
         *
         * var users = [
         *   { 'user': 'barney',  'active': false },
         *   { 'user': 'fred',    'active': false},
         *   { 'user': 'pebbles', 'active': true }
         * ];
         *
         * // using the `_.matches` callback shorthand
         * _.pluck(_.takeWhile(users, { 'user': 'barney', 'active': false }), 'user');
         * // => ['barney']
         *
         * // using the `_.matchesProperty` callback shorthand
         * _.pluck(_.takeWhile(users, 'active', false), 'user');
         * // => ['barney', 'fred']
         *
         * // using the `_.property` callback shorthand
         * _.pluck(_.takeWhile(users, 'active'), 'user');
         * // => []
         */
        function takeWhile(array, predicate, thisArg) {
          return (array && array.length)
            ? baseWhile(array, getCallback(predicate, thisArg, 3))
            : [];
        }
    
        /**
         * Creates an array of unique values, in order, from all of the provided arrays
         * using [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
         * for equality comparisons.
         *
         * @static
         * @memberOf _
         * @category Array
         * @param {...Array} [arrays] The arrays to inspect.
         * @returns {Array} Returns the new array of combined values.
         * @example
         *
         * _.union([1, 2], [4, 2], [2, 1]);
         * // => [1, 2, 4]
         */
        var union = restParam(function(arrays) {
          return baseUniq(baseFlatten(arrays, false, true));
        });
    
        /**
         * Creates a duplicate-free version of an array, using
         * [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
         * for equality comparisons, in which only the first occurence of each element
         * is kept. Providing `true` for `isSorted` performs a faster search algorithm
         * for sorted arrays. If an iteratee function is provided it is invoked for
         * each element in the array to generate the criterion by which uniqueness
         * is computed. The `iteratee` is bound to `thisArg` and invoked with three
         * arguments: (value, index, array).
         *
         * If a property name is provided for `iteratee` the created `_.property`
         * style callback returns the property value of the given element.
         *
         * If a value is also provided for `thisArg` the created `_.matchesProperty`
         * style callback returns `true` for elements that have a matching property
         * value, else `false`.
         *
         * If an object is provided for `iteratee` the created `_.matches` style
         * callback returns `true` for elements that have the properties of the given
         * object, else `false`.
         *
         * @static
         * @memberOf _
         * @alias unique
         * @category Array
         * @param {Array} array The array to inspect.
         * @param {boolean} [isSorted] Specify the array is sorted.
         * @param {Function|Object|string} [iteratee] The function invoked per iteration.
         * @param {*} [thisArg] The `this` binding of `iteratee`.
         * @returns {Array} Returns the new duplicate-value-free array.
         * @example
         *
         * _.uniq([2, 1, 2]);
         * // => [2, 1]
         *
         * // using `isSorted`
         * _.uniq([1, 1, 2], true);
         * // => [1, 2]
         *
         * // using an iteratee function
         * _.uniq([1, 2.5, 1.5, 2], function(n) {
         *   return this.floor(n);
         * }, Math);
         * // => [1, 2.5]
         *
         * // using the `_.property` callback shorthand
         * _.uniq([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');
         * // => [{ 'x': 1 }, { 'x': 2 }]
         */
        function uniq(array, isSorted, iteratee, thisArg) {
          var length = array ? array.length : 0;
          if (!length) {
            return [];
          }
          if (isSorted != null && typeof isSorted != 'boolean') {
            thisArg = iteratee;
            iteratee = isIterateeCall(array, isSorted, thisArg) ? undefined : isSorted;
            isSorted = false;
          }
          var callback = getCallback();
          if (!(iteratee == null && callback === baseCallback)) {
            iteratee = callback(iteratee, thisArg, 3);
          }
          return (isSorted && getIndexOf() == baseIndexOf)
            ? sortedUniq(array, iteratee)
            : baseUniq(array, iteratee);
        }
    
        /**
         * This method is like `_.zip` except that it accepts an array of grouped
         * elements and creates an array regrouping the elements to their pre-zip
         * configuration.
         *
         * @static
         * @memberOf _
         * @category Array
         * @param {Array} array The array of grouped elements to process.
         * @returns {Array} Returns the new array of regrouped elements.
         * @example
         *
         * var zipped = _.zip(['fred', 'barney'], [30, 40], [true, false]);
         * // => [['fred', 30, true], ['barney', 40, false]]
         *
         * _.unzip(zipped);
         * // => [['fred', 'barney'], [30, 40], [true, false]]
         */
        function unzip(array) {
          if (!(array && array.length)) {
            return [];
          }
          var index = -1,
              length = 0;
    
          array = arrayFilter(array, function(group) {
            if (isArrayLike(group)) {
              length = nativeMax(group.length, length);
              return true;
            }
          });
          var result = Array(length);
          while (++index < length) {
            result[index] = arrayMap(array, baseProperty(index));
          }
          return result;
        }
    
        /**
         * This method is like `_.unzip` except that it accepts an iteratee to specify
         * how regrouped values should be combined. The `iteratee` is bound to `thisArg`
         * and invoked with four arguments: (accumulator, value, index, group).
         *
         * @static
         * @memberOf _
         * @category Array
         * @param {Array} array The array of grouped elements to process.
         * @param {Function} [iteratee] The function to combine regrouped values.
         * @param {*} [thisArg] The `this` binding of `iteratee`.
         * @returns {Array} Returns the new array of regrouped elements.
         * @example
         *
         * var zipped = _.zip([1, 2], [10, 20], [100, 200]);
         * // => [[1, 10, 100], [2, 20, 200]]
         *
         * _.unzipWith(zipped, _.add);
         * // => [3, 30, 300]
         */
        function unzipWith(array, iteratee, thisArg) {
          var length = array ? array.length : 0;
          if (!length) {
            return [];
          }
          var result = unzip(array);
          if (iteratee == null) {
            return result;
          }
          iteratee = bindCallback(iteratee, thisArg, 4);
          return arrayMap(result, function(group) {
            return arrayReduce(group, iteratee, undefined, true);
          });
        }
    
        /**
         * Creates an array excluding all provided values using
         * [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
         * for equality comparisons.
         *
         * @static
         * @memberOf _
         * @category Array
         * @param {Array} array The array to filter.
         * @param {...*} [values] The values to exclude.
         * @returns {Array} Returns the new array of filtered values.
         * @example
         *
         * _.without([1, 2, 1, 3], 1, 2);
         * // => [3]
         */
        var without = restParam(function(array, values) {
          return isArrayLike(array)
            ? baseDifference(array, values)
            : [];
        });
    
        /**
         * Creates an array of unique values that is the [symmetric difference](https://en.wikipedia.org/wiki/Symmetric_difference)
         * of the provided arrays.
         *
         * @static
         * @memberOf _
         * @category Array
         * @param {...Array} [arrays] The arrays to inspect.
         * @returns {Array} Returns the new array of values.
         * @example
         *
         * _.xor([1, 2], [4, 2]);
         * // => [1, 4]
         */
        function xor() {
          var index = -1,
              length = arguments.length;
    
          while (++index < length) {
            var array = arguments[index];
            if (isArrayLike(array)) {
              var result = result
                ? arrayPush(baseDifference(result, array), baseDifference(array, result))
                : array;
            }
          }
          return result ? baseUniq(result) : [];
        }
    
        /**
         * Creates an array of grouped elements, the first of which contains the first
         * elements of the given arrays, the second of which contains the second elements
         * of the given arrays, and so on.
         *
         * @static
         * @memberOf _
         * @category Array
         * @param {...Array} [arrays] The arrays to process.
         * @returns {Array} Returns the new array of grouped elements.
         * @example
         *
         * _.zip(['fred', 'barney'], [30, 40], [true, false]);
         * // => [['fred', 30, true], ['barney', 40, false]]
         */
        var zip = restParam(unzip);
    
        /**
         * The inverse of `_.pairs`; this method returns an object composed from arrays
         * of property names and values. Provide either a single two dimensional array,
         * e.g. `[[key1, value1], [key2, value2]]` or two arrays, one of property names
         * and one of corresponding values.
         *
         * @static
         * @memberOf _
         * @alias object
         * @category Array
         * @param {Array} props The property names.
         * @param {Array} [values=[]] The property values.
         * @returns {Object} Returns the new object.
         * @example
         *
         * _.zipObject([['fred', 30], ['barney', 40]]);
         * // => { 'fred': 30, 'barney': 40 }
         *
         * _.zipObject(['fred', 'barney'], [30, 40]);
         * // => { 'fred': 30, 'barney': 40 }
         */
        function zipObject(props, values) {
          var index = -1,
              length = props ? props.length : 0,
              result = {};
    
          if (length && !values && !isArray(props[0])) {
            values = [];
          }
          while (++index < length) {
            var key = props[index];
            if (values) {
              result[key] = values[index];
            } else if (key) {
              result[key[0]] = key[1];
            }
          }
          return result;
        }
    
        /**
         * This method is like `_.zip` except that it accepts an iteratee to specify
         * how grouped values should be combined. The `iteratee` is bound to `thisArg`
         * and invoked with four arguments: (accumulator, value, index, group).
         *
         * @static
         * @memberOf _
         * @category Array
         * @param {...Array} [arrays] The arrays to process.
         * @param {Function} [iteratee] The function to combine grouped values.
         * @param {*} [thisArg] The `this` binding of `iteratee`.
         * @returns {Array} Returns the new array of grouped elements.
         * @example
         *
         * _.zipWith([1, 2], [10, 20], [100, 200], _.add);
         * // => [111, 222]
         */
        var zipWith = restParam(function(arrays) {
          var length = arrays.length,
              iteratee = length > 2 ? arrays[length - 2] : undefined,
              thisArg = length > 1 ? arrays[length - 1] : undefined;
    
          if (length > 2 && typeof iteratee == 'function') {
            length -= 2;
          } else {
            iteratee = (length > 1 && typeof thisArg == 'function') ? (--length, thisArg) : undefined;
            thisArg = undefined;
          }
          arrays.length = length;
          return unzipWith(arrays, iteratee, thisArg);
        });
    
        /*------------------------------------------------------------------------*/
    
        /**
         * Creates a `lodash` object that wraps `value` with explicit method
         * chaining enabled.
         *
         * @static
         * @memberOf _
         * @category Chain
         * @param {*} value The value to wrap.
         * @returns {Object} Returns the new `lodash` wrapper instance.
         * @example
         *
         * var users = [
         *   { 'user': 'barney',  'age': 36 },
         *   { 'user': 'fred',    'age': 40 },
         *   { 'user': 'pebbles', 'age': 1 }
         * ];
         *
         * var youngest = _.chain(users)
         *   .sortBy('age')
         *   .map(function(chr) {
         *     return chr.user + ' is ' + chr.age;
         *   })
         *   .first()
         *   .value();
         * // => 'pebbles is 1'
         */
        function chain(value) {
          var result = lodash(value);
          result.__chain__ = true;
          return result;
        }
    
        /**
         * This method invokes `interceptor` and returns `value`. The interceptor is
         * bound to `thisArg` and invoked with one argument; (value). The purpose of
         * this method is to "tap into" a method chain in order to perform operations
         * on intermediate results within the chain.
         *
         * @static
         * @memberOf _
         * @category Chain
         * @param {*} value The value to provide to `interceptor`.
         * @param {Function} interceptor The function to invoke.
         * @param {*} [thisArg] The `this` binding of `interceptor`.
         * @returns {*} Returns `value`.
         * @example
         *
         * _([1, 2, 3])
         *  .tap(function(array) {
         *    array.pop();
         *  })
         *  .reverse()
         *  .value();
         * // => [2, 1]
         */
        function tap(value, interceptor, thisArg) {
          interceptor.call(thisArg, value);
          return value;
        }
    
        /**
         * This method is like `_.tap` except that it returns the result of `interceptor`.
         *
         * @static
         * @memberOf _
         * @category Chain
         * @param {*} value The value to provide to `interceptor`.
         * @param {Function} interceptor The function to invoke.
         * @param {*} [thisArg] The `this` binding of `interceptor`.
         * @returns {*} Returns the result of `interceptor`.
         * @example
         *
         * _('  abc  ')
         *  .chain()
         *  .trim()
         *  .thru(function(value) {
         *    return [value];
         *  })
         *  .value();
         * // => ['abc']
         */
        function thru(value, interceptor, thisArg) {
          return interceptor.call(thisArg, value);
        }
    
        /**
         * Enables explicit method chaining on the wrapper object.
         *
         * @name chain
         * @memberOf _
         * @category Chain
         * @returns {Object} Returns the new `lodash` wrapper instance.
         * @example
         *
         * var users = [
         *   { 'user': 'barney', 'age': 36 },
         *   { 'user': 'fred',   'age': 40 }
         * ];
         *
         * // without explicit chaining
         * _(users).first();
         * // => { 'user': 'barney', 'age': 36 }
         *
         * // with explicit chaining
         * _(users).chain()
         *   .first()
         *   .pick('user')
         *   .value();
         * // => { 'user': 'barney' }
         */
        function wrapperChain() {
          return chain(this);
        }
    
        /**
         * Executes the chained sequence and returns the wrapped result.
         *
         * @name commit
         * @memberOf _
         * @category Chain
         * @returns {Object} Returns the new `lodash` wrapper instance.
         * @example
         *
         * var array = [1, 2];
         * var wrapped = _(array).push(3);
         *
         * console.log(array);
         * // => [1, 2]
         *
         * wrapped = wrapped.commit();
         * console.log(array);
         * // => [1, 2, 3]
         *
         * wrapped.last();
         * // => 3
         *
         * console.log(array);
         * // => [1, 2, 3]
         */
        function wrapperCommit() {
          return new LodashWrapper(this.value(), this.__chain__);
        }
    
        /**
         * Creates a new array joining a wrapped array with any additional arrays
         * and/or values.
         *
         * @name concat
         * @memberOf _
         * @category Chain
         * @param {...*} [values] The values to concatenate.
         * @returns {Array} Returns the new concatenated array.
         * @example
         *
         * var array = [1];
         * var wrapped = _(array).concat(2, [3], [[4]]);
         *
         * console.log(wrapped.value());
         * // => [1, 2, 3, [4]]
         *
         * console.log(array);
         * // => [1]
         */
        var wrapperConcat = restParam(function(values) {
          values = baseFlatten(values);
          return this.thru(function(array) {
            return arrayConcat(isArray(array) ? array : [toObject(array)], values);
          });
        });
    
        /**
         * Creates a clone of the chained sequence planting `value` as the wrapped value.
         *
         * @name plant
         * @memberOf _
         * @category Chain
         * @returns {Object} Returns the new `lodash` wrapper instance.
         * @example
         *
         * var array = [1, 2];
         * var wrapped = _(array).map(function(value) {
         *   return Math.pow(value, 2);
         * });
         *
         * var other = [3, 4];
         * var otherWrapped = wrapped.plant(other);
         *
         * otherWrapped.value();
         * // => [9, 16]
         *
         * wrapped.value();
         * // => [1, 4]
         */
        function wrapperPlant(value) {
          var result,
              parent = this;
    
          while (parent instanceof baseLodash) {
            var clone = wrapperClone(parent);
            if (result) {
              previous.__wrapped__ = clone;
            } else {
              result = clone;
            }
            var previous = clone;
            parent = parent.__wrapped__;
          }
          previous.__wrapped__ = value;
          return result;
        }
    
        /**
         * Reverses the wrapped array so the first element becomes the last, the
         * second element becomes the second to last, and so on.
         *
         * **Note:** This method mutates the wrapped array.
         *
         * @name reverse
         * @memberOf _
         * @category Chain
         * @returns {Object} Returns the new reversed `lodash` wrapper instance.
         * @example
         *
         * var array = [1, 2, 3];
         *
         * _(array).reverse().value()
         * // => [3, 2, 1]
         *
         * console.log(array);
         * // => [3, 2, 1]
         */
        function wrapperReverse() {
          var value = this.__wrapped__;
    
          var interceptor = function(value) {
            return (wrapped && wrapped.__dir__ < 0) ? value : value.reverse();
          };
          if (value instanceof LazyWrapper) {
            var wrapped = value;
            if (this.__actions__.length) {
              wrapped = new LazyWrapper(this);
            }
            wrapped = wrapped.reverse();
            wrapped.__actions__.push({ 'func': thru, 'args': [interceptor], 'thisArg': undefined });
            return new LodashWrapper(wrapped, this.__chain__);
          }
          return this.thru(interceptor);
        }
    
        /**
         * Produces the result of coercing the unwrapped value to a string.
         *
         * @name toString
         * @memberOf _
         * @category Chain
         * @returns {string} Returns the coerced string value.
         * @example
         *
         * _([1, 2, 3]).toString();
         * // => '1,2,3'
         */
        function wrapperToString() {
          return (this.value() + '');
        }
    
        /**
         * Executes the chained sequence to extract the unwrapped value.
         *
         * @name value
         * @memberOf _
         * @alias run, toJSON, valueOf
         * @category Chain
         * @returns {*} Returns the resolved unwrapped value.
         * @example
         *
         * _([1, 2, 3]).value();
         * // => [1, 2, 3]
         */
        function wrapperValue() {
          return baseWrapperValue(this.__wrapped__, this.__actions__);
        }
    
        /*------------------------------------------------------------------------*/
    
        /**
         * Creates an array of elements corresponding to the given keys, or indexes,
         * of `collection`. Keys may be specified as individual arguments or as arrays
         * of keys.
         *
         * @static
         * @memberOf _
         * @category Collection
         * @param {Array|Object|string} collection The collection to iterate over.
         * @param {...(number|number[]|string|string[])} [props] The property names
         *  or indexes of elements to pick, specified individually or in arrays.
         * @returns {Array} Returns the new array of picked elements.
         * @example
         *
         * _.at(['a', 'b', 'c'], [0, 2]);
         * // => ['a', 'c']
         *
         * _.at(['barney', 'fred', 'pebbles'], 0, 2);
         * // => ['barney', 'pebbles']
         */
        var at = restParam(function(collection, props) {
          return baseAt(collection, baseFlatten(props));
        });
    
        /**
         * Creates an object composed of keys generated from the results of running
         * each element of `collection` through `iteratee`. The corresponding value
         * of each key is the number of times the key was returned by `iteratee`.
         * The `iteratee` is bound to `thisArg` and invoked with three arguments:
         * (value, index|key, collection).
         *
         * If a property name is provided for `iteratee` the created `_.property`
         * style callback returns the property value of the given element.
         *
         * If a value is also provided for `thisArg` the created `_.matchesProperty`
         * style callback returns `true` for elements that have a matching property
         * value, else `false`.
         *
         * If an object is provided for `iteratee` the created `_.matches` style
         * callback returns `true` for elements that have the properties of the given
         * object, else `false`.
         *
         * @static
         * @memberOf _
         * @category Collection
         * @param {Array|Object|string} collection The collection to iterate over.
         * @param {Function|Object|string} [iteratee=_.identity] The function invoked
         *  per iteration.
         * @param {*} [thisArg] The `this` binding of `iteratee`.
         * @returns {Object} Returns the composed aggregate object.
         * @example
         *
         * _.countBy([4.3, 6.1, 6.4], function(n) {
         *   return Math.floor(n);
         * });
         * // => { '4': 1, '6': 2 }
         *
         * _.countBy([4.3, 6.1, 6.4], function(n) {
         *   return this.floor(n);
         * }, Math);
         * // => { '4': 1, '6': 2 }
         *
         * _.countBy(['one', 'two', 'three'], 'length');
         * // => { '3': 2, '5': 1 }
         */
        var countBy = createAggregator(function(result, value, key) {
          hasOwnProperty.call(result, key) ? ++result[key] : (result[key] = 1);
        });
    
        /**
         * Checks if `predicate` returns truthy for **all** elements of `collection`.
         * The predicate is bound to `thisArg` and invoked with three arguments:
         * (value, index|key, collection).
         *
         * If a property name is provided for `predicate` the created `_.property`
         * style callback returns the property value of the given element.
         *
         * If a value is also provided for `thisArg` the created `_.matchesProperty`
         * style callback returns `true` for elements that have a matching property
         * value, else `false`.
         *
         * If an object is provided for `predicate` the created `_.matches` style
         * callback returns `true` for elements that have the properties of the given
         * object, else `false`.
         *
         * @static
         * @memberOf _
         * @alias all
         * @category Collection
         * @param {Array|Object|string} collection The collection to iterate over.
         * @param {Function|Object|string} [predicate=_.identity] The function invoked
         *  per iteration.
         * @param {*} [thisArg] The `this` binding of `predicate`.
         * @returns {boolean} Returns `true` if all elements pass the predicate check,
         *  else `false`.
         * @example
         *
         * _.every([true, 1, null, 'yes'], Boolean);
         * // => false
         *
         * var users = [
         *   { 'user': 'barney', 'active': false },
         *   { 'user': 'fred',   'active': false }
         * ];
         *
         * // using the `_.matches` callback shorthand
         * _.every(users, { 'user': 'barney', 'active': false });
         * // => false
         *
         * // using the `_.matchesProperty` callback shorthand
         * _.every(users, 'active', false);
         * // => true
         *
         * // using the `_.property` callback shorthand
         * _.every(users, 'active');
         * // => false
         */
        function every(collection, predicate, thisArg) {
          var func = isArray(collection) ? arrayEvery : baseEvery;
          if (thisArg && isIterateeCall(collection, predicate, thisArg)) {
            predicate = undefined;
          }
          if (typeof predicate != 'function' || thisArg !== undefined) {
            predicate = getCallback(predicate, thisArg, 3);
          }
          return func(collection, predicate);
        }
    
        /**
         * Iterates over elements of `collection`, returning an array of all elements
         * `predicate` returns truthy for. The predicate is bound to `thisArg` and
         * invoked with three arguments: (value, index|key, collection).
         *
         * If a property name is provided for `predicate` the created `_.property`
         * style callback returns the property value of the given element.
         *
         * If a value is also provided for `thisArg` the created `_.matchesProperty`
         * style callback returns `true` for elements that have a matching property
         * value, else `false`.
         *
         * If an object is provided for `predicate` the created `_.matches` style
         * callback returns `true` for elements that have the properties of the given
         * object, else `false`.
         *
         * @static
         * @memberOf _
         * @alias select
         * @category Collection
         * @param {Array|Object|string} collection The collection to iterate over.
         * @param {Function|Object|string} [predicate=_.identity] The function invoked
         *  per iteration.
         * @param {*} [thisArg] The `this` binding of `predicate`.
         * @returns {Array} Returns the new filtered array.
         * @example
         *
         * _.filter([4, 5, 6], function(n) {
         *   return n % 2 == 0;
         * });
         * // => [4, 6]
         *
         * var users = [
         *   { 'user': 'barney', 'age': 36, 'active': true },
         *   { 'user': 'fred',   'age': 40, 'active': false }
         * ];
         *
         * // using the `_.matches` callback shorthand
         * _.pluck(_.filter(users, { 'age': 36, 'active': true }), 'user');
         * // => ['barney']
         *
         * // using the `_.matchesProperty` callback shorthand
         * _.pluck(_.filter(users, 'active', false), 'user');
         * // => ['fred']
         *
         * // using the `_.property` callback shorthand
         * _.pluck(_.filter(users, 'active'), 'user');
         * // => ['barney']
         */
        function filter(collection, predicate, thisArg) {
          var func = isArray(collection) ? arrayFilter : baseFilter;
          predicate = getCallback(predicate, thisArg, 3);
          return func(collection, predicate);
        }
    
        /**
         * Iterates over elements of `collection`, returning the first element
         * `predicate` returns truthy for. The predicate is bound to `thisArg` and
         * invoked with three arguments: (value, index|key, collection).
         *
         * If a property name is provided for `predicate` the created `_.property`
         * style callback returns the property value of the given element.
         *
         * If a value is also provided for `thisArg` the created `_.matchesProperty`
         * style callback returns `true` for elements that have a matching property
         * value, else `false`.
         *
         * If an object is provided for `predicate` the created `_.matches` style
         * callback returns `true` for elements that have the properties of the given
         * object, else `false`.
         *
         * @static
         * @memberOf _
         * @alias detect
         * @category Collection
         * @param {Array|Object|string} collection The collection to search.
         * @param {Function|Object|string} [predicate=_.identity] The function invoked
         *  per iteration.
         * @param {*} [thisArg] The `this` binding of `predicate`.
         * @returns {*} Returns the matched element, else `undefined`.
         * @example
         *
         * var users = [
         *   { 'user': 'barney',  'age': 36, 'active': true },
         *   { 'user': 'fred',    'age': 40, 'active': false },
         *   { 'user': 'pebbles', 'age': 1,  'active': true }
         * ];
         *
         * _.result(_.find(users, function(chr) {
         *   return chr.age < 40;
         * }), 'user');
         * // => 'barney'
         *
         * // using the `_.matches` callback shorthand
         * _.result(_.find(users, { 'age': 1, 'active': true }), 'user');
         * // => 'pebbles'
         *
         * // using the `_.matchesProperty` callback shorthand
         * _.result(_.find(users, 'active', false), 'user');
         * // => 'fred'
         *
         * // using the `_.property` callback shorthand
         * _.result(_.find(users, 'active'), 'user');
         * // => 'barney'
         */
        var find = createFind(baseEach);
    
        /**
         * This method is like `_.find` except that it iterates over elements of
         * `collection` from right to left.
         *
         * @static
         * @memberOf _
         * @category Collection
         * @param {Array|Object|string} collection The collection to search.
         * @param {Function|Object|string} [predicate=_.identity] The function invoked
         *  per iteration.
         * @param {*} [thisArg] The `this` binding of `predicate`.
         * @returns {*} Returns the matched element, else `undefined`.
         * @example
         *
         * _.findLast([1, 2, 3, 4], function(n) {
         *   return n % 2 == 1;
         * });
         * // => 3
         */
        var findLast = createFind(baseEachRight, true);
    
        /**
         * Performs a deep comparison between each element in `collection` and the
         * source object, returning the first element that has equivalent property
         * values.
         *
         * **Note:** This method supports comparing arrays, booleans, `Date` objects,
         * numbers, `Object` objects, regexes, and strings. Objects are compared by
         * their own, not inherited, enumerable properties. For comparing a single
         * own or inherited property value see `_.matchesProperty`.
         *
         * @static
         * @memberOf _
         * @category Collection
         * @param {Array|Object|string} collection The collection to search.
         * @param {Object} source The object of property values to match.
         * @returns {*} Returns the matched element, else `undefined`.
         * @example
         *
         * var users = [
         *   { 'user': 'barney', 'age': 36, 'active': true },
         *   { 'user': 'fred',   'age': 40, 'active': false }
         * ];
         *
         * _.result(_.findWhere(users, { 'age': 36, 'active': true }), 'user');
         * // => 'barney'
         *
         * _.result(_.findWhere(users, { 'age': 40, 'active': false }), 'user');
         * // => 'fred'
         */
        function findWhere(collection, source) {
          return find(collection, baseMatches(source));
        }
    
        /**
         * Iterates over elements of `collection` invoking `iteratee` for each element.
         * The `iteratee` is bound to `thisArg` and invoked with three arguments:
         * (value, index|key, collection). Iteratee functions may exit iteration early
         * by explicitly returning `false`.
         *
         * **Note:** As with other "Collections" methods, objects with a "length" property
         * are iterated like arrays. To avoid this behavior `_.forIn` or `_.forOwn`
         * may be used for object iteration.
         *
         * @static
         * @memberOf _
         * @alias each
         * @category Collection
         * @param {Array|Object|string} collection The collection to iterate over.
         * @param {Function} [iteratee=_.identity] The function invoked per iteration.
         * @param {*} [thisArg] The `this` binding of `iteratee`.
         * @returns {Array|Object|string} Returns `collection`.
         * @example
         *
         * _([1, 2]).forEach(function(n) {
         *   console.log(n);
         * }).value();
         * // => logs each value from left to right and returns the array
         *
         * _.forEach({ 'a': 1, 'b': 2 }, function(n, key) {
         *   console.log(n, key);
         * });
         * // => logs each value-key pair and returns the object (iteration order is not guaranteed)
         */
        var forEach = createForEach(arrayEach, baseEach);
    
        /**
         * This method is like `_.forEach` except that it iterates over elements of
         * `collection` from right to left.
         *
         * @static
         * @memberOf _
         * @alias eachRight
         * @category Collection
         * @param {Array|Object|string} collection The collection to iterate over.
         * @param {Function} [iteratee=_.identity] The function invoked per iteration.
         * @param {*} [thisArg] The `this` binding of `iteratee`.
         * @returns {Array|Object|string} Returns `collection`.
         * @example
         *
         * _([1, 2]).forEachRight(function(n) {
         *   console.log(n);
         * }).value();
         * // => logs each value from right to left and returns the array
         */
        var forEachRight = createForEach(arrayEachRight, baseEachRight);
    
        /**
         * Creates an object composed of keys generated from the results of running
         * each element of `collection` through `iteratee`. The corresponding value
         * of each key is an array of the elements responsible for generating the key.
         * The `iteratee` is bound to `thisArg` and invoked with three arguments:
         * (value, index|key, collection).
         *
         * If a property name is provided for `iteratee` the created `_.property`
         * style callback returns the property value of the given element.
         *
         * If a value is also provided for `thisArg` the created `_.matchesProperty`
         * style callback returns `true` for elements that have a matching property
         * value, else `false`.
         *
         * If an object is provided for `iteratee` the created `_.matches` style
         * callback returns `true` for elements that have the properties of the given
         * object, else `false`.
         *
         * @static
         * @memberOf _
         * @category Collection
         * @param {Array|Object|string} collection The collection to iterate over.
         * @param {Function|Object|string} [iteratee=_.identity] The function invoked
         *  per iteration.
         * @param {*} [thisArg] The `this` binding of `iteratee`.
         * @returns {Object} Returns the composed aggregate object.
         * @example
         *
         * _.groupBy([4.2, 6.1, 6.4], function(n) {
         *   return Math.floor(n);
         * });
         * // => { '4': [4.2], '6': [6.1, 6.4] }
         *
         * _.groupBy([4.2, 6.1, 6.4], function(n) {
         *   return this.floor(n);
         * }, Math);
         * // => { '4': [4.2], '6': [6.1, 6.4] }
         *
         * // using the `_.property` callback shorthand
         * _.groupBy(['one', 'two', 'three'], 'length');
         * // => { '3': ['one', 'two'], '5': ['three'] }
         */
        var groupBy = createAggregator(function(result, value, key) {
          if (hasOwnProperty.call(result, key)) {
            result[key].push(value);
          } else {
            result[key] = [value];
          }
        });
    
        /**
         * Checks if `value` is in `collection` using
         * [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
         * for equality comparisons. If `fromIndex` is negative, it is used as the offset
         * from the end of `collection`.
         *
         * @static
         * @memberOf _
         * @alias contains, include
         * @category Collection
         * @param {Array|Object|string} collection The collection to search.
         * @param {*} target The value to search for.
         * @param {number} [fromIndex=0] The index to search from.
         * @param- {Object} [guard] Enables use as a callback for functions like `_.reduce`.
         * @returns {boolean} Returns `true` if a matching element is found, else `false`.
         * @example
         *
         * _.includes([1, 2, 3], 1);
         * // => true
         *
         * _.includes([1, 2, 3], 1, 2);
         * // => false
         *
         * _.includes({ 'user': 'fred', 'age': 40 }, 'fred');
         * // => true
         *
         * _.includes('pebbles', 'eb');
         * // => true
         */
        function includes(collection, target, fromIndex, guard) {
          var length = collection ? getLength(collection) : 0;
          if (!isLength(length)) {
            collection = values(collection);
            length = collection.length;
          }
          if (typeof fromIndex != 'number' || (guard && isIterateeCall(target, fromIndex, guard))) {
            fromIndex = 0;
          } else {
            fromIndex = fromIndex < 0 ? nativeMax(length + fromIndex, 0) : (fromIndex || 0);
          }
          return (typeof collection == 'string' || !isArray(collection) && isString(collection))
            ? (fromIndex <= length && collection.indexOf(target, fromIndex) > -1)
            : (!!length && getIndexOf(collection, target, fromIndex) > -1);
        }
    
        /**
         * Creates an object composed of keys generated from the results of running
         * each element of `collection` through `iteratee`. The corresponding value
         * of each key is the last element responsible for generating the key. The
         * iteratee function is bound to `thisArg` and invoked with three arguments:
         * (value, index|key, collection).
         *
         * If a property name is provided for `iteratee` the created `_.property`
         * style callback returns the property value of the given element.
         *
         * If a value is also provided for `thisArg` the created `_.matchesProperty`
         * style callback returns `true` for elements that have a matching property
         * value, else `false`.
         *
         * If an object is provided for `iteratee` the created `_.matches` style
         * callback returns `true` for elements that have the properties of the given
         * object, else `false`.
         *
         * @static
         * @memberOf _
         * @category Collection
         * @param {Array|Object|string} collection The collection to iterate over.
         * @param {Function|Object|string} [iteratee=_.identity] The function invoked
         *  per iteration.
         * @param {*} [thisArg] The `this` binding of `iteratee`.
         * @returns {Object} Returns the composed aggregate object.
         * @example
         *
         * var keyData = [
         *   { 'dir': 'left', 'code': 97 },
         *   { 'dir': 'right', 'code': 100 }
         * ];
         *
         * _.indexBy(keyData, 'dir');
         * // => { 'left': { 'dir': 'left', 'code': 97 }, 'right': { 'dir': 'right', 'code': 100 } }
         *
         * _.indexBy(keyData, function(object) {
         *   return String.fromCharCode(object.code);
         * });
         * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
         *
         * _.indexBy(keyData, function(object) {
         *   return this.fromCharCode(object.code);
         * }, String);
         * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
         */
        var indexBy = createAggregator(function(result, value, key) {
          result[key] = value;
        });
    
        /**
         * Invokes the method at `path` of each element in `collection`, returning
         * an array of the results of each invoked method. Any additional arguments
         * are provided to each invoked method. If `methodName` is a function it is
         * invoked for, and `this` bound to, each element in `collection`.
         *
         * @static
         * @memberOf _
         * @category Collection
         * @param {Array|Object|string} collection The collection to iterate over.
         * @param {Array|Function|string} path The path of the method to invoke or
         *  the function invoked per iteration.
         * @param {...*} [args] The arguments to invoke the method with.
         * @returns {Array} Returns the array of results.
         * @example
         *
         * _.invoke([[5, 1, 7], [3, 2, 1]], 'sort');
         * // => [[1, 5, 7], [1, 2, 3]]
         *
         * _.invoke([123, 456], String.prototype.split, '');
         * // => [['1', '2', '3'], ['4', '5', '6']]
         */
        var invoke = restParam(function(collection, path, args) {
          var index = -1,
              isFunc = typeof path == 'function',
              isProp = isKey(path),
              result = isArrayLike(collection) ? Array(collection.length) : [];
    
          baseEach(collection, function(value) {
            var func = isFunc ? path : ((isProp && value != null) ? value[path] : undefined);
            result[++index] = func ? func.apply(value, args) : invokePath(value, path, args);
          });
          return result;
        });
    
        /**
         * Creates an array of values by running each element in `collection` through
         * `iteratee`. The `iteratee` is bound to `thisArg` and invoked with three
         * arguments: (value, index|key, collection).
         *
         * If a property name is provided for `iteratee` the created `_.property`
         * style callback returns the property value of the given element.
         *
         * If a value is also provided for `thisArg` the created `_.matchesProperty`
         * style callback returns `true` for elements that have a matching property
         * value, else `false`.
         *
         * If an object is provided for `iteratee` the created `_.matches` style
         * callback returns `true` for elements that have the properties of the given
         * object, else `false`.
         *
         * Many lodash methods are guarded to work as iteratees for methods like
         * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.
         *
         * The guarded methods are:
         * `ary`, `callback`, `chunk`, `clone`, `create`, `curry`, `curryRight`,
         * `drop`, `dropRight`, `every`, `fill`, `flatten`, `invert`, `max`, `min`,
         * `parseInt`, `slice`, `sortBy`, `take`, `takeRight`, `template`, `trim`,
         * `trimLeft`, `trimRight`, `trunc`, `random`, `range`, `sample`, `some`,
         * `sum`, `uniq`, and `words`
         *
         * @static
         * @memberOf _
         * @alias collect
         * @category Collection
         * @param {Array|Object|string} collection The collection to iterate over.
         * @param {Function|Object|string} [iteratee=_.identity] The function invoked
         *  per iteration.
         * @param {*} [thisArg] The `this` binding of `iteratee`.
         * @returns {Array} Returns the new mapped array.
         * @example
         *
         * function timesThree(n) {
         *   return n * 3;
         * }
         *
         * _.map([1, 2], timesThree);
         * // => [3, 6]
         *
         * _.map({ 'a': 1, 'b': 2 }, timesThree);
         * // => [3, 6] (iteration order is not guaranteed)
         *
         * var users = [
         *   { 'user': 'barney' },
         *   { 'user': 'fred' }
         * ];
         *
         * // using the `_.property` callback shorthand
         * _.map(users, 'user');
         * // => ['barney', 'fred']
         */
        function map(collection, iteratee, thisArg) {
          var func = isArray(collection) ? arrayMap : baseMap;
          iteratee = getCallback(iteratee, thisArg, 3);
          return func(collection, iteratee);
        }
    
        /**
         * Creates an array of elements split into two groups, the first of which
         * contains elements `predicate` returns truthy for, while the second of which
         * contains elements `predicate` returns falsey for. The predicate is bound
         * to `thisArg` and invoked with three arguments: (value, index|key, collection).
         *
         * If a property name is provided for `predicate` the created `_.property`
         * style callback returns the property value of the given element.
         *
         * If a value is also provided for `thisArg` the created `_.matchesProperty`
         * style callback returns `true` for elements that have a matching property
         * value, else `false`.
         *
         * If an object is provided for `predicate` the created `_.matches` style
         * callback returns `true` for elements that have the properties of the given
         * object, else `false`.
         *
         * @static
         * @memberOf _
         * @category Collection
         * @param {Array|Object|string} collection The collection to iterate over.
         * @param {Function|Object|string} [predicate=_.identity] The function invoked
         *  per iteration.
         * @param {*} [thisArg] The `this` binding of `predicate`.
         * @returns {Array} Returns the array of grouped elements.
         * @example
         *
         * _.partition([1, 2, 3], function(n) {
         *   return n % 2;
         * });
         * // => [[1, 3], [2]]
         *
         * _.partition([1.2, 2.3, 3.4], function(n) {
         *   return this.floor(n) % 2;
         * }, Math);
         * // => [[1.2, 3.4], [2.3]]
         *
         * var users = [
         *   { 'user': 'barney',  'age': 36, 'active': false },
         *   { 'user': 'fred',    'age': 40, 'active': true },
         *   { 'user': 'pebbles', 'age': 1,  'active': false }
         * ];
         *
         * var mapper = function(array) {
         *   return _.pluck(array, 'user');
         * };
         *
         * // using the `_.matches` callback shorthand
         * _.map(_.partition(users, { 'age': 1, 'active': false }), mapper);
         * // => [['pebbles'], ['barney', 'fred']]
         *
         * // using the `_.matchesProperty` callback shorthand
         * _.map(_.partition(users, 'active', false), mapper);
         * // => [['barney', 'pebbles'], ['fred']]
         *
         * // using the `_.property` callback shorthand
         * _.map(_.partition(users, 'active'), mapper);
         * // => [['fred'], ['barney', 'pebbles']]
         */
        var partition = createAggregator(function(result, value, key) {
          result[key ? 0 : 1].push(value);
        }, function() { return [[], []]; });
    
        /**
         * Gets the property value of `path` from all elements in `collection`.
         *
         * @static
         * @memberOf _
         * @category Collection
         * @param {Array|Object|string} collection The collection to iterate over.
         * @param {Array|string} path The path of the property to pluck.
         * @returns {Array} Returns the property values.
         * @example
         *
         * var users = [
         *   { 'user': 'barney', 'age': 36 },
         *   { 'user': 'fred',   'age': 40 }
         * ];
         *
         * _.pluck(users, 'user');
         * // => ['barney', 'fred']
         *
         * var userIndex = _.indexBy(users, 'user');
         * _.pluck(userIndex, 'age');
         * // => [36, 40] (iteration order is not guaranteed)
         */
        function pluck(collection, path) {
          return map(collection, property(path));
        }
    
        /**
         * Reduces `collection` to a value which is the accumulated result of running
         * each element in `collection` through `iteratee`, where each successive
         * invocation is supplied the return value of the previous. If `accumulator`
         * is not provided the first element of `collection` is used as the initial
         * value. The `iteratee` is bound to `thisArg` and invoked with four arguments:
         * (accumulator, value, index|key, collection).
         *
         * Many lodash methods are guarded to work as iteratees for methods like
         * `_.reduce`, `_.reduceRight`, and `_.transform`.
         *
         * The guarded methods are:
         * `assign`, `defaults`, `defaultsDeep`, `includes`, `merge`, `sortByAll`,
         * and `sortByOrder`
         *
         * @static
         * @memberOf _
         * @alias foldl, inject
         * @category Collection
         * @param {Array|Object|string} collection The collection to iterate over.
         * @param {Function} [iteratee=_.identity] The function invoked per iteration.
         * @param {*} [accumulator] The initial value.
         * @param {*} [thisArg] The `this` binding of `iteratee`.
         * @returns {*} Returns the accumulated value.
         * @example
         *
         * _.reduce([1, 2], function(total, n) {
         *   return total + n;
         * });
         * // => 3
         *
         * _.reduce({ 'a': 1, 'b': 2 }, function(result, n, key) {
         *   result[key] = n * 3;
         *   return result;
         * }, {});
         * // => { 'a': 3, 'b': 6 } (iteration order is not guaranteed)
         */
        var reduce = createReduce(arrayReduce, baseEach);
    
        /**
         * This method is like `_.reduce` except that it iterates over elements of
         * `collection` from right to left.
         *
         * @static
         * @memberOf _
         * @alias foldr
         * @category Collection
         * @param {Array|Object|string} collection The collection to iterate over.
         * @param {Function} [iteratee=_.identity] The function invoked per iteration.
         * @param {*} [accumulator] The initial value.
         * @param {*} [thisArg] The `this` binding of `iteratee`.
         * @returns {*} Returns the accumulated value.
         * @example
         *
         * var array = [[0, 1], [2, 3], [4, 5]];
         *
         * _.reduceRight(array, function(flattened, other) {
         *   return flattened.concat(other);
         * }, []);
         * // => [4, 5, 2, 3, 0, 1]
         */
        var reduceRight = createReduce(arrayReduceRight, baseEachRight);
    
        /**
         * The opposite of `_.filter`; this method returns the elements of `collection`
         * that `predicate` does **not** return truthy for.
         *
         * @static
         * @memberOf _
         * @category Collection
         * @param {Array|Object|string} collection The collection to iterate over.
         * @param {Function|Object|string} [predicate=_.identity] The function invoked
         *  per iteration.
         * @param {*} [thisArg] The `this` binding of `predicate`.
         * @returns {Array} Returns the new filtered array.
         * @example
         *
         * _.reject([1, 2, 3, 4], function(n) {
         *   return n % 2 == 0;
         * });
         * // => [1, 3]
         *
         * var users = [
         *   { 'user': 'barney', 'age': 36, 'active': false },
         *   { 'user': 'fred',   'age': 40, 'active': true }
         * ];
         *
         * // using the `_.matches` callback shorthand
         * _.pluck(_.reject(users, { 'age': 40, 'active': true }), 'user');
         * // => ['barney']
         *
         * // using the `_.matchesProperty` callback shorthand
         * _.pluck(_.reject(users, 'active', false), 'user');
         * // => ['fred']
         *
         * // using the `_.property` callback shorthand
         * _.pluck(_.reject(users, 'active'), 'user');
         * // => ['barney']
         */
        function reject(collection, predicate, thisArg) {
          var func = isArray(collection) ? arrayFilter : baseFilter;
          predicate = getCallback(predicate, thisArg, 3);
          return func(collection, function(value, index, collection) {
            return !predicate(value, index, collection);
          });
        }
    
        /**
         * Gets a random element or `n` random elements from a collection.
         *
         * @static
         * @memberOf _
         * @category Collection
         * @param {Array|Object|string} collection The collection to sample.
         * @param {number} [n] The number of elements to sample.
         * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
         * @returns {*} Returns the random sample(s).
         * @example
         *
         * _.sample([1, 2, 3, 4]);
         * // => 2
         *
         * _.sample([1, 2, 3, 4], 2);
         * // => [3, 1]
         */
        function sample(collection, n, guard) {
          if (guard ? isIterateeCall(collection, n, guard) : n == null) {
            collection = toIterable(collection);
            var length = collection.length;
            return length > 0 ? collection[baseRandom(0, length - 1)] : undefined;
          }
          var index = -1,
              result = toArray(collection),
              length = result.length,
              lastIndex = length - 1;
    
          n = nativeMin(n < 0 ? 0 : (+n || 0), length);
          while (++index < n) {
            var rand = baseRandom(index, lastIndex),
                value = result[rand];
    
            result[rand] = result[index];
            result[index] = value;
          }
          result.length = n;
          return result;
        }
    
        /**
         * Creates an array of shuffled values, using a version of the
         * [Fisher-Yates shuffle](https://en.wikipedia.org/wiki/Fisher-Yates_shuffle).
         *
         * @static
         * @memberOf _
         * @category Collection
         * @param {Array|Object|string} collection The collection to shuffle.
         * @returns {Array} Returns the new shuffled array.
         * @example
         *
         * _.shuffle([1, 2, 3, 4]);
         * // => [4, 1, 3, 2]
         */
        function shuffle(collection) {
          return sample(collection, POSITIVE_INFINITY);
        }
    
        /**
         * Gets the size of `collection` by returning its length for array-like
         * values or the number of own enumerable properties for objects.
         *
         * @static
         * @memberOf _
         * @category Collection
         * @param {Array|Object|string} collection The collection to inspect.
         * @returns {number} Returns the size of `collection`.
         * @example
         *
         * _.size([1, 2, 3]);
         * // => 3
         *
         * _.size({ 'a': 1, 'b': 2 });
         * // => 2
         *
         * _.size('pebbles');
         * // => 7
         */
        function size(collection) {
          var length = collection ? getLength(collection) : 0;
          return isLength(length) ? length : keys(collection).length;
        }
    
        /**
         * Checks if `predicate` returns truthy for **any** element of `collection`.
         * The function returns as soon as it finds a passing value and does not iterate
         * over the entire collection. The predicate is bound to `thisArg` and invoked
         * with three arguments: (value, index|key, collection).
         *
         * If a property name is provided for `predicate` the created `_.property`
         * style callback returns the property value of the given element.
         *
         * If a value is also provided for `thisArg` the created `_.matchesProperty`
         * style callback returns `true` for elements that have a matching property
         * value, else `false`.
         *
         * If an object is provided for `predicate` the created `_.matches` style
         * callback returns `true` for elements that have the properties of the given
         * object, else `false`.
         *
         * @static
         * @memberOf _
         * @alias any
         * @category Collection
         * @param {Array|Object|string} collection The collection to iterate over.
         * @param {Function|Object|string} [predicate=_.identity] The function invoked
         *  per iteration.
         * @param {*} [thisArg] The `this` binding of `predicate`.
         * @returns {boolean} Returns `true` if any element passes the predicate check,
         *  else `false`.
         * @example
         *
         * _.some([null, 0, 'yes', false], Boolean);
         * // => true
         *
         * var users = [
         *   { 'user': 'barney', 'active': true },
         *   { 'user': 'fred',   'active': false }
         * ];
         *
         * // using the `_.matches` callback shorthand
         * _.some(users, { 'user': 'barney', 'active': false });
         * // => false
         *
         * // using the `_.matchesProperty` callback shorthand
         * _.some(users, 'active', false);
         * // => true
         *
         * // using the `_.property` callback shorthand
         * _.some(users, 'active');
         * // => true
         */
        function some(collection, predicate, thisArg) {
          var func = isArray(collection) ? arraySome : baseSome;
          if (thisArg && isIterateeCall(collection, predicate, thisArg)) {
            predicate = undefined;
          }
          if (typeof predicate != 'function' || thisArg !== undefined) {
            predicate = getCallback(predicate, thisArg, 3);
          }
          return func(collection, predicate);
        }
    
        /**
         * Creates an array of elements, sorted in ascending order by the results of
         * running each element in a collection through `iteratee`. This method performs
         * a stable sort, that is, it preserves the original sort order of equal elements.
         * The `iteratee` is bound to `thisArg` and invoked with three arguments:
         * (value, index|key, collection).
         *
         * If a property name is provided for `iteratee` the created `_.property`
         * style callback returns the property value of the given element.
         *
         * If a value is also provided for `thisArg` the created `_.matchesProperty`
         * style callback returns `true` for elements that have a matching property
         * value, else `false`.
         *
         * If an object is provided for `iteratee` the created `_.matches` style
         * callback returns `true` for elements that have the properties of the given
         * object, else `false`.
         *
         * @static
         * @memberOf _
         * @category Collection
         * @param {Array|Object|string} collection The collection to iterate over.
         * @param {Function|Object|string} [iteratee=_.identity] The function invoked
         *  per iteration.
         * @param {*} [thisArg] The `this` binding of `iteratee`.
         * @returns {Array} Returns the new sorted array.
         * @example
         *
         * _.sortBy([1, 2, 3], function(n) {
         *   return Math.sin(n);
         * });
         * // => [3, 1, 2]
         *
         * _.sortBy([1, 2, 3], function(n) {
         *   return this.sin(n);
         * }, Math);
         * // => [3, 1, 2]
         *
         * var users = [
         *   { 'user': 'fred' },
         *   { 'user': 'pebbles' },
         *   { 'user': 'barney' }
         * ];
         *
         * // using the `_.property` callback shorthand
         * _.pluck(_.sortBy(users, 'user'), 'user');
         * // => ['barney', 'fred', 'pebbles']
         */
        function sortBy(collection, iteratee, thisArg) {
          if (collection == null) {
            return [];
          }
          if (thisArg && isIterateeCall(collection, iteratee, thisArg)) {
            iteratee = undefined;
          }
          var index = -1;
          iteratee = getCallback(iteratee, thisArg, 3);
    
          var result = baseMap(collection, function(value, key, collection) {
            return { 'criteria': iteratee(value, key, collection), 'index': ++index, 'value': value };
          });
          return baseSortBy(result, compareAscending);
        }
    
        /**
         * This method is like `_.sortBy` except that it can sort by multiple iteratees
         * or property names.
         *
         * If a property name is provided for an iteratee the created `_.property`
         * style callback returns the property value of the given element.
         *
         * If an object is provided for an iteratee the created `_.matches` style
         * callback returns `true` for elements that have the properties of the given
         * object, else `false`.
         *
         * @static
         * @memberOf _
         * @category Collection
         * @param {Array|Object|string} collection The collection to iterate over.
         * @param {...(Function|Function[]|Object|Object[]|string|string[])} iteratees
         *  The iteratees to sort by, specified as individual values or arrays of values.
         * @returns {Array} Returns the new sorted array.
         * @example
         *
         * var users = [
         *   { 'user': 'fred',   'age': 48 },
         *   { 'user': 'barney', 'age': 36 },
         *   { 'user': 'fred',   'age': 42 },
         *   { 'user': 'barney', 'age': 34 }
         * ];
         *
         * _.map(_.sortByAll(users, ['user', 'age']), _.values);
         * // => [['barney', 34], ['barney', 36], ['fred', 42], ['fred', 48]]
         *
         * _.map(_.sortByAll(users, 'user', function(chr) {
         *   return Math.floor(chr.age / 10);
         * }), _.values);
         * // => [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 42]]
         */
        var sortByAll = restParam(function(collection, iteratees) {
          if (collection == null) {
            return [];
          }
          var guard = iteratees[2];
          if (guard && isIterateeCall(iteratees[0], iteratees[1], guard)) {
            iteratees.length = 1;
          }
          return baseSortByOrder(collection, baseFlatten(iteratees), []);
        });
    
        /**
         * This method is like `_.sortByAll` except that it allows specifying the
         * sort orders of the iteratees to sort by. If `orders` is unspecified, all
         * values are sorted in ascending order. Otherwise, a value is sorted in
         * ascending order if its corresponding order is "asc", and descending if "desc".
         *
         * If a property name is provided for an iteratee the created `_.property`
         * style callback returns the property value of the given element.
         *
         * If an object is provided for an iteratee the created `_.matches` style
         * callback returns `true` for elements that have the properties of the given
         * object, else `false`.
         *
         * @static
         * @memberOf _
         * @category Collection
         * @param {Array|Object|string} collection The collection to iterate over.
         * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.
         * @param {boolean[]} [orders] The sort orders of `iteratees`.
         * @param- {Object} [guard] Enables use as a callback for functions like `_.reduce`.
         * @returns {Array} Returns the new sorted array.
         * @example
         *
         * var users = [
         *   { 'user': 'fred',   'age': 48 },
         *   { 'user': 'barney', 'age': 34 },
         *   { 'user': 'fred',   'age': 42 },
         *   { 'user': 'barney', 'age': 36 }
         * ];
         *
         * // sort by `user` in ascending order and by `age` in descending order
         * _.map(_.sortByOrder(users, ['user', 'age'], ['asc', 'desc']), _.values);
         * // => [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 42]]
         */
        function sortByOrder(collection, iteratees, orders, guard) {
          if (collection == null) {
            return [];
          }
          if (guard && isIterateeCall(iteratees, orders, guard)) {
            orders = undefined;
          }
          if (!isArray(iteratees)) {
            iteratees = iteratees == null ? [] : [iteratees];
          }
          if (!isArray(orders)) {
            orders = orders == null ? [] : [orders];
          }
          return baseSortByOrder(collection, iteratees, orders);
        }
    
        /**
         * Performs a deep comparison between each element in `collection` and the
         * source object, returning an array of all elements that have equivalent
         * property values.
         *
         * **Note:** This method supports comparing arrays, booleans, `Date` objects,
         * numbers, `Object` objects, regexes, and strings. Objects are compared by
         * their own, not inherited, enumerable properties. For comparing a single
         * own or inherited property value see `_.matchesProperty`.
         *
         * @static
         * @memberOf _
         * @category Collection
         * @param {Array|Object|string} collection The collection to search.
         * @param {Object} source The object of property values to match.
         * @returns {Array} Returns the new filtered array.
         * @example
         *
         * var users = [
         *   { 'user': 'barney', 'age': 36, 'active': false, 'pets': ['hoppy'] },
         *   { 'user': 'fred',   'age': 40, 'active': true, 'pets': ['baby puss', 'dino'] }
         * ];
         *
         * _.pluck(_.where(users, { 'age': 36, 'active': false }), 'user');
         * // => ['barney']
         *
         * _.pluck(_.where(users, { 'pets': ['dino'] }), 'user');
         * // => ['fred']
         */
        function where(collection, source) {
          return filter(collection, baseMatches(source));
        }
    
        /*------------------------------------------------------------------------*/
    
        /**
         * Gets the number of milliseconds that have elapsed since the Unix epoch
         * (1 January 1970 00:00:00 UTC).
         *
         * @static
         * @memberOf _
         * @category Date
         * @example
         *
         * _.defer(function(stamp) {
         *   console.log(_.now() - stamp);
         * }, _.now());
         * // => logs the number of milliseconds it took for the deferred function to be invoked
         */
        var now = nativeNow || function() {
          return new Date().getTime();
        };
    
        /*------------------------------------------------------------------------*/
    
        /**
         * The opposite of `_.before`; this method creates a function that invokes
         * `func` once it is called `n` or more times.
         *
         * @static
         * @memberOf _
         * @category Function
         * @param {number} n The number of calls before `func` is invoked.
         * @param {Function} func The function to restrict.
         * @returns {Function} Returns the new restricted function.
         * @example
         *
         * var saves = ['profile', 'settings'];
         *
         * var done = _.after(saves.length, function() {
         *   console.log('done saving!');
         * });
         *
         * _.forEach(saves, function(type) {
         *   asyncSave({ 'type': type, 'complete': done });
         * });
         * // => logs 'done saving!' after the two async saves have completed
         */
        function after(n, func) {
          if (typeof func != 'function') {
            if (typeof n == 'function') {
              var temp = n;
              n = func;
              func = temp;
            } else {
              throw new TypeError(FUNC_ERROR_TEXT);
            }
          }
          n = nativeIsFinite(n = +n) ? n : 0;
          return function() {
            if (--n < 1) {
              return func.apply(this, arguments);
            }
          };
        }
    
        /**
         * Creates a function that accepts up to `n` arguments ignoring any
         * additional arguments.
         *
         * @static
         * @memberOf _
         * @category Function
         * @param {Function} func The function to cap arguments for.
         * @param {number} [n=func.length] The arity cap.
         * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
         * @returns {Function} Returns the new function.
         * @example
         *
         * _.map(['6', '8', '10'], _.ary(parseInt, 1));
         * // => [6, 8, 10]
         */
        function ary(func, n, guard) {
          if (guard && isIterateeCall(func, n, guard)) {
            n = undefined;
          }
          n = (func && n == null) ? func.length : nativeMax(+n || 0, 0);
          return createWrapper(func, ARY_FLAG, undefined, undefined, undefined, undefined, n);
        }
    
        /**
         * Creates a function that invokes `func`, with the `this` binding and arguments
         * of the created function, while it is called less than `n` times. Subsequent
         * calls to the created function return the result of the last `func` invocation.
         *
         * @static
         * @memberOf _
         * @category Function
         * @param {number} n The number of calls at which `func` is no longer invoked.
         * @param {Function} func The function to restrict.
         * @returns {Function} Returns the new restricted function.
         * @example
         *
         * jQuery('#add').on('click', _.before(5, addContactToList));
         * // => allows adding up to 4 contacts to the list
         */
        function before(n, func) {
          var result;
          if (typeof func != 'function') {
            if (typeof n == 'function') {
              var temp = n;
              n = func;
              func = temp;
            } else {
              throw new TypeError(FUNC_ERROR_TEXT);
            }
          }
          return function() {
            if (--n > 0) {
              result = func.apply(this, arguments);
            }
            if (n <= 1) {
              func = undefined;
            }
            return result;
          };
        }
    
        /**
         * Creates a function that invokes `func` with the `this` binding of `thisArg`
         * and prepends any additional `_.bind` arguments to those provided to the
         * bound function.
         *
         * The `_.bind.placeholder` value, which defaults to `_` in monolithic builds,
         * may be used as a placeholder for partially applied arguments.
         *
         * **Note:** Unlike native `Function#bind` this method does not set the "length"
         * property of bound functions.
         *
         * @static
         * @memberOf _
         * @category Function
         * @param {Function} func The function to bind.
         * @param {*} thisArg The `this` binding of `func`.
         * @param {...*} [partials] The arguments to be partially applied.
         * @returns {Function} Returns the new bound function.
         * @example
         *
         * var greet = function(greeting, punctuation) {
         *   return greeting + ' ' + this.user + punctuation;
         * };
         *
         * var object = { 'user': 'fred' };
         *
         * var bound = _.bind(greet, object, 'hi');
         * bound('!');
         * // => 'hi fred!'
         *
         * // using placeholders
         * var bound = _.bind(greet, object, _, '!');
         * bound('hi');
         * // => 'hi fred!'
         */
        var bind = restParam(function(func, thisArg, partials) {
          var bitmask = BIND_FLAG;
          if (partials.length) {
            var holders = replaceHolders(partials, bind.placeholder);
            bitmask |= PARTIAL_FLAG;
          }
          return createWrapper(func, bitmask, thisArg, partials, holders);
        });
    
        /**
         * Binds methods of an object to the object itself, overwriting the existing
         * method. Method names may be specified as individual arguments or as arrays
         * of method names. If no method names are provided all enumerable function
         * properties, own and inherited, of `object` are bound.
         *
         * **Note:** This method does not set the "length" property of bound functions.
         *
         * @static
         * @memberOf _
         * @category Function
         * @param {Object} object The object to bind and assign the bound methods to.
         * @param {...(string|string[])} [methodNames] The object method names to bind,
         *  specified as individual method names or arrays of method names.
         * @returns {Object} Returns `object`.
         * @example
         *
         * var view = {
         *   'label': 'docs',
         *   'onClick': function() {
         *     console.log('clicked ' + this.label);
         *   }
         * };
         *
         * _.bindAll(view);
         * jQuery('#docs').on('click', view.onClick);
         * // => logs 'clicked docs' when the element is clicked
         */
        var bindAll = restParam(function(object, methodNames) {
          methodNames = methodNames.length ? baseFlatten(methodNames) : functions(object);
    
          var index = -1,
              length = methodNames.length;
    
          while (++index < length) {
            var key = methodNames[index];
            object[key] = createWrapper(object[key], BIND_FLAG, object);
          }
          return object;
        });
    
        /**
         * Creates a function that invokes the method at `object[key]` and prepends
         * any additional `_.bindKey` arguments to those provided to the bound function.
         *
         * This method differs from `_.bind` by allowing bound functions to reference
         * methods that may be redefined or don't yet exist.
         * See [Peter Michaux's article](http://peter.michaux.ca/articles/lazy-function-definition-pattern)
         * for more details.
         *
         * The `_.bindKey.placeholder` value, which defaults to `_` in monolithic
         * builds, may be used as a placeholder for partially applied arguments.
         *
         * @static
         * @memberOf _
         * @category Function
         * @param {Object} object The object the method belongs to.
         * @param {string} key The key of the method.
         * @param {...*} [partials] The arguments to be partially applied.
         * @returns {Function} Returns the new bound function.
         * @example
         *
         * var object = {
         *   'user': 'fred',
         *   'greet': function(greeting, punctuation) {
         *     return greeting + ' ' + this.user + punctuation;
         *   }
         * };
         *
         * var bound = _.bindKey(object, 'greet', 'hi');
         * bound('!');
         * // => 'hi fred!'
         *
         * object.greet = function(greeting, punctuation) {
         *   return greeting + 'ya ' + this.user + punctuation;
         * };
         *
         * bound('!');
         * // => 'hiya fred!'
         *
         * // using placeholders
         * var bound = _.bindKey(object, 'greet', _, '!');
         * bound('hi');
         * // => 'hiya fred!'
         */
        var bindKey = restParam(function(object, key, partials) {
          var bitmask = BIND_FLAG | BIND_KEY_FLAG;
          if (partials.length) {
            var holders = replaceHolders(partials, bindKey.placeholder);
            bitmask |= PARTIAL_FLAG;
          }
          return createWrapper(key, bitmask, object, partials, holders);
        });
    
        /**
         * Creates a function that accepts one or more arguments of `func` that when
         * called either invokes `func` returning its result, if all `func` arguments
         * have been provided, or returns a function that accepts one or more of the
         * remaining `func` arguments, and so on. The arity of `func` may be specified
         * if `func.length` is not sufficient.
         *
         * The `_.curry.placeholder` value, which defaults to `_` in monolithic builds,
         * may be used as a placeholder for provided arguments.
         *
         * **Note:** This method does not set the "length" property of curried functions.
         *
         * @static
         * @memberOf _
         * @category Function
         * @param {Function} func The function to curry.
         * @param {number} [arity=func.length] The arity of `func`.
         * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
         * @returns {Function} Returns the new curried function.
         * @example
         *
         * var abc = function(a, b, c) {
         *   return [a, b, c];
         * };
         *
         * var curried = _.curry(abc);
         *
         * curried(1)(2)(3);
         * // => [1, 2, 3]
         *
         * curried(1, 2)(3);
         * // => [1, 2, 3]
         *
         * curried(1, 2, 3);
         * // => [1, 2, 3]
         *
         * // using placeholders
         * curried(1)(_, 3)(2);
         * // => [1, 2, 3]
         */
        var curry = createCurry(CURRY_FLAG);
    
        /**
         * This method is like `_.curry` except that arguments are applied to `func`
         * in the manner of `_.partialRight` instead of `_.partial`.
         *
         * The `_.curryRight.placeholder` value, which defaults to `_` in monolithic
         * builds, may be used as a placeholder for provided arguments.
         *
         * **Note:** This method does not set the "length" property of curried functions.
         *
         * @static
         * @memberOf _
         * @category Function
         * @param {Function} func The function to curry.
         * @param {number} [arity=func.length] The arity of `func`.
         * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
         * @returns {Function} Returns the new curried function.
         * @example
         *
         * var abc = function(a, b, c) {
         *   return [a, b, c];
         * };
         *
         * var curried = _.curryRight(abc);
         *
         * curried(3)(2)(1);
         * // => [1, 2, 3]
         *
         * curried(2, 3)(1);
         * // => [1, 2, 3]
         *
         * curried(1, 2, 3);
         * // => [1, 2, 3]
         *
         * // using placeholders
         * curried(3)(1, _)(2);
         * // => [1, 2, 3]
         */
        var curryRight = createCurry(CURRY_RIGHT_FLAG);
    
        /**
         * Creates a debounced function that delays invoking `func` until after `wait`
         * milliseconds have elapsed since the last time the debounced function was
         * invoked. The debounced function comes with a `cancel` method to cancel
         * delayed invocations. Provide an options object to indicate that `func`
         * should be invoked on the leading and/or trailing edge of the `wait` timeout.
         * Subsequent calls to the debounced function return the result of the last
         * `func` invocation.
         *
         * **Note:** If `leading` and `trailing` options are `true`, `func` is invoked
         * on the trailing edge of the timeout only if the the debounced function is
         * invoked more than once during the `wait` timeout.
         *
         * See [David Corbacho's article](http://drupalmotion.com/article/debounce-and-throttle-visual-explanation)
         * for details over the differences between `_.debounce` and `_.throttle`.
         *
         * @static
         * @memberOf _
         * @category Function
         * @param {Function} func The function to debounce.
         * @param {number} [wait=0] The number of milliseconds to delay.
         * @param {Object} [options] The options object.
         * @param {boolean} [options.leading=false] Specify invoking on the leading
         *  edge of the timeout.
         * @param {number} [options.maxWait] The maximum time `func` is allowed to be
         *  delayed before it is invoked.
         * @param {boolean} [options.trailing=true] Specify invoking on the trailing
         *  edge of the timeout.
         * @returns {Function} Returns the new debounced function.
         * @example
         *
         * // avoid costly calculations while the window size is in flux
         * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
         *
         * // invoke `sendMail` when the click event is fired, debouncing subsequent calls
         * jQuery('#postbox').on('click', _.debounce(sendMail, 300, {
         *   'leading': true,
         *   'trailing': false
         * }));
         *
         * // ensure `batchLog` is invoked once after 1 second of debounced calls
         * var source = new EventSource('/stream');
         * jQuery(source).on('message', _.debounce(batchLog, 250, {
         *   'maxWait': 1000
         * }));
         *
         * // cancel a debounced call
         * var todoChanges = _.debounce(batchLog, 1000);
         * Object.observe(models.todo, todoChanges);
         *
         * Object.observe(models, function(changes) {
         *   if (_.find(changes, { 'user': 'todo', 'type': 'delete'})) {
         *     todoChanges.cancel();
         *   }
         * }, ['delete']);
         *
         * // ...at some point `models.todo` is changed
         * models.todo.completed = true;
         *
         * // ...before 1 second has passed `models.todo` is deleted
         * // which cancels the debounced `todoChanges` call
         * delete models.todo;
         */
        function debounce(func, wait, options) {
          var args,
              maxTimeoutId,
              result,
              stamp,
              thisArg,
              timeoutId,
              trailingCall,
              lastCalled = 0,
              maxWait = false,
              trailing = true;
    
          if (typeof func != 'function') {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          wait = wait < 0 ? 0 : (+wait || 0);
          if (options === true) {
            var leading = true;
            trailing = false;
          } else if (isObject(options)) {
            leading = !!options.leading;
            maxWait = 'maxWait' in options && nativeMax(+options.maxWait || 0, wait);
            trailing = 'trailing' in options ? !!options.trailing : trailing;
          }
    
          function cancel() {
            if (timeoutId) {
              clearTimeout(timeoutId);
            }
            if (maxTimeoutId) {
              clearTimeout(maxTimeoutId);
            }
            lastCalled = 0;
            maxTimeoutId = timeoutId = trailingCall = undefined;
          }
    
          function complete(isCalled, id) {
            if (id) {
              clearTimeout(id);
            }
            maxTimeoutId = timeoutId = trailingCall = undefined;
            if (isCalled) {
              lastCalled = now();
              result = func.apply(thisArg, args);
              if (!timeoutId && !maxTimeoutId) {
                args = thisArg = undefined;
              }
            }
          }
    
          function delayed() {
            var remaining = wait - (now() - stamp);
            if (remaining <= 0 || remaining > wait) {
              complete(trailingCall, maxTimeoutId);
            } else {
              timeoutId = setTimeout(delayed, remaining);
            }
          }
    
          function maxDelayed() {
            complete(trailing, timeoutId);
          }
    
          function debounced() {
            args = arguments;
            stamp = now();
            thisArg = this;
            trailingCall = trailing && (timeoutId || !leading);
    
            if (maxWait === false) {
              var leadingCall = leading && !timeoutId;
            } else {
              if (!maxTimeoutId && !leading) {
                lastCalled = stamp;
              }
              var remaining = maxWait - (stamp - lastCalled),
                  isCalled = remaining <= 0 || remaining > maxWait;
    
              if (isCalled) {
                if (maxTimeoutId) {
                  maxTimeoutId = clearTimeout(maxTimeoutId);
                }
                lastCalled = stamp;
                result = func.apply(thisArg, args);
              }
              else if (!maxTimeoutId) {
                maxTimeoutId = setTimeout(maxDelayed, remaining);
              }
            }
            if (isCalled && timeoutId) {
              timeoutId = clearTimeout(timeoutId);
            }
            else if (!timeoutId && wait !== maxWait) {
              timeoutId = setTimeout(delayed, wait);
            }
            if (leadingCall) {
              isCalled = true;
              result = func.apply(thisArg, args);
            }
            if (isCalled && !timeoutId && !maxTimeoutId) {
              args = thisArg = undefined;
            }
            return result;
          }
          debounced.cancel = cancel;
          return debounced;
        }
    
        /**
         * Defers invoking the `func` until the current call stack has cleared. Any
         * additional arguments are provided to `func` when it is invoked.
         *
         * @static
         * @memberOf _
         * @category Function
         * @param {Function} func The function to defer.
         * @param {...*} [args] The arguments to invoke the function with.
         * @returns {number} Returns the timer id.
         * @example
         *
         * _.defer(function(text) {
         *   console.log(text);
         * }, 'deferred');
         * // logs 'deferred' after one or more milliseconds
         */
        var defer = restParam(function(func, args) {
          return baseDelay(func, 1, args);
        });
    
        /**
         * Invokes `func` after `wait` milliseconds. Any additional arguments are
         * provided to `func` when it is invoked.
         *
         * @static
         * @memberOf _
         * @category Function
         * @param {Function} func The function to delay.
         * @param {number} wait The number of milliseconds to delay invocation.
         * @param {...*} [args] The arguments to invoke the function with.
         * @returns {number} Returns the timer id.
         * @example
         *
         * _.delay(function(text) {
         *   console.log(text);
         * }, 1000, 'later');
         * // => logs 'later' after one second
         */
        var delay = restParam(function(func, wait, args) {
          return baseDelay(func, wait, args);
        });
    
        /**
         * Creates a function that returns the result of invoking the provided
         * functions with the `this` binding of the created function, where each
         * successive invocation is supplied the return value of the previous.
         *
         * @static
         * @memberOf _
         * @category Function
         * @param {...Function} [funcs] Functions to invoke.
         * @returns {Function} Returns the new function.
         * @example
         *
         * function square(n) {
         *   return n * n;
         * }
         *
         * var addSquare = _.flow(_.add, square);
         * addSquare(1, 2);
         * // => 9
         */
        var flow = createFlow();
    
        /**
         * This method is like `_.flow` except that it creates a function that
         * invokes the provided functions from right to left.
         *
         * @static
         * @memberOf _
         * @alias backflow, compose
         * @category Function
         * @param {...Function} [funcs] Functions to invoke.
         * @returns {Function} Returns the new function.
         * @example
         *
         * function square(n) {
         *   return n * n;
         * }
         *
         * var addSquare = _.flowRight(square, _.add);
         * addSquare(1, 2);
         * // => 9
         */
        var flowRight = createFlow(true);
    
        /**
         * Creates a function that memoizes the result of `func`. If `resolver` is
         * provided it determines the cache key for storing the result based on the
         * arguments provided to the memoized function. By default, the first argument
         * provided to the memoized function is coerced to a string and used as the
         * cache key. The `func` is invoked with the `this` binding of the memoized
         * function.
         *
         * **Note:** The cache is exposed as the `cache` property on the memoized
         * function. Its creation may be customized by replacing the `_.memoize.Cache`
         * constructor with one whose instances implement the [`Map`](http://ecma-international.org/ecma-262/6.0/#sec-properties-of-the-map-prototype-object)
         * method interface of `get`, `has`, and `set`.
         *
         * @static
         * @memberOf _
         * @category Function
         * @param {Function} func The function to have its output memoized.
         * @param {Function} [resolver] The function to resolve the cache key.
         * @returns {Function} Returns the new memoizing function.
         * @example
         *
         * var upperCase = _.memoize(function(string) {
         *   return string.toUpperCase();
         * });
         *
         * upperCase('fred');
         * // => 'FRED'
         *
         * // modifying the result cache
         * upperCase.cache.set('fred', 'BARNEY');
         * upperCase('fred');
         * // => 'BARNEY'
         *
         * // replacing `_.memoize.Cache`
         * var object = { 'user': 'fred' };
         * var other = { 'user': 'barney' };
         * var identity = _.memoize(_.identity);
         *
         * identity(object);
         * // => { 'user': 'fred' }
         * identity(other);
         * // => { 'user': 'fred' }
         *
         * _.memoize.Cache = WeakMap;
         * var identity = _.memoize(_.identity);
         *
         * identity(object);
         * // => { 'user': 'fred' }
         * identity(other);
         * // => { 'user': 'barney' }
         */
        function memoize(func, resolver) {
          if (typeof func != 'function' || (resolver && typeof resolver != 'function')) {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          var memoized = function() {
            var args = arguments,
                key = resolver ? resolver.apply(this, args) : args[0],
                cache = memoized.cache;
    
            if (cache.has(key)) {
              return cache.get(key);
            }
            var result = func.apply(this, args);
            memoized.cache = cache.set(key, result);
            return result;
          };
          memoized.cache = new memoize.Cache;
          return memoized;
        }
    
        /**
         * Creates a function that runs each argument through a corresponding
         * transform function.
         *
         * @static
         * @memberOf _
         * @category Function
         * @param {Function} func The function to wrap.
         * @param {...(Function|Function[])} [transforms] The functions to transform
         * arguments, specified as individual functions or arrays of functions.
         * @returns {Function} Returns the new function.
         * @example
         *
         * function doubled(n) {
         *   return n * 2;
         * }
         *
         * function square(n) {
         *   return n * n;
         * }
         *
         * var modded = _.modArgs(function(x, y) {
         *   return [x, y];
         * }, square, doubled);
         *
         * modded(1, 2);
         * // => [1, 4]
         *
         * modded(5, 10);
         * // => [25, 20]
         */
        var modArgs = restParam(function(func, transforms) {
          transforms = baseFlatten(transforms);
          if (typeof func != 'function' || !arrayEvery(transforms, baseIsFunction)) {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          var length = transforms.length;
          return restParam(function(args) {
            var index = nativeMin(args.length, length);
            while (index--) {
              args[index] = transforms[index](args[index]);
            }
            return func.apply(this, args);
          });
        });
    
        /**
         * Creates a function that negates the result of the predicate `func`. The
         * `func` predicate is invoked with the `this` binding and arguments of the
         * created function.
         *
         * @static
         * @memberOf _
         * @category Function
         * @param {Function} predicate The predicate to negate.
         * @returns {Function} Returns the new function.
         * @example
         *
         * function isEven(n) {
         *   return n % 2 == 0;
         * }
         *
         * _.filter([1, 2, 3, 4, 5, 6], _.negate(isEven));
         * // => [1, 3, 5]
         */
        function negate(predicate) {
          if (typeof predicate != 'function') {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          return function() {
            return !predicate.apply(this, arguments);
          };
        }
    
        /**
         * Creates a function that is restricted to invoking `func` once. Repeat calls
         * to the function return the value of the first call. The `func` is invoked
         * with the `this` binding and arguments of the created function.
         *
         * @static
         * @memberOf _
         * @category Function
         * @param {Function} func The function to restrict.
         * @returns {Function} Returns the new restricted function.
         * @example
         *
         * var initialize = _.once(createApplication);
         * initialize();
         * initialize();
         * // `initialize` invokes `createApplication` once
         */
        function once(func) {
          return before(2, func);
        }
    
        /**
         * Creates a function that invokes `func` with `partial` arguments prepended
         * to those provided to the new function. This method is like `_.bind` except
         * it does **not** alter the `this` binding.
         *
         * The `_.partial.placeholder` value, which defaults to `_` in monolithic
         * builds, may be used as a placeholder for partially applied arguments.
         *
         * **Note:** This method does not set the "length" property of partially
         * applied functions.
         *
         * @static
         * @memberOf _
         * @category Function
         * @param {Function} func The function to partially apply arguments to.
         * @param {...*} [partials] The arguments to be partially applied.
         * @returns {Function} Returns the new partially applied function.
         * @example
         *
         * var greet = function(greeting, name) {
         *   return greeting + ' ' + name;
         * };
         *
         * var sayHelloTo = _.partial(greet, 'hello');
         * sayHelloTo('fred');
         * // => 'hello fred'
         *
         * // using placeholders
         * var greetFred = _.partial(greet, _, 'fred');
         * greetFred('hi');
         * // => 'hi fred'
         */
        var partial = createPartial(PARTIAL_FLAG);
    
        /**
         * This method is like `_.partial` except that partially applied arguments
         * are appended to those provided to the new function.
         *
         * The `_.partialRight.placeholder` value, which defaults to `_` in monolithic
         * builds, may be used as a placeholder for partially applied arguments.
         *
         * **Note:** This method does not set the "length" property of partially
         * applied functions.
         *
         * @static
         * @memberOf _
         * @category Function
         * @param {Function} func The function to partially apply arguments to.
         * @param {...*} [partials] The arguments to be partially applied.
         * @returns {Function} Returns the new partially applied function.
         * @example
         *
         * var greet = function(greeting, name) {
         *   return greeting + ' ' + name;
         * };
         *
         * var greetFred = _.partialRight(greet, 'fred');
         * greetFred('hi');
         * // => 'hi fred'
         *
         * // using placeholders
         * var sayHelloTo = _.partialRight(greet, 'hello', _);
         * sayHelloTo('fred');
         * // => 'hello fred'
         */
        var partialRight = createPartial(PARTIAL_RIGHT_FLAG);
    
        /**
         * Creates a function that invokes `func` with arguments arranged according
         * to the specified indexes where the argument value at the first index is
         * provided as the first argument, the argument value at the second index is
         * provided as the second argument, and so on.
         *
         * @static
         * @memberOf _
         * @category Function
         * @param {Function} func The function to rearrange arguments for.
         * @param {...(number|number[])} indexes The arranged argument indexes,
         *  specified as individual indexes or arrays of indexes.
         * @returns {Function} Returns the new function.
         * @example
         *
         * var rearged = _.rearg(function(a, b, c) {
         *   return [a, b, c];
         * }, 2, 0, 1);
         *
         * rearged('b', 'c', 'a')
         * // => ['a', 'b', 'c']
         *
         * var map = _.rearg(_.map, [1, 0]);
         * map(function(n) {
         *   return n * 3;
         * }, [1, 2, 3]);
         * // => [3, 6, 9]
         */
        var rearg = restParam(function(func, indexes) {
          return createWrapper(func, REARG_FLAG, undefined, undefined, undefined, baseFlatten(indexes));
        });
    
        /**
         * Creates a function that invokes `func` with the `this` binding of the
         * created function and arguments from `start` and beyond provided as an array.
         *
         * **Note:** This method is based on the [rest parameter](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/rest_parameters).
         *
         * @static
         * @memberOf _
         * @category Function
         * @param {Function} func The function to apply a rest parameter to.
         * @param {number} [start=func.length-1] The start position of the rest parameter.
         * @returns {Function} Returns the new function.
         * @example
         *
         * var say = _.restParam(function(what, names) {
         *   return what + ' ' + _.initial(names).join(', ') +
         *     (_.size(names) > 1 ? ', & ' : '') + _.last(names);
         * });
         *
         * say('hello', 'fred', 'barney', 'pebbles');
         * // => 'hello fred, barney, & pebbles'
         */
        function restParam(func, start) {
          if (typeof func != 'function') {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          start = nativeMax(start === undefined ? (func.length - 1) : (+start || 0), 0);
          return function() {
            var args = arguments,
                index = -1,
                length = nativeMax(args.length - start, 0),
                rest = Array(length);
    
            while (++index < length) {
              rest[index] = args[start + index];
            }
            switch (start) {
              case 0: return func.call(this, rest);
              case 1: return func.call(this, args[0], rest);
              case 2: return func.call(this, args[0], args[1], rest);
            }
            var otherArgs = Array(start + 1);
            index = -1;
            while (++index < start) {
              otherArgs[index] = args[index];
            }
            otherArgs[start] = rest;
            return func.apply(this, otherArgs);
          };
        }
    
        /**
         * Creates a function that invokes `func` with the `this` binding of the created
         * function and an array of arguments much like [`Function#apply`](https://es5.github.io/#x15.3.4.3).
         *
         * **Note:** This method is based on the [spread operator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_operator).
         *
         * @static
         * @memberOf _
         * @category Function
         * @param {Function} func The function to spread arguments over.
         * @returns {Function} Returns the new function.
         * @example
         *
         * var say = _.spread(function(who, what) {
         *   return who + ' says ' + what;
         * });
         *
         * say(['fred', 'hello']);
         * // => 'fred says hello'
         *
         * // with a Promise
         * var numbers = Promise.all([
         *   Promise.resolve(40),
         *   Promise.resolve(36)
         * ]);
         *
         * numbers.then(_.spread(function(x, y) {
         *   return x + y;
         * }));
         * // => a Promise of 76
         */
        function spread(func) {
          if (typeof func != 'function') {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          return function(array) {
            return func.apply(this, array);
          };
        }
    
        /**
         * Creates a throttled function that only invokes `func` at most once per
         * every `wait` milliseconds. The throttled function comes with a `cancel`
         * method to cancel delayed invocations. Provide an options object to indicate
         * that `func` should be invoked on the leading and/or trailing edge of the
         * `wait` timeout. Subsequent calls to the throttled function return the
         * result of the last `func` call.
         *
         * **Note:** If `leading` and `trailing` options are `true`, `func` is invoked
         * on the trailing edge of the timeout only if the the throttled function is
         * invoked more than once during the `wait` timeout.
         *
         * See [David Corbacho's article](http://drupalmotion.com/article/debounce-and-throttle-visual-explanation)
         * for details over the differences between `_.throttle` and `_.debounce`.
         *
         * @static
         * @memberOf _
         * @category Function
         * @param {Function} func The function to throttle.
         * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
         * @param {Object} [options] The options object.
         * @param {boolean} [options.leading=true] Specify invoking on the leading
         *  edge of the timeout.
         * @param {boolean} [options.trailing=true] Specify invoking on the trailing
         *  edge of the timeout.
         * @returns {Function} Returns the new throttled function.
         * @example
         *
         * // avoid excessively updating the position while scrolling
         * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
         *
         * // invoke `renewToken` when the click event is fired, but not more than once every 5 minutes
         * jQuery('.interactive').on('click', _.throttle(renewToken, 300000, {
         *   'trailing': false
         * }));
         *
         * // cancel a trailing throttled call
         * jQuery(window).on('popstate', throttled.cancel);
         */
        function throttle(func, wait, options) {
          var leading = true,
              trailing = true;
    
          if (typeof func != 'function') {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          if (options === false) {
            leading = false;
          } else if (isObject(options)) {
            leading = 'leading' in options ? !!options.leading : leading;
            trailing = 'trailing' in options ? !!options.trailing : trailing;
          }
          return debounce(func, wait, { 'leading': leading, 'maxWait': +wait, 'trailing': trailing });
        }
    
        /**
         * Creates a function that provides `value` to the wrapper function as its
         * first argument. Any additional arguments provided to the function are
         * appended to those provided to the wrapper function. The wrapper is invoked
         * with the `this` binding of the created function.
         *
         * @static
         * @memberOf _
         * @category Function
         * @param {*} value The value to wrap.
         * @param {Function} wrapper The wrapper function.
         * @returns {Function} Returns the new function.
         * @example
         *
         * var p = _.wrap(_.escape, function(func, text) {
         *   return '<p>' + func(text) + '</p>';
         * });
         *
         * p('fred, barney, & pebbles');
         * // => '<p>fred, barney, &amp; pebbles</p>'
         */
        function wrap(value, wrapper) {
          wrapper = wrapper == null ? identity : wrapper;
          return createWrapper(wrapper, PARTIAL_FLAG, undefined, [value], []);
        }
    
        /*------------------------------------------------------------------------*/
    
        /**
         * Creates a clone of `value`. If `isDeep` is `true` nested objects are cloned,
         * otherwise they are assigned by reference. If `customizer` is provided it is
         * invoked to produce the cloned values. If `customizer` returns `undefined`
         * cloning is handled by the method instead. The `customizer` is bound to
         * `thisArg` and invoked with two argument; (value [, index|key, object]).
         *
         * **Note:** This method is loosely based on the
         * [structured clone algorithm](http://www.w3.org/TR/html5/infrastructure.html#internal-structured-cloning-algorithm).
         * The enumerable properties of `arguments` objects and objects created by
         * constructors other than `Object` are cloned to plain `Object` objects. An
         * empty object is returned for uncloneable values such as functions, DOM nodes,
         * Maps, Sets, and WeakMaps.
         *
         * @static
         * @memberOf _
         * @category Lang
         * @param {*} value The value to clone.
         * @param {boolean} [isDeep] Specify a deep clone.
         * @param {Function} [customizer] The function to customize cloning values.
         * @param {*} [thisArg] The `this` binding of `customizer`.
         * @returns {*} Returns the cloned value.
         * @example
         *
         * var users = [
         *   { 'user': 'barney' },
         *   { 'user': 'fred' }
         * ];
         *
         * var shallow = _.clone(users);
         * shallow[0] === users[0];
         * // => true
         *
         * var deep = _.clone(users, true);
         * deep[0] === users[0];
         * // => false
         *
         * // using a customizer callback
         * var el = _.clone(document.body, function(value) {
         *   if (_.isElement(value)) {
         *     return value.cloneNode(false);
         *   }
         * });
         *
         * el === document.body
         * // => false
         * el.nodeName
         * // => BODY
         * el.childNodes.length;
         * // => 0
         */
        function clone(value, isDeep, customizer, thisArg) {
          if (isDeep && typeof isDeep != 'boolean' && isIterateeCall(value, isDeep, customizer)) {
            isDeep = false;
          }
          else if (typeof isDeep == 'function') {
            thisArg = customizer;
            customizer = isDeep;
            isDeep = false;
          }
          return typeof customizer == 'function'
            ? baseClone(value, isDeep, bindCallback(customizer, thisArg, 1))
            : baseClone(value, isDeep);
        }
    
        /**
         * Creates a deep clone of `value`. If `customizer` is provided it is invoked
         * to produce the cloned values. If `customizer` returns `undefined` cloning
         * is handled by the method instead. The `customizer` is bound to `thisArg`
         * and invoked with two argument; (value [, index|key, object]).
         *
         * **Note:** This method is loosely based on the
         * [structured clone algorithm](http://www.w3.org/TR/html5/infrastructure.html#internal-structured-cloning-algorithm).
         * The enumerable properties of `arguments` objects and objects created by
         * constructors other than `Object` are cloned to plain `Object` objects. An
         * empty object is returned for uncloneable values such as functions, DOM nodes,
         * Maps, Sets, and WeakMaps.
         *
         * @static
         * @memberOf _
         * @category Lang
         * @param {*} value The value to deep clone.
         * @param {Function} [customizer] The function to customize cloning values.
         * @param {*} [thisArg] The `this` binding of `customizer`.
         * @returns {*} Returns the deep cloned value.
         * @example
         *
         * var users = [
         *   { 'user': 'barney' },
         *   { 'user': 'fred' }
         * ];
         *
         * var deep = _.cloneDeep(users);
         * deep[0] === users[0];
         * // => false
         *
         * // using a customizer callback
         * var el = _.cloneDeep(document.body, function(value) {
         *   if (_.isElement(value)) {
         *     return value.cloneNode(true);
         *   }
         * });
         *
         * el === document.body
         * // => false
         * el.nodeName
         * // => BODY
         * el.childNodes.length;
         * // => 20
         */
        function cloneDeep(value, customizer, thisArg) {
          return typeof customizer == 'function'
            ? baseClone(value, true, bindCallback(customizer, thisArg, 1))
            : baseClone(value, true);
        }
    
        /**
         * Checks if `value` is greater than `other`.
         *
         * @static
         * @memberOf _
         * @category Lang
         * @param {*} value The value to compare.
         * @param {*} other The other value to compare.
         * @returns {boolean} Returns `true` if `value` is greater than `other`, else `false`.
         * @example
         *
         * _.gt(3, 1);
         * // => true
         *
         * _.gt(3, 3);
         * // => false
         *
         * _.gt(1, 3);
         * // => false
         */
        function gt(value, other) {
          return value > other;
        }
    
        /**
         * Checks if `value` is greater than or equal to `other`.
         *
         * @static
         * @memberOf _
         * @category Lang
         * @param {*} value The value to compare.
         * @param {*} other The other value to compare.
         * @returns {boolean} Returns `true` if `value` is greater than or equal to `other`, else `false`.
         * @example
         *
         * _.gte(3, 1);
         * // => true
         *
         * _.gte(3, 3);
         * // => true
         *
         * _.gte(1, 3);
         * // => false
         */
        function gte(value, other) {
          return value >= other;
        }
    
        /**
         * Checks if `value` is classified as an `arguments` object.
         *
         * @static
         * @memberOf _
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
         * @example
         *
         * _.isArguments(function() { return arguments; }());
         * // => true
         *
         * _.isArguments([1, 2, 3]);
         * // => false
         */
        function isArguments(value) {
          return isObjectLike(value) && isArrayLike(value) &&
            hasOwnProperty.call(value, 'callee') && !propertyIsEnumerable.call(value, 'callee');
        }
    
        /**
         * Checks if `value` is classified as an `Array` object.
         *
         * @static
         * @memberOf _
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
         * @example
         *
         * _.isArray([1, 2, 3]);
         * // => true
         *
         * _.isArray(function() { return arguments; }());
         * // => false
         */
        var isArray = nativeIsArray || function(value) {
          return isObjectLike(value) && isLength(value.length) && objToString.call(value) == arrayTag;
        };
    
        /**
         * Checks if `value` is classified as a boolean primitive or object.
         *
         * @static
         * @memberOf _
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
         * @example
         *
         * _.isBoolean(false);
         * // => true
         *
         * _.isBoolean(null);
         * // => false
         */
        function isBoolean(value) {
          return value === true || value === false || (isObjectLike(value) && objToString.call(value) == boolTag);
        }
    
        /**
         * Checks if `value` is classified as a `Date` object.
         *
         * @static
         * @memberOf _
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
         * @example
         *
         * _.isDate(new Date);
         * // => true
         *
         * _.isDate('Mon April 23 2012');
         * // => false
         */
        function isDate(value) {
          return isObjectLike(value) && objToString.call(value) == dateTag;
        }
    
        /**
         * Checks if `value` is a DOM element.
         *
         * @static
         * @memberOf _
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a DOM element, else `false`.
         * @example
         *
         * _.isElement(document.body);
         * // => true
         *
         * _.isElement('<body>');
         * // => false
         */
        function isElement(value) {
          return !!value && value.nodeType === 1 && isObjectLike(value) && !isPlainObject(value);
        }
    
        /**
         * Checks if `value` is empty. A value is considered empty unless it is an
         * `arguments` object, array, string, or jQuery-like collection with a length
         * greater than `0` or an object with own enumerable properties.
         *
         * @static
         * @memberOf _
         * @category Lang
         * @param {Array|Object|string} value The value to inspect.
         * @returns {boolean} Returns `true` if `value` is empty, else `false`.
         * @example
         *
         * _.isEmpty(null);
         * // => true
         *
         * _.isEmpty(true);
         * // => true
         *
         * _.isEmpty(1);
         * // => true
         *
         * _.isEmpty([1, 2, 3]);
         * // => false
         *
         * _.isEmpty({ 'a': 1 });
         * // => false
         */
        function isEmpty(value) {
          if (value == null) {
            return true;
          }
          if (isArrayLike(value) && (isArray(value) || isString(value) || isArguments(value) ||
              (isObjectLike(value) && isFunction(value.splice)))) {
            return !value.length;
          }
          return !keys(value).length;
        }
    
        /**
         * Performs a deep comparison between two values to determine if they are
         * equivalent. If `customizer` is provided it is invoked to compare values.
         * If `customizer` returns `undefined` comparisons are handled by the method
         * instead. The `customizer` is bound to `thisArg` and invoked with three
         * arguments: (value, other [, index|key]).
         *
         * **Note:** This method supports comparing arrays, booleans, `Date` objects,
         * numbers, `Object` objects, regexes, and strings. Objects are compared by
         * their own, not inherited, enumerable properties. Functions and DOM nodes
         * are **not** supported. Provide a customizer function to extend support
         * for comparing other values.
         *
         * @static
         * @memberOf _
         * @alias eq
         * @category Lang
         * @param {*} value The value to compare.
         * @param {*} other The other value to compare.
         * @param {Function} [customizer] The function to customize value comparisons.
         * @param {*} [thisArg] The `this` binding of `customizer`.
         * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
         * @example
         *
         * var object = { 'user': 'fred' };
         * var other = { 'user': 'fred' };
         *
         * object == other;
         * // => false
         *
         * _.isEqual(object, other);
         * // => true
         *
         * // using a customizer callback
         * var array = ['hello', 'goodbye'];
         * var other = ['hi', 'goodbye'];
         *
         * _.isEqual(array, other, function(value, other) {
         *   if (_.every([value, other], RegExp.prototype.test, /^h(?:i|ello)$/)) {
         *     return true;
         *   }
         * });
         * // => true
         */
        function isEqual(value, other, customizer, thisArg) {
          customizer = typeof customizer == 'function' ? bindCallback(customizer, thisArg, 3) : undefined;
          var result = customizer ? customizer(value, other) : undefined;
          return  result === undefined ? baseIsEqual(value, other, customizer) : !!result;
        }
    
        /**
         * Checks if `value` is an `Error`, `EvalError`, `RangeError`, `ReferenceError`,
         * `SyntaxError`, `TypeError`, or `URIError` object.
         *
         * @static
         * @memberOf _
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is an error object, else `false`.
         * @example
         *
         * _.isError(new Error);
         * // => true
         *
         * _.isError(Error);
         * // => false
         */
        function isError(value) {
          return isObjectLike(value) && typeof value.message == 'string' && objToString.call(value) == errorTag;
        }
    
        /**
         * Checks if `value` is a finite primitive number.
         *
         * **Note:** This method is based on [`Number.isFinite`](http://ecma-international.org/ecma-262/6.0/#sec-number.isfinite).
         *
         * @static
         * @memberOf _
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a finite number, else `false`.
         * @example
         *
         * _.isFinite(10);
         * // => true
         *
         * _.isFinite('10');
         * // => false
         *
         * _.isFinite(true);
         * // => false
         *
         * _.isFinite(Object(10));
         * // => false
         *
         * _.isFinite(Infinity);
         * // => false
         */
        function isFinite(value) {
          return typeof value == 'number' && nativeIsFinite(value);
        }
    
        /**
         * Checks if `value` is classified as a `Function` object.
         *
         * @static
         * @memberOf _
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
         * @example
         *
         * _.isFunction(_);
         * // => true
         *
         * _.isFunction(/abc/);
         * // => false
         */
        function isFunction(value) {
          // The use of `Object#toString` avoids issues with the `typeof` operator
          // in older versions of Chrome and Safari which return 'function' for regexes
          // and Safari 8 equivalents which return 'object' for typed array constructors.
          return isObject(value) && objToString.call(value) == funcTag;
        }
    
        /**
         * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.
         * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
         *
         * @static
         * @memberOf _
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is an object, else `false`.
         * @example
         *
         * _.isObject({});
         * // => true
         *
         * _.isObject([1, 2, 3]);
         * // => true
         *
         * _.isObject(1);
         * // => false
         */
        function isObject(value) {
          // Avoid a V8 JIT bug in Chrome 19-20.
          // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.
          var type = typeof value;
          return !!value && (type == 'object' || type == 'function');
        }
    
        /**
         * Performs a deep comparison between `object` and `source` to determine if
         * `object` contains equivalent property values. If `customizer` is provided
         * it is invoked to compare values. If `customizer` returns `undefined`
         * comparisons are handled by the method instead. The `customizer` is bound
         * to `thisArg` and invoked with three arguments: (value, other, index|key).
         *
         * **Note:** This method supports comparing properties of arrays, booleans,
         * `Date` objects, numbers, `Object` objects, regexes, and strings. Functions
         * and DOM nodes are **not** supported. Provide a customizer function to extend
         * support for comparing other values.
         *
         * @static
         * @memberOf _
         * @category Lang
         * @param {Object} object The object to inspect.
         * @param {Object} source The object of property values to match.
         * @param {Function} [customizer] The function to customize value comparisons.
         * @param {*} [thisArg] The `this` binding of `customizer`.
         * @returns {boolean} Returns `true` if `object` is a match, else `false`.
         * @example
         *
         * var object = { 'user': 'fred', 'age': 40 };
         *
         * _.isMatch(object, { 'age': 40 });
         * // => true
         *
         * _.isMatch(object, { 'age': 36 });
         * // => false
         *
         * // using a customizer callback
         * var object = { 'greeting': 'hello' };
         * var source = { 'greeting': 'hi' };
         *
         * _.isMatch(object, source, function(value, other) {
         *   return _.every([value, other], RegExp.prototype.test, /^h(?:i|ello)$/) || undefined;
         * });
         * // => true
         */
        function isMatch(object, source, customizer, thisArg) {
          customizer = typeof customizer == 'function' ? bindCallback(customizer, thisArg, 3) : undefined;
          return baseIsMatch(object, getMatchData(source), customizer);
        }
    
        /**
         * Checks if `value` is `NaN`.
         *
         * **Note:** This method is not the same as [`isNaN`](https://es5.github.io/#x15.1.2.4)
         * which returns `true` for `undefined` and other non-numeric values.
         *
         * @static
         * @memberOf _
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
         * @example
         *
         * _.isNaN(NaN);
         * // => true
         *
         * _.isNaN(new Number(NaN));
         * // => true
         *
         * isNaN(undefined);
         * // => true
         *
         * _.isNaN(undefined);
         * // => false
         */
        function isNaN(value) {
          // An `NaN` primitive is the only value that is not equal to itself.
          // Perform the `toStringTag` check first to avoid errors with some host objects in IE.
          return isNumber(value) && value != +value;
        }
    
        /**
         * Checks if `value` is a native function.
         *
         * @static
         * @memberOf _
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a native function, else `false`.
         * @example
         *
         * _.isNative(Array.prototype.push);
         * // => true
         *
         * _.isNative(_);
         * // => false
         */
        function isNative(value) {
          if (value == null) {
            return false;
          }
          if (isFunction(value)) {
            return reIsNative.test(fnToString.call(value));
          }
          return isObjectLike(value) && reIsHostCtor.test(value);
        }
    
        /**
         * Checks if `value` is `null`.
         *
         * @static
         * @memberOf _
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is `null`, else `false`.
         * @example
         *
         * _.isNull(null);
         * // => true
         *
         * _.isNull(void 0);
         * // => false
         */
        function isNull(value) {
          return value === null;
        }
    
        /**
         * Checks if `value` is classified as a `Number` primitive or object.
         *
         * **Note:** To exclude `Infinity`, `-Infinity`, and `NaN`, which are classified
         * as numbers, use the `_.isFinite` method.
         *
         * @static
         * @memberOf _
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
         * @example
         *
         * _.isNumber(8.4);
         * // => true
         *
         * _.isNumber(NaN);
         * // => true
         *
         * _.isNumber('8.4');
         * // => false
         */
        function isNumber(value) {
          return typeof value == 'number' || (isObjectLike(value) && objToString.call(value) == numberTag);
        }
    
        /**
         * Checks if `value` is a plain object, that is, an object created by the
         * `Object` constructor or one with a `[[Prototype]]` of `null`.
         *
         * **Note:** This method assumes objects created by the `Object` constructor
         * have no inherited enumerable properties.
         *
         * @static
         * @memberOf _
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
         * @example
         *
         * function Foo() {
         *   this.a = 1;
         * }
         *
         * _.isPlainObject(new Foo);
         * // => false
         *
         * _.isPlainObject([1, 2, 3]);
         * // => false
         *
         * _.isPlainObject({ 'x': 0, 'y': 0 });
         * // => true
         *
         * _.isPlainObject(Object.create(null));
         * // => true
         */
        function isPlainObject(value) {
          var Ctor;
    
          // Exit early for non `Object` objects.
          if (!(isObjectLike(value) && objToString.call(value) == objectTag && !isArguments(value)) ||
              (!hasOwnProperty.call(value, 'constructor') && (Ctor = value.constructor, typeof Ctor == 'function' && !(Ctor instanceof Ctor)))) {
            return false;
          }
          // IE < 9 iterates inherited properties before own properties. If the first
          // iterated property is an object's own property then there are no inherited
          // enumerable properties.
          var result;
          // In most environments an object's own properties are iterated before
          // its inherited properties. If the last iterated property is an object's
          // own property then there are no inherited enumerable properties.
          baseForIn(value, function(subValue, key) {
            result = key;
          });
          return result === undefined || hasOwnProperty.call(value, result);
        }
    
        /**
         * Checks if `value` is classified as a `RegExp` object.
         *
         * @static
         * @memberOf _
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
         * @example
         *
         * _.isRegExp(/abc/);
         * // => true
         *
         * _.isRegExp('/abc/');
         * // => false
         */
        function isRegExp(value) {
          return isObject(value) && objToString.call(value) == regexpTag;
        }
    
        /**
         * Checks if `value` is classified as a `String` primitive or object.
         *
         * @static
         * @memberOf _
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
         * @example
         *
         * _.isString('abc');
         * // => true
         *
         * _.isString(1);
         * // => false
         */
        function isString(value) {
          return typeof value == 'string' || (isObjectLike(value) && objToString.call(value) == stringTag);
        }
    
        /**
         * Checks if `value` is classified as a typed array.
         *
         * @static
         * @memberOf _
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
         * @example
         *
         * _.isTypedArray(new Uint8Array);
         * // => true
         *
         * _.isTypedArray([]);
         * // => false
         */
        function isTypedArray(value) {
          return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[objToString.call(value)];
        }
    
        /**
         * Checks if `value` is `undefined`.
         *
         * @static
         * @memberOf _
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.
         * @example
         *
         * _.isUndefined(void 0);
         * // => true
         *
         * _.isUndefined(null);
         * // => false
         */
        function isUndefined(value) {
          return value === undefined;
        }
    
        /**
         * Checks if `value` is less than `other`.
         *
         * @static
         * @memberOf _
         * @category Lang
         * @param {*} value The value to compare.
         * @param {*} other The other value to compare.
         * @returns {boolean} Returns `true` if `value` is less than `other`, else `false`.
         * @example
         *
         * _.lt(1, 3);
         * // => true
         *
         * _.lt(3, 3);
         * // => false
         *
         * _.lt(3, 1);
         * // => false
         */
        function lt(value, other) {
          return value < other;
        }
    
        /**
         * Checks if `value` is less than or equal to `other`.
         *
         * @static
         * @memberOf _
         * @category Lang
         * @param {*} value The value to compare.
         * @param {*} other The other value to compare.
         * @returns {boolean} Returns `true` if `value` is less than or equal to `other`, else `false`.
         * @example
         *
         * _.lte(1, 3);
         * // => true
         *
         * _.lte(3, 3);
         * // => true
         *
         * _.lte(3, 1);
         * // => false
         */
        function lte(value, other) {
          return value <= other;
        }
    
        /**
         * Converts `value` to an array.
         *
         * @static
         * @memberOf _
         * @category Lang
         * @param {*} value The value to convert.
         * @returns {Array} Returns the converted array.
         * @example
         *
         * (function() {
         *   return _.toArray(arguments).slice(1);
         * }(1, 2, 3));
         * // => [2, 3]
         */
        function toArray(value) {
          var length = value ? getLength(value) : 0;
          if (!isLength(length)) {
            return values(value);
          }
          if (!length) {
            return [];
          }
          return arrayCopy(value);
        }
    
        /**
         * Converts `value` to a plain object flattening inherited enumerable
         * properties of `value` to own properties of the plain object.
         *
         * @static
         * @memberOf _
         * @category Lang
         * @param {*} value The value to convert.
         * @returns {Object} Returns the converted plain object.
         * @example
         *
         * function Foo() {
         *   this.b = 2;
         * }
         *
         * Foo.prototype.c = 3;
         *
         * _.assign({ 'a': 1 }, new Foo);
         * // => { 'a': 1, 'b': 2 }
         *
         * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
         * // => { 'a': 1, 'b': 2, 'c': 3 }
         */
        function toPlainObject(value) {
          return baseCopy(value, keysIn(value));
        }
    
        /*------------------------------------------------------------------------*/
    
        /**
         * Recursively merges own enumerable properties of the source object(s), that
         * don't resolve to `undefined` into the destination object. Subsequent sources
         * overwrite property assignments of previous sources. If `customizer` is
         * provided it is invoked to produce the merged values of the destination and
         * source properties. If `customizer` returns `undefined` merging is handled
         * by the method instead. The `customizer` is bound to `thisArg` and invoked
         * with five arguments: (objectValue, sourceValue, key, object, source).
         *
         * @static
         * @memberOf _
         * @category Object
         * @param {Object} object The destination object.
         * @param {...Object} [sources] The source objects.
         * @param {Function} [customizer] The function to customize assigned values.
         * @param {*} [thisArg] The `this` binding of `customizer`.
         * @returns {Object} Returns `object`.
         * @example
         *
         * var users = {
         *   'data': [{ 'user': 'barney' }, { 'user': 'fred' }]
         * };
         *
         * var ages = {
         *   'data': [{ 'age': 36 }, { 'age': 40 }]
         * };
         *
         * _.merge(users, ages);
         * // => { 'data': [{ 'user': 'barney', 'age': 36 }, { 'user': 'fred', 'age': 40 }] }
         *
         * // using a customizer callback
         * var object = {
         *   'fruits': ['apple'],
         *   'vegetables': ['beet']
         * };
         *
         * var other = {
         *   'fruits': ['banana'],
         *   'vegetables': ['carrot']
         * };
         *
         * _.merge(object, other, function(a, b) {
         *   if (_.isArray(a)) {
         *     return a.concat(b);
         *   }
         * });
         * // => { 'fruits': ['apple', 'banana'], 'vegetables': ['beet', 'carrot'] }
         */
        var merge = createAssigner(baseMerge);
    
        /**
         * Assigns own enumerable properties of source object(s) to the destination
         * object. Subsequent sources overwrite property assignments of previous sources.
         * If `customizer` is provided it is invoked to produce the assigned values.
         * The `customizer` is bound to `thisArg` and invoked with five arguments:
         * (objectValue, sourceValue, key, object, source).
         *
         * **Note:** This method mutates `object` and is based on
         * [`Object.assign`](http://ecma-international.org/ecma-262/6.0/#sec-object.assign).
         *
         * @static
         * @memberOf _
         * @alias extend
         * @category Object
         * @param {Object} object The destination object.
         * @param {...Object} [sources] The source objects.
         * @param {Function} [customizer] The function to customize assigned values.
         * @param {*} [thisArg] The `this` binding of `customizer`.
         * @returns {Object} Returns `object`.
         * @example
         *
         * _.assign({ 'user': 'barney' }, { 'age': 40 }, { 'user': 'fred' });
         * // => { 'user': 'fred', 'age': 40 }
         *
         * // using a customizer callback
         * var defaults = _.partialRight(_.assign, function(value, other) {
         *   return _.isUndefined(value) ? other : value;
         * });
         *
         * defaults({ 'user': 'barney' }, { 'age': 36 }, { 'user': 'fred' });
         * // => { 'user': 'barney', 'age': 36 }
         */
        var assign = createAssigner(function(object, source, customizer) {
          return customizer
            ? assignWith(object, source, customizer)
            : baseAssign(object, source);
        });
    
        /**
         * Creates an object that inherits from the given `prototype` object. If a
         * `properties` object is provided its own enumerable properties are assigned
         * to the created object.
         *
         * @static
         * @memberOf _
         * @category Object
         * @param {Object} prototype The object to inherit from.
         * @param {Object} [properties] The properties to assign to the object.
         * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
         * @returns {Object} Returns the new object.
         * @example
         *
         * function Shape() {
         *   this.x = 0;
         *   this.y = 0;
         * }
         *
         * function Circle() {
         *   Shape.call(this);
         * }
         *
         * Circle.prototype = _.create(Shape.prototype, {
         *   'constructor': Circle
         * });
         *
         * var circle = new Circle;
         * circle instanceof Circle;
         * // => true
         *
         * circle instanceof Shape;
         * // => true
         */
        function create(prototype, properties, guard) {
          var result = baseCreate(prototype);
          if (guard && isIterateeCall(prototype, properties, guard)) {
            properties = undefined;
          }
          return properties ? baseAssign(result, properties) : result;
        }
    
        /**
         * Assigns own enumerable properties of source object(s) to the destination
         * object for all destination properties that resolve to `undefined`. Once a
         * property is set, additional values of the same property are ignored.
         *
         * **Note:** This method mutates `object`.
         *
         * @static
         * @memberOf _
         * @category Object
         * @param {Object} object The destination object.
         * @param {...Object} [sources] The source objects.
         * @returns {Object} Returns `object`.
         * @example
         *
         * _.defaults({ 'user': 'barney' }, { 'age': 36 }, { 'user': 'fred' });
         * // => { 'user': 'barney', 'age': 36 }
         */
        var defaults = createDefaults(assign, assignDefaults);
    
        /**
         * This method is like `_.defaults` except that it recursively assigns
         * default properties.
         *
         * **Note:** This method mutates `object`.
         *
         * @static
         * @memberOf _
         * @category Object
         * @param {Object} object The destination object.
         * @param {...Object} [sources] The source objects.
         * @returns {Object} Returns `object`.
         * @example
         *
         * _.defaultsDeep({ 'user': { 'name': 'barney' } }, { 'user': { 'name': 'fred', 'age': 36 } });
         * // => { 'user': { 'name': 'barney', 'age': 36 } }
         *
         */
        var defaultsDeep = createDefaults(merge, mergeDefaults);
    
        /**
         * This method is like `_.find` except that it returns the key of the first
         * element `predicate` returns truthy for instead of the element itself.
         *
         * If a property name is provided for `predicate` the created `_.property`
         * style callback returns the property value of the given element.
         *
         * If a value is also provided for `thisArg` the created `_.matchesProperty`
         * style callback returns `true` for elements that have a matching property
         * value, else `false`.
         *
         * If an object is provided for `predicate` the created `_.matches` style
         * callback returns `true` for elements that have the properties of the given
         * object, else `false`.
         *
         * @static
         * @memberOf _
         * @category Object
         * @param {Object} object The object to search.
         * @param {Function|Object|string} [predicate=_.identity] The function invoked
         *  per iteration.
         * @param {*} [thisArg] The `this` binding of `predicate`.
         * @returns {string|undefined} Returns the key of the matched element, else `undefined`.
         * @example
         *
         * var users = {
         *   'barney':  { 'age': 36, 'active': true },
         *   'fred':    { 'age': 40, 'active': false },
         *   'pebbles': { 'age': 1,  'active': true }
         * };
         *
         * _.findKey(users, function(chr) {
         *   return chr.age < 40;
         * });
         * // => 'barney' (iteration order is not guaranteed)
         *
         * // using the `_.matches` callback shorthand
         * _.findKey(users, { 'age': 1, 'active': true });
         * // => 'pebbles'
         *
         * // using the `_.matchesProperty` callback shorthand
         * _.findKey(users, 'active', false);
         * // => 'fred'
         *
         * // using the `_.property` callback shorthand
         * _.findKey(users, 'active');
         * // => 'barney'
         */
        var findKey = createFindKey(baseForOwn);
    
        /**
         * This method is like `_.findKey` except that it iterates over elements of
         * a collection in the opposite order.
         *
         * If a property name is provided for `predicate` the created `_.property`
         * style callback returns the property value of the given element.
         *
         * If a value is also provided for `thisArg` the created `_.matchesProperty`
         * style callback returns `true` for elements that have a matching property
         * value, else `false`.
         *
         * If an object is provided for `predicate` the created `_.matches` style
         * callback returns `true` for elements that have the properties of the given
         * object, else `false`.
         *
         * @static
         * @memberOf _
         * @category Object
         * @param {Object} object The object to search.
         * @param {Function|Object|string} [predicate=_.identity] The function invoked
         *  per iteration.
         * @param {*} [thisArg] The `this` binding of `predicate`.
         * @returns {string|undefined} Returns the key of the matched element, else `undefined`.
         * @example
         *
         * var users = {
         *   'barney':  { 'age': 36, 'active': true },
         *   'fred':    { 'age': 40, 'active': false },
         *   'pebbles': { 'age': 1,  'active': true }
         * };
         *
         * _.findLastKey(users, function(chr) {
         *   return chr.age < 40;
         * });
         * // => returns `pebbles` assuming `_.findKey` returns `barney`
         *
         * // using the `_.matches` callback shorthand
         * _.findLastKey(users, { 'age': 36, 'active': true });
         * // => 'barney'
         *
         * // using the `_.matchesProperty` callback shorthand
         * _.findLastKey(users, 'active', false);
         * // => 'fred'
         *
         * // using the `_.property` callback shorthand
         * _.findLastKey(users, 'active');
         * // => 'pebbles'
         */
        var findLastKey = createFindKey(baseForOwnRight);
    
        /**
         * Iterates over own and inherited enumerable properties of an object invoking
         * `iteratee` for each property. The `iteratee` is bound to `thisArg` and invoked
         * with three arguments: (value, key, object). Iteratee functions may exit
         * iteration early by explicitly returning `false`.
         *
         * @static
         * @memberOf _
         * @category Object
         * @param {Object} object The object to iterate over.
         * @param {Function} [iteratee=_.identity] The function invoked per iteration.
         * @param {*} [thisArg] The `this` binding of `iteratee`.
         * @returns {Object} Returns `object`.
         * @example
         *
         * function Foo() {
         *   this.a = 1;
         *   this.b = 2;
         * }
         *
         * Foo.prototype.c = 3;
         *
         * _.forIn(new Foo, function(value, key) {
         *   console.log(key);
         * });
         * // => logs 'a', 'b', and 'c' (iteration order is not guaranteed)
         */
        var forIn = createForIn(baseFor);
    
        /**
         * This method is like `_.forIn` except that it iterates over properties of
         * `object` in the opposite order.
         *
         * @static
         * @memberOf _
         * @category Object
         * @param {Object} object The object to iterate over.
         * @param {Function} [iteratee=_.identity] The function invoked per iteration.
         * @param {*} [thisArg] The `this` binding of `iteratee`.
         * @returns {Object} Returns `object`.
         * @example
         *
         * function Foo() {
         *   this.a = 1;
         *   this.b = 2;
         * }
         *
         * Foo.prototype.c = 3;
         *
         * _.forInRight(new Foo, function(value, key) {
         *   console.log(key);
         * });
         * // => logs 'c', 'b', and 'a' assuming `_.forIn ` logs 'a', 'b', and 'c'
         */
        var forInRight = createForIn(baseForRight);
    
        /**
         * Iterates over own enumerable properties of an object invoking `iteratee`
         * for each property. The `iteratee` is bound to `thisArg` and invoked with
         * three arguments: (value, key, object). Iteratee functions may exit iteration
         * early by explicitly returning `false`.
         *
         * @static
         * @memberOf _
         * @category Object
         * @param {Object} object The object to iterate over.
         * @param {Function} [iteratee=_.identity] The function invoked per iteration.
         * @param {*} [thisArg] The `this` binding of `iteratee`.
         * @returns {Object} Returns `object`.
         * @example
         *
         * function Foo() {
         *   this.a = 1;
         *   this.b = 2;
         * }
         *
         * Foo.prototype.c = 3;
         *
         * _.forOwn(new Foo, function(value, key) {
         *   console.log(key);
         * });
         * // => logs 'a' and 'b' (iteration order is not guaranteed)
         */
        var forOwn = createForOwn(baseForOwn);
    
        /**
         * This method is like `_.forOwn` except that it iterates over properties of
         * `object` in the opposite order.
         *
         * @static
         * @memberOf _
         * @category Object
         * @param {Object} object The object to iterate over.
         * @param {Function} [iteratee=_.identity] The function invoked per iteration.
         * @param {*} [thisArg] The `this` binding of `iteratee`.
         * @returns {Object} Returns `object`.
         * @example
         *
         * function Foo() {
         *   this.a = 1;
         *   this.b = 2;
         * }
         *
         * Foo.prototype.c = 3;
         *
         * _.forOwnRight(new Foo, function(value, key) {
         *   console.log(key);
         * });
         * // => logs 'b' and 'a' assuming `_.forOwn` logs 'a' and 'b'
         */
        var forOwnRight = createForOwn(baseForOwnRight);
    
        /**
         * Creates an array of function property names from all enumerable properties,
         * own and inherited, of `object`.
         *
         * @static
         * @memberOf _
         * @alias methods
         * @category Object
         * @param {Object} object The object to inspect.
         * @returns {Array} Returns the new array of property names.
         * @example
         *
         * _.functions(_);
         * // => ['after', 'ary', 'assign', ...]
         */
        function functions(object) {
          return baseFunctions(object, keysIn(object));
        }
    
        /**
         * Gets the property value at `path` of `object`. If the resolved value is
         * `undefined` the `defaultValue` is used in its place.
         *
         * @static
         * @memberOf _
         * @category Object
         * @param {Object} object The object to query.
         * @param {Array|string} path The path of the property to get.
         * @param {*} [defaultValue] The value returned if the resolved value is `undefined`.
         * @returns {*} Returns the resolved value.
         * @example
         *
         * var object = { 'a': [{ 'b': { 'c': 3 } }] };
         *
         * _.get(object, 'a[0].b.c');
         * // => 3
         *
         * _.get(object, ['a', '0', 'b', 'c']);
         * // => 3
         *
         * _.get(object, 'a.b.c', 'default');
         * // => 'default'
         */
        function get(object, path, defaultValue) {
          var result = object == null ? undefined : baseGet(object, toPath(path), path + '');
          return result === undefined ? defaultValue : result;
        }
    
        /**
         * Checks if `path` is a direct property.
         *
         * @static
         * @memberOf _
         * @category Object
         * @param {Object} object The object to query.
         * @param {Array|string} path The path to check.
         * @returns {boolean} Returns `true` if `path` is a direct property, else `false`.
         * @example
         *
         * var object = { 'a': { 'b': { 'c': 3 } } };
         *
         * _.has(object, 'a');
         * // => true
         *
         * _.has(object, 'a.b.c');
         * // => true
         *
         * _.has(object, ['a', 'b', 'c']);
         * // => true
         */
        function has(object, path) {
          if (object == null) {
            return false;
          }
          var result = hasOwnProperty.call(object, path);
          if (!result && !isKey(path)) {
            path = toPath(path);
            object = path.length == 1 ? object : baseGet(object, baseSlice(path, 0, -1));
            if (object == null) {
              return false;
            }
            path = last(path);
            result = hasOwnProperty.call(object, path);
          }
          return result || (isLength(object.length) && isIndex(path, object.length) &&
            (isArray(object) || isArguments(object)));
        }
    
        /**
         * Creates an object composed of the inverted keys and values of `object`.
         * If `object` contains duplicate values, subsequent values overwrite property
         * assignments of previous values unless `multiValue` is `true`.
         *
         * @static
         * @memberOf _
         * @category Object
         * @param {Object} object The object to invert.
         * @param {boolean} [multiValue] Allow multiple values per key.
         * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
         * @returns {Object} Returns the new inverted object.
         * @example
         *
         * var object = { 'a': 1, 'b': 2, 'c': 1 };
         *
         * _.invert(object);
         * // => { '1': 'c', '2': 'b' }
         *
         * // with `multiValue`
         * _.invert(object, true);
         * // => { '1': ['a', 'c'], '2': ['b'] }
         */
        function invert(object, multiValue, guard) {
          if (guard && isIterateeCall(object, multiValue, guard)) {
            multiValue = undefined;
          }
          var index = -1,
              props = keys(object),
              length = props.length,
              result = {};
    
          while (++index < length) {
            var key = props[index],
                value = object[key];
    
            if (multiValue) {
              if (hasOwnProperty.call(result, value)) {
                result[value].push(key);
              } else {
                result[value] = [key];
              }
            }
            else {
              result[value] = key;
            }
          }
          return result;
        }
    
        /**
         * Creates an array of the own enumerable property names of `object`.
         *
         * **Note:** Non-object values are coerced to objects. See the
         * [ES spec](http://ecma-international.org/ecma-262/6.0/#sec-object.keys)
         * for more details.
         *
         * @static
         * @memberOf _
         * @category Object
         * @param {Object} object The object to query.
         * @returns {Array} Returns the array of property names.
         * @example
         *
         * function Foo() {
         *   this.a = 1;
         *   this.b = 2;
         * }
         *
         * Foo.prototype.c = 3;
         *
         * _.keys(new Foo);
         * // => ['a', 'b'] (iteration order is not guaranteed)
         *
         * _.keys('hi');
         * // => ['0', '1']
         */
        var keys = !nativeKeys ? shimKeys : function(object) {
          var Ctor = object == null ? undefined : object.constructor;
          if ((typeof Ctor == 'function' && Ctor.prototype === object) ||
              (typeof object != 'function' && isArrayLike(object))) {
            return shimKeys(object);
          }
          return isObject(object) ? nativeKeys(object) : [];
        };
    
        /**
         * Creates an array of the own and inherited enumerable property names of `object`.
         *
         * **Note:** Non-object values are coerced to objects.
         *
         * @static
         * @memberOf _
         * @category Object
         * @param {Object} object The object to query.
         * @returns {Array} Returns the array of property names.
         * @example
         *
         * function Foo() {
         *   this.a = 1;
         *   this.b = 2;
         * }
         *
         * Foo.prototype.c = 3;
         *
         * _.keysIn(new Foo);
         * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
         */
        function keysIn(object) {
          if (object == null) {
            return [];
          }
          if (!isObject(object)) {
            object = Object(object);
          }
          var length = object.length;
          length = (length && isLength(length) &&
            (isArray(object) || isArguments(object)) && length) || 0;
    
          var Ctor = object.constructor,
              index = -1,
              isProto = typeof Ctor == 'function' && Ctor.prototype === object,
              result = Array(length),
              skipIndexes = length > 0;
    
          while (++index < length) {
            result[index] = (index + '');
          }
          for (var key in object) {
            if (!(skipIndexes && isIndex(key, length)) &&
                !(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
              result.push(key);
            }
          }
          return result;
        }
    
        /**
         * The opposite of `_.mapValues`; this method creates an object with the
         * same values as `object` and keys generated by running each own enumerable
         * property of `object` through `iteratee`.
         *
         * @static
         * @memberOf _
         * @category Object
         * @param {Object} object The object to iterate over.
         * @param {Function|Object|string} [iteratee=_.identity] The function invoked
         *  per iteration.
         * @param {*} [thisArg] The `this` binding of `iteratee`.
         * @returns {Object} Returns the new mapped object.
         * @example
         *
         * _.mapKeys({ 'a': 1, 'b': 2 }, function(value, key) {
         *   return key + value;
         * });
         * // => { 'a1': 1, 'b2': 2 }
         */
        var mapKeys = createObjectMapper(true);
    
        /**
         * Creates an object with the same keys as `object` and values generated by
         * running each own enumerable property of `object` through `iteratee`. The
         * iteratee function is bound to `thisArg` and invoked with three arguments:
         * (value, key, object).
         *
         * If a property name is provided for `iteratee` the created `_.property`
         * style callback returns the property value of the given element.
         *
         * If a value is also provided for `thisArg` the created `_.matchesProperty`
         * style callback returns `true` for elements that have a matching property
         * value, else `false`.
         *
         * If an object is provided for `iteratee` the created `_.matches` style
         * callback returns `true` for elements that have the properties of the given
         * object, else `false`.
         *
         * @static
         * @memberOf _
         * @category Object
         * @param {Object} object The object to iterate over.
         * @param {Function|Object|string} [iteratee=_.identity] The function invoked
         *  per iteration.
         * @param {*} [thisArg] The `this` binding of `iteratee`.
         * @returns {Object} Returns the new mapped object.
         * @example
         *
         * _.mapValues({ 'a': 1, 'b': 2 }, function(n) {
         *   return n * 3;
         * });
         * // => { 'a': 3, 'b': 6 }
         *
         * var users = {
         *   'fred':    { 'user': 'fred',    'age': 40 },
         *   'pebbles': { 'user': 'pebbles', 'age': 1 }
         * };
         *
         * // using the `_.property` callback shorthand
         * _.mapValues(users, 'age');
         * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
         */
        var mapValues = createObjectMapper();
    
        /**
         * The opposite of `_.pick`; this method creates an object composed of the
         * own and inherited enumerable properties of `object` that are not omitted.
         *
         * @static
         * @memberOf _
         * @category Object
         * @param {Object} object The source object.
         * @param {Function|...(string|string[])} [predicate] The function invoked per
         *  iteration or property names to omit, specified as individual property
         *  names or arrays of property names.
         * @param {*} [thisArg] The `this` binding of `predicate`.
         * @returns {Object} Returns the new object.
         * @example
         *
         * var object = { 'user': 'fred', 'age': 40 };
         *
         * _.omit(object, 'age');
         * // => { 'user': 'fred' }
         *
         * _.omit(object, _.isNumber);
         * // => { 'user': 'fred' }
         */
        var omit = restParam(function(object, props) {
          if (object == null) {
            return {};
          }
          if (typeof props[0] != 'function') {
            var props = arrayMap(baseFlatten(props), String);
            return pickByArray(object, baseDifference(keysIn(object), props));
          }
          var predicate = bindCallback(props[0], props[1], 3);
          return pickByCallback(object, function(value, key, object) {
            return !predicate(value, key, object);
          });
        });
    
        /**
         * Creates a two dimensional array of the key-value pairs for `object`,
         * e.g. `[[key1, value1], [key2, value2]]`.
         *
         * @static
         * @memberOf _
         * @category Object
         * @param {Object} object The object to query.
         * @returns {Array} Returns the new array of key-value pairs.
         * @example
         *
         * _.pairs({ 'barney': 36, 'fred': 40 });
         * // => [['barney', 36], ['fred', 40]] (iteration order is not guaranteed)
         */
        function pairs(object) {
          object = toObject(object);
    
          var index = -1,
              props = keys(object),
              length = props.length,
              result = Array(length);
    
          while (++index < length) {
            var key = props[index];
            result[index] = [key, object[key]];
          }
          return result;
        }
    
        /**
         * Creates an object composed of the picked `object` properties. Property
         * names may be specified as individual arguments or as arrays of property
         * names. If `predicate` is provided it is invoked for each property of `object`
         * picking the properties `predicate` returns truthy for. The predicate is
         * bound to `thisArg` and invoked with three arguments: (value, key, object).
         *
         * @static
         * @memberOf _
         * @category Object
         * @param {Object} object The source object.
         * @param {Function|...(string|string[])} [predicate] The function invoked per
         *  iteration or property names to pick, specified as individual property
         *  names or arrays of property names.
         * @param {*} [thisArg] The `this` binding of `predicate`.
         * @returns {Object} Returns the new object.
         * @example
         *
         * var object = { 'user': 'fred', 'age': 40 };
         *
         * _.pick(object, 'user');
         * // => { 'user': 'fred' }
         *
         * _.pick(object, _.isString);
         * // => { 'user': 'fred' }
         */
        var pick = restParam(function(object, props) {
          if (object == null) {
            return {};
          }
          return typeof props[0] == 'function'
            ? pickByCallback(object, bindCallback(props[0], props[1], 3))
            : pickByArray(object, baseFlatten(props));
        });
    
        /**
         * This method is like `_.get` except that if the resolved value is a function
         * it is invoked with the `this` binding of its parent object and its result
         * is returned.
         *
         * @static
         * @memberOf _
         * @category Object
         * @param {Object} object The object to query.
         * @param {Array|string} path The path of the property to resolve.
         * @param {*} [defaultValue] The value returned if the resolved value is `undefined`.
         * @returns {*} Returns the resolved value.
         * @example
         *
         * var object = { 'a': [{ 'b': { 'c1': 3, 'c2': _.constant(4) } }] };
         *
         * _.result(object, 'a[0].b.c1');
         * // => 3
         *
         * _.result(object, 'a[0].b.c2');
         * // => 4
         *
         * _.result(object, 'a.b.c', 'default');
         * // => 'default'
         *
         * _.result(object, 'a.b.c', _.constant('default'));
         * // => 'default'
         */
        function result(object, path, defaultValue) {
          var result = object == null ? undefined : object[path];
          if (result === undefined) {
            if (object != null && !isKey(path, object)) {
              path = toPath(path);
              object = path.length == 1 ? object : baseGet(object, baseSlice(path, 0, -1));
              result = object == null ? undefined : object[last(path)];
            }
            result = result === undefined ? defaultValue : result;
          }
          return isFunction(result) ? result.call(object) : result;
        }
    
        /**
         * Sets the property value of `path` on `object`. If a portion of `path`
         * does not exist it is created.
         *
         * @static
         * @memberOf _
         * @category Object
         * @param {Object} object The object to augment.
         * @param {Array|string} path The path of the property to set.
         * @param {*} value The value to set.
         * @returns {Object} Returns `object`.
         * @example
         *
         * var object = { 'a': [{ 'b': { 'c': 3 } }] };
         *
         * _.set(object, 'a[0].b.c', 4);
         * console.log(object.a[0].b.c);
         * // => 4
         *
         * _.set(object, 'x[0].y.z', 5);
         * console.log(object.x[0].y.z);
         * // => 5
         */
        function set(object, path, value) {
          if (object == null) {
            return object;
          }
          var pathKey = (path + '');
          path = (object[pathKey] != null || isKey(path, object)) ? [pathKey] : toPath(path);
    
          var index = -1,
              length = path.length,
              lastIndex = length - 1,
              nested = object;
    
          while (nested != null && ++index < length) {
            var key = path[index];
            if (isObject(nested)) {
              if (index == lastIndex) {
                nested[key] = value;
              } else if (nested[key] == null) {
                nested[key] = isIndex(path[index + 1]) ? [] : {};
              }
            }
            nested = nested[key];
          }
          return object;
        }
    
        /**
         * An alternative to `_.reduce`; this method transforms `object` to a new
         * `accumulator` object which is the result of running each of its own enumerable
         * properties through `iteratee`, with each invocation potentially mutating
         * the `accumulator` object. The `iteratee` is bound to `thisArg` and invoked
         * with four arguments: (accumulator, value, key, object). Iteratee functions
         * may exit iteration early by explicitly returning `false`.
         *
         * @static
         * @memberOf _
         * @category Object
         * @param {Array|Object} object The object to iterate over.
         * @param {Function} [iteratee=_.identity] The function invoked per iteration.
         * @param {*} [accumulator] The custom accumulator value.
         * @param {*} [thisArg] The `this` binding of `iteratee`.
         * @returns {*} Returns the accumulated value.
         * @example
         *
         * _.transform([2, 3, 4], function(result, n) {
         *   result.push(n *= n);
         *   return n % 2 == 0;
         * });
         * // => [4, 9]
         *
         * _.transform({ 'a': 1, 'b': 2 }, function(result, n, key) {
         *   result[key] = n * 3;
         * });
         * // => { 'a': 3, 'b': 6 }
         */
        function transform(object, iteratee, accumulator, thisArg) {
          var isArr = isArray(object) || isTypedArray(object);
          iteratee = getCallback(iteratee, thisArg, 4);
    
          if (accumulator == null) {
            if (isArr || isObject(object)) {
              var Ctor = object.constructor;
              if (isArr) {
                accumulator = isArray(object) ? new Ctor : [];
              } else {
                accumulator = baseCreate(isFunction(Ctor) ? Ctor.prototype : undefined);
              }
            } else {
              accumulator = {};
            }
          }
          (isArr ? arrayEach : baseForOwn)(object, function(value, index, object) {
            return iteratee(accumulator, value, index, object);
          });
          return accumulator;
        }
    
        /**
         * Creates an array of the own enumerable property values of `object`.
         *
         * **Note:** Non-object values are coerced to objects.
         *
         * @static
         * @memberOf _
         * @category Object
         * @param {Object} object The object to query.
         * @returns {Array} Returns the array of property values.
         * @example
         *
         * function Foo() {
         *   this.a = 1;
         *   this.b = 2;
         * }
         *
         * Foo.prototype.c = 3;
         *
         * _.values(new Foo);
         * // => [1, 2] (iteration order is not guaranteed)
         *
         * _.values('hi');
         * // => ['h', 'i']
         */
        function values(object) {
          return baseValues(object, keys(object));
        }
    
        /**
         * Creates an array of the own and inherited enumerable property values
         * of `object`.
         *
         * **Note:** Non-object values are coerced to objects.
         *
         * @static
         * @memberOf _
         * @category Object
         * @param {Object} object The object to query.
         * @returns {Array} Returns the array of property values.
         * @example
         *
         * function Foo() {
         *   this.a = 1;
         *   this.b = 2;
         * }
         *
         * Foo.prototype.c = 3;
         *
         * _.valuesIn(new Foo);
         * // => [1, 2, 3] (iteration order is not guaranteed)
         */
        function valuesIn(object) {
          return baseValues(object, keysIn(object));
        }
    
        /*------------------------------------------------------------------------*/
    
        /**
         * Checks if `n` is between `start` and up to but not including, `end`. If
         * `end` is not specified it is set to `start` with `start` then set to `0`.
         *
         * @static
         * @memberOf _
         * @category Number
         * @param {number} n The number to check.
         * @param {number} [start=0] The start of the range.
         * @param {number} end The end of the range.
         * @returns {boolean} Returns `true` if `n` is in the range, else `false`.
         * @example
         *
         * _.inRange(3, 2, 4);
         * // => true
         *
         * _.inRange(4, 8);
         * // => true
         *
         * _.inRange(4, 2);
         * // => false
         *
         * _.inRange(2, 2);
         * // => false
         *
         * _.inRange(1.2, 2);
         * // => true
         *
         * _.inRange(5.2, 4);
         * // => false
         */
        function inRange(value, start, end) {
          start = +start || 0;
          if (end === undefined) {
            end = start;
            start = 0;
          } else {
            end = +end || 0;
          }
          return value >= nativeMin(start, end) && value < nativeMax(start, end);
        }
    
        /**
         * Produces a random number between `min` and `max` (inclusive). If only one
         * argument is provided a number between `0` and the given number is returned.
         * If `floating` is `true`, or either `min` or `max` are floats, a floating-point
         * number is returned instead of an integer.
         *
         * @static
         * @memberOf _
         * @category Number
         * @param {number} [min=0] The minimum possible value.
         * @param {number} [max=1] The maximum possible value.
         * @param {boolean} [floating] Specify returning a floating-point number.
         * @returns {number} Returns the random number.
         * @example
         *
         * _.random(0, 5);
         * // => an integer between 0 and 5
         *
         * _.random(5);
         * // => also an integer between 0 and 5
         *
         * _.random(5, true);
         * // => a floating-point number between 0 and 5
         *
         * _.random(1.2, 5.2);
         * // => a floating-point number between 1.2 and 5.2
         */
        function random(min, max, floating) {
          if (floating && isIterateeCall(min, max, floating)) {
            max = floating = undefined;
          }
          var noMin = min == null,
              noMax = max == null;
    
          if (floating == null) {
            if (noMax && typeof min == 'boolean') {
              floating = min;
              min = 1;
            }
            else if (typeof max == 'boolean') {
              floating = max;
              noMax = true;
            }
          }
          if (noMin && noMax) {
            max = 1;
            noMax = false;
          }
          min = +min || 0;
          if (noMax) {
            max = min;
            min = 0;
          } else {
            max = +max || 0;
          }
          if (floating || min % 1 || max % 1) {
            var rand = nativeRandom();
            return nativeMin(min + (rand * (max - min + parseFloat('1e-' + ((rand + '').length - 1)))), max);
          }
          return baseRandom(min, max);
        }
    
        /*------------------------------------------------------------------------*/
    
        /**
         * Converts `string` to [camel case](https://en.wikipedia.org/wiki/CamelCase).
         *
         * @static
         * @memberOf _
         * @category String
         * @param {string} [string=''] The string to convert.
         * @returns {string} Returns the camel cased string.
         * @example
         *
         * _.camelCase('Foo Bar');
         * // => 'fooBar'
         *
         * _.camelCase('--foo-bar');
         * // => 'fooBar'
         *
         * _.camelCase('__foo_bar__');
         * // => 'fooBar'
         */
        var camelCase = createCompounder(function(result, word, index) {
          word = word.toLowerCase();
          return result + (index ? (word.charAt(0).toUpperCase() + word.slice(1)) : word);
        });
    
        /**
         * Capitalizes the first character of `string`.
         *
         * @static
         * @memberOf _
         * @category String
         * @param {string} [string=''] The string to capitalize.
         * @returns {string} Returns the capitalized string.
         * @example
         *
         * _.capitalize('fred');
         * // => 'Fred'
         */
        function capitalize(string) {
          string = baseToString(string);
          return string && (string.charAt(0).toUpperCase() + string.slice(1));
        }
    
        /**
         * Deburrs `string` by converting [latin-1 supplementary letters](https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)#Character_table)
         * to basic latin letters and removing [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks).
         *
         * @static
         * @memberOf _
         * @category String
         * @param {string} [string=''] The string to deburr.
         * @returns {string} Returns the deburred string.
         * @example
         *
         * _.deburr('déjà vu');
         * // => 'deja vu'
         */
        function deburr(string) {
          string = baseToString(string);
          return string && string.replace(reLatin1, deburrLetter).replace(reComboMark, '');
        }
    
        /**
         * Checks if `string` ends with the given target string.
         *
         * @static
         * @memberOf _
         * @category String
         * @param {string} [string=''] The string to search.
         * @param {string} [target] The string to search for.
         * @param {number} [position=string.length] The position to search from.
         * @returns {boolean} Returns `true` if `string` ends with `target`, else `false`.
         * @example
         *
         * _.endsWith('abc', 'c');
         * // => true
         *
         * _.endsWith('abc', 'b');
         * // => false
         *
         * _.endsWith('abc', 'b', 2);
         * // => true
         */
        function endsWith(string, target, position) {
          string = baseToString(string);
          target = (target + '');
    
          var length = string.length;
          position = position === undefined
            ? length
            : nativeMin(position < 0 ? 0 : (+position || 0), length);
    
          position -= target.length;
          return position >= 0 && string.indexOf(target, position) == position;
        }
    
        /**
         * Converts the characters "&", "<", ">", '"', "'", and "\`", in `string` to
         * their corresponding HTML entities.
         *
         * **Note:** No other characters are escaped. To escape additional characters
         * use a third-party library like [_he_](https://mths.be/he).
         *
         * Though the ">" character is escaped for symmetry, characters like
         * ">" and "/" don't need escaping in HTML and have no special meaning
         * unless they're part of a tag or unquoted attribute value.
         * See [Mathias Bynens's article](https://mathiasbynens.be/notes/ambiguous-ampersands)
         * (under "semi-related fun fact") for more details.
         *
         * Backticks are escaped because in Internet Explorer < 9, they can break out
         * of attribute values or HTML comments. See [#59](https://html5sec.org/#59),
         * [#102](https://html5sec.org/#102), [#108](https://html5sec.org/#108), and
         * [#133](https://html5sec.org/#133) of the [HTML5 Security Cheatsheet](https://html5sec.org/)
         * for more details.
         *
         * When working with HTML you should always [quote attribute values](http://wonko.com/post/html-escaping)
         * to reduce XSS vectors.
         *
         * @static
         * @memberOf _
         * @category String
         * @param {string} [string=''] The string to escape.
         * @returns {string} Returns the escaped string.
         * @example
         *
         * _.escape('fred, barney, & pebbles');
         * // => 'fred, barney, &amp; pebbles'
         */
        function escape(string) {
          // Reset `lastIndex` because in IE < 9 `String#replace` does not.
          string = baseToString(string);
          return (string && reHasUnescapedHtml.test(string))
            ? string.replace(reUnescapedHtml, escapeHtmlChar)
            : string;
        }
    
        /**
         * Escapes the `RegExp` special characters "\", "/", "^", "$", ".", "|", "?",
         * "*", "+", "(", ")", "[", "]", "{" and "}" in `string`.
         *
         * @static
         * @memberOf _
         * @category String
         * @param {string} [string=''] The string to escape.
         * @returns {string} Returns the escaped string.
         * @example
         *
         * _.escapeRegExp('[lodash](https://lodash.com/)');
         * // => '\[lodash\]\(https:\/\/lodash\.com\/\)'
         */
        function escapeRegExp(string) {
          string = baseToString(string);
          return (string && reHasRegExpChars.test(string))
            ? string.replace(reRegExpChars, escapeRegExpChar)
            : (string || '(?:)');
        }
    
        /**
         * Converts `string` to [kebab case](https://en.wikipedia.org/wiki/Letter_case#Special_case_styles).
         *
         * @static
         * @memberOf _
         * @category String
         * @param {string} [string=''] The string to convert.
         * @returns {string} Returns the kebab cased string.
         * @example
         *
         * _.kebabCase('Foo Bar');
         * // => 'foo-bar'
         *
         * _.kebabCase('fooBar');
         * // => 'foo-bar'
         *
         * _.kebabCase('__foo_bar__');
         * // => 'foo-bar'
         */
        var kebabCase = createCompounder(function(result, word, index) {
          return result + (index ? '-' : '') + word.toLowerCase();
        });
    
        /**
         * Pads `string` on the left and right sides if it's shorter than `length`.
         * Padding characters are truncated if they can't be evenly divided by `length`.
         *
         * @static
         * @memberOf _
         * @category String
         * @param {string} [string=''] The string to pad.
         * @param {number} [length=0] The padding length.
         * @param {string} [chars=' '] The string used as padding.
         * @returns {string} Returns the padded string.
         * @example
         *
         * _.pad('abc', 8);
         * // => '  abc   '
         *
         * _.pad('abc', 8, '_-');
         * // => '_-abc_-_'
         *
         * _.pad('abc', 3);
         * // => 'abc'
         */
        function pad(string, length, chars) {
          string = baseToString(string);
          length = +length;
    
          var strLength = string.length;
          if (strLength >= length || !nativeIsFinite(length)) {
            return string;
          }
          var mid = (length - strLength) / 2,
              leftLength = nativeFloor(mid),
              rightLength = nativeCeil(mid);
    
          chars = createPadding('', rightLength, chars);
          return chars.slice(0, leftLength) + string + chars;
        }
    
        /**
         * Pads `string` on the left side if it's shorter than `length`. Padding
         * characters are truncated if they exceed `length`.
         *
         * @static
         * @memberOf _
         * @category String
         * @param {string} [string=''] The string to pad.
         * @param {number} [length=0] The padding length.
         * @param {string} [chars=' '] The string used as padding.
         * @returns {string} Returns the padded string.
         * @example
         *
         * _.padLeft('abc', 6);
         * // => '   abc'
         *
         * _.padLeft('abc', 6, '_-');
         * // => '_-_abc'
         *
         * _.padLeft('abc', 3);
         * // => 'abc'
         */
        var padLeft = createPadDir();
    
        /**
         * Pads `string` on the right side if it's shorter than `length`. Padding
         * characters are truncated if they exceed `length`.
         *
         * @static
         * @memberOf _
         * @category String
         * @param {string} [string=''] The string to pad.
         * @param {number} [length=0] The padding length.
         * @param {string} [chars=' '] The string used as padding.
         * @returns {string} Returns the padded string.
         * @example
         *
         * _.padRight('abc', 6);
         * // => 'abc   '
         *
         * _.padRight('abc', 6, '_-');
         * // => 'abc_-_'
         *
         * _.padRight('abc', 3);
         * // => 'abc'
         */
        var padRight = createPadDir(true);
    
        /**
         * Converts `string` to an integer of the specified radix. If `radix` is
         * `undefined` or `0`, a `radix` of `10` is used unless `value` is a hexadecimal,
         * in which case a `radix` of `16` is used.
         *
         * **Note:** This method aligns with the [ES5 implementation](https://es5.github.io/#E)
         * of `parseInt`.
         *
         * @static
         * @memberOf _
         * @category String
         * @param {string} string The string to convert.
         * @param {number} [radix] The radix to interpret `value` by.
         * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
         * @returns {number} Returns the converted integer.
         * @example
         *
         * _.parseInt('08');
         * // => 8
         *
         * _.map(['6', '08', '10'], _.parseInt);
         * // => [6, 8, 10]
         */
        function parseInt(string, radix, guard) {
          // Firefox < 21 and Opera < 15 follow ES3 for `parseInt`.
          // Chrome fails to trim leading <BOM> whitespace characters.
          // See https://code.google.com/p/v8/issues/detail?id=3109 for more details.
          if (guard ? isIterateeCall(string, radix, guard) : radix == null) {
            radix = 0;
          } else if (radix) {
            radix = +radix;
          }
          string = trim(string);
          return nativeParseInt(string, radix || (reHasHexPrefix.test(string) ? 16 : 10));
        }
    
        /**
         * Repeats the given string `n` times.
         *
         * @static
         * @memberOf _
         * @category String
         * @param {string} [string=''] The string to repeat.
         * @param {number} [n=0] The number of times to repeat the string.
         * @returns {string} Returns the repeated string.
         * @example
         *
         * _.repeat('*', 3);
         * // => '***'
         *
         * _.repeat('abc', 2);
         * // => 'abcabc'
         *
         * _.repeat('abc', 0);
         * // => ''
         */
        function repeat(string, n) {
          var result = '';
          string = baseToString(string);
          n = +n;
          if (n < 1 || !string || !nativeIsFinite(n)) {
            return result;
          }
          // Leverage the exponentiation by squaring algorithm for a faster repeat.
          // See https://en.wikipedia.org/wiki/Exponentiation_by_squaring for more details.
          do {
            if (n % 2) {
              result += string;
            }
            n = nativeFloor(n / 2);
            string += string;
          } while (n);
    
          return result;
        }
    
        /**
         * Converts `string` to [snake case](https://en.wikipedia.org/wiki/Snake_case).
         *
         * @static
         * @memberOf _
         * @category String
         * @param {string} [string=''] The string to convert.
         * @returns {string} Returns the snake cased string.
         * @example
         *
         * _.snakeCase('Foo Bar');
         * // => 'foo_bar'
         *
         * _.snakeCase('fooBar');
         * // => 'foo_bar'
         *
         * _.snakeCase('--foo-bar');
         * // => 'foo_bar'
         */
        var snakeCase = createCompounder(function(result, word, index) {
          return result + (index ? '_' : '') + word.toLowerCase();
        });
    
        /**
         * Converts `string` to [start case](https://en.wikipedia.org/wiki/Letter_case#Stylistic_or_specialised_usage).
         *
         * @static
         * @memberOf _
         * @category String
         * @param {string} [string=''] The string to convert.
         * @returns {string} Returns the start cased string.
         * @example
         *
         * _.startCase('--foo-bar');
         * // => 'Foo Bar'
         *
         * _.startCase('fooBar');
         * // => 'Foo Bar'
         *
         * _.startCase('__foo_bar__');
         * // => 'Foo Bar'
         */
        var startCase = createCompounder(function(result, word, index) {
          return result + (index ? ' ' : '') + (word.charAt(0).toUpperCase() + word.slice(1));
        });
    
        /**
         * Checks if `string` starts with the given target string.
         *
         * @static
         * @memberOf _
         * @category String
         * @param {string} [string=''] The string to search.
         * @param {string} [target] The string to search for.
         * @param {number} [position=0] The position to search from.
         * @returns {boolean} Returns `true` if `string` starts with `target`, else `false`.
         * @example
         *
         * _.startsWith('abc', 'a');
         * // => true
         *
         * _.startsWith('abc', 'b');
         * // => false
         *
         * _.startsWith('abc', 'b', 1);
         * // => true
         */
        function startsWith(string, target, position) {
          string = baseToString(string);
          position = position == null
            ? 0
            : nativeMin(position < 0 ? 0 : (+position || 0), string.length);
    
          return string.lastIndexOf(target, position) == position;
        }
    
        /**
         * Creates a compiled template function that can interpolate data properties
         * in "interpolate" delimiters, HTML-escape interpolated data properties in
         * "escape" delimiters, and execute JavaScript in "evaluate" delimiters. Data
         * properties may be accessed as free variables in the template. If a setting
         * object is provided it takes precedence over `_.templateSettings` values.
         *
         * **Note:** In the development build `_.template` utilizes
         * [sourceURLs](http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl)
         * for easier debugging.
         *
         * For more information on precompiling templates see
         * [lodash's custom builds documentation](https://lodash.com/custom-builds).
         *
         * For more information on Chrome extension sandboxes see
         * [Chrome's extensions documentation](https://developer.chrome.com/extensions/sandboxingEval).
         *
         * @static
         * @memberOf _
         * @category String
         * @param {string} [string=''] The template string.
         * @param {Object} [options] The options object.
         * @param {RegExp} [options.escape] The HTML "escape" delimiter.
         * @param {RegExp} [options.evaluate] The "evaluate" delimiter.
         * @param {Object} [options.imports] An object to import into the template as free variables.
         * @param {RegExp} [options.interpolate] The "interpolate" delimiter.
         * @param {string} [options.sourceURL] The sourceURL of the template's compiled source.
         * @param {string} [options.variable] The data object variable name.
         * @param- {Object} [otherOptions] Enables the legacy `options` param signature.
         * @returns {Function} Returns the compiled template function.
         * @example
         *
         * // using the "interpolate" delimiter to create a compiled template
         * var compiled = _.template('hello <%= user %>!');
         * compiled({ 'user': 'fred' });
         * // => 'hello fred!'
         *
         * // using the HTML "escape" delimiter to escape data property values
         * var compiled = _.template('<b><%- value %></b>');
         * compiled({ 'value': '<script>' });
         * // => '<b>&lt;script&gt;</b>'
         *
         * // using the "evaluate" delimiter to execute JavaScript and generate HTML
         * var compiled = _.template('<% _.forEach(users, function(user) { %><li><%- user %></li><% }); %>');
         * compiled({ 'users': ['fred', 'barney'] });
         * // => '<li>fred</li><li>barney</li>'
         *
         * // using the internal `print` function in "evaluate" delimiters
         * var compiled = _.template('<% print("hello " + user); %>!');
         * compiled({ 'user': 'barney' });
         * // => 'hello barney!'
         *
         * // using the ES delimiter as an alternative to the default "interpolate" delimiter
         * var compiled = _.template('hello ${ user }!');
         * compiled({ 'user': 'pebbles' });
         * // => 'hello pebbles!'
         *
         * // using custom template delimiters
         * _.templateSettings.interpolate = /{{([\s\S]+?)}}/g;
         * var compiled = _.template('hello {{ user }}!');
         * compiled({ 'user': 'mustache' });
         * // => 'hello mustache!'
         *
         * // using backslashes to treat delimiters as plain text
         * var compiled = _.template('<%= "\\<%- value %\\>" %>');
         * compiled({ 'value': 'ignored' });
         * // => '<%- value %>'
         *
         * // using the `imports` option to import `jQuery` as `jq`
         * var text = '<% jq.each(users, function(user) { %><li><%- user %></li><% }); %>';
         * var compiled = _.template(text, { 'imports': { 'jq': jQuery } });
         * compiled({ 'users': ['fred', 'barney'] });
         * // => '<li>fred</li><li>barney</li>'
         *
         * // using the `sourceURL` option to specify a custom sourceURL for the template
         * var compiled = _.template('hello <%= user %>!', { 'sourceURL': '/basic/greeting.jst' });
         * compiled(data);
         * // => find the source of "greeting.jst" under the Sources tab or Resources panel of the web inspector
         *
         * // using the `variable` option to ensure a with-statement isn't used in the compiled template
         * var compiled = _.template('hi <%= data.user %>!', { 'variable': 'data' });
         * compiled.source;
         * // => function(data) {
         * //   var __t, __p = '';
         * //   __p += 'hi ' + ((__t = ( data.user )) == null ? '' : __t) + '!';
         * //   return __p;
         * // }
         *
         * // using the `source` property to inline compiled templates for meaningful
         * // line numbers in error messages and a stack trace
         * fs.writeFileSync(path.join(cwd, 'jst.js'), '\
         *   var JST = {\
         *     "main": ' + _.template(mainText).source + '\
         *   };\
         * ');
         */
        function template(string, options, otherOptions) {
          // Based on John Resig's `tmpl` implementation (http://ejohn.org/blog/javascript-micro-templating/)
          // and Laura Doktorova's doT.js (https://github.com/olado/doT).
          var settings = lodash.templateSettings;
    
          if (otherOptions && isIterateeCall(string, options, otherOptions)) {
            options = otherOptions = undefined;
          }
          string = baseToString(string);
          options = assignWith(baseAssign({}, otherOptions || options), settings, assignOwnDefaults);
    
          var imports = assignWith(baseAssign({}, options.imports), settings.imports, assignOwnDefaults),
              importsKeys = keys(imports),
              importsValues = baseValues(imports, importsKeys);
    
          var isEscaping,
              isEvaluating,
              index = 0,
              interpolate = options.interpolate || reNoMatch,
              source = "__p += '";
    
          // Compile the regexp to match each delimiter.
          var reDelimiters = RegExp(
            (options.escape || reNoMatch).source + '|' +
            interpolate.source + '|' +
            (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + '|' +
            (options.evaluate || reNoMatch).source + '|$'
          , 'g');
    
          // Use a sourceURL for easier debugging.
          var sourceURL = '//# sourceURL=' +
            ('sourceURL' in options
              ? options.sourceURL
              : ('lodash.templateSources[' + (++templateCounter) + ']')
            ) + '\n';
    
          string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
            interpolateValue || (interpolateValue = esTemplateValue);
    
            // Escape characters that can't be included in string literals.
            source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);
    
            // Replace delimiters with snippets.
            if (escapeValue) {
              isEscaping = true;
              source += "' +\n__e(" + escapeValue + ") +\n'";
            }
            if (evaluateValue) {
              isEvaluating = true;
              source += "';\n" + evaluateValue + ";\n__p += '";
            }
            if (interpolateValue) {
              source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
            }
            index = offset + match.length;
    
            // The JS engine embedded in Adobe products requires returning the `match`
            // string in order to produce the correct `offset` value.
            return match;
          });
    
          source += "';\n";
    
          // If `variable` is not specified wrap a with-statement around the generated
          // code to add the data object to the top of the scope chain.
          var variable = options.variable;
          if (!variable) {
            source = 'with (obj) {\n' + source + '\n}\n';
          }
          // Cleanup code by stripping empty strings.
          source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source)
            .replace(reEmptyStringMiddle, '$1')
            .replace(reEmptyStringTrailing, '$1;');
    
          // Frame code as the function body.
          source = 'function(' + (variable || 'obj') + ') {\n' +
            (variable
              ? ''
              : 'obj || (obj = {});\n'
            ) +
            "var __t, __p = ''" +
            (isEscaping
               ? ', __e = _.escape'
               : ''
            ) +
            (isEvaluating
              ? ', __j = Array.prototype.join;\n' +
                "function print() { __p += __j.call(arguments, '') }\n"
              : ';\n'
            ) +
            source +
            'return __p\n}';
    
          var result = attempt(function() {
            return Function(importsKeys, sourceURL + 'return ' + source).apply(undefined, importsValues);
          });
    
          // Provide the compiled function's source by its `toString` method or
          // the `source` property as a convenience for inlining compiled templates.
          result.source = source;
          if (isError(result)) {
            throw result;
          }
          return result;
        }
    
        /**
         * Removes leading and trailing whitespace or specified characters from `string`.
         *
         * @static
         * @memberOf _
         * @category String
         * @param {string} [string=''] The string to trim.
         * @param {string} [chars=whitespace] The characters to trim.
         * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
         * @returns {string} Returns the trimmed string.
         * @example
         *
         * _.trim('  abc  ');
         * // => 'abc'
         *
         * _.trim('-_-abc-_-', '_-');
         * // => 'abc'
         *
         * _.map(['  foo  ', '  bar  '], _.trim);
         * // => ['foo', 'bar']
         */
        function trim(string, chars, guard) {
          var value = string;
          string = baseToString(string);
          if (!string) {
            return string;
          }
          if (guard ? isIterateeCall(value, chars, guard) : chars == null) {
            return string.slice(trimmedLeftIndex(string), trimmedRightIndex(string) + 1);
          }
          chars = (chars + '');
          return string.slice(charsLeftIndex(string, chars), charsRightIndex(string, chars) + 1);
        }
    
        /**
         * Removes leading whitespace or specified characters from `string`.
         *
         * @static
         * @memberOf _
         * @category String
         * @param {string} [string=''] The string to trim.
         * @param {string} [chars=whitespace] The characters to trim.
         * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
         * @returns {string} Returns the trimmed string.
         * @example
         *
         * _.trimLeft('  abc  ');
         * // => 'abc  '
         *
         * _.trimLeft('-_-abc-_-', '_-');
         * // => 'abc-_-'
         */
        function trimLeft(string, chars, guard) {
          var value = string;
          string = baseToString(string);
          if (!string) {
            return string;
          }
          if (guard ? isIterateeCall(value, chars, guard) : chars == null) {
            return string.slice(trimmedLeftIndex(string));
          }
          return string.slice(charsLeftIndex(string, (chars + '')));
        }
    
        /**
         * Removes trailing whitespace or specified characters from `string`.
         *
         * @static
         * @memberOf _
         * @category String
         * @param {string} [string=''] The string to trim.
         * @param {string} [chars=whitespace] The characters to trim.
         * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
         * @returns {string} Returns the trimmed string.
         * @example
         *
         * _.trimRight('  abc  ');
         * // => '  abc'
         *
         * _.trimRight('-_-abc-_-', '_-');
         * // => '-_-abc'
         */
        function trimRight(string, chars, guard) {
          var value = string;
          string = baseToString(string);
          if (!string) {
            return string;
          }
          if (guard ? isIterateeCall(value, chars, guard) : chars == null) {
            return string.slice(0, trimmedRightIndex(string) + 1);
          }
          return string.slice(0, charsRightIndex(string, (chars + '')) + 1);
        }
    
        /**
         * Truncates `string` if it's longer than the given maximum string length.
         * The last characters of the truncated string are replaced with the omission
         * string which defaults to "...".
         *
         * @static
         * @memberOf _
         * @category String
         * @param {string} [string=''] The string to truncate.
         * @param {Object|number} [options] The options object or maximum string length.
         * @param {number} [options.length=30] The maximum string length.
         * @param {string} [options.omission='...'] The string to indicate text is omitted.
         * @param {RegExp|string} [options.separator] The separator pattern to truncate to.
         * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
         * @returns {string} Returns the truncated string.
         * @example
         *
         * _.trunc('hi-diddly-ho there, neighborino');
         * // => 'hi-diddly-ho there, neighbo...'
         *
         * _.trunc('hi-diddly-ho there, neighborino', 24);
         * // => 'hi-diddly-ho there, n...'
         *
         * _.trunc('hi-diddly-ho there, neighborino', {
         *   'length': 24,
         *   'separator': ' '
         * });
         * // => 'hi-diddly-ho there,...'
         *
         * _.trunc('hi-diddly-ho there, neighborino', {
         *   'length': 24,
         *   'separator': /,? +/
         * });
         * // => 'hi-diddly-ho there...'
         *
         * _.trunc('hi-diddly-ho there, neighborino', {
         *   'omission': ' [...]'
         * });
         * // => 'hi-diddly-ho there, neig [...]'
         */
        function trunc(string, options, guard) {
          if (guard && isIterateeCall(string, options, guard)) {
            options = undefined;
          }
          var length = DEFAULT_TRUNC_LENGTH,
              omission = DEFAULT_TRUNC_OMISSION;
    
          if (options != null) {
            if (isObject(options)) {
              var separator = 'separator' in options ? options.separator : separator;
              length = 'length' in options ? (+options.length || 0) : length;
              omission = 'omission' in options ? baseToString(options.omission) : omission;
            } else {
              length = +options || 0;
            }
          }
          string = baseToString(string);
          if (length >= string.length) {
            return string;
          }
          var end = length - omission.length;
          if (end < 1) {
            return omission;
          }
          var result = string.slice(0, end);
          if (separator == null) {
            return result + omission;
          }
          if (isRegExp(separator)) {
            if (string.slice(end).search(separator)) {
              var match,
                  newEnd,
                  substring = string.slice(0, end);
    
              if (!separator.global) {
                separator = RegExp(separator.source, (reFlags.exec(separator) || '') + 'g');
              }
              separator.lastIndex = 0;
              while ((match = separator.exec(substring))) {
                newEnd = match.index;
              }
              result = result.slice(0, newEnd == null ? end : newEnd);
            }
          } else if (string.indexOf(separator, end) != end) {
            var index = result.lastIndexOf(separator);
            if (index > -1) {
              result = result.slice(0, index);
            }
          }
          return result + omission;
        }
    
        /**
         * The inverse of `_.escape`; this method converts the HTML entities
         * `&amp;`, `&lt;`, `&gt;`, `&quot;`, `&#39;`, and `&#96;` in `string` to their
         * corresponding characters.
         *
         * **Note:** No other HTML entities are unescaped. To unescape additional HTML
         * entities use a third-party library like [_he_](https://mths.be/he).
         *
         * @static
         * @memberOf _
         * @category String
         * @param {string} [string=''] The string to unescape.
         * @returns {string} Returns the unescaped string.
         * @example
         *
         * _.unescape('fred, barney, &amp; pebbles');
         * // => 'fred, barney, & pebbles'
         */
        function unescape(string) {
          string = baseToString(string);
          return (string && reHasEscapedHtml.test(string))
            ? string.replace(reEscapedHtml, unescapeHtmlChar)
            : string;
        }
    
        /**
         * Splits `string` into an array of its words.
         *
         * @static
         * @memberOf _
         * @category String
         * @param {string} [string=''] The string to inspect.
         * @param {RegExp|string} [pattern] The pattern to match words.
         * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
         * @returns {Array} Returns the words of `string`.
         * @example
         *
         * _.words('fred, barney, & pebbles');
         * // => ['fred', 'barney', 'pebbles']
         *
         * _.words('fred, barney, & pebbles', /[^, ]+/g);
         * // => ['fred', 'barney', '&', 'pebbles']
         */
        function words(string, pattern, guard) {
          if (guard && isIterateeCall(string, pattern, guard)) {
            pattern = undefined;
          }
          string = baseToString(string);
          return string.match(pattern || reWords) || [];
        }
    
        /*------------------------------------------------------------------------*/
    
        /**
         * Attempts to invoke `func`, returning either the result or the caught error
         * object. Any additional arguments are provided to `func` when it is invoked.
         *
         * @static
         * @memberOf _
         * @category Utility
         * @param {Function} func The function to attempt.
         * @returns {*} Returns the `func` result or error object.
         * @example
         *
         * // avoid throwing errors for invalid selectors
         * var elements = _.attempt(function(selector) {
         *   return document.querySelectorAll(selector);
         * }, '>_>');
         *
         * if (_.isError(elements)) {
         *   elements = [];
         * }
         */
        var attempt = restParam(function(func, args) {
          try {
            return func.apply(undefined, args);
          } catch(e) {
            return isError(e) ? e : new Error(e);
          }
        });
    
        /**
         * Creates a function that invokes `func` with the `this` binding of `thisArg`
         * and arguments of the created function. If `func` is a property name the
         * created callback returns the property value for a given element. If `func`
         * is an object the created callback returns `true` for elements that contain
         * the equivalent object properties, otherwise it returns `false`.
         *
         * @static
         * @memberOf _
         * @alias iteratee
         * @category Utility
         * @param {*} [func=_.identity] The value to convert to a callback.
         * @param {*} [thisArg] The `this` binding of `func`.
         * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
         * @returns {Function} Returns the callback.
         * @example
         *
         * var users = [
         *   { 'user': 'barney', 'age': 36 },
         *   { 'user': 'fred',   'age': 40 }
         * ];
         *
         * // wrap to create custom callback shorthands
         * _.callback = _.wrap(_.callback, function(callback, func, thisArg) {
         *   var match = /^(.+?)__([gl]t)(.+)$/.exec(func);
         *   if (!match) {
         *     return callback(func, thisArg);
         *   }
         *   return function(object) {
         *     return match[2] == 'gt'
         *       ? object[match[1]] > match[3]
         *       : object[match[1]] < match[3];
         *   };
         * });
         *
         * _.filter(users, 'age__gt36');
         * // => [{ 'user': 'fred', 'age': 40 }]
         */
        function callback(func, thisArg, guard) {
          if (guard && isIterateeCall(func, thisArg, guard)) {
            thisArg = undefined;
          }
          return isObjectLike(func)
            ? matches(func)
            : baseCallback(func, thisArg);
        }
    
        /**
         * Creates a function that returns `value`.
         *
         * @static
         * @memberOf _
         * @category Utility
         * @param {*} value The value to return from the new function.
         * @returns {Function} Returns the new function.
         * @example
         *
         * var object = { 'user': 'fred' };
         * var getter = _.constant(object);
         *
         * getter() === object;
         * // => true
         */
        function constant(value) {
          return function() {
            return value;
          };
        }
    
        /**
         * This method returns the first argument provided to it.
         *
         * @static
         * @memberOf _
         * @category Utility
         * @param {*} value Any value.
         * @returns {*} Returns `value`.
         * @example
         *
         * var object = { 'user': 'fred' };
         *
         * _.identity(object) === object;
         * // => true
         */
        function identity(value) {
          return value;
        }
    
        /**
         * Creates a function that performs a deep comparison between a given object
         * and `source`, returning `true` if the given object has equivalent property
         * values, else `false`.
         *
         * **Note:** This method supports comparing arrays, booleans, `Date` objects,
         * numbers, `Object` objects, regexes, and strings. Objects are compared by
         * their own, not inherited, enumerable properties. For comparing a single
         * own or inherited property value see `_.matchesProperty`.
         *
         * @static
         * @memberOf _
         * @category Utility
         * @param {Object} source The object of property values to match.
         * @returns {Function} Returns the new function.
         * @example
         *
         * var users = [
         *   { 'user': 'barney', 'age': 36, 'active': true },
         *   { 'user': 'fred',   'age': 40, 'active': false }
         * ];
         *
         * _.filter(users, _.matches({ 'age': 40, 'active': false }));
         * // => [{ 'user': 'fred', 'age': 40, 'active': false }]
         */
        function matches(source) {
          return baseMatches(baseClone(source, true));
        }
    
        /**
         * Creates a function that compares the property value of `path` on a given
         * object to `value`.
         *
         * **Note:** This method supports comparing arrays, booleans, `Date` objects,
         * numbers, `Object` objects, regexes, and strings. Objects are compared by
         * their own, not inherited, enumerable properties.
         *
         * @static
         * @memberOf _
         * @category Utility
         * @param {Array|string} path The path of the property to get.
         * @param {*} srcValue The value to match.
         * @returns {Function} Returns the new function.
         * @example
         *
         * var users = [
         *   { 'user': 'barney' },
         *   { 'user': 'fred' }
         * ];
         *
         * _.find(users, _.matchesProperty('user', 'fred'));
         * // => { 'user': 'fred' }
         */
        function matchesProperty(path, srcValue) {
          return baseMatchesProperty(path, baseClone(srcValue, true));
        }
    
        /**
         * Creates a function that invokes the method at `path` on a given object.
         * Any additional arguments are provided to the invoked method.
         *
         * @static
         * @memberOf _
         * @category Utility
         * @param {Array|string} path The path of the method to invoke.
         * @param {...*} [args] The arguments to invoke the method with.
         * @returns {Function} Returns the new function.
         * @example
         *
         * var objects = [
         *   { 'a': { 'b': { 'c': _.constant(2) } } },
         *   { 'a': { 'b': { 'c': _.constant(1) } } }
         * ];
         *
         * _.map(objects, _.method('a.b.c'));
         * // => [2, 1]
         *
         * _.invoke(_.sortBy(objects, _.method(['a', 'b', 'c'])), 'a.b.c');
         * // => [1, 2]
         */
        var method = restParam(function(path, args) {
          return function(object) {
            return invokePath(object, path, args);
          };
        });
    
        /**
         * The opposite of `_.method`; this method creates a function that invokes
         * the method at a given path on `object`. Any additional arguments are
         * provided to the invoked method.
         *
         * @static
         * @memberOf _
         * @category Utility
         * @param {Object} object The object to query.
         * @param {...*} [args] The arguments to invoke the method with.
         * @returns {Function} Returns the new function.
         * @example
         *
         * var array = _.times(3, _.constant),
         *     object = { 'a': array, 'b': array, 'c': array };
         *
         * _.map(['a[2]', 'c[0]'], _.methodOf(object));
         * // => [2, 0]
         *
         * _.map([['a', '2'], ['c', '0']], _.methodOf(object));
         * // => [2, 0]
         */
        var methodOf = restParam(function(object, args) {
          return function(path) {
            return invokePath(object, path, args);
          };
        });
    
        /**
         * Adds all own enumerable function properties of a source object to the
         * destination object. If `object` is a function then methods are added to
         * its prototype as well.
         *
         * **Note:** Use `_.runInContext` to create a pristine `lodash` function to
         * avoid conflicts caused by modifying the original.
         *
         * @static
         * @memberOf _
         * @category Utility
         * @param {Function|Object} [object=lodash] The destination object.
         * @param {Object} source The object of functions to add.
         * @param {Object} [options] The options object.
         * @param {boolean} [options.chain=true] Specify whether the functions added
         *  are chainable.
         * @returns {Function|Object} Returns `object`.
         * @example
         *
         * function vowels(string) {
         *   return _.filter(string, function(v) {
         *     return /[aeiou]/i.test(v);
         *   });
         * }
         *
         * _.mixin({ 'vowels': vowels });
         * _.vowels('fred');
         * // => ['e']
         *
         * _('fred').vowels().value();
         * // => ['e']
         *
         * _.mixin({ 'vowels': vowels }, { 'chain': false });
         * _('fred').vowels();
         * // => ['e']
         */
        function mixin(object, source, options) {
          if (options == null) {
            var isObj = isObject(source),
                props = isObj ? keys(source) : undefined,
                methodNames = (props && props.length) ? baseFunctions(source, props) : undefined;
    
            if (!(methodNames ? methodNames.length : isObj)) {
              methodNames = false;
              options = source;
              source = object;
              object = this;
            }
          }
          if (!methodNames) {
            methodNames = baseFunctions(source, keys(source));
          }
          var chain = true,
              index = -1,
              isFunc = isFunction(object),
              length = methodNames.length;
    
          if (options === false) {
            chain = false;
          } else if (isObject(options) && 'chain' in options) {
            chain = options.chain;
          }
          while (++index < length) {
            var methodName = methodNames[index],
                func = source[methodName];
    
            object[methodName] = func;
            if (isFunc) {
              object.prototype[methodName] = (function(func) {
                return function() {
                  var chainAll = this.__chain__;
                  if (chain || chainAll) {
                    var result = object(this.__wrapped__),
                        actions = result.__actions__ = arrayCopy(this.__actions__);
    
                    actions.push({ 'func': func, 'args': arguments, 'thisArg': object });
                    result.__chain__ = chainAll;
                    return result;
                  }
                  return func.apply(object, arrayPush([this.value()], arguments));
                };
              }(func));
            }
          }
          return object;
        }
    
        /**
         * Reverts the `_` variable to its previous value and returns a reference to
         * the `lodash` function.
         *
         * @static
         * @memberOf _
         * @category Utility
         * @returns {Function} Returns the `lodash` function.
         * @example
         *
         * var lodash = _.noConflict();
         */
        function noConflict() {
          root._ = oldDash;
          return this;
        }
    
        /**
         * A no-operation function that returns `undefined` regardless of the
         * arguments it receives.
         *
         * @static
         * @memberOf _
         * @category Utility
         * @example
         *
         * var object = { 'user': 'fred' };
         *
         * _.noop(object) === undefined;
         * // => true
         */
        function noop() {
          // No operation performed.
        }
    
        /**
         * Creates a function that returns the property value at `path` on a
         * given object.
         *
         * @static
         * @memberOf _
         * @category Utility
         * @param {Array|string} path The path of the property to get.
         * @returns {Function} Returns the new function.
         * @example
         *
         * var objects = [
         *   { 'a': { 'b': { 'c': 2 } } },
         *   { 'a': { 'b': { 'c': 1 } } }
         * ];
         *
         * _.map(objects, _.property('a.b.c'));
         * // => [2, 1]
         *
         * _.pluck(_.sortBy(objects, _.property(['a', 'b', 'c'])), 'a.b.c');
         * // => [1, 2]
         */
        function property(path) {
          return isKey(path) ? baseProperty(path) : basePropertyDeep(path);
        }
    
        /**
         * The opposite of `_.property`; this method creates a function that returns
         * the property value at a given path on `object`.
         *
         * @static
         * @memberOf _
         * @category Utility
         * @param {Object} object The object to query.
         * @returns {Function} Returns the new function.
         * @example
         *
         * var array = [0, 1, 2],
         *     object = { 'a': array, 'b': array, 'c': array };
         *
         * _.map(['a[2]', 'c[0]'], _.propertyOf(object));
         * // => [2, 0]
         *
         * _.map([['a', '2'], ['c', '0']], _.propertyOf(object));
         * // => [2, 0]
         */
        function propertyOf(object) {
          return function(path) {
            return baseGet(object, toPath(path), path + '');
          };
        }
    
        /**
         * Creates an array of numbers (positive and/or negative) progressing from
         * `start` up to, but not including, `end`. If `end` is not specified it is
         * set to `start` with `start` then set to `0`. If `end` is less than `start`
         * a zero-length range is created unless a negative `step` is specified.
         *
         * @static
         * @memberOf _
         * @category Utility
         * @param {number} [start=0] The start of the range.
         * @param {number} end The end of the range.
         * @param {number} [step=1] The value to increment or decrement by.
         * @returns {Array} Returns the new array of numbers.
         * @example
         *
         * _.range(4);
         * // => [0, 1, 2, 3]
         *
         * _.range(1, 5);
         * // => [1, 2, 3, 4]
         *
         * _.range(0, 20, 5);
         * // => [0, 5, 10, 15]
         *
         * _.range(0, -4, -1);
         * // => [0, -1, -2, -3]
         *
         * _.range(1, 4, 0);
         * // => [1, 1, 1]
         *
         * _.range(0);
         * // => []
         */
        function range(start, end, step) {
          if (step && isIterateeCall(start, end, step)) {
            end = step = undefined;
          }
          start = +start || 0;
          step = step == null ? 1 : (+step || 0);
    
          if (end == null) {
            end = start;
            start = 0;
          } else {
            end = +end || 0;
          }
          // Use `Array(length)` so engines like Chakra and V8 avoid slower modes.
          // See https://youtu.be/XAqIpGU8ZZk#t=17m25s for more details.
          var index = -1,
              length = nativeMax(nativeCeil((end - start) / (step || 1)), 0),
              result = Array(length);
    
          while (++index < length) {
            result[index] = start;
            start += step;
          }
          return result;
        }
    
        /**
         * Invokes the iteratee function `n` times, returning an array of the results
         * of each invocation. The `iteratee` is bound to `thisArg` and invoked with
         * one argument; (index).
         *
         * @static
         * @memberOf _
         * @category Utility
         * @param {number} n The number of times to invoke `iteratee`.
         * @param {Function} [iteratee=_.identity] The function invoked per iteration.
         * @param {*} [thisArg] The `this` binding of `iteratee`.
         * @returns {Array} Returns the array of results.
         * @example
         *
         * var diceRolls = _.times(3, _.partial(_.random, 1, 6, false));
         * // => [3, 6, 4]
         *
         * _.times(3, function(n) {
         *   mage.castSpell(n);
         * });
         * // => invokes `mage.castSpell(n)` three times with `n` of `0`, `1`, and `2`
         *
         * _.times(3, function(n) {
         *   this.cast(n);
         * }, mage);
         * // => also invokes `mage.castSpell(n)` three times
         */
        function times(n, iteratee, thisArg) {
          n = nativeFloor(n);
    
          // Exit early to avoid a JSC JIT bug in Safari 8
          // where `Array(0)` is treated as `Array(1)`.
          if (n < 1 || !nativeIsFinite(n)) {
            return [];
          }
          var index = -1,
              result = Array(nativeMin(n, MAX_ARRAY_LENGTH));
    
          iteratee = bindCallback(iteratee, thisArg, 1);
          while (++index < n) {
            if (index < MAX_ARRAY_LENGTH) {
              result[index] = iteratee(index);
            } else {
              iteratee(index);
            }
          }
          return result;
        }
    
        /**
         * Generates a unique ID. If `prefix` is provided the ID is appended to it.
         *
         * @static
         * @memberOf _
         * @category Utility
         * @param {string} [prefix] The value to prefix the ID with.
         * @returns {string} Returns the unique ID.
         * @example
         *
         * _.uniqueId('contact_');
         * // => 'contact_104'
         *
         * _.uniqueId();
         * // => '105'
         */
        function uniqueId(prefix) {
          var id = ++idCounter;
          return baseToString(prefix) + id;
        }
    
        /*------------------------------------------------------------------------*/
    
        /**
         * Adds two numbers.
         *
         * @static
         * @memberOf _
         * @category Math
         * @param {number} augend The first number to add.
         * @param {number} addend The second number to add.
         * @returns {number} Returns the sum.
         * @example
         *
         * _.add(6, 4);
         * // => 10
         */
        function add(augend, addend) {
          return (+augend || 0) + (+addend || 0);
        }
    
        /**
         * Calculates `n` rounded up to `precision`.
         *
         * @static
         * @memberOf _
         * @category Math
         * @param {number} n The number to round up.
         * @param {number} [precision=0] The precision to round up to.
         * @returns {number} Returns the rounded up number.
         * @example
         *
         * _.ceil(4.006);
         * // => 5
         *
         * _.ceil(6.004, 2);
         * // => 6.01
         *
         * _.ceil(6040, -2);
         * // => 6100
         */
        var ceil = createRound('ceil');
    
        /**
         * Calculates `n` rounded down to `precision`.
         *
         * @static
         * @memberOf _
         * @category Math
         * @param {number} n The number to round down.
         * @param {number} [precision=0] The precision to round down to.
         * @returns {number} Returns the rounded down number.
         * @example
         *
         * _.floor(4.006);
         * // => 4
         *
         * _.floor(0.046, 2);
         * // => 0.04
         *
         * _.floor(4060, -2);
         * // => 4000
         */
        var floor = createRound('floor');
    
        /**
         * Gets the maximum value of `collection`. If `collection` is empty or falsey
         * `-Infinity` is returned. If an iteratee function is provided it is invoked
         * for each value in `collection` to generate the criterion by which the value
         * is ranked. The `iteratee` is bound to `thisArg` and invoked with three
         * arguments: (value, index, collection).
         *
         * If a property name is provided for `iteratee` the created `_.property`
         * style callback returns the property value of the given element.
         *
         * If a value is also provided for `thisArg` the created `_.matchesProperty`
         * style callback returns `true` for elements that have a matching property
         * value, else `false`.
         *
         * If an object is provided for `iteratee` the created `_.matches` style
         * callback returns `true` for elements that have the properties of the given
         * object, else `false`.
         *
         * @static
         * @memberOf _
         * @category Math
         * @param {Array|Object|string} collection The collection to iterate over.
         * @param {Function|Object|string} [iteratee] The function invoked per iteration.
         * @param {*} [thisArg] The `this` binding of `iteratee`.
         * @returns {*} Returns the maximum value.
         * @example
         *
         * _.max([4, 2, 8, 6]);
         * // => 8
         *
         * _.max([]);
         * // => -Infinity
         *
         * var users = [
         *   { 'user': 'barney', 'age': 36 },
         *   { 'user': 'fred',   'age': 40 }
         * ];
         *
         * _.max(users, function(chr) {
         *   return chr.age;
         * });
         * // => { 'user': 'fred', 'age': 40 }
         *
         * // using the `_.property` callback shorthand
         * _.max(users, 'age');
         * // => { 'user': 'fred', 'age': 40 }
         */
        var max = createExtremum(gt, NEGATIVE_INFINITY);
    
        /**
         * Gets the minimum value of `collection`. If `collection` is empty or falsey
         * `Infinity` is returned. If an iteratee function is provided it is invoked
         * for each value in `collection` to generate the criterion by which the value
         * is ranked. The `iteratee` is bound to `thisArg` and invoked with three
         * arguments: (value, index, collection).
         *
         * If a property name is provided for `iteratee` the created `_.property`
         * style callback returns the property value of the given element.
         *
         * If a value is also provided for `thisArg` the created `_.matchesProperty`
         * style callback returns `true` for elements that have a matching property
         * value, else `false`.
         *
         * If an object is provided for `iteratee` the created `_.matches` style
         * callback returns `true` for elements that have the properties of the given
         * object, else `false`.
         *
         * @static
         * @memberOf _
         * @category Math
         * @param {Array|Object|string} collection The collection to iterate over.
         * @param {Function|Object|string} [iteratee] The function invoked per iteration.
         * @param {*} [thisArg] The `this` binding of `iteratee`.
         * @returns {*} Returns the minimum value.
         * @example
         *
         * _.min([4, 2, 8, 6]);
         * // => 2
         *
         * _.min([]);
         * // => Infinity
         *
         * var users = [
         *   { 'user': 'barney', 'age': 36 },
         *   { 'user': 'fred',   'age': 40 }
         * ];
         *
         * _.min(users, function(chr) {
         *   return chr.age;
         * });
         * // => { 'user': 'barney', 'age': 36 }
         *
         * // using the `_.property` callback shorthand
         * _.min(users, 'age');
         * // => { 'user': 'barney', 'age': 36 }
         */
        var min = createExtremum(lt, POSITIVE_INFINITY);
    
        /**
         * Calculates `n` rounded to `precision`.
         *
         * @static
         * @memberOf _
         * @category Math
         * @param {number} n The number to round.
         * @param {number} [precision=0] The precision to round to.
         * @returns {number} Returns the rounded number.
         * @example
         *
         * _.round(4.006);
         * // => 4
         *
         * _.round(4.006, 2);
         * // => 4.01
         *
         * _.round(4060, -2);
         * // => 4100
         */
        var round = createRound('round');
    
        /**
         * Gets the sum of the values in `collection`.
         *
         * @static
         * @memberOf _
         * @category Math
         * @param {Array|Object|string} collection The collection to iterate over.
         * @param {Function|Object|string} [iteratee] The function invoked per iteration.
         * @param {*} [thisArg] The `this` binding of `iteratee`.
         * @returns {number} Returns the sum.
         * @example
         *
         * _.sum([4, 6]);
         * // => 10
         *
         * _.sum({ 'a': 4, 'b': 6 });
         * // => 10
         *
         * var objects = [
         *   { 'n': 4 },
         *   { 'n': 6 }
         * ];
         *
         * _.sum(objects, function(object) {
         *   return object.n;
         * });
         * // => 10
         *
         * // using the `_.property` callback shorthand
         * _.sum(objects, 'n');
         * // => 10
         */
        function sum(collection, iteratee, thisArg) {
          if (thisArg && isIterateeCall(collection, iteratee, thisArg)) {
            iteratee = undefined;
          }
          iteratee = getCallback(iteratee, thisArg, 3);
          return iteratee.length == 1
            ? arraySum(isArray(collection) ? collection : toIterable(collection), iteratee)
            : baseSum(collection, iteratee);
        }
    
        /*------------------------------------------------------------------------*/
    
        // Ensure wrappers are instances of `baseLodash`.
        lodash.prototype = baseLodash.prototype;
    
        LodashWrapper.prototype = baseCreate(baseLodash.prototype);
        LodashWrapper.prototype.constructor = LodashWrapper;
    
        LazyWrapper.prototype = baseCreate(baseLodash.prototype);
        LazyWrapper.prototype.constructor = LazyWrapper;
    
        // Add functions to the `Map` cache.
        MapCache.prototype['delete'] = mapDelete;
        MapCache.prototype.get = mapGet;
        MapCache.prototype.has = mapHas;
        MapCache.prototype.set = mapSet;
    
        // Add functions to the `Set` cache.
        SetCache.prototype.push = cachePush;
    
        // Assign cache to `_.memoize`.
        memoize.Cache = MapCache;
    
        // Add functions that return wrapped values when chaining.
        lodash.after = after;
        lodash.ary = ary;
        lodash.assign = assign;
        lodash.at = at;
        lodash.before = before;
        lodash.bind = bind;
        lodash.bindAll = bindAll;
        lodash.bindKey = bindKey;
        lodash.callback = callback;
        lodash.chain = chain;
        lodash.chunk = chunk;
        lodash.compact = compact;
        lodash.constant = constant;
        lodash.countBy = countBy;
        lodash.create = create;
        lodash.curry = curry;
        lodash.curryRight = curryRight;
        lodash.debounce = debounce;
        lodash.defaults = defaults;
        lodash.defaultsDeep = defaultsDeep;
        lodash.defer = defer;
        lodash.delay = delay;
        lodash.difference = difference;
        lodash.drop = drop;
        lodash.dropRight = dropRight;
        lodash.dropRightWhile = dropRightWhile;
        lodash.dropWhile = dropWhile;
        lodash.fill = fill;
        lodash.filter = filter;
        lodash.flatten = flatten;
        lodash.flattenDeep = flattenDeep;
        lodash.flow = flow;
        lodash.flowRight = flowRight;
        lodash.forEach = forEach;
        lodash.forEachRight = forEachRight;
        lodash.forIn = forIn;
        lodash.forInRight = forInRight;
        lodash.forOwn = forOwn;
        lodash.forOwnRight = forOwnRight;
        lodash.functions = functions;
        lodash.groupBy = groupBy;
        lodash.indexBy = indexBy;
        lodash.initial = initial;
        lodash.intersection = intersection;
        lodash.invert = invert;
        lodash.invoke = invoke;
        lodash.keys = keys;
        lodash.keysIn = keysIn;
        lodash.map = map;
        lodash.mapKeys = mapKeys;
        lodash.mapValues = mapValues;
        lodash.matches = matches;
        lodash.matchesProperty = matchesProperty;
        lodash.memoize = memoize;
        lodash.merge = merge;
        lodash.method = method;
        lodash.methodOf = methodOf;
        lodash.mixin = mixin;
        lodash.modArgs = modArgs;
        lodash.negate = negate;
        lodash.omit = omit;
        lodash.once = once;
        lodash.pairs = pairs;
        lodash.partial = partial;
        lodash.partialRight = partialRight;
        lodash.partition = partition;
        lodash.pick = pick;
        lodash.pluck = pluck;
        lodash.property = property;
        lodash.propertyOf = propertyOf;
        lodash.pull = pull;
        lodash.pullAt = pullAt;
        lodash.range = range;
        lodash.rearg = rearg;
        lodash.reject = reject;
        lodash.remove = remove;
        lodash.rest = rest;
        lodash.restParam = restParam;
        lodash.set = set;
        lodash.shuffle = shuffle;
        lodash.slice = slice;
        lodash.sortBy = sortBy;
        lodash.sortByAll = sortByAll;
        lodash.sortByOrder = sortByOrder;
        lodash.spread = spread;
        lodash.take = take;
        lodash.takeRight = takeRight;
        lodash.takeRightWhile = takeRightWhile;
        lodash.takeWhile = takeWhile;
        lodash.tap = tap;
        lodash.throttle = throttle;
        lodash.thru = thru;
        lodash.times = times;
        lodash.toArray = toArray;
        lodash.toPlainObject = toPlainObject;
        lodash.transform = transform;
        lodash.union = union;
        lodash.uniq = uniq;
        lodash.unzip = unzip;
        lodash.unzipWith = unzipWith;
        lodash.values = values;
        lodash.valuesIn = valuesIn;
        lodash.where = where;
        lodash.without = without;
        lodash.wrap = wrap;
        lodash.xor = xor;
        lodash.zip = zip;
        lodash.zipObject = zipObject;
        lodash.zipWith = zipWith;
    
        // Add aliases.
        lodash.backflow = flowRight;
        lodash.collect = map;
        lodash.compose = flowRight;
        lodash.each = forEach;
        lodash.eachRight = forEachRight;
        lodash.extend = assign;
        lodash.iteratee = callback;
        lodash.methods = functions;
        lodash.object = zipObject;
        lodash.select = filter;
        lodash.tail = rest;
        lodash.unique = uniq;
    
        // Add functions to `lodash.prototype`.
        mixin(lodash, lodash);
    
        /*------------------------------------------------------------------------*/
    
        // Add functions that return unwrapped values when chaining.
        lodash.add = add;
        lodash.attempt = attempt;
        lodash.camelCase = camelCase;
        lodash.capitalize = capitalize;
        lodash.ceil = ceil;
        lodash.clone = clone;
        lodash.cloneDeep = cloneDeep;
        lodash.deburr = deburr;
        lodash.endsWith = endsWith;
        lodash.escape = escape;
        lodash.escapeRegExp = escapeRegExp;
        lodash.every = every;
        lodash.find = find;
        lodash.findIndex = findIndex;
        lodash.findKey = findKey;
        lodash.findLast = findLast;
        lodash.findLastIndex = findLastIndex;
        lodash.findLastKey = findLastKey;
        lodash.findWhere = findWhere;
        lodash.first = first;
        lodash.floor = floor;
        lodash.get = get;
        lodash.gt = gt;
        lodash.gte = gte;
        lodash.has = has;
        lodash.identity = identity;
        lodash.includes = includes;
        lodash.indexOf = indexOf;
        lodash.inRange = inRange;
        lodash.isArguments = isArguments;
        lodash.isArray = isArray;
        lodash.isBoolean = isBoolean;
        lodash.isDate = isDate;
        lodash.isElement = isElement;
        lodash.isEmpty = isEmpty;
        lodash.isEqual = isEqual;
        lodash.isError = isError;
        lodash.isFinite = isFinite;
        lodash.isFunction = isFunction;
        lodash.isMatch = isMatch;
        lodash.isNaN = isNaN;
        lodash.isNative = isNative;
        lodash.isNull = isNull;
        lodash.isNumber = isNumber;
        lodash.isObject = isObject;
        lodash.isPlainObject = isPlainObject;
        lodash.isRegExp = isRegExp;
        lodash.isString = isString;
        lodash.isTypedArray = isTypedArray;
        lodash.isUndefined = isUndefined;
        lodash.kebabCase = kebabCase;
        lodash.last = last;
        lodash.lastIndexOf = lastIndexOf;
        lodash.lt = lt;
        lodash.lte = lte;
        lodash.max = max;
        lodash.min = min;
        lodash.noConflict = noConflict;
        lodash.noop = noop;
        lodash.now = now;
        lodash.pad = pad;
        lodash.padLeft = padLeft;
        lodash.padRight = padRight;
        lodash.parseInt = parseInt;
        lodash.random = random;
        lodash.reduce = reduce;
        lodash.reduceRight = reduceRight;
        lodash.repeat = repeat;
        lodash.result = result;
        lodash.round = round;
        lodash.runInContext = runInContext;
        lodash.size = size;
        lodash.snakeCase = snakeCase;
        lodash.some = some;
        lodash.sortedIndex = sortedIndex;
        lodash.sortedLastIndex = sortedLastIndex;
        lodash.startCase = startCase;
        lodash.startsWith = startsWith;
        lodash.sum = sum;
        lodash.template = template;
        lodash.trim = trim;
        lodash.trimLeft = trimLeft;
        lodash.trimRight = trimRight;
        lodash.trunc = trunc;
        lodash.unescape = unescape;
        lodash.uniqueId = uniqueId;
        lodash.words = words;
    
        // Add aliases.
        lodash.all = every;
        lodash.any = some;
        lodash.contains = includes;
        lodash.eq = isEqual;
        lodash.detect = find;
        lodash.foldl = reduce;
        lodash.foldr = reduceRight;
        lodash.head = first;
        lodash.include = includes;
        lodash.inject = reduce;
    
        mixin(lodash, (function() {
          var source = {};
          baseForOwn(lodash, function(func, methodName) {
            if (!lodash.prototype[methodName]) {
              source[methodName] = func;
            }
          });
          return source;
        }()), false);
    
        /*------------------------------------------------------------------------*/
    
        // Add functions capable of returning wrapped and unwrapped values when chaining.
        lodash.sample = sample;
    
        lodash.prototype.sample = function(n) {
          if (!this.__chain__ && n == null) {
            return sample(this.value());
          }
          return this.thru(function(value) {
            return sample(value, n);
          });
        };
    
        /*------------------------------------------------------------------------*/
    
        /**
         * The semantic version number.
         *
         * @static
         * @memberOf _
         * @type string
         */
        lodash.VERSION = VERSION;
    
        // Assign default placeholders.
        arrayEach(['bind', 'bindKey', 'curry', 'curryRight', 'partial', 'partialRight'], function(methodName) {
          lodash[methodName].placeholder = lodash;
        });
    
        // Add `LazyWrapper` methods for `_.drop` and `_.take` variants.
        arrayEach(['drop', 'take'], function(methodName, index) {
          LazyWrapper.prototype[methodName] = function(n) {
            var filtered = this.__filtered__;
            if (filtered && !index) {
              return new LazyWrapper(this);
            }
            n = n == null ? 1 : nativeMax(nativeFloor(n) || 0, 0);
    
            var result = this.clone();
            if (filtered) {
              result.__takeCount__ = nativeMin(result.__takeCount__, n);
            } else {
              result.__views__.push({ 'size': n, 'type': methodName + (result.__dir__ < 0 ? 'Right' : '') });
            }
            return result;
          };
    
          LazyWrapper.prototype[methodName + 'Right'] = function(n) {
            return this.reverse()[methodName](n).reverse();
          };
        });
    
        // Add `LazyWrapper` methods that accept an `iteratee` value.
        arrayEach(['filter', 'map', 'takeWhile'], function(methodName, index) {
          var type = index + 1,
              isFilter = type != LAZY_MAP_FLAG;
    
          LazyWrapper.prototype[methodName] = function(iteratee, thisArg) {
            var result = this.clone();
            result.__iteratees__.push({ 'iteratee': getCallback(iteratee, thisArg, 1), 'type': type });
            result.__filtered__ = result.__filtered__ || isFilter;
            return result;
          };
        });
    
        // Add `LazyWrapper` methods for `_.first` and `_.last`.
        arrayEach(['first', 'last'], function(methodName, index) {
          var takeName = 'take' + (index ? 'Right' : '');
    
          LazyWrapper.prototype[methodName] = function() {
            return this[takeName](1).value()[0];
          };
        });
    
        // Add `LazyWrapper` methods for `_.initial` and `_.rest`.
        arrayEach(['initial', 'rest'], function(methodName, index) {
          var dropName = 'drop' + (index ? '' : 'Right');
    
          LazyWrapper.prototype[methodName] = function() {
            return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
          };
        });
    
        // Add `LazyWrapper` methods for `_.pluck` and `_.where`.
        arrayEach(['pluck', 'where'], function(methodName, index) {
          var operationName = index ? 'filter' : 'map',
              createCallback = index ? baseMatches : property;
    
          LazyWrapper.prototype[methodName] = function(value) {
            return this[operationName](createCallback(value));
          };
        });
    
        LazyWrapper.prototype.compact = function() {
          return this.filter(identity);
        };
    
        LazyWrapper.prototype.reject = function(predicate, thisArg) {
          predicate = getCallback(predicate, thisArg, 1);
          return this.filter(function(value) {
            return !predicate(value);
          });
        };
    
        LazyWrapper.prototype.slice = function(start, end) {
          start = start == null ? 0 : (+start || 0);
    
          var result = this;
          if (result.__filtered__ && (start > 0 || end < 0)) {
            return new LazyWrapper(result);
          }
          if (start < 0) {
            result = result.takeRight(-start);
          } else if (start) {
            result = result.drop(start);
          }
          if (end !== undefined) {
            end = (+end || 0);
            result = end < 0 ? result.dropRight(-end) : result.take(end - start);
          }
          return result;
        };
    
        LazyWrapper.prototype.takeRightWhile = function(predicate, thisArg) {
          return this.reverse().takeWhile(predicate, thisArg).reverse();
        };
    
        LazyWrapper.prototype.toArray = function() {
          return this.take(POSITIVE_INFINITY);
        };
    
        // Add `LazyWrapper` methods to `lodash.prototype`.
        baseForOwn(LazyWrapper.prototype, function(func, methodName) {
          var checkIteratee = /^(?:filter|map|reject)|While$/.test(methodName),
              retUnwrapped = /^(?:first|last)$/.test(methodName),
              lodashFunc = lodash[retUnwrapped ? ('take' + (methodName == 'last' ? 'Right' : '')) : methodName];
    
          if (!lodashFunc) {
            return;
          }
          lodash.prototype[methodName] = function() {
            var args = retUnwrapped ? [1] : arguments,
                chainAll = this.__chain__,
                value = this.__wrapped__,
                isHybrid = !!this.__actions__.length,
                isLazy = value instanceof LazyWrapper,
                iteratee = args[0],
                useLazy = isLazy || isArray(value);
    
            if (useLazy && checkIteratee && typeof iteratee == 'function' && iteratee.length != 1) {
              // Avoid lazy use if the iteratee has a "length" value other than `1`.
              isLazy = useLazy = false;
            }
            var interceptor = function(value) {
              return (retUnwrapped && chainAll)
                ? lodashFunc(value, 1)[0]
                : lodashFunc.apply(undefined, arrayPush([value], args));
            };
    
            var action = { 'func': thru, 'args': [interceptor], 'thisArg': undefined },
                onlyLazy = isLazy && !isHybrid;
    
            if (retUnwrapped && !chainAll) {
              if (onlyLazy) {
                value = value.clone();
                value.__actions__.push(action);
                return func.call(value);
              }
              return lodashFunc.call(undefined, this.value())[0];
            }
            if (!retUnwrapped && useLazy) {
              value = onlyLazy ? value : new LazyWrapper(this);
              var result = func.apply(value, args);
              result.__actions__.push(action);
              return new LodashWrapper(result, chainAll);
            }
            return this.thru(interceptor);
          };
        });
    
        // Add `Array` and `String` methods to `lodash.prototype`.
        arrayEach(['join', 'pop', 'push', 'replace', 'shift', 'sort', 'splice', 'split', 'unshift'], function(methodName) {
          var func = (/^(?:replace|split)$/.test(methodName) ? stringProto : arrayProto)[methodName],
              chainName = /^(?:push|sort|unshift)$/.test(methodName) ? 'tap' : 'thru',
              retUnwrapped = /^(?:join|pop|replace|shift)$/.test(methodName);
    
          lodash.prototype[methodName] = function() {
            var args = arguments;
            if (retUnwrapped && !this.__chain__) {
              return func.apply(this.value(), args);
            }
            return this[chainName](function(value) {
              return func.apply(value, args);
            });
          };
        });
    
        // Map minified function names to their real names.
        baseForOwn(LazyWrapper.prototype, function(func, methodName) {
          var lodashFunc = lodash[methodName];
          if (lodashFunc) {
            var key = lodashFunc.name,
                names = realNames[key] || (realNames[key] = []);
    
            names.push({ 'name': methodName, 'func': lodashFunc });
          }
        });
    
        realNames[createHybridWrapper(undefined, BIND_KEY_FLAG).name] = [{ 'name': 'wrapper', 'func': undefined }];
    
        // Add functions to the lazy wrapper.
        LazyWrapper.prototype.clone = lazyClone;
        LazyWrapper.prototype.reverse = lazyReverse;
        LazyWrapper.prototype.value = lazyValue;
    
        // Add chaining functions to the `lodash` wrapper.
        lodash.prototype.chain = wrapperChain;
        lodash.prototype.commit = wrapperCommit;
        lodash.prototype.concat = wrapperConcat;
        lodash.prototype.plant = wrapperPlant;
        lodash.prototype.reverse = wrapperReverse;
        lodash.prototype.toString = wrapperToString;
        lodash.prototype.run = lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;
    
        // Add function aliases to the `lodash` wrapper.
        lodash.prototype.collect = lodash.prototype.map;
        lodash.prototype.head = lodash.prototype.first;
        lodash.prototype.select = lodash.prototype.filter;
        lodash.prototype.tail = lodash.prototype.rest;
    
        return lodash;
      }
    
      /*--------------------------------------------------------------------------*/
    
      // Export lodash.
      var _ = runInContext();
    
      // Some AMD build optimizers like r.js check for condition patterns like the following:
      if (typeof define == 'function' && typeof define.amd == 'object' && define.amd) {
        // Expose lodash to the global object when an AMD loader is present to avoid
        // errors in cases where lodash is loaded by a script tag and not intended
        // as an AMD module. See http://requirejs.org/docs/errors.html#mismatch for
        // more details.
        root._ = _;
    
        // Define as an anonymous module so, through path mapping, it can be
        // referenced as the "underscore" module.
        define(function() {
          return _;
        });
      }
      // Check for `exports` after `define` in case a build optimizer adds an `exports` object.
      else if (freeExports && freeModule) {
        // Export for Node.js or RingoJS.
        if (moduleExports) {
          (freeModule.exports = _)._ = _;
        }
        // Export for Rhino with CommonJS support.
        else {
          freeExports._ = _;
        }
      }
      else {
        // Export for a browser or Rhino.
        root._ = _;
      }
    }.call(this));
    
  provide("lodash", module.exports);
}(global));

// pakmanager:pretty-bytes
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    var numberIsNan = require('number-is-nan');
    
    module.exports = function (num) {
    	if (typeof num !== 'number' || numberIsNan(num)) {
    		throw new TypeError('Expected a number');
    	}
    
    	var exponent;
    	var unit;
    	var neg = num < 0;
    	var units = ['B', 'kB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'];
    
    	if (neg) {
    		num = -num;
    	}
    
    	if (num < 1) {
    		return (neg ? '-' : '') + num + ' B';
    	}
    
    	exponent = Math.min(Math.floor(Math.log(num) / Math.log(1000)), units.length - 1);
    	num = (num / Math.pow(1000, exponent)).toFixed(2) * 1;
    	unit = units[exponent];
    
    	return (neg ? '-' : '') + num + ' ' + unit;
    };
    
  provide("pretty-bytes", module.exports);
}(global));

// pakmanager:sort-on
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    var dotProp = require('dot-prop');
    var arrify = require('arrify');
    var dotPropGet = dotProp.get;
    
    module.exports = function (arr, prop) {
    	if (!Array.isArray(arr)) {
    		throw new TypeError('Expected an array');
    	}
    
    	return arr.slice().sort(function (a, b) {
    		var ret = 0;
    
    		arrify(prop).some(function (el) {
    			var x;
    			var y;
    
    			if (typeof el === 'function') {
    				x = el(a);
    				y = el(b);
    			} else if (typeof el === 'string') {
    				x = dotPropGet(a, el);
    				y = dotPropGet(b, el);
    			} else {
    				x = a;
    				y = b;
    			}
    
    			if (x === y) {
    				ret = 0;
    				return false;
    			}
    
    			if (typeof x === 'string' && typeof y === 'string') {
    				ret = x.localeCompare(y);
    				return ret !== 0;
    			}
    
    			ret = x < y ? -1 : 1;
    			return true;
    		});
    
    		return ret;
    	});
    };
    
  provide("sort-on", module.exports);
}(global));

// pakmanager:update-notifier
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    var spawn = require('child_process').spawn;
    var path = require('path');
    var Configstore = require('configstore');
    var chalk = require('chalk');
    var semverDiff = require('semver-diff');
    var latestVersion = require('latest-version');
    var stringLength = require('string-length');
    var isNpm = require('is-npm');
    var repeating = require('repeating');
    
    function UpdateNotifier(options) {
    	this.options = options = options || {};
    	options.pkg = options.pkg || {};
    
    	// deprecated options
    	// TODO: remove this at some point far into the future
    	if (options.packageName && options.packageVersion) {
    		options.pkg.name = options.packageName;
    		options.pkg.version = options.packageVersion;
    	}
    
    	if (!options.pkg.name || !options.pkg.version) {
    		throw new Error('pkg.name and pkg.version required');
    	}
    
    	this.packageName = options.pkg.name;
    	this.packageVersion = options.pkg.version;
    	this.updateCheckInterval = typeof options.updateCheckInterval === 'number' ? options.updateCheckInterval : 1000 * 60 * 60 * 24; // 1 day
    	this.hasCallback = typeof options.callback === 'function';
    	this.callback = options.callback || function () {};
    
    	if (!this.hasCallback) {
    		this.config = new Configstore('update-notifier-' + this.packageName, {
    			optOut: false,
    			// init with the current time so the first check is only
    			// after the set interval, so not to bother users right away
    			lastUpdateCheck: Date.now()
    		});
    	}
    }
    
    UpdateNotifier.prototype.check = function () {
    	if (this.hasCallback) {
    		return this.checkNpm(this.callback);
    	}
    
    	if (this.config.get('optOut') || 'NO_UPDATE_NOTIFIER' in process.env || process.argv.indexOf('--no-update-notifier') !== -1) {
    		return;
    	}
    
    	this.update = this.config.get('update');
    
    	if (this.update) {
    		this.config.del('update');
    	}
    
    	// Only check for updates on a set interval
    	if (Date.now() - this.config.get('lastUpdateCheck') < this.updateCheckInterval) {
    		return;
    	}
    
    	// Spawn a detached process, passing the options as an environment property
    	spawn(process.execPath, [path.join(__dirname, 'check.js'), JSON.stringify(this.options)], {
    		detached: true,
    		stdio: 'ignore'
    	}).unref();
    };
    
    UpdateNotifier.prototype.checkNpm = function (cb) {
    	latestVersion(this.packageName, function (err, latestVersion) {
    		if (err) {
    			return cb(err);
    		}
    
    		cb(null, {
    			latest: latestVersion,
    			current: this.packageVersion,
    			type: semverDiff(this.packageVersion, latestVersion) || 'latest',
    			name: this.packageName
    		});
    	}.bind(this));
    };
    
    UpdateNotifier.prototype.notify = function (opts) {
    	if (!process.stdout.isTTY || isNpm || !this.update) {
    		return this;
    	}
    
    	opts = opts || {};
    	opts.defer = opts.defer === undefined ? true : false;
    
    	var line1 = ' Update available: ' + chalk.green.bold(this.update.latest) +
    		chalk.dim(' (current: ' + this.update.current + ')') + ' ';
    	var line2 = ' Run ' + chalk.blue('npm install -g ' + this.packageName) +
    		' to update. ';
    	var contentWidth = Math.max(stringLength(line1), stringLength(line2));
    	var line1rest = contentWidth - stringLength(line1);
    	var line2rest = contentWidth - stringLength(line2);
    	var top = chalk.yellow('┌' + repeating('─', contentWidth) + '┐');
    	var bottom = chalk.yellow('└' + repeating('─', contentWidth) + '┘');
    	var side = chalk.yellow('│');
    
    	var message =
    		'\n\n' +
    		top + '\n' +
    		side + line1 + repeating(' ', line1rest) + side + '\n' +
    		side + line2 + repeating(' ', line2rest) + side + '\n' +
    		bottom + '\n';
    
    	if (opts.defer) {
    		process.on('exit', function () {
    			console.error(message);
    		});
    	} else {
    		console.error(message);
    	}
    
    	return this;
    };
    
    module.exports = function (options) {
    	var updateNotifier = new UpdateNotifier(options);
    	updateNotifier.check();
    	return updateNotifier;
    };
    
    module.exports.UpdateNotifier = UpdateNotifier;
    
  provide("update-notifier", module.exports);
}(global));

// pakmanager:cli-table/lib/utils
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  
    /**
     * Repeats a string.
     *
     * @param {String} char(s)
     * @param {Number} number of times
     * @return {String} repeated string
     */
    
    exports.repeat = function (str, times){
      return Array(times + 1).join(str);
    };
    
    /**
     * Pads a string
     *
     * @api public
     */
    
    exports.pad = function (str, len, pad, dir) {
      if (len + 1 >= str.length)
        switch (dir){
          case 'left':
            str = Array(len + 1 - str.length).join(pad) + str;
            break;
    
          case 'both':
            var right = Math.ceil((padlen = len - str.length) / 2);
            var left = padlen - right;
            str = Array(left + 1).join(pad) + str + Array(right + 1).join(pad);
            break;
    
          default:
            str = str + Array(len + 1 - str.length).join(pad);
        };
    
      return str;
    };
    
    /**
     * Truncates a string
     *
     * @api public
     */
    
    exports.truncate = function (str, length, chr){
      chr = chr || '…';
      return str.length >= length ? str.substr(0, length - chr.length) + chr : str;
    };
    
    /**
     * Copies and merges options with defaults.
     *
     * @param {Object} defaults
     * @param {Object} supplied options
     * @return {Object} new (merged) object
     */
    
    function options(defaults, opts) {
      for (var p in opts) {
        if (opts[p] && opts[p].constructor && opts[p].constructor === Object) {
          defaults[p] = defaults[p] || {};
          options(defaults[p], opts[p]);
        } else {
          defaults[p] = opts[p];
        }
      }
      return defaults;
    };
    exports.options = options;
    
    //
    // For consideration of terminal "color" programs like colors.js,
    // which can add ANSI escape color codes to strings,
    // we destyle the ANSI color escape codes for padding calculations.
    //
    // see: http://en.wikipedia.org/wiki/ANSI_escape_code
    //
    exports.strlen = function(str){
      var code = /\u001b\[(?:\d*;){0,5}\d*m/g;
      var stripped = ("" + str).replace(code,'');
      var split = stripped.split("\n");
      return split.reduce(function (memo, s) { return (s.length > memo) ? s.length : memo }, 0);
    }
    
  provide("cli-table/lib/utils", module.exports);
}(global));

// pakmanager:cli-table
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  
    /**
     * Module dependencies.
     */
    
    var colors = require('colors/safe')
      , utils =  require('cli-table/lib/utils')
      , repeat = utils.repeat
      , truncate = utils.truncate
      , pad = utils.pad;
    
    /**
     * Table constructor
     *
     * @param {Object} options
     * @api public
     */
    
    function Table (options){
      this.options = utils.options({
          chars: {
              'top': '─'
            , 'top-mid': '┬'
            , 'top-left': '┌'
            , 'top-right': '┐'
            , 'bottom': '─'
            , 'bottom-mid': '┴'
            , 'bottom-left': '└'
            , 'bottom-right': '┘'
            , 'left': '│'
            , 'left-mid': '├'
            , 'mid': '─'
            , 'mid-mid': '┼'
            , 'right': '│'
            , 'right-mid': '┤'
            , 'middle': '│'
          }
        , truncate: '…'
        , colWidths: []
        , colAligns: []
        , style: {
              'padding-left': 1
            , 'padding-right': 1
            , head: ['red']
            , border: ['grey']
            , compact : false
          }
        , head: []
      }, options);
    };
    
    /**
     * Inherit from Array.
     */
    
    Table.prototype.__proto__ = Array.prototype;
    
    /**
     * Width getter
     *
     * @return {Number} width
     * @api public
     */
    
    Table.prototype.__defineGetter__('width', function (){
      var str = this.toString().split("\n");
      if (str.length) return str[0].length;
      return 0;
    });
    
    /**
     * Render to a string.
     *
     * @return {String} table representation
     * @api public
     */
    
    Table.prototype.render
    Table.prototype.toString = function (){
      var ret = ''
        , options = this.options
        , style = options.style
        , head = options.head
        , chars = options.chars
        , truncater = options.truncate
          , colWidths = options.colWidths || new Array(this.head.length)
          , totalWidth = 0;
    
        if (!head.length && !this.length) return '';
    
        if (!colWidths.length){
          var all_rows = this.slice(0);
          if (head.length) { all_rows = all_rows.concat([head]) };
    
          all_rows.forEach(function(cells){
            // horizontal (arrays)
            if (typeof cells === 'object' && cells.length) {
              extractColumnWidths(cells);
    
            // vertical (objects)
            } else {
              var header_cell = Object.keys(cells)[0]
                , value_cell = cells[header_cell];
    
              colWidths[0] = Math.max(colWidths[0] || 0, get_width(header_cell) || 0);
    
              // cross (objects w/ array values)
              if (typeof value_cell === 'object' && value_cell.length) {
                extractColumnWidths(value_cell, 1);
              } else {
                colWidths[1] = Math.max(colWidths[1] || 0, get_width(value_cell) || 0);
              }
            }
        });
      };
    
      totalWidth = (colWidths.length == 1 ? colWidths[0] : colWidths.reduce(
        function (a, b){
          return a + b
        })) + colWidths.length + 1;
    
      function extractColumnWidths(arr, offset) {
        var offset = offset || 0;
        arr.forEach(function(cell, i){
          colWidths[i + offset] = Math.max(colWidths[i + offset] || 0, get_width(cell) || 0);
        });
      };
    
      function get_width(obj) {
        return typeof obj == 'object' && obj.width != undefined
             ? obj.width
             : ((typeof obj == 'object' ? utils.strlen(obj.text) : utils.strlen(obj)) + (style['padding-left'] || 0) + (style['padding-right'] || 0))
      }
    
      // draws a line
      function line (line, left, right, intersection){
        var width = 0
          , line =
              left
            + repeat(line, totalWidth - 2)
            + right;
    
        colWidths.forEach(function (w, i){
          if (i == colWidths.length - 1) return;
          width += w + 1;
          line = line.substr(0, width) + intersection + line.substr(width + 1);
        });
    
        return applyStyles(options.style.border, line);
      };
    
      // draws the top line
      function lineTop (){
        var l = line(chars.top
                   , chars['top-left'] || chars.top
                   , chars['top-right'] ||  chars.top
                   , chars['top-mid']);
        if (l)
          ret += l + "\n";
      };
    
      function generateRow (items, style) {
        var cells = []
          , max_height = 0;
    
        // prepare vertical and cross table data
        if (!Array.isArray(items) && typeof items === "object") {
          var key = Object.keys(items)[0]
            , value = items[key]
            , first_cell_head = true;
    
          if (Array.isArray(value)) {
            items = value;
            items.unshift(key);
          } else {
            items = [key, value];
          }
        }
    
        // transform array of item strings into structure of cells
        items.forEach(function (item, i) {
          var contents = item.toString().split("\n").reduce(function (memo, l) {
            memo.push(string(l, i));
            return memo;
          }, [])
    
          var height = contents.length;
          if (height > max_height) { max_height = height };
    
          cells.push({ contents: contents , height: height });
        });
    
        // transform vertical cells into horizontal lines
        var lines = new Array(max_height);
        cells.forEach(function (cell, i) {
          cell.contents.forEach(function (line, j) {
            if (!lines[j]) { lines[j] = [] };
            if (style || (first_cell_head && i === 0 && options.style.head)) {
              line = applyStyles(options.style.head, line)
            }
    
            lines[j].push(line);
          });
    
          // populate empty lines in cell
          for (var j = cell.height, l = max_height; j < l; j++) {
            if (!lines[j]) { lines[j] = [] };
            lines[j].push(string('', i));
          }
        });
        var ret = "";
        lines.forEach(function (line, index) {
          if (ret.length > 0) {
            ret += "\n" + applyStyles(options.style.border, chars.left);
          }
    
          ret += line.join(applyStyles(options.style.border, chars.middle)) + applyStyles(options.style.border, chars.right);
        });
    
        return applyStyles(options.style.border, chars.left) + ret;
      };
    
      function applyStyles(styles, subject) {
        if (!subject)
          return '';
        styles.forEach(function(style) {
          subject = colors[style](subject);
        });
        return subject;
      };
    
      // renders a string, by padding it or truncating it
      function string (str, index){
        var str = String(typeof str == 'object' && str.text ? str.text : str)
          , length = utils.strlen(str)
          , width = colWidths[index]
              - (style['padding-left'] || 0)
              - (style['padding-right'] || 0)
          , align = options.colAligns[index] || 'left';
    
        return repeat(' ', style['padding-left'] || 0)
             + (length == width ? str :
                 (length < width
                  ? pad(str, ( width + (str.length - length) ), ' ', align == 'left' ? 'right' :
                      (align == 'middle' ? 'both' : 'left'))
                  : (truncater ? truncate(str, width, truncater) : str))
               )
             + repeat(' ', style['padding-right'] || 0);
      };
    
      if (head.length){
        lineTop();
    
        ret += generateRow(head, style.head) + "\n"
      }
    
      if (this.length)
        this.forEach(function (cells, i){
          if (!head.length && i == 0)
            lineTop();
          else {
            if (!style.compact || i<(!!head.length) ?1:0 || cells.length == 0){
              var l = line(chars.mid
                         , chars['left-mid']
                         , chars['right-mid']
                         , chars['mid-mid']);
              if (l)
                ret += l + "\n"
            }
          }
    
          if (cells.hasOwnProperty("length") && !cells.length) {
            return
          } else {
            ret += generateRow(cells) + "\n";
          };
        });
    
      var l = line(chars.bottom
                 , chars['bottom-left'] || chars.bottom
                 , chars['bottom-right'] || chars.bottom
                 , chars['bottom-mid']);
      if (l)
        ret += l;
      else
        // trim the last '\n' if we didn't add the bottom decoration
        ret = ret.slice(0, -1);
    
      return ret;
    };
    
    /**
     * Module exports.
     */
    
    module.exports = Table;
    
    module.exports.version = '0.0.1';
    
  provide("cli-table", module.exports);
}(global));

// pakmanager:csv-generate
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Generated by CoffeeScript 1.7.1
    var Generator, stream, util;
    
    stream = require('stream');
    
    util = require('util');
    
    module.exports = function() {
      var callback, data, generator, options;
      if (arguments.length === 2) {
        options = arguments[0];
        callback = arguments[1];
      } else if (arguments.length === 1) {
        if (typeof arguments[0] === 'function') {
          options = {};
          callback = arguments[0];
        } else {
          options = arguments[0];
        }
      } else if (arguments.length === 0) {
        options = {};
      }
      generator = new Generator(options);
      if (callback) {
        data = [];
        generator.on('readable', function() {
          var d, _results;
          _results = [];
          while (d = generator.read()) {
            _results.push(data.push(options.objectMode ? d : d.toString()));
          }
          return _results;
        });
        generator.on('error', callback);
        generator.on('end', function() {
          return callback(null, options.objectMode ? data : data.join(''));
        });
      }
      return generator;
    };
    
    Generator = function(options) {
      var i, v, _base, _base1, _base2, _base3, _base4, _base5, _base6, _base7, _base8, _i, _len, _ref;
      this.options = options != null ? options : {};
      stream.Readable.call(this, this.options);
      this.options.count = 0;
      if ((_base = this.options).duration == null) {
        _base.duration = 4 * 60 * 1000;
      }
      if ((_base1 = this.options).columns == null) {
        _base1.columns = 8;
      }
      if ((_base2 = this.options).max_word_length == null) {
        _base2.max_word_length = 16;
      }
      if ((_base3 = this.options).fixed_size == null) {
        _base3.fixed_size = false;
      }
      if (this.fixed_size_buffer == null) {
        this.fixed_size_buffer = '';
      }
      if ((_base4 = this.options).start == null) {
        _base4.start = Date.now();
      }
      if ((_base5 = this.options).end == null) {
        _base5.end = null;
      }
      if ((_base6 = this.options).seed == null) {
        _base6.seed = false;
      }
      if ((_base7 = this.options).length == null) {
        _base7.length = -1;
      }
      if ((_base8 = this.options).delimiter == null) {
        _base8.delimiter = ',';
      }
      this.count_written = 0;
      this.count_created = 0;
      if (typeof this.options.columns === 'number') {
        this.options.columns = new Array(this.options.columns);
      }
      _ref = this.options.columns;
      for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
        v = _ref[i];
        if (v == null) {
          v = 'ascii';
        }
        if (typeof v === 'string') {
          this.options.columns[i] = Generator[v];
        }
      }
      return this;
    };
    
    util.inherits(Generator, stream.Readable);
    
    module.exports.Generator = Generator;
    
    Generator.prototype.random = function() {
      if (this.options.seed) {
        return this.options.seed = this.options.seed * Math.PI * 100 % 100 / 100;
      } else {
        return Math.random();
      }
    };
    
    Generator.prototype.end = function() {
      return this.push(null);
    };
    
    Generator.prototype._read = function(size) {
      var column, data, header, length, line, lineLength, _i, _j, _k, _l, _len, _len1, _len2, _len3, _ref;
      data = [];
      length = this.fixed_size_buffer.length;
      if (length) {
        data.push(this.fixed_size_buffer);
      }
      while (true) {
        if ((this.count_created === this.options.length) || (this.options.end && Date.now() > this.options.end)) {
          if (data.length) {
            if (this.options.objectMode) {
              for (_i = 0, _len = data.length; _i < _len; _i++) {
                line = data[_i];
                this.count_written++;
                this.push(line);
              }
            } else {
              this.count_written++;
              this.push(data.join(''));
            }
          }
          return this.push(null);
        }
        line = [];
        _ref = this.options.columns;
        for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
          header = _ref[_j];
          line.push("" + (header(this)));
        }
        if (this.options.objectMode) {
          lineLength = 0;
          for (_k = 0, _len2 = line.length; _k < _len2; _k++) {
            column = line[_k];
            lineLength += column.length;
          }
        } else {
          line = "" + (this.count_created === 0 ? '' : '\n') + (line.join(this.options.delimiter));
          lineLength = line.length;
        }
        this.count_created++;
        if (length + lineLength > size) {
          if (this.options.objectMode) {
            data.push(line);
            for (_l = 0, _len3 = data.length; _l < _len3; _l++) {
              line = data[_l];
              this.count_written++;
              this.push(line);
            }
          } else {
            if (this.options.fixed_size) {
              this.fixed_size_buffer = line.substr(size - length);
              data.push(line.substr(0, size - length));
            } else {
              data.push(line);
            }
            this.count_written++;
            this.push(data.join(''));
          }
          break;
        }
        length += lineLength;
        data.push(line);
      }
    };
    
    Generator.ascii = function(gen) {
      var char, column, nb_chars, _i, _ref;
      column = [];
      for (nb_chars = _i = 0, _ref = Math.ceil(gen.random() * gen.options.max_word_length); 0 <= _ref ? _i < _ref : _i > _ref; nb_chars = 0 <= _ref ? ++_i : --_i) {
        char = Math.floor(gen.random() * 32);
        column.push(String.fromCharCode(char + (char < 16 ? 65 : 97 - 16)));
      }
      return column.join('');
    };
    
    Generator.int = function(gen) {
      return Math.floor(gen.random() * Math.pow(2, 52));
    };
    
    Generator.bool = function(gen) {
      return Math.floor(gen.random() * 2);
    };
    
  provide("csv-generate", module.exports);
}(global));

// pakmanager:csv-parse
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Generated by CoffeeScript 1.9.1
    var Parser, StringDecoder, stream, util;
    
    stream = require('stream');
    
    util = require('util');
    
    StringDecoder = require('string_decoder').StringDecoder;
    
    module.exports = function() {
      var callback, called, chunks, data, options, parser;
      if (arguments.length === 3) {
        data = arguments[0];
        options = arguments[1];
        callback = arguments[2];
        if (typeof callback !== 'function') {
          throw Error("Invalid callback argument: " + (JSON.stringify(callback)));
        }
        if (typeof data !== 'string') {
          return callback(Error("Invalid data argument: " + (JSON.stringify(data))));
        }
      } else if (arguments.length === 2) {
        if (typeof arguments[0] === 'string' || Buffer.isBuffer(arguments[0])) {
          data = arguments[0];
        } else {
          options = arguments[0];
        }
        if (typeof arguments[1] === 'function') {
          callback = arguments[1];
        } else {
          options = arguments[1];
        }
      } else if (arguments.length === 1) {
        if (typeof arguments[0] === 'function') {
          callback = arguments[0];
        } else {
          options = arguments[0];
        }
      }
      if (options == null) {
        options = {};
      }
      parser = new Parser(options);
      if (data) {
        process.nextTick(function() {
          parser.write(data);
          return parser.end();
        });
      }
      if (callback) {
        called = false;
        chunks = options.objname ? {} : [];
        parser.on('readable', function() {
          var chunk, results;
          results = [];
          while (chunk = parser.read()) {
            if (options.objname) {
              results.push(chunks[chunk[0]] = chunk[1]);
            } else {
              results.push(chunks.push(chunk));
            }
          }
          return results;
        });
        parser.on('error', function(err) {
          called = true;
          return callback(err);
        });
        parser.on('end', function() {
          if (!called) {
            return callback(null, chunks);
          }
        });
      }
      return parser;
    };
    
    Parser = function(options) {
      var base, base1, base10, base11, base2, base3, base4, base5, base6, base7, base8, base9, k, v;
      if (options == null) {
        options = {};
      }
      options.objectMode = true;
      this.options = {};
      for (k in options) {
        v = options[k];
        this.options[k] = v;
      }
      stream.Transform.call(this, this.options);
      if ((base = this.options).rowDelimiter == null) {
        base.rowDelimiter = null;
      }
      if ((base1 = this.options).delimiter == null) {
        base1.delimiter = ',';
      }
      if ((base2 = this.options).quote == null) {
        base2.quote = '"';
      }
      if ((base3 = this.options).escape == null) {
        base3.escape = '"';
      }
      if ((base4 = this.options).columns == null) {
        base4.columns = null;
      }
      if ((base5 = this.options).comment == null) {
        base5.comment = '';
      }
      if ((base6 = this.options).objname == null) {
        base6.objname = false;
      }
      if ((base7 = this.options).trim == null) {
        base7.trim = false;
      }
      if ((base8 = this.options).ltrim == null) {
        base8.ltrim = false;
      }
      if ((base9 = this.options).rtrim == null) {
        base9.rtrim = false;
      }
      if ((base10 = this.options).auto_parse == null) {
        base10.auto_parse = false;
      }
      if ((base11 = this.options).skip_empty_lines == null) {
        base11.skip_empty_lines = false;
      }
      this.lines = 0;
      this.count = 0;
      this.regexp_int = /^(\-|\+)?([1-9]+[0-9]*)$/;
      this.regexp_float = /^(\-|\+)?([0-9]+(\.[0-9]+)?([eE][0-9]+)?|Infinity)$/;
      this.decoder = new StringDecoder();
      this.buf = '';
      this.quoting = false;
      this.commenting = false;
      this.field = '';
      this.nextChar = null;
      this.closingQuote = 0;
      this.line = [];
      this.chunks = [];
      return this;
    };
    
    util.inherits(Parser, stream.Transform);
    
    module.exports.Parser = Parser;
    
    Parser.prototype._transform = function(chunk, encoding, callback) {
      var err;
      if (chunk instanceof Buffer) {
        chunk = this.decoder.write(chunk);
      }
      try {
        this.__write(chunk, false);
        return callback();
      } catch (_error) {
        err = _error;
        return this.emit('error', err);
      }
    };
    
    Parser.prototype._flush = function(callback) {
      var err;
      try {
        this.__write(this.decoder.end(), true);
        if (this.quoting) {
          this.emit('error', new Error("Quoted field not terminated at line " + (this.lines + 1)));
          return;
        }
        if (this.line.length > 0) {
          this.__push(this.line);
        }
        return callback();
      } catch (_error) {
        err = _error;
        return this.emit('error', err);
      }
    };
    
    Parser.prototype.__push = function(line) {
      var field, i, j, len, lineAsColumns;
      if (this.options.columns === true) {
        this.options.columns = line;
        return;
      } else if (typeof this.options.columns === 'function') {
        this.options.columns = this.options.columns(line);
        return;
      }
      this.count++;
      if (this.options.columns != null) {
        lineAsColumns = {};
        for (i = j = 0, len = line.length; j < len; i = ++j) {
          field = line[i];
          lineAsColumns[this.options.columns[i]] = field;
        }
        if (this.options.objname) {
          return this.push([lineAsColumns[this.options.objname], lineAsColumns]);
        } else {
          return this.push(lineAsColumns);
        }
      } else {
        return this.push(line);
      }
    };
    
    Parser.prototype.__write = function(chars, end, callback) {
      var acceptedLength, areNextCharsDelimiter, areNextCharsRowDelimiters, char, escapeIsQuote, i, isDelimiter, isEscape, isNextCharAComment, isQuote, isRowDelimiter, l, ltrim, nextCharPos, ref, results, rowDelimiter, rowDelimiterLength, rtrim, wasCommenting;
      ltrim = this.options.trim || this.options.ltrim;
      rtrim = this.options.trim || this.options.rtrim;
      chars = this.buf + chars;
      l = chars.length;
      rowDelimiterLength = this.options.rowDelimiter ? this.options.rowDelimiter.length : 0;
      i = 0;
      if (this.lines === 0 && 0xFEFF === chars.charCodeAt(0)) {
        i++;
      }
      while (i < l) {
        acceptedLength = rowDelimiterLength + this.options.comment.length + this.options.escape.length + this.options.delimiter.length;
        if (this.quoting) {
          acceptedLength += this.options.quote.length;
        }
        if (!end && (i + acceptedLength >= l)) {
          break;
        }
        char = this.nextChar ? this.nextChar : chars.charAt(i);
        this.nextChar = chars.charAt(i + 1);
        if (this.options.rowDelimiter == null) {
          if ((this.field === '') && (char === '\n' || char === '\r')) {
            rowDelimiter = char;
            nextCharPos = i + 1;
          } else if (this.nextChar === '\n' || this.nextChar === '\r') {
            rowDelimiter = this.nextChar;
            nextCharPos = i + 2;
          }
          if (rowDelimiter) {
            if (rowDelimiter === '\r' && chars.charAt(nextCharPos) === '\n') {
              rowDelimiter += '\n';
            }
            this.options.rowDelimiter = rowDelimiter;
            rowDelimiterLength = this.options.rowDelimiter.length;
          }
        }
        if (!this.commenting && char === this.options.escape) {
          escapeIsQuote = this.options.escape === this.options.quote;
          isEscape = this.nextChar === this.options.escape;
          isQuote = this.nextChar === this.options.quote;
          if (!(escapeIsQuote && !this.field && !this.quoting) && (isEscape || isQuote)) {
            i++;
            char = this.nextChar;
            this.nextChar = chars.charAt(i + 1);
            this.field += char;
            i++;
            continue;
          }
        }
        if (!this.commenting && char === this.options.quote) {
          if (this.quoting) {
            areNextCharsRowDelimiters = this.options.rowDelimiter && chars.substr(i + 1, this.options.rowDelimiter.length) === this.options.rowDelimiter;
            areNextCharsDelimiter = chars.substr(i + 1, this.options.delimiter.length) === this.options.delimiter;
            isNextCharAComment = this.nextChar === this.options.comment;
            if (this.nextChar && !areNextCharsRowDelimiters && !areNextCharsDelimiter && !isNextCharAComment) {
              if (this.options.relax) {
                this.quoting = false;
                this.field = "" + this.options.quote + this.field;
              } else {
                throw Error("Invalid closing quote at line " + (this.lines + 1) + "; found " + (JSON.stringify(this.nextChar)) + " instead of delimiter " + (JSON.stringify(this.options.delimiter)));
              }
            } else {
              this.quoting = false;
              this.closingQuote = this.options.quote.length;
              i++;
              if (end && i === l) {
                this.line.push(this.field);
              }
              continue;
            }
          } else if (!this.field) {
            this.quoting = true;
            i++;
            continue;
          } else if (this.field && !this.options.relax) {
            throw Error("Invalid opening quote at line " + (this.lines + 1));
          }
        }
        isRowDelimiter = this.options.rowDelimiter && chars.substr(i, this.options.rowDelimiter.length) === this.options.rowDelimiter;
        if (isRowDelimiter) {
          this.lines++;
        }
        wasCommenting = false;
        if (!this.commenting && !this.quoting && this.options.comment && chars.substr(i, this.options.comment.length) === this.options.comment) {
          this.commenting = true;
        } else if (this.commenting && isRowDelimiter) {
          wasCommenting = true;
          this.commenting = false;
        }
        isDelimiter = chars.substr(i, this.options.delimiter.length) === this.options.delimiter;
        if (!this.commenting && !this.quoting && (isDelimiter || isRowDelimiter)) {
          if (isRowDelimiter && this.line.length === 0 && this.field === '') {
            if (wasCommenting || this.options.skip_empty_lines) {
              i += this.options.rowDelimiter.length;
              this.nextChar = chars.charAt(i);
              continue;
            }
          }
          if (rtrim) {
            if (!this.closingQuote) {
              this.field = this.field.trimRight();
            }
          }
          if (this.options.auto_parse && this.regexp_int.test(this.field)) {
            this.line.push(parseInt(this.field));
          } else if (this.options.auto_parse && this.regexp_float.test(this.field)) {
            this.line.push(parseFloat(this.field));
          } else {
            this.line.push(this.field);
          }
          this.closingQuote = 0;
          this.field = '';
          if (isDelimiter) {
            i += this.options.delimiter.length;
            this.nextChar = chars.charAt(i);
            if (end && !this.nextChar) {
              isRowDelimiter = true;
              this.line.push('');
            }
          }
          if (isRowDelimiter) {
            this.__push(this.line);
            this.line = [];
            i += (ref = this.options.rowDelimiter) != null ? ref.length : void 0;
            this.nextChar = chars.charAt(i);
            continue;
          }
        } else if (!this.commenting && !this.quoting && (char === ' ' || char === '\t')) {
          if (!(ltrim && !this.field)) {
            this.field += char;
          }
          if (end && i + 1 === l) {
            if (this.options.trim || this.options.rtrim) {
              this.field = this.field.trimRight();
            }
            this.line.push(this.field);
          }
          i++;
        } else if (!this.commenting) {
          this.field += char;
          i++;
          if (end && i === l) {
            this.line.push(this.field);
          }
        } else {
          i++;
        }
      }
      this.buf = '';
      results = [];
      while (i < l) {
        this.buf += chars.charAt(i);
        results.push(i++);
      }
      return results;
    };
    
  provide("csv-parse", module.exports);
}(global));

// pakmanager:stream-transform
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Generated by CoffeeScript 1.9.2
    var Transformer, stream, util,
      slice = [].slice;
    
    stream = require('stream');
    
    util = require('util');
    
    module.exports = function() {
      var argument, callback, data, error, handler, i, j, k, len, options, result, transform, type, v;
      options = {};
      for (i = j = 0, len = arguments.length; j < len; i = ++j) {
        argument = arguments[i];
        type = typeof argument;
        if (argument === null) {
          type = 'null';
        } else if (type === 'object' && Array.isArray(argument)) {
          type = 'array';
        }
        if (i === 0) {
          if (type === 'function') {
            handler = argument;
          } else if (type !== null) {
            data = argument;
          }
          continue;
        }
        if (type === 'object') {
          for (k in argument) {
            v = argument[k];
            options[k] = v;
          }
        } else if (type === 'function') {
          if (handler && i === arguments.length - 1) {
            callback = argument;
          } else {
            handler = argument;
          }
        } else if (type !== 'null') {
          throw new Error('Invalid arguments');
        }
      }
      transform = new Transformer(options, handler);
      error = false;
      if (data) {
        process.nextTick(function() {
          var l, len1, row;
          for (l = 0, len1 = data.length; l < len1; l++) {
            row = data[l];
            if (error) {
              break;
            }
            transform.write(row);
          }
          return transform.end();
        });
      }
      if (callback) {
        result = [];
        transform.on('readable', function() {
          var r, results;
          results = [];
          while ((r = transform.read())) {
            results.push(result.push(r));
          }
          return results;
        });
        transform.on('error', function(err) {
          error = true;
          return callback(err);
        });
        transform.on('end', function() {
          if (!error) {
            return callback(null, result);
          }
        });
      }
      return transform;
    };
    
    Transformer = function(options1, transform1) {
      var base;
      this.options = options1 != null ? options1 : {};
      this.transform = transform1;
      this.options.objectMode = true;
      if ((base = this.options).parallel == null) {
        base.parallel = 100;
      }
      stream.Transform.call(this, this.options);
      this.running = 0;
      this.started = 0;
      this.finished = 0;
      return this;
    };
    
    util.inherits(Transformer, stream.Transform);
    
    module.exports.Transformer = Transformer;
    
    Transformer.prototype._transform = function(chunk, encoding, cb) {
      var err;
      this.started++;
      this.running++;
      if (this.running < this.options.parallel) {
        cb();
        cb = null;
      }
      try {
        if (this.transform.length === 2) {
          this.transform.call(null, chunk, (function(_this) {
            return function() {
              var chunks, err;
              err = arguments[0], chunks = 2 <= arguments.length ? slice.call(arguments, 1) : [];
              return _this._done(err, chunks, cb);
            };
          })(this));
        } else {
          this._done(null, [this.transform.call(null, chunk)], cb);
        }
        return false;
      } catch (_error) {
        err = _error;
        return this._done(err);
      }
    };
    
    Transformer.prototype._flush = function(cb) {
      this._ending = function() {
        if (this.running === 0) {
          return cb();
        }
      };
      return this._ending();
    };
    
    Transformer.prototype._done = function(err, chunks, cb) {
      var chunk, j, len;
      this.running--;
      if (err) {
        return this.emit('error', err);
      }
      this.finished++;
      for (j = 0, len = chunks.length; j < len; j++) {
        chunk = chunks[j];
        if (typeof chunk === 'number') {
          chunk = "" + chunk;
        }
        if (chunk != null) {
          this.push(chunk);
        }
      }
      if (cb) {
        cb();
      }
      if (this._ending) {
        return this._ending();
      }
    };
    
  provide("stream-transform", module.exports);
}(global));

// pakmanager:csv-stringify
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Generated by CoffeeScript 1.9.2
    var Stringifier, stream, util;
    
    stream = require('stream');
    
    util = require('util');
    
    module.exports = function() {
      var callback, chunks, data, options, stringifier;
      if (arguments.length === 3) {
        data = arguments[0];
        options = arguments[1];
        callback = arguments[2];
      } else if (arguments.length === 2) {
        if (Array.isArray(arguments[0])) {
          data = arguments[0];
        } else {
          options = arguments[0];
        }
        if (typeof arguments[1] === 'function') {
          callback = arguments[1];
        } else {
          options = arguments[1];
        }
      } else if (arguments.length === 1) {
        if (typeof arguments[0] === 'function') {
          callback = arguments[0];
        } else if (Array.isArray(arguments[0])) {
          data = arguments[0];
        } else {
          options = arguments[0];
        }
      }
      if (options == null) {
        options = {};
      }
      stringifier = new Stringifier(options);
      if (data) {
        process.nextTick(function() {
          var d, j, len;
          for (j = 0, len = data.length; j < len; j++) {
            d = data[j];
            stringifier.write(d);
          }
          return stringifier.end();
        });
      }
      if (callback) {
        chunks = [];
        stringifier.on('readable', function() {
          var chunk, results;
          results = [];
          while (chunk = stringifier.read()) {
            results.push(chunks.push(chunk));
          }
          return results;
        });
        stringifier.on('error', function(err) {
          return callback(err);
        });
        stringifier.on('end', function() {
          return callback(null, chunks.join(''));
        });
      }
      return stringifier;
    };
    
    Stringifier = function(options) {
      var base, base1, base2, base3, base4, base5, base6, base7, base8;
      if (options == null) {
        options = {};
      }
      stream.Transform.call(this, options);
      this.options = options;
      if ((base = this.options).delimiter == null) {
        base.delimiter = ',';
      }
      if ((base1 = this.options).quote == null) {
        base1.quote = '"';
      }
      if ((base2 = this.options).quoted == null) {
        base2.quoted = false;
      }
      if ((base3 = this.options).quotedString == null) {
        base3.quotedString = false;
      }
      if ((base4 = this.options).eof == null) {
        base4.eof = true;
      }
      if ((base5 = this.options).escape == null) {
        base5.escape = '"';
      }
      if ((base6 = this.options).columns == null) {
        base6.columns = null;
      }
      if ((base7 = this.options).header == null) {
        base7.header = false;
      }
      if ((base8 = this.options).rowDelimiter == null) {
        base8.rowDelimiter = '\n';
      }
      if (this.countWriten == null) {
        this.countWriten = 0;
      }
      switch (this.options.rowDelimiter) {
        case 'auto':
          this.options.rowDelimiter = null;
          break;
        case 'unix':
          this.options.rowDelimiter = "\n";
          break;
        case 'mac':
          this.options.rowDelimiter = "\r";
          break;
        case 'windows':
          this.options.rowDelimiter = "\r\n";
          break;
        case 'unicode':
          this.options.rowDelimiter = "\u2028";
      }
      return this;
    };
    
    util.inherits(Stringifier, stream.Transform);
    
    module.exports.Stringifier = Stringifier;
    
    Stringifier.prototype.headers = function() {
      var k, label, labels;
      if (!this.options.header) {
        return;
      }
      if (!this.options.columns) {
        return;
      }
      labels = this.options.columns;
      if (typeof labels === 'object') {
        labels = (function() {
          var results;
          results = [];
          for (k in labels) {
            label = labels[k];
            results.push(label);
          }
          return results;
        })();
      }
      if (this.options.eof) {
        labels = this.stringify(labels) + this.options.rowDelimiter;
      } else {
        labels = this.stringify(labels);
      }
      return stream.Transform.prototype.write.call(this, labels);
    };
    
    Stringifier.prototype.end = function(chunk, encoding, callback) {
      if (this.countWriten === 0) {
        this.headers();
      }
      return stream.Transform.prototype.end.apply(this, arguments);
    };
    
    Stringifier.prototype.write = function(chunk, encoding, callback) {
      var base, e, preserve;
      if (chunk == null) {
        return;
      }
      preserve = typeof chunk !== 'object';
      if (!preserve) {
        if (this.countWriten === 0 && !Array.isArray(chunk)) {
          if ((base = this.options).columns == null) {
            base.columns = Object.keys(chunk);
          }
        }
        try {
          this.emit('record', chunk, this.countWriten);
        } catch (_error) {
          e = _error;
          return this.emit('error', e);
        }
        if (this.options.eof) {
          chunk = this.stringify(chunk) + this.options.rowDelimiter;
        } else {
          chunk = this.stringify(chunk);
          if (this.options.header || this.countWriten) {
            chunk = this.options.rowDelimiter + chunk;
          }
        }
      }
      if (typeof chunk === 'number') {
        chunk = "" + chunk;
      }
      if (this.countWriten === 0) {
        this.headers();
      }
      if (!preserve) {
        this.countWriten++;
      }
      return stream.Transform.prototype.write.call(this, chunk, encoding, callback);
    };
    
    Stringifier.prototype._transform = function(chunk, encoding, callback) {
      this.push(chunk);
      return callback();
    };
    
    Stringifier.prototype.stringify = function(line) {
      var _line, column, columns, containsLinebreak, containsQuote, containsdelimiter, delimiter, escape, field, i, j, l, newLine, quote, ref, ref1, regexp;
      if (typeof line !== 'object') {
        return line;
      }
      columns = this.options.columns;
      if (typeof columns === 'object' && columns !== null && !Array.isArray(columns)) {
        columns = Object.keys(columns);
      }
      delimiter = this.options.delimiter;
      quote = this.options.quote;
      escape = this.options.escape;
      if (!Array.isArray(line)) {
        _line = [];
        if (columns) {
          for (i = j = 0, ref = columns.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
            column = columns[i];
            _line[i] = typeof line[column] === 'undefined' || line[column] === null ? '' : line[column];
          }
        } else {
          for (column in line) {
            _line.push(line[column]);
          }
        }
        line = _line;
        _line = null;
      } else if (columns) {
        line.splice(columns.length);
      }
      if (Array.isArray(line)) {
        newLine = '';
        for (i = l = 0, ref1 = line.length; 0 <= ref1 ? l < ref1 : l > ref1; i = 0 <= ref1 ? ++l : --l) {
          field = line[i];
          if (typeof field === 'string') {
    
          } else if (typeof field === 'number') {
            field = '' + field;
          } else if (typeof field === 'boolean') {
            field = field ? '1' : '';
          } else if (field instanceof Date) {
            field = '' + field.getTime();
          } else if (typeof field === 'object' && field !== null) {
            field = JSON.stringify(field);
          }
          if (field) {
            containsdelimiter = field.indexOf(delimiter) >= 0;
            containsQuote = field.indexOf(quote) >= 0;
            containsLinebreak = field.indexOf('\r') >= 0 || field.indexOf('\n') >= 0;
            if (containsQuote) {
              regexp = new RegExp(quote, 'g');
              field = field.replace(regexp, escape + quote);
            }
            if (containsQuote || containsdelimiter || containsLinebreak || this.options.quoted || (this.options.quotedString && typeof line[i] === 'string')) {
              field = quote + field + quote;
            }
            newLine += field;
          } else if (this.options.quotedEmpty || ((this.options.quotedEmpty == null) && line[i] === '' && this.options.quotedString)) {
            newLine += quote + quote;
          }
          if (i !== line.length - 1) {
            newLine += delimiter;
          }
        }
        line = newLine;
      }
      return line;
    };
    
  provide("csv-stringify", module.exports);
}(global));

// pakmanager:ngrok
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var os = require('os');
    var spawn = require('child_process').spawn;
    var EventEmitter = require('events').EventEmitter;
    
    var emitter = new EventEmitter();
    var tunnels = {};
    var exports = {};
    
    var TUNNEL_OK = /\[INFO\] \[client\] Tunnel established at ((tcp|https)..*.ngrok.com(:[0-9]+)?)/;
    var TUNNEL_BUSY = /\[EROR\] \[client\] Server failed to allocate tunnel: The tunnel ((tcp|http|https)..*.ngrok.com([0-9]+)?) (.*is already registered)/;
    
    function connect(opts, cb) {
    
    	cb || (cb = function(){});
    	if (typeof opts === 'number') {
    		opts = {log: false, port: opts};
    	}
    
    	var error = validateOpts(opts);
    	if (error) {
    		cb(error);
    		return emitter.emit('error', error);
    	}
    
    	var tunnelUrl;
    	var ngrok = spawn('./' + getNgrokBin(), getNgrokArgs(opts), {cwd: __dirname + '/bin'});
    
    	ngrok.stdout.on('data', function (data) {
    		var urlOk = data.toString().match(TUNNEL_OK);
    		if (urlOk && urlOk[1]) {
    			tunnelUrl = urlOk[1];
    			tunnels[tunnelUrl] = ngrok;
    			log('ngrok: tunnel established at ' + tunnelUrl);
    			cb(null, tunnelUrl);
    			return emitter.emit('connect', tunnelUrl);
    		}
    		var urlBusy = data.toString().match(TUNNEL_BUSY);
    		if (urlBusy && urlBusy[1]) {
    			ngrok.kill();
    			var info = 'ngrok: The tunnel ' + urlBusy[1] + ' ' + urlBusy[4];
    			var err = new Error(info);
    			log(info);
    			return cb(err);
    		}
    	});
    
    	ngrok.stderr.on('data', function (data) {
    		ngrok.kill();
    		var info = 'ngrok: process exited due to error\n' + data.toString().substring(0, 10000);
    		var err = new Error(info);
    		log(info);
    		cb(err);
    		return emitter.emit('error', err);
    	});
    
    	ngrok.on('close', function () {
    		var tunnelInfo = tunnelUrl ? tunnelUrl + ' ' : '';
    		log('ngrok: ' + tunnelInfo + 'disconnected');
    		return emitter.emit('close');
    	});
    
    	function log(message) {
    		opts.log && console.log(message);
    	}
    }
    
    function validateOpts (opts) {
    	if (!opts.port) {
    		return new Error('port not specified');
    	}
    	if (opts.start || opts.hostname) {
    		return new Error('starting multiple ngrok clients or using hostname option is not supported yet');
    	}
    	if ((opts.subdomain || opts.httpauth || opts.proto) && !opts.authtoken) {
    		return new Error('authtoken should be specified to use signup features: subdomain|httpauth|proto');
    	}
    	return false;
    }
    
    function getNgrokBin () {
    	var suffix = os.platform() === 'win32' ? '.exe' : '';
    	return 'ngrok' + suffix;
    }
    
    function getNgrokArgs(opts) {
    	var args = ['-log=stdout'];
    	opts.authtoken && args.push('-authtoken', opts.authtoken);
    	opts.subdomain && args.push('-subdomain', opts.subdomain);
    	opts.httpauth && args.push('-httpauth', opts.httpauth);
    	opts.proto && args.push('-proto', opts.proto);
    	args.push(opts.port);
    	return args;
    }
    
    function disconnect(tunnelUrl, callback) {
    	if (typeof tunnelUrl === 'function') {
    		callback = tunnelUrl;
    		tunnelUrl = null;
    	}
    	if (tunnelUrl) {
    		return kill(tunnelUrl, callback);
    	}
    	var pending = 1;
    	Object.keys(tunnels).forEach(function(url) {
    		pending++;
    		kill(url, next);
    	});
    	process.nextTick(next);
    	
    	function next() {
    		if (--pending === 0) callback && callback();
    	}
    }
    
    function kill(tunnelUrl, callback) {
    	var ngrok = tunnels[tunnelUrl];
    	delete tunnels[tunnelUrl];
    	if (!ngrok) {
    		return callback && process.nextTick(callback);
    	}
    	ngrok.once('exit', function() {
    		emitter.emit('disconnect');  
    		return callback && callback();
    	});
    	return ngrok.kill();
    }
    
    for(var key in emitter ) {
    	exports[key] = emitter[key];
    }
    exports.connect = connect;
    exports.disconnect = disconnect;
    
    module.exports = exports;
    
  provide("ngrok", module.exports);
}(global));

// pakmanager:psi/lib/output
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    var prettyBytes = require('pretty-bytes');
    var sortOn = require('sort-on');
    var humanizeUrl = require('humanize-url');
    var THRESHOLD = 70;
    
    function overview(url, strategy, score) {
      var ret = [];
    
      ret.push({
        label: 'URL',
        value: url
      });
    
      ret.push({
        label: 'Strategy',
        value: strategy
      });
    
      ret.push({
        label: 'Score',
        value: score
      });
    
      return ret;
    }
    
    function ruleSetResults(rulesets) {
      var ret = [];
    
      for (var title in rulesets) {
        ret.push({
          label: title,
          value: Math.ceil(rulesets[title].ruleImpact * 100) / 100
        });
      }
    
      return sortOn(ret, 'label');
    }
    
    function statistics(stats) {
      var ret = [];
    
      for (var title in stats) {
        ret.push({
          label: title,
          value: title.indexOf('Bytes') !== -1 ? prettyBytes(Number(stats[title])) : stats[title]
        });
      }
    
      return sortOn(ret, 'label');
    }
    
    function getReporter(format) {
      format = ['cli', 'json', 'tap'].indexOf(format) === -1 ? 'cli' : format;
      return require('./formats/' + format);
    }
    
    module.exports = function (parameters, response) {
      var renderer = getReporter(parameters.format);
      var threshold = parameters.threshold || THRESHOLD;
    
      console.log(renderer(
        overview(humanizeUrl(response.id), parameters.strategy, response.score),
        statistics(response.pageStats),
        ruleSetResults(response.formattedResults.ruleResults),
        threshold
      ));
    
      if (response.score < threshold) {
        var err = new Error('Threshold of ' + threshold + ' not met with score of ' + response.score);
        err.noStack = true;
        throw err;
      }
    };
    
  provide("psi/lib/output", module.exports);
}(global));

// pakmanager:psi
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    var googleapis = require('googleapis');
    var prependHttp = require('prepend-http');
    var objectAssign = require('object-assign');
    var pagespeed = googleapis.pagespeedonline('v1').pagespeedapi.runpagespeed;
    var output =  require('psi/lib/output');
    
    function handleOpts(url, opts) {
      opts = objectAssign({strategy: 'mobile'}, opts);
      opts.nokey = opts.key === undefined;
      opts.url = prependHttp(url);
      return opts;
    }
    
    var psi = module.exports = function (url, opts, cb) {
      if (typeof opts !== 'object') {
          cb = opts;
          opts = {};
      }
    
      if (!url) {
        throw new Error('URL required');
      }
    
      if (typeof cb !== 'function') {
        throw new Error('Callback required');
      }
    
      pagespeed(handleOpts(url, opts), function (err, response) {
        if (err) {
          err.noStack = true;
          cb(err);
          return;
        }
    
        cb(null, response);
      });
    };
    
    module.exports.output = function (url, opts, cb) {
      if (typeof opts !== 'object') {
          cb = opts;
          opts = {};
      }
    
      cb = cb || function () {};
    
      psi(url, opts, function (err, data) {
        if (err) {
          cb(err);
          return;
        }
    
        try {
          output(handleOpts(url, opts), data);
        } catch (err) {
          cb(err);
          return;
        }
    
        cb();
      });
    };
    
  provide("psi", module.exports);
}(global));

// pakmanager:json2csv
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Module dependencies.
     */
    var os = require('os');
    var async = require('async');
    
    /**
     * Main function that converts json to csv
     *
     * @param {Object} params Function parameters containing data, fields,
     * delimiter (default is ',') and hasCSVColumnTitle (default is true)
     * @param {Function} callback(err, csv) - Callback function
     *   if error, returning error in call back.
     *   if csv is created successfully, returning csv output to callback.
     */
    module.exports = function(params, callback) {
      checkParams(params, function(err) {
        if (err) return callback(err);
        createColumnTitles(params, function(err, title) {
          if (err) return callback(err);
          createColumnContent(params, title, function(csv) {
            callback(null, csv);
          });
        });
      });
    };
    
    
    /**
     * Check passing params
     *
     * @param {Object} params Function parameters containing data, fields,
     * delimiter and hasCSVColumnTitle
     * @param {Function} callback Callback function returning error when invalid field is found
     */
    var checkParams = function(params, callback) {
      // if data is an Object, not in array [{}], then just create 1 item array.
      // So from now all data in array of object format.
      if (!(params.data instanceof Array)) {
        var ar = new Array();
        ar[0] = params.data;
        params.data = ar;
      }
    
      //#check fieldNames
      if (params.fieldNames && params.fieldNames.length !== params.fields.length) {
        callback(new Error('fieldNames and fields should be of the same length, if fieldNames is provided.'));
      }
    
      params.fieldNames = params.fieldNames || params.fields;
    
      //#check delimiter
      params.del = params.del || ',';
    
      //#check end of line character
      params.eol = params.eol || '';
    
      //#check hasCSVColumnTitle, if it is not explicitly set to false then true.
      if (params.hasCSVColumnTitle !== false) {
        params.hasCSVColumnTitle = true;
      }
      callback(null);
    };
    
    /**
     * Create the title row with all the provided fields as column headings
     *
     * @param {Object} params Function parameters containing data, fields and delimiter
     * @param {Function} callback Callback function returning error and title row as a string
     */
    var createColumnTitles = function(params, callback) {
      var str = '';
    
      //if CSV has column title, then create it
      if (params.hasCSVColumnTitle) {
        params.fieldNames.forEach(function(element) {
          if (str !== '') {
            str += params.del;
          }
          str += JSON.stringify(element);
        });
      }
      callback(null, str);
    };
    
    /**
     * Create the content column by column and row by row below the title
     *
     * @param {Object} params Function parameters containing data, fields and delimiter
     * @param {String} str Title row as a string
     * @param {Function} callback Callback function returning title row and all content rows
     */
    var createColumnContent = function(params, str, callback) {
      params.data.forEach(function(data_element) {
        //if null or empty object do nothing
        if (data_element && Object.getOwnPropertyNames(data_element).length > 0) {
          var line = '';
          var eol = os.EOL || '\n';
    
          params.fields.forEach(function(field_element) {
            if (data_element.hasOwnProperty(field_element)) {
              line += JSON.stringify(data_element[field_element]);
            }
            line += params.del;
          });
    
          //remove last delimeter
          line = line.substring(0, line.length - 1);
          line = line.replace(/\\"/g, '""');
    
          //If header exists, add it, otherwise, print only content
          if (str !== '') {
            str += eol + line + params.eol;
          } else {
            str = line + params.eol;
          }
        }
      });
      callback(str);
    };
    
  provide("json2csv", module.exports);
}(global));

// pakmanager:csv
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Generated by CoffeeScript 1.7.1
    var generate, parse, stringify, transform;
    
    generate = require('csv-generate');
    
    parse = require('csv-parse');
    
    transform = require('stream-transform');
    
    stringify = require('csv-stringify');
    
    module.exports.generate = generate;
    
    module.exports.parse = parse;
    
    module.exports.transform = transform;
    
    module.exports.stringify = stringify;
    
  provide("csv", module.exports);
}(global));